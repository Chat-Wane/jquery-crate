(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

function CloseButton(model, closeView, container){
    // (TODO) remove the model
    closeView.button.click(function(){
        // #1 remove the view
        container.remove();
        // #2 disconnect the signaling server
        if (model.signaling.startedSocket){
            model.signaling.stopSharing();
        };
        // #3 disconnect the network
        model.rps.leave();
    });
};

module.exports = CloseButton;
    

},{}],2:[function(require,module,exports){
var Marker = require('../view/marker.js');

function EditorController(model, viewEditor){
    var self = this, editor = viewEditor.editor;
    this.viewEditor = viewEditor;   
    this.fromRemote = false;
    
    // #B initialize the string within the editor
    function getStringChildNode(childNode){
        var result = '';
        if (childNode.e !== null){ result = childNode.e; };
        for (var i=0; i<childNode.children.length; ++i){
            result += getStringChildNode(childNode.children[i]);
        };
        return result;
    };
    
    editor.setValue(getStringChildNode(model.sequence.root),1);
    
    var insertRemoveOp = false;
    editor.getSession().on('change', function(e){
        switch(e.data.action){
        case 'removeLines':
        case 'removeText':
        case 'insertLines':
        case 'insertText':
            insertRemoveOp = true;
        }
    });
    
    editor.getSession().getSelection().on('changeCursor', function(e, sel){
        if (!insertRemoveOp){
            var range = sel.getRange();
            model.core.caretMoved({
                start: editor.getSession().getDocument().positionToIndex(range.start),
                end: editor.getSession().getDocument().positionToIndex(range.end)
            });
        }
        insertRemoveOp = false;
    });
    
    editor.getSession().on('change', function(e) {
        var begin, end, text, message, j=0;

        if (!self.fromRemote){
            // #1 process the boundaries from range to index and text
            begin = editor.getSession().getDocument().positionToIndex(
                e.data.range.start);
            
            switch (e.data.action){
            case 'removeLines':
                end = begin;
                for (var i=0; i<e.data.lines.length;++i){
                    end += e.data.lines[i].length+1; // +1 because of \n
                };
                remoteCaretsUpdate(begin, begin-end);
                break;  
            case 'removeText':
                if (e.data.text.length === 1){
                    end = begin+1; //faster
                } else {
                    end = editor.getSession().getDocument().positionToIndex(
                        e.data.range.end);
                };
                remoteCaretsUpdate(begin, begin-end);
                break;
            case 'insertLines':
                text = '';
                for (var i=0; i<e.data.lines.length;++i){
                    text = text + (e.data.lines[i]) + '\n';
                };
                end = begin + text.length;
                remoteCaretsUpdate(begin, text.length);
                break;
            case 'insertText':
                text = e.data.text;
                end = editor.getSession().getDocument().positionToIndex(
                    e.data.range.end);
                remoteCaretsUpdate(begin, text.length);
                break;
            };
            // #2 update the underlying CRDT model and broadcast the results
            for (var i=begin; i<end; ++i){
                switch (e.data.action){
                case 'insertText': model.core.insert(text[j], i); break;
                case 'insertLines': model.core.insert(text[j], i); break;
                case 'removeText': model.core.remove(begin); break;
                case 'removeLines': model.core.remove(begin); break;
                };
                ++j;
            };
        };
    });
    
    model.core.on('remoteInsert', function(element, index){
        var aceDocument = editor.getSession().getDocument(),
            delta,
            tempFromRemote;
        if (index!==-1){
            delta = {action: 'insertText',
                     range: { start: aceDocument.indexToPosition(index-1),
                              end:   aceDocument.indexToPosition(index)},
                     text: element},
            tempFromRemote = self.fromRemote;
            self.fromRemote = true;
            aceDocument.applyDeltas([delta]);
            remoteCaretsUpdate(index,1);
            self.fromRemote = tempFromRemote;
        };
    });
    
    model.core.on('remoteRemove', function(index){    
        var aceDocument = editor.getSession().getDocument(),
            delta,
            tempFromRemote;
        if (index !== -1){
            delta = {action: 'removeText',
                     range: { start: aceDocument.indexToPosition(index - 1),
                              end:   aceDocument.indexToPosition(index)},
                     text: null};
            tempFromRemote = self.fromRemote;
            self.fromRemote = true;
            aceDocument.applyDeltas([delta]);
            remoteCaretsUpdate(index,-1);
            self.fromRemote = tempFromRemote;
        };
    });
    
    model.core.on('remoteCaretMoved', function(range, origin){
        if (!origin) return;
        if (editor.session.remoteCarets[origin]){
            // #A update the existing cursor
            var marker = editor.session.remoteCarets[origin];
            marker.cursors = [range]; // save the cursors as indexes
            editor.getSession()._signal('changeFrontMarker');
            marker.refresh();
        }else{
            // #B create a new cursor
            var marker = new Marker(editor.session, origin, range);
            editor.session.addDynamicMarker(marker, true);
            editor.session.remoteCarets[origin] = marker;
            marker.refresh();
            // call marker.session.removeMarker(marker.id) to remove it
            // call marker.redraw after changing one of cursors
        }
    });
    
    editor.session.remoteCarets = {};
    function remoteCaretsUpdate(index, length){
        var change = false, document = editor.session.getDocument();
        for (origin in editor.session.remoteCarets){
            var remoteCaret = editor.session.remoteCarets[origin];
            for (i=0; i<remoteCaret.cursors.length; ++i){
                var cursor = remoteCaret.cursors[i];
                if (cursor.start >= index){
                    cursor.start += length;
                    change = true;
                }
                if (cursor.end >= index){
                    cursor.end += length;
                    change = true;
                }
            }
        }
        if (change){
            editor.session._signal('changeFrontMarker');
        }
    };
    
};

module.exports = EditorController;

},{"../view/marker.js":12}],3:[function(require,module,exports){
//var markdown = require('markdown').markdown;
var marked = require('marked');
marked.setOptions({
    renderer: new marked.Renderer(),
    gfm: true,
    tables: true,
    breaks: false,
    pedantic: false,
    sanitize: false,
    smartLists: true,
    smartypants: false
});


function Preview(buttonView, editorView, previewView){
    var self = this;
    
    this.isPreviewing = false;
    this.startPreviewText = '<i class="fa fa-eye"></i>';
    this.startPreviewTooltip = 'switch to preview';
    this.stopPreviewText = '<i class="fa fa-eye-slash"></i>';
    this.stopPreviewTooltip = 'switch to editor';

    this.refreshTimeout = 5000; // (TODO) configuable
    this.refresh = null;

    buttonView.button.click(function(){
        if (!self.isPreviewing){
            self.isPreviewing = true;
            editorView.div.hide();
            previewView.div.html(marked(editorView.editor.getValue()));
            previewView.div.show();
            buttonView.button.html(self.stopPreviewText);
            buttonView.button.attr('title', self.stopPreviewTooltip)
                .tooltip('fixTitle');
            self.refresh = setInterval(function(){
                previewView.div.html(marked(editorView.editor.getValue()));
            }, self.refreshTimeout);           
        } else {
            self.isPreviewing = false;
            previewView.div.hide();
            editorView.div.show();
            editorView.editor.resize();
            buttonView.button.html(self.startPreviewText);
            buttonView.button.attr('title', self.startPreviewTooltip)
                .tooltip('fixTitle');
            clearTimeout(self.refresh);
            self.refresh = null;
        };
        
    });
};

module.exports = Preview;

},{"marked":100}],4:[function(require,module,exports){
require('jquery-qrcode');

function StatesHeader(model, statesView, linkView, shareView){
    var self = this;
    this.model = model;
    this.statesView = statesView;

    this.startSharingText = '<i class="fa fa-link"></i>';
    this.startSharingTooltip = 'start sharing';
    this.stopSharingText = '<i class="fa fa-unlink"></i>';
    this.stopSharingTooltip = 'stop sharing';
    
    model.broadcast.source.on("statechange", function(state){
        switch (state){
        case "connect": statesView.setNetworkState('connected'); break;
        case "partial": statesView.setNetworkState('partiallyConnected'); break;
        case "disconnect": statesView.setNetworkState('disconnected'); break;
        };
    });

    shareView.button.unbind("click").click( function(){
        var socket, action, client;
        if (model.signaling.startedSocket){
            model.signaling.stopSharing();
            return ; // ugly as hell
        };
        // #0 create the proper call to the server
        socket = model.signaling.startSharing();
        statesView.setSignalingState("waitSignaling");
        socket.on("connect", function(){
            shareView.button.removeAttr("disabled");
            statesView.setSignalingState("waitJoiners");
            shareView.button.html(self.stopSharingText);
            shareView.button.attr('title', self.stopSharingTooltip)
                .tooltip('fixTitle');
        });
        socket.on("disconnect", function(){
            shareView.button.html(self.startSharingText);
            shareView.button.attr('title', self.startSharingTooltip)
                .tooltip('fixTitle');
        });
        shareView.button.attr("disabled","disabled");
        // #1 modify the view
        if (model.signaling.startedSocket){
            // #A clean the address from args
            var address = (window.location.href).split('?')[0];
            // #B add the new argument
            action = linkView.printLink(address +"?"+
                                        model.signalingOptions.session);
            client = new ZeroClipboard(action);
            client.on("ready", function(event){
                client.on( "copy", function( event ){
                    var clipboard = event.clipboardData;
                    clipboard.setData( "text/plain",
                                       linkView.input.val() );
                });
            });
        };        
    });

    linkView.qrcode.click(function(){
        var address = model.signaling.address +
            "/index.html?" +
            model.signalingOptions.session;
        linkView.qrcodeCanvas.html("");
        linkView.qrcodeCanvas.qrcode({
            size:400,
            text:address
        });
    });    
};

StatesHeader.prototype.startJoining = function(signalingOptions){
    var socket = this.model.signaling.startJoining(signalingOptions);
    this.statesView.setSignalingState('waitSignaling');
    
    var self = this;
    socket.on('connect',
              function(){ self.statesView.setSignalingState('waitSharer'); });
};

module.exports = StatesHeader;

},{"jquery-qrcode":98}],5:[function(require,module,exports){
var Model = require('./model/model.js');
var GUID = require('./model/guid.js');
var ace = require('brace');
require('brace/theme/chrome');

var VStructure = require('./view/structure.js');
var VEditor = require('./view/editor.js');
var VCloseButton = require('./view/closebutton.js');
var VLink = require('./view/link.js');
var VStatesHeader = require('./view/statesheader.js');
var VMetadata = require('./view/metadata.js');
var VRoundButton = require('./view/roundbutton.js');
var VPreview = require('./view/preview.js');

var CStatesHeader = require('./controller/statesheader.js');
var CCloseButton = require('./controller/closebutton.js');
var CEditor = require('./controller/editor.js');
var CPreview = require('./controller/preview.js');

/*!
 * \brief transform the selected division into a distributed and decentralized 
 * collaborative editor.
 * \param options {
 *   signalingOptions: configure the signaling service to join or share the
 *     document. {address: http://example.of.signaling.service.address,
 *                session: the-session-unique-identifier,
 *                connect: true|false}
 *   webRTCOptions: configure the STUN/TURN server to establish WebRTC
 *     connections.
 *   styleOptions: change the default styling options of the editor.
 *   name: the name of the document
 *   importFromJSON: the json object containing the aformentionned options plus
 *     the saved sequence. If any of the other above options are specified, the
 *     option in the json object are erased by them.
 * }
 */
$.fn.cratify = function(options){
    // #0 examine the arguments
    // (TODO) apply style options
    var styleOptions=$.extend({'headerBackgroundColor': '#242b32',
                               'headerColor': '#ececec',
                               'editorBackgroundColor': '#ffffff',
                               'editorHeight': '400px'},
                              (options && options.styleOptions) ||
                              (options && options.importFromJSON &&
                               options.importFromJSON.styleOptions) ||
                              {});
    
    var webRTCOptions = (options && options.webRTCOptions) ||
        (options && options.importFromJSON &&
         options.importFromJSON.webRTCOptions) ||
        {};
    
    var signalingOptions=
        $.extend(
            $.extend({//server: "http://127.0.0.1:5000",
                      server: "https://ancient-shelf-9067.herokuapp.com",
                      session: GUID(),
                      connect: false},
                     (options && options.importFromJSON &&
                      options.importFromJSON.signalingOptions) ||
                     {}),
            (options && options.signalingOptions) || {});

    var name = (options && options.name) ||
        (options && options.importFromJSON &&
         options.importFromJSON.name) ||
        "default";
    
    return this.each(function(){
        // #1 initialize the model
        var m = new Model(signalingOptions, webRTCOptions, name,
                          options.importFromJSON);

        // #2 initialize the view
        var divId = GUID();
        var vs  = new VStructure(this);
        var ve  = new VEditor(vs.body, divId);
        var vcb = new VCloseButton(vs.headerRightRightRight);
        var vm  = new VMetadata(m, vs.headerLeft);
        var vsh = new VStatesHeader(m, vs.headerRight);
        var vl  = new VLink(this, divId);
        var vpb = new VRoundButton(vs.headerRightRight,
                                   '<i class="fa fa-eye"></i>',
                                   'switch to preview');
        var vp  = new VPreview(vs.body);

        var vsb = new VRoundButton(vs.headerRightRight,
                                   '<i class="fa fa-link"></i>',
                                   'start sharing');
        var vset = new VRoundButton(vs.headerRightRight,
                                    '<i class="fa fa-cogs"></i>',
                                    'settings (disabled)');
        // #3 initialize the controllers
        var ccb = new CCloseButton(m, vcb, this);
        var csh = new CStatesHeader(m, vsh, vl, vsb);
        var ce  = new CEditor(m, ve);
        var cp  = new CPreview(vpb, ve, vp);
        
        // #4 grant quick access
        this.header = vs.headerRightRight;
        this.closeButton = vcb.button;
        this.previewButton = vpb.button;
        this.model = m;

        // #5 optionnally join an editing session
        if (signalingOptions.connect){
            csh.startJoining(signalingOptions);
        };
    });
};

},{"./controller/closebutton.js":1,"./controller/editor.js":2,"./controller/preview.js":3,"./controller/statesheader.js":4,"./model/guid.js":6,"./model/model.js":7,"./view/closebutton.js":9,"./view/editor.js":10,"./view/link.js":11,"./view/metadata.js":13,"./view/preview.js":14,"./view/roundbutton.js":15,"./view/statesheader.js":16,"./view/structure.js":17,"brace":26,"brace/theme/chrome":27}],6:[function(require,module,exports){
/*
 * \url https://github.com/justayak/yutils/blob/master/yutils.js
 * \author justayak
 */

/*!
 * \brief get a globally unique (with high probability) identifier
 * \return a string being the identifier
 */
function GUID(){
    var d = new Date().getTime();
    var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
    return guid;
};

module.exports = GUID;

},{}],7:[function(require,module,exports){
var Core = require('crate-core');

var GUID = require('./guid.js');
var Signaling = require('./signaling.js');


function Model(signalingOptions, webRTCOptions, name, importFromJSON){
    // #1A initialize internal variables
    this.uid = GUID();
    this.name = name;
    this.date = new Date(); // (TODO) change
    this.webRTCOptions = webRTCOptions;

    this.core = new Core(this.uid, {config:webRTCOptions});
    this.signaling = new Signaling(this.core.broadcast.source,signalingOptions);

    // #1B if it is imported from an existing object, initialize it with these
    if (importFromJSON){ this.core.init(importFromJSON); };    
    
    // #2 grant fast access
    this.broadcast = this.core.broadcast;
    this.rps = this.core.broadcast.source;
    this.sequence = this.core.sequence;
    this.causality = this.broadcast.causality;
    this.signalingOptions = this.signaling.signalingOptions;
    
};

module.exports = Model;

},{"./guid.js":6,"./signaling.js":8,"crate-core":34}],8:[function(require,module,exports){
var io = require('socket.io-client');

/*!
 * \brief handle the signaling server
 * \param rps the random peer sampling protocol
 * \param signalingOptions specific options for the signaling server(s). For
 * now, it's an object { server, session, duration } where server is
 * the address of the server to contact, session is the editing session to join
 * or share, duration is the optional duration time during which the socket with
 * the signaling server stays open.
 */
function Signaling(rps, signalingOptions){
    this.rps = rps;
    this.signalingOptions = signalingOptions;
    this.socketIOConfig = { 'force new connection': true,
                            'reconnection': false };
    this.startedSocket = false;
    this.socket = null;
    this.timeout = null; // event id of the termination
    this.joiners = 0;
};

/*!
 * \brief create a connection with a socket.io server and initialize the events
 */
Signaling.prototype.createSocket = function(){
    var self = this;
    // #A establish the dialog with the socket.io server
    if(!this.startedSocket){
        this.socket = io(this.signalingOptions.server, this.socketIOConfig);
        this.startedSocket = true;
        this.socket.on('connect', function(){
            console.log('Connection to the signaling server established');
        });
        this.socket.on('launchResponse', function(idJoiner, offerTicket){
            self.joiners = self.joiners + 1;
            self.rps.answer(offerTicket, function(stampedTicket){                
                self.socket.emit('answer', idJoiner, stampedTicket);
            });
        });
        this.socket.on('answerResponse', function(handshakeMessage){
            self.rps.handshake(handshakeMessage);
            self.socket.disconnect();
        });
        this.socket.on('disconnect', function(){
            console.log('Disconnection from the signaling server');
            self.startedSocket = false;
            self.joiners = 0;
            clearTimeout(this.timeout);
        });
    }
    // #B reset timer before closing the connection
    if (this.timeout!==null){ clearTimeout(this.timeout); };
    // #C initialize a timer before closing the connection
    if (this.signalingOptions.duration){
        this.timeout = setTimeout(function(){
            self.stopSharing();
        }, this.signalingOptions.duration);
    };
};

Signaling.prototype.startSharing = function(){
    var self = this;
    this.createSocket();
    this.socket.on('connect', function(){
        self.socket.emit('share', self.signalingOptions.session);
    });
    return this.socket;
};

Signaling.prototype.stopSharing = function(){
    this.socket.disconnect();
    this.timeout = null;
};

Signaling.prototype.startJoining = function(signalingOptions){
    var self = this;
    this.createSocket();
    this.socket.on('connect', function(){
        self.rps.launch(function(launchMessage){
            self.socket.emit('launch', signalingOptions.session, launchMessage);
        });
    });
    return this.socket;
};


module.exports = Signaling;

},{"socket.io-client":107}],9:[function(require,module,exports){

function CloseButton(container){
    this.button =  jQuery('<button>').appendTo(container)
        .attr('type', 'button')
        .addClass('close')
        .css('color', 'white')
        .append(jQuery('<span>')
                .attr('aria-hidden', 'true')
                .html('&nbsp;&nbsp;&times'));
};

module.exports = CloseButton;

},{}],10:[function(require,module,exports){

function Editor(container, id){
    this.div = jQuery('<div>').appendTo(container)
        .attr('id','crate-'+id)
        .css('min-height', '400px');
    this.editor = ace.edit('crate-'+id);

    this.editor.$blockScrolling = Infinity;
    this.editor.setTheme("ace/theme/chrome");
    this.editor.getSession().setUseWrapMode(true); // word wrapping
    this.editor.setHighlightActiveLine(false); // not highlighting current line
    this.editor.setShowPrintMargin(false); // no 80 column margin
    this.editor.renderer.setShowGutter(false); // no line numbers
};

module.exports = Editor;

},{}],11:[function(require,module,exports){

function LinkView(container, id){

    this.linkContainer = jQuery('<div>').appendTo(container)
        .addClass('container')
        .css('position', 'relative')
        .css('top', '-100px')
        .css('width', 'inherit')
        .css('z-index', '10')
        .css('opacity', '0.9')
        .hide();
    
    // #0 qr code modal
    var qrCodeModal = jQuery('<div>').appendTo(container)
        .attr('id', 'modalQRCode'+id)
        .attr('tabindex','-1')
        .attr('role','dialog')
        .attr('aria-labelledby','modalQRCodeLabel')
        .attr('aria-hidden', 'true')
        .addClass('modal');
    
    var qrCodeModalDialog = jQuery('<div>').appendTo(qrCodeModal)
        .addClass('modal-dialog');
    var qrCodeModalContent = jQuery('<div>').appendTo(qrCodeModalDialog)
        .addClass('modal-content text-center');
    this.qrcodeCanvas = jQuery('<div>');
    qrCodeModalContent.append(jQuery('<br>'))
        .append(this.qrcodeCanvas)
        .append(jQuery('<br>'));
    
    // #1 overall division
    this.alert = jQuery('<div>').appendTo(this.linkContainer)
        .attr('role', 'alert')
        .addClass('alert alert-warning alert-dismissible');
    // #2 cross to close the division
    this.dismiss = jQuery('<button>').appendTo(this.alert)
        .attr('type', 'button')
        .addClass('close')
        .html('<span  aria-hidden="true">&times;</span><span class="sr-only"> '+
              'Close </span>');
    var rowContainer = jQuery('<div>').appendTo(this.alert)
        .addClass('container');
    var inputGroup = jQuery('<div>').appendTo(rowContainer)
        .addClass('input-group');
    this.input = jQuery('<input>').appendTo(inputGroup)
        .attr('type', 'text')
        .attr('placeholder', 'Nothing to see here, move along.')
        .addClass('form-control');
    
    var inputGroup2 = jQuery('<span>').appendTo(inputGroup)
        .addClass('input-group-btn');

    this.qrcode = jQuery('<button>').appendTo(inputGroup2)
        .attr('aria-label', 'QR-code')
        .attr('type', 'button')
        .attr('data-target', '#modalQRCode'+id)
        .attr('data-toggle', 'modal')
        .addClass('btn btn-default')
        .html('<i class="fa fa-qrcode"></i> QR-Code');

    this.action = jQuery('<button>').appendTo(inputGroup2)
        .attr('aria-label', 'Go!')
        .attr('type', 'button')
        .addClass('btn btn-default')
        .html('Go!')
        .css('z-index', '15');

    var self = this;
    this.dismiss.unbind("click").click(function(){self.linkContainer.hide();});
};

LinkView.prototype.printLink = function(link){
    this.linkContainer.show();
    this.alert.removeClass("alert-info").addClass("alert-warning");
    this.action.html('<i class="fa fa-clipboard"></i> Copy');
    this.action.attr("aria-label", "Copy to clipboard");
    this.input.attr("readonly","readonly");
    this.input.val(link);
    this.qrcode.show();
};

LinkView.prototype.printLaunchLink = function(link){
    this.printLink(link);
    this.input.attr("placeholder",
                    "A link will appear in this field, give it to your "+
                    "friend!");
    this.action.unbind("click");
    this.qrcode.hide();
    return this.action;
};

LinkView.prototype.printAnswerLink = function(link){
    this.printLink(link);
    this.input.attr("placeholder",
                    "A link will appear in this field. Please give it "+
                    "back to your friend.");
    this.action.unbind("click");
    this.qrcode.hide();
    return this.action;
};

LinkView.prototype.askLink = function(){
    this.linkContainer.show();
    this.alert.removeClass("alert-warning").addClass("alert-info");
    this.action.html('Go!');
    this.action.attr("aria-label", "Stamp the ticket");
    this.input.removeAttr("readonly");
    this.input.val("");
    this.action.unbind("click");
    this.qrcode.hide();
};

LinkView.prototype.askLaunchLink = function(){
    this.askLink();
    this.input.attr("placeholder",
                    "Please, copy the ticket of your friend here to stamp "+
                    "it!");
    this.qrcode.hide();
    return this.action;
};

LinkView.prototype.askAnswerLink = function(){
    this.askLink();
    this.input.attr("placeholder", "Copy the stamped ticket to confirm "+
                    "your arrival in the network");
    this.qrcode.hide();
    return this.action;
};

LinkView.prototype.hide = function(){
    this.linkContainer.hide();
};

module.exports = LinkView;

},{}],12:[function(require,module,exports){
var animals = require('animals');
var hash = require('string-hash');

function Marker(session, origin, range){
    this.origin = origin;
    this.session = session;
    this.cursors = [range];
    this.color = getColor(this.origin);
    this.colorRGB = 'rgb('+this.color+')';
    this.colorRGBLight = 'rgba('+this.color+', 0.5)';
    this.animal = 'Anonymous ' +
        capitalize(animals.words[hash(this.origin)%animals.words.length]);
};

// (TODO) refactor using jquery
Marker.prototype.update = function(html, markerLayer, session, config){
    var start = config.firstRow, end = config.lastRow;
    var cursors = this.cursors;
    for (var i = 0; i < cursors.length; i++) {
        var rng = {
            start: session.getDocument().indexToPosition(cursors[i].start),
            end: session.getDocument().indexToPosition(cursors[i].end)
        };
        var startScreenPos = session.documentToScreenPosition(rng.start);
        var endScreenPos = session.documentToScreenPosition(rng.end);
        if (startScreenPos.row === endScreenPos.row){//!range.isMultiLine()){
            // only one line
            var height = config.lineHeight;
            var width = config.characterWidth *
                (endScreenPos.column - startScreenPos.column);
            var top = markerLayer.$getTop(startScreenPos.row, config);
            var left = markerLayer.$padding + startScreenPos.column
                * config.characterWidth;
            var range = this.colorRGBLight;
            if(width === 0){
                range = this.colorRGB;
                width = 2;
            }
            var code = '<div class="remoteCaret" style="' +
                'background-color:' +range +';' +
                'height:' + height + 'px;' +
                'top:' + top + 'px;' +
                'left:' + left + 'px;' +
                'width:' + width + 'px">';
            code += '<div class="squareCaret" style="background:' +
                this.colorRGB + ';">';
            code += '<div class="infoCaret" style="background:' +
                this.colorRGBLight + ';">' + this.animal + '</div></div></div>';
            html.push(code);
        }else{
            // multi-line
            // first line
            var height = config.lineHeight;
            var top = markerLayer.$getTop(startScreenPos.row, config);
            var left = markerLayer.$padding + startScreenPos.column *
                config.characterWidth;
            var code = "<div class='remoteCaret selection' style='" +
                "background-color:" + this.colorRGBLight + ";" +
                "height:" + height + "px;" +
                "top:" + top + "px;" +
                "left:" + left + "px;" +
                "right: 0;'>";
            code += '<div class="squareCaret" style="background:' +
                this.colorRGB + ';">';
            code += '<div class="infoCaret" style="background:' +
                this.colorRGBLight + ';">' + this.animal + '</div></div></div>';
            // last line
            height = config.lineHeight;
            top = markerLayer.$getTop(endScreenPos.row, config);
            left = markerLayer.$padding;
            width = config.characterWidth * endScreenPos.column;
            code += "<div class='remoteCaret' style='" +
                "background-color:" + this.colorRGBLight + ";" +
                "height:" + height + "px;" +
                "top:" + top + "px;" +
                "left:" + left + "px;" +
                "width:" + width + "px;'></div>";
            // middle lines
            if (endScreenPos.row - startScreenPos.row > 1){
                height = config.lineHeight *
                    (endScreenPos.row - startScreenPos.row - 1);
                top = markerLayer.$getTop(startScreenPos.row + 1, config);
                left = markerLayer.$padding;
                code += "<div class='remoteCaret' style='" +
                    "background-color:" + this.colorRGBLight + ";" +
                    "height:" + height + "px;" +
                    "top:" + top + "px;" +
                    "left:" + left + "px;" +
                    "right:0;'></div>";
            }
            html.push(code);
        }
    }
};

Marker.prototype.redraw = function(){
    this.session._signal("changeFrontMarker");
};

Marker.prototype.refresh = function(){
    var self = this;
    if (this.timeout){
        clearTimeout(this.timeout);
    };
    this.timeout = setTimeout(function(){
        self.session.removeMarker(self.id);
        delete self.session.remoteCarets[self.origin];
    },10000);
};

Marker.prototype.addCursor = function(){
    // add to this cursors
    // trigger redraw
    this.redraw()
}



function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

function getColor(str){
    var h1 = hash(str)%206;
    var h2 = (h1*7)%206;
    var h3 = (h1*11)%206;
    return Math.floor(h1+50)+ ", "+Math.floor(h2+50)+ ", "+Math.floor(h3+50);
}

module.exports = Marker;

},{"animals":19,"string-hash":127}],13:[function(require,module,exports){


var imdata = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAWNJREFUeNrsly92g0AQh2f70GgMJ6iIWEwdhtdbRCASmVpMRU0tlUTkIpg9QFbkDDFoLkBF3m6nw05gCWlEGcO/t3wfw4/Hrui6Dh5ZT/DgWgQCfPCRC9/xOEBeg98PXV/AF5ql0p6slZ4kE9wCxTVVJrgFypWPTMCBfaGeMoIT6OYCj3iloieQpRKeXysAACiLZJYu1Erb/XxXwfm0/3WOzcDb59Hu+8q4oPFqY7egtn5fwRgZCsWF4efTng9hrTTEq8uNwkiyMm2jIYwklEXCQnFxcGcGDLhtfp6IyoSRhLbRVuZaGeioDlCIKSpjOsDBMYS2f1IGXDJUgkLvlgHaAXNDCv2TDISRhBg2SwaWDCwZmDcDABc781ueMwOHr23vmsArIzIrtpMTl8zQazCFoVkqLeBlfRwUYGWG4ORJhRmLf9lmWj5W4KqMC3rPdYGolYZ8V0FZJJMXJs4M/Mu14fcADshnlZnqr1wAAAAASUVORK5CYII=";

function Metadata(model, container){
    var metadataString =
        '<ul style="padding: 5px;"><li><b>Session:</b> '+
        model.signalingOptions.session+'</li>'+
        '<li><b>Name:</b> '+ model.name+'</li>'+
        '<li><b>Date:</b> '+ model.date.toString()+'</li>';
    
    var buttonFile = jQuery('<a>').appendTo(container)
        .attr('href','#')
        .attr('data-trigger', 'hover').attr('data-toggle', 'popover')
        .attr('data-placement', 'bottom').attr('data-html', 'true')
        .attr('title','Document').attr('data-content', metadataString)
        .css('color', 'black')
        .css('display', 'inline-block')
        .css('height', '32px')
        .css('width', '32px')
        .css('margin-left', '10px')
        .css('background', 'data:image/png;base64,' + imdata +
             'no-repeat center center')
        .css('background-size', '32px 32px')
        .addClass('crate-icon')
        .css('height','34px').popover();
};

module.exports = Metadata;

},{}],14:[function(require,module,exports){


function Preview(container){
    this.div = jQuery('<div>').appendTo(container)
        .css('min-height', '400px')
        .hide();
};

module.exports = Preview;

},{}],15:[function(require,module,exports){

function RoundButton(container, text, tooltip, size){
    var s = 30;
    var p = 6;
    var b = 2;
    switch (size){
    case "large": s = 60; p = 11; break;
    case "small": s = 12; p = 2; b = 1;  break;
    };
    
    this.button = jQuery('<a>').appendTo(container)
        .addClass('btn btn-default')
        .css('width',s + 'px')
        .css('height', s + 'px')
        .css('margin-right', '10px')
        .css('border-radius', '50%')
        .css('border-width', b + 'px')
        .css('background', 'inherit')
        .css('padding', p+'px 0')
        .css('color', '#ececec')
        .css('vertical-align', 'middle')
        .attr('data-toggle', 'tooltip')
        .attr('data-placement', 'bottom')
        .attr('title', tooltip)
        .html(text)
        .prop('disable', true)
        .hover(function(){
            $(this).css('background-color', '#ececec');
            $(this).css('color', 'black');
        },     function(){
            $(this).css('background-color', 'inherit');
            $(this).css('color', '#ececec');
        })
        .tooltip();
};

module.exports = RoundButton;

},{}],16:[function(require,module,exports){

function StatesHeader(model, container){
    this.model = model;
    
    this.red = "#cd2626";
    this.yellow = "#eead0e";
    this.green = "#228b22";
    this.blue = "#00BFFF";
    
    this.signalingState = jQuery('<i>').appendTo(container)
        .addClass('fa fa-circle-o-notch fa-2x')
        .attr('data-trigger', 'hover').attr('data-toggle', 'popover')
        .attr('title', 'Signaling server status')
        .attr('data-html', 'true').attr('data-content', '')
        .attr('data-placement', 'bottom')
        .css('margin-right', '10px')
        .popover()
        .hide();

    this.networkState = jQuery('<i>').appendTo(container)
        .addClass('fa fa-globe fa-2x')
        .attr('data-trigger', 'hover').attr('data-toggle', 'popover')
        .attr('title', 'Network status')
        .attr('data-html', 'true')
        .attr('data-content', 'Disconnected: you are currently'+
              ' editing <span class="alert-info">on your own</span>.')
        .attr('data-placement', 'bottom')
        .css('margin-right', '10px')
        .css('margin-top', '2px')
        .popover();
};

StatesHeader.prototype.setNetworkState = function(state){
    switch (state){
    case "connected":
        var connectedString =
            "<span class='alert-success'>Congratulations</span>"+
            "! You are connected to people, and people are "+
            "connected to you. <span class='alert-info'>You can start editing "+
            "together</span>.";
        this.networkState.css("color", this.green);
        this.networkState.attr("data-content", connectedString);
        break;
    case "partiallyconnected":
        var partiallyConnectedString =
            "<span class='alert-warning'>Partially"+
            " connected</span>: either you are connected to people, or people "+
            "are connected to you. "+
            "<i>This is an undesired intermediary state. If it persists, "+
            "please consider rejoining the network.</i>";
        this.networkState.css("color", this.yellow);
        this.networkState.attr("data-content", partiallyConnectedString);
        break;
    case "disconnected":
        var disconnectedString =
            "<span class='alert-danger'>Disconnected</span>:"+
            " you are currently editing <span class='alert-info'>on"+
            " your own</span>.";
        this.networkState.css("color", this.red);
        this.networkState.attr("data-content", disconnectedString);
        break;
    };
};

StatesHeader.prototype.setSignalingState = function(state){
    var self = this;
    function blink(){
        self.signalingState.show();
        setTimeout( function(){
            if (self.model.signaling.startedSocket){
                blink();
            } else {
                self.setSignalingState("done");
            };
        }, 1000);
    };
    
    switch (state){
    case "waitSignaling":
        this.signalingState.show();
        this.signalingState.removeClass("fa-spin");
        this.signalingState.css("color", this.yellow);
        var waitSignalingString = "<span class='alert-warning'>Connecting"+
            "</span>: establishing a connection with the signaling server. "+
            "The latter allows people to join the editing session by using "+
            "the provided link. "+
            "<i>If this state persists, consider reloading the page.</i>";
        this.signalingState.attr("data-content", waitSignalingString);
        blink();
        break;
    case "waitSharer":
        this.signalingState.show();
        this.signalingState.addClass("fa-spin");
        this.signalingState.css("color", this.blue);
        var waitSharerString = "The connection to the signaling server has "+
            "been successfully established! <span class='alert-info'>Waiting "+
            "for the sharer now</span>.";
        this.signalingState.attr("data-content", waitSharerString);
        blink();
        break;
    case "waitJoiners":
        this.signalingState.css("color", this.blue);
        this.signalingState.addClass("fa-spin");
        var waitJoinersString = "The connection to the signaling server has "+
            "been <span class='alert-success'>successfully</span> "+
            "established! "+
            "The server allows people to join the editing session by using "+
            "the provided link. "+
            "<span class='alert-info'>Waiting for the collaborators</span>."
        this.signalingState.attr("data-content", waitJoinersString);
        blink();
        break;
    case "done":
        this.signalingState.show();
        this.signalingState.removeClass("fa-spin");
        var doneString = "The connection to the signaling server has been "+
            "<span class='alert-info'>terminated</span>.";
        this.signalingState.attr("data-content", doneString);
        this.signalingState.css("color", this.green);
        this.signalingState.fadeOut(6000, "linear");
        break;
    };
};

module.exports = StatesHeader;

},{}],17:[function(require,module,exports){

function Structure(container){
    // #A create the global header
    var header = jQuery('<div>').appendTo(container)
        .css('width', '100%')
        .css('box-shadow', '0px 1px 5px #ababab')
        .css('border-top-left-radius', '4px')
        .css('border-top-right-radius', '4px')
        .css('color', '#ececec')
        .css('background-color', '#242b32');

    var headerContainer = jQuery('<div>').appendTo(header)
        .addClass('container')
        .css('width','inherit');

    // #B Divide the header in four parts with different purposes
    this.headerLeft = jQuery('<div>').appendTo(headerContainer)
        .addClass('pull-left')
        .css('padding-top','10px')
        .css('padding-bottom','10px');

    this.headerRightRightRight = jQuery('<div>').appendTo(headerContainer)
        .addClass('pull-right')
        .css('padding-top', '10px')
        .css('padding-bottom', '10px')
        .css('height', '34px');

    this.headerRightRight = jQuery('<div>').appendTo(headerContainer)
        .addClass('pull-right')
        .css('padding-top','10px')
        .css('padding-bottom','10px')
        .css('height','34px')
        .css('margin-top', '2px');

    this.headerRight = jQuery('<div>').appendTo(headerContainer)
        .addClass('pull-right')
        .css('padding-top','10px')
        .css('padding-bottom','10px')
        .css('height','34px')
        .css('margin-right', '20px');

    this.body = jQuery('<div>').appendTo(container)
        .css('box-shadow', '0px 1px 5px #ababab')
        .css('border-bottom-left-radius', '4px')
        .css('border-bottom-right-radius', '4px')
        .css('margin-bottom', '20px')
        .css('padding', '30px 15px')
        .css('background-color', '#ffffff');
};

module.exports = Structure;

},{}],18:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],19:[function(require,module,exports){
'use strict';
var words = require('./words.json');
var uniqueRandom = require('unique-random')(0, words.length - 1);

module.exports = function () {
	return words[uniqueRandom()];
};

module.exports.words = words;

},{"./words.json":20,"unique-random":130}],20:[function(require,module,exports){
module.exports=[
  "aardvark",
  "albatross",
  "alligator",
  "alpaca",
  "ant",
  "anteater",
  "antelope",
  "ape",
  "armadillo",
  "donkey",
  "baboon",
  "badger",
  "barracuda",
  "bat",
  "bear",
  "beaver",
  "bee",
  "bison",
  "boar",
  "buffalo",
  "butterfly",
  "camel",
  "capybara",
  "caribou",
  "cassowary",
  "cat",
  "caterpillar",
  "cattle",
  "chamois",
  "cheetah",
  "chicken",
  "chimpanzee",
  "chinchilla",
  "chough",
  "clam",
  "cobra",
  "cockroach",
  "cod",
  "cormorant",
  "coyote",
  "crab",
  "crane",
  "crocodile",
  "crow",
  "curlew",
  "deer",
  "dinosaur",
  "dog",
  "dogfish",
  "dolphin",
  "donkey",
  "dotterel",
  "dove",
  "dragonfly",
  "duck",
  "dugong",
  "dunlin",
  "eagle",
  "echidna",
  "eel",
  "eland",
  "elephant",
  "elephant-seal",
  "elk",
  "emu",
  "falcon",
  "ferret",
  "finch",
  "fish",
  "flamingo",
  "fly",
  "fox",
  "frog",
  "gaur",
  "gazelle",
  "gerbil",
  "giant-panda",
  "giraffe",
  "gnat",
  "gnu",
  "goat",
  "goose",
  "goldfinch",
  "goldfish",
  "gorilla",
  "goshawk",
  "grasshopper",
  "grouse",
  "guanaco",
  "guinea-fowl",
  "guinea-pig",
  "gull",
  "hamster",
  "hare",
  "hawk",
  "hedgehog",
  "heron",
  "herring",
  "hippopotamus",
  "hornet",
  "horse",
  "human",
  "hummingbird",
  "hyena",
  "ibex",
  "ibis",
  "jackal",
  "jaguar",
  "jay",
  "jellyfish",
  "kangaroo",
  "kingfisher",
  "koala",
  "komodo-dragon",
  "kookabura",
  "kouprey",
  "kudu",
  "lapwing",
  "lark",
  "lemur",
  "leopard",
  "lion",
  "llama",
  "lobster",
  "locust",
  "loris",
  "louse",
  "lyrebird",
  "magpie",
  "mallard",
  "manatee",
  "mandrill",
  "mantis",
  "marten",
  "meerkat",
  "mink",
  "mole",
  "mongoose",
  "monkey",
  "moose",
  "mouse",
  "mosquito",
  "mule",
  "narwhal",
  "newt",
  "nightingale",
  "octopus",
  "okapi",
  "opossum",
  "oryx",
  "ostrich",
  "otter",
  "owl",
  "ox",
  "oyster",
  "panther",
  "parrot",
  "partridge",
  "peafowl",
  "pelican",
  "penguin",
  "pheasant",
  "pig",
  "pigeon",
  "polar-bear",
  "pony",
  "porcupine",
  "porpoise",
  "prairie-dog",
  "quail",
  "quelea",
  "quetzal",
  "rabbit",
  "raccoon",
  "rail",
  "ram",
  "rat",
  "raven",
  "red-deer",
  "red-panda",
  "reindeer",
  "rhinoceros",
  "rook",
  "salamander",
  "salmon",
  "sand-dollar",
  "sandpiper",
  "sardine",
  "scorpion",
  "sea-lion",
  "sea-urchin",
  "seahorse",
  "seal",
  "shark",
  "sheep",
  "shrew",
  "skunk",
  "snail",
  "snake",
  "sparrow",
  "spider",
  "spoonbill",
  "squid",
  "squirrel",
  "starling",
  "stingray",
  "stinkbug",
  "stork",
  "swallow",
  "swan",
  "tapir",
  "tarsier",
  "termite",
  "tiger",
  "toad",
  "trout",
  "turkey",
  "turtle",
  "vicuña",
  "viper",
  "vulture",
  "wallaby",
  "walrus",
  "wasp",
  "water-buffalo",
  "weasel",
  "whale",
  "wolf",
  "wolverine",
  "wombat",
  "woodcock",
  "woodpecker",
  "worm",
  "wren",
  "yak",
  "zebra"
]

},{}],21:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],22:[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],23:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],24:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],25:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ibG9iL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iQnVpbGRlciA9IGdsb2JhbC5CbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1TQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1vekJsb2JCdWlsZGVyO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGEgPSBuZXcgQmxvYihbJ2hpJ10pO1xuICAgIHJldHVybiBhLnNpemUgPT09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3NcbiAqIEZhaWxzIGluIFNhZmFyaSA2LCBzbyB3ZSBuZWVkIHRvIG1hcCB0byBBcnJheUJ1ZmZlcnMgdGhlcmUuXG4gKi9cblxudmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xuICAgIHJldHVybiBiLnNpemUgPT09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQgPSBCbG9iQnVpbGRlclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcbiAqIFVzZWQgYnkgQmxvYkJ1aWxkZXIgY29uc3RydWN0b3IgYW5kIG9sZCBicm93c2VycyB0aGF0IGRpZG4ndFxuICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cbiAqL1xuXG5mdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaHVuayA9IGFyeVtpXTtcbiAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuICAgICAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXG4gICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIGJ1ZiA9IGNvcHkuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBhcnlbaV0gPSBidWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBiYi5hcHBlbmQoYXJ5W2ldKTtcbiAgfVxuXG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcbn07XG5cbmZ1bmN0aW9uIEJsb2JDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuICByZXR1cm4gbmV3IEJsb2IoYXJ5LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xuICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBnbG9iYWwuQmxvYiA6IEJsb2JDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0pKCk7XG4iXX0=
},{}],26:[function(require,module,exports){
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (acequire, exports, module) params
 */

(function() {

var ACE_NAMESPACE = "ace";

var global = (function() { return this; })();
if (!global && typeof window != "undefined") global = window; // strict mode


if (!ACE_NAMESPACE && typeof acequirejs !== "undefined")
    return;


var define = function(module, deps, payload) {
    if (typeof module !== "string") {
        if (define.original)
            define.original.apply(this, arguments);
        else {
            console.error("dropping module because define wasn\'t a string.");
            console.trace();
        }
        return;
    }
    if (arguments.length == 2)
        payload = deps;
    if (!define.modules[module]) {
        define.payloads[module] = payload;
        define.modules[module] = null;
    }
};

define.modules = {};
define.payloads = {};

/**
 * Get at functionality ace.define()ed using the function above
 */
var _acequire = function(parentId, module, callback) {
    if (typeof module === "string") {
        var payload = lookup(parentId, module);
        if (payload != undefined) {
            callback && callback();
            return payload;
        }
    } else if (Object.prototype.toString.call(module) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined && acequire.original)
                return;
            params.push(dep);
        }
        return callback && callback.apply(null, params) || true;
    }
};

var acequire = function(module, callback) {
    var packagedModule = _acequire("", module, callback);
    if (packagedModule == undefined && acequire.original)
        return acequire.original.apply(this, arguments);
    return packagedModule;
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin acequires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative acequires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;

        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    return moduleName;
};

/**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */
var lookup = function(parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);

    var module = define.modules[moduleName];
    if (!module) {
        module = define.payloads[moduleName];
        if (typeof module === 'function') {
            var exports = {};
            var mod = {
                id: moduleName,
                uri: '',
                exports: exports,
                packaged: true
            };

            var req = function(module, callback) {
                return _acequire(moduleName, module, callback);
            };

            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
        }
        module = define.modules[moduleName] = exports || module;
    }
    return module;
};

function exportAce(ns) {
    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
        define.original = root.define;
        root.define = define;
        root.define.packaged = true;
    }

    if (!root.acequire || !root.acequire.packaged) {
        acequire.original = root.acequire;
        root.acequire = acequire;
        root.acequire.packaged = true;
    }
}

exportAce(ACE_NAMESPACE);

})();

ace.define("ace/lib/regexp",["require","exports","module"], function(acequire, exports, module) {
"use strict";

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    if (compliantLastIndexIncrement && compliantExecNpcg)
        return;
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };
    if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function (str) {
            var match = real.exec.call(this, str);
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    }

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    }

});

ace.define("ace/lib/es5-shim",["require","exports","module"], function(acequire, exports, module) {

function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        var target = this;
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        var args = slice.call(arguments, 1); // for normal call
        var bound = function () {

            if (this instanceof bound) {

                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    };
}
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}
if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = new Array(l+2);
            a[0] = a[1] = 0;
            return a;
        }
        var array = [], lengthBefore;
        
        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        lengthBefore + 1 == array.length

        if (lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
    }()) {//IE 6/7
        var array_splice = Array.prototype.splice;
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(slice.call(arguments, 2)))
            }
        };
    } else {//IE8
        Array.prototype.splice = function(pos, removeCount){
            var length = this.length;
            if (pos > 0) {
                if (pos > length)
                    pos = length;
            } else if (pos == void 0) {
                pos = 0;
            } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
            }

            if (!(pos+removeCount < length))
                removeCount = length - pos;

            var removed = this.slice(pos, pos+removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;            
            if (pos === length) {
                if (add) {
                    this.push.apply(this, insert);
                }
            } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;

                if (tailNewPos < tailOldPos) { // case A
                    for (var i = 0; i < tailCount; ++i) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } else if (tailNewPos > tailOldPos) { // case B
                    for (i = tailCount; i--; ) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } // else, add == remove (nothing to do)

                if (add && pos === lengthAfterRemove) {
                    this.length = lengthAfterRemove; // truncate array
                    this.push.apply(this, insert);
                } else {
                    this.length = lengthAfterRemove + add; // reserves space
                    for (i = 0; i < add; ++i) {
                        this[pos+i] = insert[i];
                    }
                }
            }
            return removed;
        };
    }
}
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}
if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;
        descriptor =  { enumerable: true, configurable: true };
        if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;
                return descriptor;
            }
        }
        descriptor.value = object[property];
        return descriptor;
    };
}
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        createEmpty = function () {
            var empty = {};
            for (var i in empty)
                empty[i] = null;
            empty.constructor =
            empty.hasOwnProperty =
            empty.propertyIsEnumerable =
            empty.isPrototypeOf =
            empty.toLocaleString =
            empty.toString =
            empty.valueOf =
            empty.__proto__ = null;
            return empty;
        }
    }

    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
    }
}
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
            }
        }
        if (owns(descriptor, "value")) {

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                delete object[property];
                object[property] = descriptor.value;
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}
if (!Object.seal) {
    Object.seal = function seal(object) {
        return object;
    };
}
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        return object;
    };
}
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        return object;
    };
}
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
if (!Object.keys) {
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function isPrimitive(input) {
    var type = typeof input;
    return (
        input === null ||
        type === "undefined" ||
        type === "boolean" ||
        type === "number" ||
        type === "string"
    );
}

function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
        return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === "function") {
        val = valueOf.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    toString = input.toString;
    if (typeof toString === "function") {
        val = toString.call(input);
        if (isPrimitive(val)) {
            return val;
        }
    }
    throw new TypeError();
}
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(acequire, exports, module) {
"use strict";

acequire("./regexp");
acequire("./es5-shim");

});

ace.define("ace/lib/dom",["require","exports","module"], function(acequire, exports, module) {
"use strict";

var XHTML_NS = "http://www.w3.org/1999/xhtml";

exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
}

exports.createElement = function(tag, ns) {
    return document.createElementNS ?
           document.createElementNS(ns || XHTML_NS, tag) :
           document.createElement(tag);
};

exports.hasCssClass = function(el, name) {
    var classes = (el.className || "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if(add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;

    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
        while (index < sheets.length)
            if (sheets[index++].owningElement.id === id) return true;
    } else if ((sheets = doc.getElementsByTagName("style"))) {
        while (index < sheets.length)
            if (sheets[index++].id === id) return true;
    }

    return false;
};

exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    if (id && exports.hasCssString(id, doc))
        return null;
    
    var style;
    
    if (doc.createStyleSheet) {
        style = doc.createStyleSheet();
        style.cssText = cssText;
        if (id)
            style.owningElement.id = id;
    } else {
        style = doc.createElementNS
            ? doc.createElementNS(XHTML_NS, "style")
            : doc.createElement("style");

        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        exports.getDocumentHead(doc).appendChild(style);
    }
};

exports.importCssStylsheet = function(uri, doc) {
    if (doc.createStyleSheet) {
        doc.createStyleSheet(uri);
    } else {
        var link = exports.createElement('link');
        link.rel = 'stylesheet';
        link.href = uri;

        exports.getDocumentHead(doc).appendChild(link);
    }
};

exports.getInnerWidth = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
        element.clientWidth
    );
};

exports.getInnerHeight = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
        element.clientHeight
    );
};


if (typeof document == "undefined")
    return;

if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function() {
        return window.pageYOffset;
    };

    exports.getPageScrollLeft = function() {
        return window.pageXOffset;
    };
}
else {
    exports.getPageScrollTop = function() {
        return document.body.scrollTop;
    };

    exports.getPageScrollLeft = function() {
        return document.body.scrollLeft;
    };
}

if (window.getComputedStyle)
    exports.computedStyle = function(element, style) {
        if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
        return window.getComputedStyle(element, "") || {};
    };
else
    exports.computedStyle = function(element, style) {
        if (style)
            return element.currentStyle[style];
        return element.currentStyle;
    };

exports.scrollbarWidth = function(document) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
};
exports.setInnerHtml = function(el, innerHtml) {
    var element = el.cloneNode(false);//document.createElement("div");
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
};

if ("textContent" in document.documentElement) {
    exports.setInnerText = function(el, innerText) {
        el.textContent = innerText;
    };

    exports.getInnerText = function(el) {
        return el.textContent;
    };
}
else {
    exports.setInnerText = function(el, innerText) {
        el.innerText = innerText;
    };

    exports.getInnerText = function(el) {
        return el.innerText;
    };
}

exports.getParentWindow = function(document) {
    return document.defaultView || document.parentWindow;
};

});

ace.define("ace/lib/oop",["require","exports","module"], function(acequire, exports, module) {
"use strict";

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

ace.define("ace/lib/keys",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop"], function(acequire, exports, module) {
"use strict";

acequire("./fixoldbrowsers");

var oop = acequire("./oop");
var Keys = (function() {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
        },

        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
            "super": 8, "meta": 8, "command": 8, "cmd": 8
        },

        FUNCTION_KEYS : {
            8  : "Backspace",
            9  : "Tab",
            13 : "Return",
            19 : "Pause",
            27 : "Esc",
            32 : "Space",
            33 : "PageUp",
            34 : "PageDown",
            35 : "End",
            36 : "Home",
            37 : "Left",
            38 : "Up",
            39 : "Right",
            40 : "Down",
            44 : "Print",
            45 : "Insert",
            46 : "Delete",
            96 : "Numpad0",
            97 : "Numpad1",
            98 : "Numpad2",
            99 : "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },

        PRINTABLE_KEYS: {
           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
          219: '[', 220: '\\',221: ']', 222: '\''
        }
    };
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];
    ret[173] = '-';
    
    (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i = Math.pow(2, mods.length); i--;) {            
            ret.KEY_MODS[i] = mods.filter(function(x) {
                return i & ret.KEY_MODS[x];
            }).join("-") + "-";
        }
    })();

    ret.KEY_MODS[0] = "";
    ret.KEY_MODS[-1] = "input-";

    return ret;
})();
oop.mixin(exports, Keys);

exports.keyCodeToString = function(keyCode) {
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};

});

ace.define("ace/lib/useragent",["require","exports","module"], function(acequire, exports, module) {
"use strict";
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};
if (typeof navigator != "object")
    return;

var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
var ua = navigator.userAgent;
exports.isWin = (os == "win");
exports.isMac = (os == "mac");
exports.isLinux = (os == "linux");
exports.isIE = 
    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
    
exports.isOldIE = exports.isIE && exports.isIE < 9;
exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/)||[])[1], 10) < 4;
exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isIPad = ua.indexOf("iPad") >= 0;

exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

});

ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
"use strict";

var keys = acequire("./keys");
var useragent = acequire("./useragent");

exports.addListener = function(elem, type, callback) {
    if (elem.addEventListener) {
        return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
        var wrapper = function() {
            callback.call(elem, window.event);
        };
        callback._wrapper = wrapper;
        elem.attachEvent("on" + type, wrapper);
    }
};

exports.removeListener = function(elem, type, callback) {
    if (elem.removeEventListener) {
        return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
        elem.detachEvent("on" + type, callback._wrapper || callback);
    }
};
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
    else
        e.cancelBubble = true;
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
    else
        e.returnValue = false;
};
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;
    if (e.preventDefault) {
        return e.button;
    }
    else {
        return {1:0, 2:2, 4:1}[e.button];
    }
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        exports.removeListener(document, "mousemove", eventHandler, true);
        exports.removeListener(document, "mouseup", onMouseUp, true);
        exports.removeListener(document, "dragstart", onMouseUp, true);
    }

    exports.addListener(document, "mousemove", eventHandler, true);
    exports.addListener(document, "mouseup", onMouseUp, true);
    exports.addListener(document, "dragstart", onMouseUp, true);
    
    return onMouseUp;
};

exports.addMouseWheelListener = function(el, callback) {
    if ("onmousewheel" in el) {
        exports.addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
            } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
        });
    } else if ("onwheel" in el) {
        exports.addListener(el, "wheel",  function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = e.deltaX * factor || 0;
                    e.wheelY = e.deltaY * factor || 0;
                    break;
                case e.DOM_DELTA_LINE:
                case e.DOM_DELTA_PAGE:
                    e.wheelX = (e.deltaX || 0) * 5;
                    e.wheelY = (e.deltaY || 0) * 5;
                    break;
            }
            
            callback(e);
        });
    } else {
        exports.addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
            } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
        });
    }
};

exports.addMultiMouseDownListener = function(el, timeouts, eventHandler, callbackName) {
    var clicks = 0;
    var startX, startY, timer; 
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    exports.addListener(el, "mousedown", function(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);

            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        
        e._clicks = clicks;

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    });

    if (useragent.isOldIE) {
        exports.addListener(el, "dblclick", function(e) {
            clicks = 2;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
            eventHandler[callbackName]("mousedown", e);
            eventHandler[callbackName](eventNames[clicks], e);
        });
    }
};

var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
    ? function(e) {
        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    }
    : function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };

exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
};

function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!useragent.isMac && pressedKeys) {
        if (pressedKeys[91] || pressedKeys[92])
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timestamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }

    if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
        keyCode = -1;
    }
    
    if (!hashId && keyCode === 13) {
        var location = "location" in e ? e.location : e.keyLocation;
        if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    
    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    
    return callback(e, hashId, keyCode);
}

var pressedKeys = null;
var ts = 0;
exports.addCommandKeyListener = function(el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
        });
        addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        });
    } else {
        var lastDefaultPrevented = null;

        addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        });

        addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        });

        addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
        });

        if (!pressedKeys) {
            pressedKeys = Object.create(null);
            addListener(window, "focus", function(e) {
                pressedKeys = Object.create(null);
            });
        }
    }
};

if (window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId;
        exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                exports.removeListener(win, "message", listener);
                callback();
            }
        });
        win.postMessage(messageName, "*");
    };
}


exports.nextFrame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    window.oRequestAnimationFrame;

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };
});

ace.define("ace/lib/lang",["require","exports","module"], function(acequire, exports, module) {
"use strict";

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject( array[i] );
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function (obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var cons = obj.constructor;
    if (cons === RegExp)
        return obj;
    
    var copy = cons();
    for (var key in obj) {
        if (typeof obj[key] === "object") {
            copy[key] = exports.deepCopy(obj[key]);
        } else {
            copy[key] = obj[key];
        }
    }
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang"], function(acequire, exports, module) {
"use strict";

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
var dom = acequire("../lib/dom");
var lang = acequire("../lib/lang");
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;

var TextInput = function(parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    if (useragent.isTouchPad)
        text.setAttribute("x-palm-disable-auto-cap", true);

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);

    text.style.opacity = "0";
    if (useragent.isOldIE) text.style.top = "-1000px";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = "\x01\x01";

    var copied = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;
    try { var isFocused = document.activeElement === text; } catch(e) {}
    
    event.addListener(text, "blur", function(e) {
        host.onBlur(e);
        isFocused = false;
    });
    event.addListener(text, "focus", function(e) {
        isFocused = true;
        host.onFocus(e);
        resetSelection();
    });
    this.focus = function() {
        if (tempStyle) return text.focus();
        text.style.position = "fixed";
        text.style.top = "-1000px";
        text.focus();
        setTimeout(function() {
            text.style.position = "";
        }, 0);
    };
    this.blur = function() { text.blur(); };
    this.isFocused = function() {
        return isFocused;
    };
    var syncSelection = lang.delayedCall(function() {
        isFocused && resetSelection(isSelectionEmpty);
    });
    var syncValue = lang.delayedCall(function() {
         if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
         }
    });

    function resetSelection(isEmpty) {
        if (inComposition)
            return;
        inComposition = true;

        if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
        } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
        }
        try {
            text.setSelectionRange(selectionStart, selectionEnd);
        } catch(e){}

        inComposition = false;
    }

    function resetValue() {
        if (inComposition)
            return;
        text.value = PLACEHOLDER;
        if (useragent.isWebKit)
            syncValue.schedule();
    }

    useragent.isWebKit || host.addEventListener('changeSelection', function() {
        if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
        }
    });

    resetValue();
    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };
    if (!text.setSelectionRange && text.createTextRange) {
        text.setSelectionRange = function(selectionStart, selectionEnd) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveStart('character', selectionStart);
            range.moveEnd('character', selectionEnd);
            range.select();
        };
        isAllSelected = function(text) {
            try {
                var range = text.ownerDocument.selection.createRange();
            }catch(e) {}
            if (!range || range.parentElement() != text) return false;
                return range.text == text.value;
        }
    }
    if (useragent.isOldIE) {
        var inPropertyChange = false;
        var onPropertyChange = function(e){
            if (inPropertyChange)
                return;
            var data = text.value;
            if (inComposition || !data || data == PLACEHOLDER)
                return;
            if (e && data == PLACEHOLDER[0])
                return syncProperty.schedule();

            sendText(data);
            inPropertyChange = true;
            resetValue();
            inPropertyChange = false;
        };
        var syncProperty = lang.delayedCall(onPropertyChange);
        event.addListener(text, "propertychange", onPropertyChange);

        var keytable = { 13:1, 27:1 };
        event.addListener(text, "keyup", function (e) {
            if (inComposition && (!text.value || keytable[e.keyCode]))
                setTimeout(onCompositionEnd, 0);
            if ((text.value.charCodeAt(0)||0) < 129) {
                return syncProperty.call();
            }
            inComposition ? onCompositionUpdate() : onCompositionStart();
        });
        event.addListener(text, "keydown", function (e) {
            syncProperty.schedule(50);
        });
    }

    var onSelect = function(e) {
        if (copied) {
            copied = false;
        } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
        }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb};
    this.getInputHandler = function() {return inputHandler};
    var afterContextMenu = false;
    
    var sendText = function(data) {
        if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
        }
        if (pasted) {
            resetSelection();
            if (data)
                host.onPaste(data);
            pasted = false;
        } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu)
                host.execCommand("del", {source: "ace"});
            else // some versions of android do not fire keydown when pressing backspace
                host.execCommand("backspace", {source: "ace"});
        } else {
            if (data.substring(0, 2) == PLACEHOLDER)
                data = data.substr(2);
            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                data = data.substr(1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            
            if (data)
                host.onTextInput(data);
        }
        if (afterContextMenu)
            afterContextMenu = false;
    };
    var onInput = function(e) {
        if (inComposition)
            return;
        var data = text.value;
        sendText(data);
        resetValue();
    };
    
    var handleClipboardData = function(e, data) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
        if (data) {
            return clipboardData.setData(mime, data) !== false;
        } else {
            return clipboardData.getData(mime);
        }
    };

    var doCopy = function(e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);

        if (handleClipboardData(e, data)) {
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetValue();
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };
    
    var onCut = function(e) {
        doCopy(e, true);
    };
    
    var onCopy = function(e) {
        doCopy(e, false);
    };
    
    var onPaste = function(e) {
        var data = handleClipboardData(e);
        if (typeof data == "string") {
            if (data)
                host.onPaste(data);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

    event.addListener(text, "select", onSelect);

    event.addListener(text, "input", onInput);

    event.addListener(text, "cut", onCut);
    event.addListener(text, "copy", onCopy);
    event.addListener(text, "paste", onPaste);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
        event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                return;

            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        });
    }
    var onCompositionStart = function(e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly) 
            return;
        inComposition = {};
        host.onCompositionStart();
        setTimeout(onCompositionUpdate, 0);
        host.on("mousedown", onCompositionEnd);
        if (!host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
        }
        host.session.markUndoGroup();
    };

    var onCompositionUpdate = function() {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        var val = text.value.replace(/\x01/g, "");
        if (inComposition.lastValue === val) return;
        
        host.onCompositionUpdate(val);
        if (inComposition.lastValue)
            host.undo();
        inComposition.lastValue = val;
        if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
        }
    };

    var onCompositionEnd = function(e) {
        if (!host.onCompositionEnd || host.$readOnly) return;
        var c = inComposition;
        inComposition = false;
        var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            if (inComposition)
                return;
            else if (str == c.lastValue)
                resetValue();
            else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
            }
        });
        inputHandler = function compositionInputHandler(str) {
            if (timer)
                clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue)
                return "";
            if (c.lastValue && timer)
                host.undo();
            return str;
        };
        host.onCompositionEnd();
        host.removeListener("mousedown", onCompositionEnd);
        if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
        }
    };
    
    

    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
        event.addListener(text, "text", function(){syncComposition.schedule()});
    } else {
        event.addListener(text, "keyup", function(){syncComposition.schedule()});
        event.addListener(text, "keydown", function(){syncComposition.schedule()});
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    this.getElement = function() {
        return text;
    };

    this.setReadOnly = function(readOnly) {
       text.readOnly = readOnly;
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        resetSelection(host.selection.isEmpty());
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        this.moveToMouse(e, true);
    };
    
    this.moveToMouse = function(e, bringToFront) {
        if (!bringToFront && useragent.isOldIE)
            return;
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + "height:" + text.style.height + ";"
            + (useragent.isIE ? "opacity:0.1;" : "");

        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight -2;
        var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
        }; 
        move(e);

        if (e.type != "mousedown")
            return;

        if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;
        if (useragent.isWin && !useragent.isOldIE)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout)
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
            }
        }, useragent.isOldIE ? 200 : 0);
    }

    var onContextMenu = function(e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
    event.addListener(text, "contextmenu", onContextMenu);
};

exports.TextInput = TextInput;
});

ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
"use strict";

var dom = acequire("../lib/dom");
var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");

var DRAG_OFFSET = 0; // pixels

function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;

    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);

    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
}

(function() {

    this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            editor.$blockScrolling++;
            if (selectionEmpty)
                editor.selection.moveToPosition(pos);
            editor.$blockScrolling--;
            editor.textInput.onContextMenu(ev.domEvent);
            return; // stopping event here breaks contextmenu on ff mac
        }

        this.mousedownEvent.time = Date.now();
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    };

    this.startSelect = function(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        editor.$blockScrolling++;
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
        editor.$blockScrolling--;
    };

    this.select = function() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.extendSelectionBy = function(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.selectEnd =
    this.selectAllEnd =
    this.selectByWordsEnd =
    this.selectByLinesEnd = function() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
        }
    };

    this.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };

    this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    };

    this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    };

    this.onQuadClick = function(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    };

    this.onMouseWheel = function(ev) {
        if (ev.getAccelKey())
            return;
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }

        var t = ev.domEvent.timeStamp;
        var dt = t - (this.$lastScrollTime||0);
        
        var editor = this.editor;
        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };

}).call(DefaultHandlers.prototype);

exports.DefaultHandlers = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}

});

ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
function Tooltip (parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
}

(function() {
    this.$init = function() {
        this.$element = dom.createElement("div");
        this.$element.className = "ace_tooltip";
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    };
    this.getElement = function() {
        return this.$element || this.$init();
    };
    this.setText = function(text) {
        dom.setInnerText(this.getElement(), text);
    };
    this.setHtml = function(html) {
        this.getElement().innerHTML = html;
    };
    this.setPosition = function(x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    };
    this.setClassName = function(className) {
        dom.addCssClass(this.getElement(), className);
    };
    this.show = function(text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    };

    this.hide = function() {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
        }
    };
    this.getHeight = function() {
        return this.getElement().offsetHeight;
    };
    this.getWidth = function() {
        return this.getElement().offsetWidth;
    };

}).call(Tooltip.prototype);

exports.Tooltip = Tooltip;
});

ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(acequire, exports, module) {
"use strict";
var dom = acequire("../lib/dom");
var oop = acequire("../lib/oop");
var event = acequire("../lib/event");
var Tooltip = acequire("../tooltip").Tooltip;

function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });


    var tooltipTimeout, mouseEvent, tooltipAnnotation;

    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();

        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }

        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join("<br/>");

        tooltip.setHtml(tooltipAnnotation);
        tooltip.show();
        editor.on("mousewheel", hideTooltip);

        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        } else {
            var gutterElement = gutter.$cells[editor.session.documentToScreenRow(row, 0)].element;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
        }
    }

    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor.removeEventListener("mousewheel", hideTooltip);
        }
    }

    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();

        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);

        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;

        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    });
    
    editor.on("changeSession", hideTooltip);
}

function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
}

oop.inherits(GutterTooltip, Tooltip);

(function(){
    this.setPosition = function(x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    };

}).call(GutterTooltip.prototype);



exports.GutterHandler = GutterHandler;

});

ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
"use strict";

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    
    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;
    
    this.propagationStopped = false;
    this.defaultPrevented = false;
};

(function() {  
    
    this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    
    this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    
    this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
    };
    this.getDocumentPosition = function() {
        if (this.$pos)
            return this.$pos;
        
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    this.inSelection = function() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        

        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    };
    this.getButton = function() {
        return event.getButton(this.domEvent);
    };
    this.getShiftKey = function() {
        return this.domEvent.shiftKey;
    };
    
    this.getAccelKey = useragent.isMac
        ? function() { return this.domEvent.metaKey; }
        : function() { return this.domEvent.ctrlKey; };
    
}).call(MouseEvent.prototype);

});

ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
"use strict";

var dom = acequire("../lib/dom");
var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var blankImage = dom.createElement("img");
    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (useragent.isOpera)
        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

     exports.forEach(function(x) {
         mouseHandler[x] = this[x];
    }, this);
    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;

    this.onDragStart = function(e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage.scrollTop = 0;
        }
        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
        if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
        }
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };

    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };

    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };

    this.onDrop = function(e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.$blockScrolling += 1;
        editor.selection.fromOrientedRange(range);
        editor.$blockScrolling -= 1;
        if (editor.isFocused() && !isInternal)
            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

(function() {

    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    this.dragReadyEnd = function(e) {
        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };

    this.startDrag = function(){
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };

    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.DragdropHandler = DragdropHandler;

});

ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
"use strict";
var dom = acequire("./dom");

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};
exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}

});

ace.define("ace/lib/event_emitter",["require","exports","module"], function(acequire, exports, module) {
"use strict";

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        var old = handlers[eventName];
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
"no use strict";

var oop = acequire("./oop");
var EventEmitter = acequire("./event_emitter").EventEmitter;

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            optionNames = Object.keys(this.$options);
        } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}

function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function() { throw e; });
}

var AppConfig = function() {
    this.$defaultOptions = {};
};

(function() {
    oop.implement(this, EventEmitter);
    this.defineOptions = function(obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};

        Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = {forwardTo: opt};

            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);

        return this;
    };

    this.resetOptions = function(obj) {
        Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    };

    this.setDefaultValue = function(path, name, value) {
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    };

    this.setDefaultValues = function(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    };

    this.warn = warn;
    this.reportError = reportError;

}).call(AppConfig.prototype);

exports.AppConfig = AppConfig;

});

ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(acequire, exports, module) {
"no use strict";

var lang = acequire("./lib/lang");
var oop = acequire("./lib/oop");
var net = acequire("./lib/net");
var AppConfig = acequire("./lib/app_config").AppConfig;

module.exports = exports = new AppConfig();

var global = (function() {
    return this;
})();

var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {}
};

exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    return options[key];
};

exports.set = function(key, value) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    options[key] = value;
};

exports.all = function() {
    return lang.copyObject(options);
};
exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};

exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

exports.$loading = {};
exports.loadModule = function(moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }

    try {
        module = acequire(moduleName);
    } catch (e) {}
    if (module && !exports.$loading[moduleName])
        return onLoad && onLoad(module);

    if (!exports.$loading[moduleName])
        exports.$loading[moduleName] = [];

    exports.$loading[moduleName].push(onLoad);

    if (exports.$loading[moduleName].length > 1)
        return;

    var afterLoad = function() {
        acequire([moduleName], function(module) {
            exports._emit("load.module", {name: moduleName, module: module});
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
                onLoad && onLoad(module);
            });
        });
    };

    if (!exports.get("packaged"))
        return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
};
init(true);function init(packaged) {

    options.packaged = packaged || acequire.packaged || module.packaged || (global.define && define.packaged);

    if (!global.document)
        return "";

    var scriptOptions = {};
    var scriptUrl = "";
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript && currentScript.ownerDocument || document;
    
    var scripts = currentDocument.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute("src");
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
};

exports.init = init;

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}

});

ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"], function(acequire, exports, module) {
"use strict";

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
var MouseEvent = acequire("./mouse_event").MouseEvent;
var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
var config = acequire("../config");

var MouseHandler = function(editor) {
    var _self = this;
    this.editor = editor;

    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);

    var focusEditor = function(e) {
        if (!document.hasFocus || !document.hasFocus())
            window.focus();
        editor.focus();
    };

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
    event.addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, "onMouseEvent");
    if (editor.renderer.scrollBarV) {
        event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, "onMouseEvent");
        event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, "onMouseEvent");
        if (useragent.isIE) {
            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
        }
    }
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));

    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

    event.addListener(mouseTarget, "mousedown", focusEditor);

    event.addListener(gutterEl, "mousedown", function(e) {
        editor.focus();
        return event.preventDefault(e);
    });

    editor.on("mousemove", function(e){
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;

        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;

        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
        } else {
            renderer.setCursorStyle("");
        }
    });
};

(function() {
    this.onMouseEvent = function(name, e) {
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseMove = function(name, e) {
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    };

    this.setState = function(state) {
        this.state = state;
    };

    this.captureMouse = function(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;
        var renderer = this.editor.renderer;
        if (renderer.$keepTextAreaAtCursor)
            renderer.$keepTextAreaAtCursor = null;

        var self = this;
        var onMouseMove = function(e) {
            if (!e) return;
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();

            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
                renderer.$keepTextAreaAtCursor = true;
                renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
        };

        var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function() {
        var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    };
}).call(MouseHandler.prototype);

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimout: {initialValue: 0},
    tooltipFollowsMouse: {initialValue: true}
});


exports.MouseHandler = MouseHandler;
});

ace.define("ace/mouse/fold_handler",["require","exports","module"], function(acequire, exports, module) {
"use strict";

function FoldHandler(editor) {

    editor.on("click", function(e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);

            e.stop();
        }
    });

    editor.on("gutterclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });

    editor.on("gutterdblclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;

            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                if (fold) {
                    session.removeFold(fold);
                } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                }
            }
            e.stop();
        }
    });
}

exports.FoldHandler = FoldHandler;

});

ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(acequire, exports, module) {
"use strict";

var keyUtil  = acequire("../lib/keys");
var event = acequire("../lib/event");

var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = {editor: editor};
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};

(function() {
    this.setDefaultHandler = function(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    };

    this.setKeyboardHandler = function(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    };

    this.addKeyboardHandler = function(kb, pos) {
        if (!kb)
            return;
        if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    };

    this.removeKeyboardHandler = function(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    };

    this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
    };

    this.getStatusText = function() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    };

    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;
            if (toExecute.command == "null") {
                success = true;
            } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);                
            }
            if (success && e && hashId != -1 && 
                toExecute.passEvent != true && toExecute.command.passEvent != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        return success;
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text) {
        var success = this.$callKeyboardHandlers(-1, text);
        if (!success)
            this.$editor.commands.exec("insertstring", this.$editor, text);
    };

}).call(KeyBinding.prototype);

exports.KeyBinding = KeyBinding;
});

ace.define("ace/range",["require","exports","module"], function(acequire, exports, module) {
"use strict";
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            };
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
        else
            return new Range(this.start.row, 0, this.end.row, 0)
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var lang = acequire("./lib/lang");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var Range = acequire("./range").Range;
var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

    var self = this;
    this.lead.on("change", function(e) {
        self._emit("changeCursor");
        if (!self.$isEmpty)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });

    this.selectionAnchor.on("change", function() {
        if (!self.$isEmpty)
            self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);
    this.isEmpty = function() {
        return (this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        ));
    };
    this.isMultiLine = function() {
        if (this.isEmpty()) {
            return false;
        }

        return this.getRange().isMultiLine();
    };
    this.getCursor = function() {
        return this.lead.getPosition();
    };
    this.setSelectionAnchor = function(row, column) {
        this.anchor.setPosition(row, column);

        if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
        }
    };
    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead();
        else
            return this.anchor.getPosition();
    };
    this.getSelectionLead = function() {
        return this.lead.getPosition();
    };
    this.shiftSelection = function(columns) {
        if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return;
        }

        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();

        var isBackwards = this.isBackwards();

        if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);

        if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
                this.moveCursorTo(lead.row, lead.column + columns);
            });
        }
    };
    this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };
    this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.isEmpty())
            return Range.fromPoints(lead, lead);

        if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
        }
        else {
            return Range.fromPoints(anchor, lead);
        }
    };
    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };
    this.selectAll = function() {
        var lastRow = this.doc.getLength() - 1;
        this.setSelectionAnchor(0, 0);
        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
    };
    this.setRange =
    this.setSelectionRange = function(range, reverse) {
        if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
        } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
        }
        if (this.getRange().isEmpty())
            this.$isEmpty = true;
        this.$desiredColumn = null;
    };

    this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };
    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    };
    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    };
    this.moveTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };
    this.moveToPosition = function(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    };
    this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };
    this.selectWord = function() {
        this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    this.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
    };
    this.moveCursorLeft = function() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, -tabSize);
            else
                this.moveCursorBy(0, -1);
        }
    };
    this.moveCursorRight = function() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
                this.moveCursorBy(0, tabSize);
            else
                this.moveCursorBy(0, 1);
        }
    };
    this.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }

        var leftOfCursor = lang.stringReverse(str);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }
        if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.$shortWordEndIndex = function(rightOfCursor) {
        var match, index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    };

    this.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    };

    this.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));

            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    };

    this.moveCursorWordRight = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };

    this.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        if (chars === 0) {
            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }

        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
        
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])
                docPos.row++;
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function(row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
    };

    this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };

    this.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };
    this.getRangeOfMovements = function(func) {
        var start = this.getCursor();
        try {
            func.call(null, this);
            var end = this.getCursor();
            return Range.fromPoints(start,end);
        } catch(e) {
            return Range.fromPoints(start,start);
        } finally {
            this.moveCursorToPosition(start);
        }
    };

    this.toJSON = function() {
        if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };

    this.fromJSON = function(data) {
        if (data.start == undefined) {
            if (this.rangeList) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data.isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else
                data = data[0];
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };

    this.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    };

}).call(Selection.prototype);

exports.Selection = Selection;
});

ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(acequire, exports, module) {
"use strict";

var config = acequire("./config");
var MAX_TOKEN_COUNT = 2000;
var Tokenizer = function(rules) {
    this.states = rules;

    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {defaultToken: "text"};
        var flag = "g";

        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
                flag = "gi";
            if (rule.regex == null)
                continue;

            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                        rule: rule,
                        groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }

            if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule); // flag will be known only at the very end
            }

            mapping[matchTotal] = i;
            matchTotal += matchcount;

            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
                rule.onMatch = null;
        }
        
        if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
        }
        
        splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);

        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
};

(function() {
    this.$setMaxTokenCount = function(m) {
        MAX_TOKEN_COUNT = m | 0;
    };
    
    this.$applyToken = function(str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    },

    this.$arrayTokens = function(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };

    this.removeCapturingGroups = function(src) {
        var r = src.replace(
            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    };

    this.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        return new RegExp(src, (flag||"").replace("g", ""));
    };
    this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift()
                startState = stack.shift()
            }
        } else
            var stack = [];

        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    } else {
                        currentState = rule.next(currentState, stack);
                    }
                    
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                break;
            }

            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 2000),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);
        
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    };

    this.reportError = config.reportError;

}).call(Tokenizer.prototype);

exports.Tokenizer = Tokenizer;
});

ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(acequire, exports, module) {
"use strict";

var lang = acequire("../lib/lang");

var TextHighlightRules = function() {

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next != "string") {
                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                            rule.nextState = prefix + rule.nextState;
                    } else {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    this.getRules = function() {
        return this.$rules;
    };

    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        stack.shift();
        return stack.shift() || "start";
    };

    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                if (rule.include || typeof rule == "string") {
                    var includeName = rule.include || rule;
                    var toInsert = rules[includeName];
                } else if (Array.isArray(rule))
                    toInsert = rule;

                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    i--;
                    toInsert = null;
                }
                
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
                a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
                keywords[list[i]] = className;
        });
        if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
        }
        this.$keywordList = Object.keys(keywords);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
            : function(value) {return keywords[value] || defaultToken };
    };

    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.TextHighlightRules = TextHighlightRules;
});

ace.define("ace/mode/behaviour",["require","exports","module"], function(acequire, exports, module) {
"use strict";

var Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    }
    
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    }
    
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    }
    
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    }
    
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {}
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    }

}).call(Behaviour.prototype);

exports.Behaviour = Behaviour;
});

ace.define("ace/unicode",["require","exports","module"], function(acequire, exports, module) {
"use strict";
exports.packages = {};

addUnicodePackage({
    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
    Z:  "002000A01680180E2000-200A20282029202F205F3000",
    Zs: "002000A01680180E2000-200A202F205F3000",
    Zl: "2028",
    Zp: "2029",
    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
    Cc: "0000-001F007F-009F",
    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
    Co: "E000-F8FF",
    Cs: "D800-DFFF",
    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
});

function addUnicodePackage (pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
};

});

ace.define("ace/token_iterator",["require","exports","module"], function(acequire, exports, module) {
"use strict";
var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};

(function() { 
    this.stepBackward = function() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };   
    this.stepForward = function() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentTokenRow = function () {
        return this.$row;
    };     
    this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    };
            
}).call(TokenIterator.prototype);

exports.TokenIterator = TokenIterator;
});

ace.define("ace/mode/text",["require","exports","module","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(acequire, exports, module) {
"use strict";

var Tokenizer = acequire("../tokenizer").Tokenizer;
var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
var Behaviour = acequire("./behaviour").Behaviour;
var unicode = acequire("../unicode");
var lang = acequire("../lib/lang");
var TokenIterator = acequire("../token_iterator").TokenIterator;
var Range = acequire("../range").Range;

var Mode = function() {
    this.HighlightRules = TextHighlightRules;
    this.$behaviour = new Behaviour();
};

(function() {

    this.tokenRe = new RegExp("^["
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]+", "g"
    );

    this.nonTokenRe = new RegExp("^(?:[^"
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]|\\s])+", "g"
    );

    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === 'comment')
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            
            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };
            
            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
                return true;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();

        var sel = session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                this.$embeds.push(i);
                this.$modes[i] = new mapping[i]();
            }
        }

        var delegations = ['toggleBlockComment', 'toggleCommentLines', 'getNextLineIndent', 
            'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];

        for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
              };
            } (this));
        }
    };

    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0];
        if (typeof state != "string")
            state = state[0];
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };
    
    this.getKeywords = function(append) {
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };
    
    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;
});

ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(e) {
        var delta = e.data;
        var range = delta.range;

        if (range.start.row == range.end.row && range.start.row != this.row)
            return;

        if (range.start.row > this.row)
            return;

        if (range.start.row == this.row && range.start.column > this.column)
            return;

        var row = this.row;
        var column = this.column;
        var start = range.start;
        var end = range.end;

        if (delta.action === "insertText") {
            if (start.row === row && start.column <= column) {
                if (start.column === column && this.$insertRight) {
                } else if (start.row === end.row) {
                    column += end.column - start.column;
                } else {
                    column -= start.column;
                    row += end.row - start.row;
                }
            } else if (start.row !== end.row && start.row < row) {
                row += end.row - start.row;
            }
        } else if (delta.action === "insertLines") {
            if (start.row === row && column === 0 && this.$insertRight) {
            }
            else if (start.row <= row) {
                row += end.row - start.row;
            }
        } else if (delta.action === "removeText") {
            if (start.row === row && start.column < column) {
                if (end.column >= column)
                    column = start.column;
                else
                    column = Math.max(0, column - (end.column - start.column));

            } else if (start.row !== end.row && start.row < row) {
                if (end.row === row)
                    column = Math.max(0, column - end.column) + start.column;
                row -= (end.row - start.row);
            } else if (end.row === row) {
                row -= end.row - start.row;
                column = Math.max(0, column - end.column) + start.column;
            }
        } else if (delta.action == "removeLines") {
            if (start.row <= row) {
                if (end.row <= row)
                    row -= end.row - start.row;
                else {
                    row = start.row;
                    column = 0;
                }
            }
        }

        this.setPosition(row, column, true);
    };
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/lib/event_emitter","ace/range","ace/anchor"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var Range = acequire("./range").Range;
var Anchor = acequire("./anchor").Anchor;

var Document = function(text) {
    this.$lines = [];
    if (text.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(text)) {
        this._insertLines(0, text);
    } else {
        this.insert({row: 0, column:0}, text);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength();
        this.remove(new Range(0, 0, len, this.getLine(len-1).length));
        this.insert({row: 0, column:0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0)
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    else
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        if (range.start.row == range.end.row) {
            return this.getLine(range.start.row)
                .substring(range.start.column, range.end.column);
        }
        var lines = this.getLines(range.start.row, range.end.row);
        lines[0] = (lines[0] || "").substring(range.start.column);
        var l = lines.length - 1;
        if (range.end.row - range.start.row == l)
            lines[l] = lines[l].substring(0, range.end.column);
        return lines.join(this.getNewLineCharacter());
    };

    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length-1).length;
        } else if (position.row < 0)
            position.row = 0;
        return position;
    };
    this.insert = function(position, text) {
        if (!text || text.length === 0)
            return position;

        position = this.$clipPosition(position);
        if (this.getLength() <= 1)
            this.$detectNewLine(text);

        var lines = this.$split(text);
        var firstLine = lines.splice(0, 1)[0];
        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];

        position = this.insertInLine(position, firstLine);
        if (lastLine !== null) {
            position = this.insertNewLine(position); // terminate first line
            position = this._insertLines(position.row, lines);
            position = this.insertInLine(position, lastLine || "");
        }
        return position;
    };
    this.insertLines = function(row, lines) {
        if (row >= this.getLength())
            return this.insert({row: row, column: 0}, "\n" + lines.join("\n"));
        return this._insertLines(Math.max(row, 0), lines);
    };
    this._insertLines = function(row, lines) {
        if (lines.length == 0)
            return {row: row, column: 0};
        while (lines.length > 20000) {
            var end = this._insertLines(row, lines.slice(0, 20000));
            lines = lines.slice(20000);
            row = end.row;
        }

        var args = [row, 0];
        args.push.apply(args, lines);
        this.$lines.splice.apply(this.$lines, args);

        var range = new Range(row, 0, row + lines.length, 0);
        var delta = {
            action: "insertLines",
            range: range,
            lines: lines
        };
        this._signal("change", { data: delta });
        return range.end;
    };
    this.insertNewLine = function(position) {
        position = this.$clipPosition(position);
        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column);
        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));

        var end = {
            row : position.row + 1,
            column : 0
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: this.getNewLineCharacter()
        };
        this._signal("change", { data: delta });

        return end;
    };
    this.insertInLine = function(position, text) {
        if (text.length == 0)
            return position;

        var line = this.$lines[position.row] || "";

        this.$lines[position.row] = line.substring(0, position.column) + text
                + line.substring(position.column);

        var end = {
            row : position.row,
            column : position.column + text.length
        };

        var delta = {
            action: "insertText",
            range: Range.fromPoints(position, end),
            text: text
        };
        this._signal("change", { data: delta });

        return end;
    };
    this.remove = function(range) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        range.start = this.$clipPosition(range.start);
        range.end = this.$clipPosition(range.end);

        if (range.isEmpty())
            return range.start;

        var firstRow = range.start.row;
        var lastRow = range.end.row;

        if (range.isMultiLine()) {
            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
            var lastFullRow = lastRow - 1;

            if (range.end.column > 0)
                this.removeInLine(lastRow, 0, range.end.column);

            if (lastFullRow >= firstFullRow)
                this._removeLines(firstFullRow, lastFullRow);

            if (firstFullRow != firstRow) {
                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
                this.removeNewLine(range.start.row);
            }
        }
        else {
            this.removeInLine(firstRow, range.start.column, range.end.column);
        }
        return range.start;
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        if (startColumn == endColumn)
            return;

        var range = new Range(row, startColumn, row, endColumn);
        var line = this.getLine(row);
        var removed = line.substring(startColumn, endColumn);
        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
        this.$lines.splice(row, 1, newLine);

        var delta = {
            action: "removeText",
            range: range,
            text: removed
        };
        this._signal("change", { data: delta });
        return range.start;
    };
    this.removeLines = function(firstRow, lastRow) {
        if (firstRow < 0 || lastRow >= this.getLength())
            return this.remove(new Range(firstRow, 0, lastRow + 1, 0));
        return this._removeLines(firstRow, lastRow);
    };

    this._removeLines = function(firstRow, lastRow) {
        var range = new Range(firstRow, 0, lastRow + 1, 0);
        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);

        var delta = {
            action: "removeLines",
            range: range,
            nl: this.getNewLineCharacter(),
            lines: removed
        };
        this._signal("change", { data: delta });
        return removed;
    };
    this.removeNewLine = function(row) {
        var firstLine = this.getLine(row);
        var secondLine = this.getLine(row+1);

        var range = new Range(row, firstLine.length, row+1, 0);
        var line = firstLine + secondLine;

        this.$lines.splice(row, 2, line);

        var delta = {
            action: "removeText",
            range: range,
            text: this.getNewLineCharacter()
        };
        this._signal("change", { data: delta });
    };
    this.replace = function(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length == 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        if (text) {
            var end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }

        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            var delta = deltas[i];
            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this.insertLines(range.start.row, delta.lines);
            else if (delta.action == "insertText")
                this.insert(range.start, delta.text);
            else if (delta.action == "removeLines")
                this._removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "removeText")
                this.remove(range);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            var delta = deltas[i];

            var range = Range.fromPoints(delta.range.start, delta.range.end);

            if (delta.action == "insertLines")
                this._removeLines(range.start.row, range.end.row - 1);
            else if (delta.action == "insertText")
                this.remove(range);
            else if (delta.action == "removeLines")
                this._insertLines(range.start.row, delta.lines);
            else if (delta.action == "removeText")
                this.insert(range.start, delta.text);
        }
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: lines[l-1].length};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;

        while (self.lines[currentLine])
            currentLine++;

        var startLine = currentLine;

        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);
            processedLines ++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                
                self.running = setTimeout(self.$worker, 20);
                break;
            }
        }
        self.currentLine = currentLine;
        
        if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};

(function(){

    oop.implement(this, EventEmitter);
    this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    };
    this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    };
    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", {data: data});
    };
    this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        this.running = setTimeout(this.$worker, 700);
    };
    
    this.scheduleStart = function() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    }

    this.$updateOnChange = function(delta) {
        var range = delta.range;
        var startRow = range.start.row;
        var len = range.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    };
    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };
    this.getTokens = function(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    };

    this.$tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];

        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    };

}).call(BackgroundTokenizer.prototype);

exports.BackgroundTokenizer = BackgroundTokenizer;
});

ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
"use strict";

var lang = acequire("./lib/lang");
var oop = acequire("./lib/oop");
var Range = acequire("./range").Range;

var SearchHighlight = function(regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
};

(function() {
    this.MAX_RANGES = 500;
    
    this.setRegexp = function(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    };

    this.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }

            for (var j = ranges.length; j --; ) {
                markerLayer.drawSingleLineMarker(
                    html, ranges[j].toScreenRange(session), this.clazz, config);
            }
        }
    };

}).call(SearchHighlight.prototype);

exports.SearchHighlight = SearchHighlight;
});

ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(acequire, exports, module) {
"use strict";

var Range = acequire("../range").Range;
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    } else {
        folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column,
                           last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
    }, this);
}

(function() {
    this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    };

    this.addFold = function(fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    };

    this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
    };

    this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
                return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    };

    this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    };

    this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    };

    this.split = function(row, column) {
        var pos = this.getNextFoldTo(row, column);
        
        if (!pos || pos.kind == "inside")
            return null;
            
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    };

    this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    };

    this.toString = function() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    };

    this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    };
}).call(FoldLine.prototype);

exports.FoldLine = FoldLine;
});

ace.define("ace/range_list",["require","exports","module","ace/range"], function(acequire, exports, module) {
"use strict";
var Range = acequire("./range").Range;
var comparePoints = Range.comparePoints;

var RangeList = function() {
    this.ranges = [];
};

(function() {
    this.comparePoints = comparePoints;

    this.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    };

    this.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };

    this.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.call(removed, this.add(list[i]));
        }
        return removed;
    };

    this.substractPoint = function(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    };
    this.merge = function() {
        var removed = [];
        var list = this.ranges;
        
        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });
        
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        
        this.ranges = list;

        return removed;
    };

    this.contains = function(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    };

    this.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
    };

    this.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    };


    this.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };

    this.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
    };

    this.attach = function(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    };

    this.detach = function() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    };

    this.$onChange = function(e) {
        var changeRange = e.data.range;
        if (e.data.action[0] == "i"){
            var start = changeRange.start;
            var end = changeRange.end;
        } else {
            var end = changeRange.start;
            var start = changeRange.end;
        }
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;

        var colDiff = -start.column + end.column;
        var ranges = this.ranges;

        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow)
                continue;
            if (r.start.row > startRow)
                break;

            if (r.start.row == startRow && r.start.column >= start.column ) {
                if (r.start.column == start.column && this.$insertRight) {
                } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
                if (r.end.column == start.column && this.$insertRight) {
                    continue;
                }
                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                        r.end.column -= colDiff;
                }
                r.end.column += colDiff;
                r.end.row += lineDif;
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };

}).call(RangeList.prototype);

exports.RangeList = RangeList;
});

ace.define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"], function(acequire, exports, module) {
"use strict";

var Range = acequire("../range").Range;
var RangeList = acequire("../range_list").RangeList;
var oop = acequire("../lib/oop")
var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};

oop.inherits(Fold, RangeList);

(function() {

    this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    };

    this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };

    this.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
            return;

        if (!this.range.containsRange(fold))
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];

        if (cmp == 0)
            return afterStart.addSubFold(fold);
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterEnd = this.subFolds[j];

        if (cmp == 0)
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        fold.setFoldLine(this.foldLine);

        return fold;
    };
    
    this.restoreRange = function(range) {
        return restoreRange(range, this.start);
    };

}).call(Fold.prototype);

function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(acequire, exports, module) {
"use strict";

var Range = acequire("../range").Range;
var FoldLine = acequire("./fold_line").FoldLine;
var Fold = acequire("./fold").Fold;
var TokenIterator = acequire("../token_iterator").TokenIterator;

function Folding() {
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
                if (side == 1 && fold.range.isEnd(row, column)) {
                    continue;
                } else if (side == -1 && fold.range.isStart(row, column)) {
                    continue;
                }
                return fold;
            }
        }
    };
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                continue;
            }
            else if (cmp == -2) {
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    }
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if(start < last) {
                    if(start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0;//in one fold
                }
                break;
            } else if(end >= first){
                if (start >= first) //fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        if (!(startRow < endRow || 
            startRow == endRow && startColumn <= endColumn - 2))
            throw new Error("The range has to be at least 2 characters width");

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);

        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
            });
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._emit("changeFold", { data: fold, action: "add" });

        return fold;
    };

    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._emit("changeFold", { data: fold, action: "remove" });
    };

    this.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
        } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
            range = Range.fromPoints(location, location);
        else
            range = location;
        
        folds = this.getFoldsInRangeList(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            var subFolds = folds;
            while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
            }
        }
        if (folds.length)
            return folds;
    };
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if(placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        if (token && /^comment|string/.test(token.type)) {
            var range = new Range();
            var re = new RegExp(token.type.replace(/\..*/, "\\."));
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while(token && re.test(token.type));
                iterator.stepForward();
            }
            
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);
            
            if (dir != -1) {
                do {
                    token = iterator.stepForward();
                } while(token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
        }
    };

    this.foldAll = function(startRow, endRow, depth) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;

            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                try {
                    var fold = this.addFold("...", range);
                    if (fold)
                        fold.collapseChildren = depth;
                } catch(e) {}
            }
        }
    };
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;
            
        this.$foldMode = foldMode;
        
        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._emit("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };

    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    }

    this.onFoldWidgetClick = function(row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement)
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };
    
    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return;
        }

        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return;
            }
        }
        
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all) 
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        
        return range;
    };
    
    
    
    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        
        if (range)
            return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    this.updateFoldWidgets = function(e) {
        var delta = e.data;
        var range = delta.range;
        var firstRow = range.start.row;
        var len = range.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    }
}

exports.Folding = Folding;

});

ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(acequire, exports, module) {
"use strict";

var TokenIterator = acequire("../token_iterator").TokenIterator;
var Range = acequire("../range").Range;


function BracketMatch() {

    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };
    
    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column-1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        
        return range;
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{"
    };

    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        
         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end|start|begin)\b/, "")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:end|start|begin)\b/, "")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };
}
exports.BracketMatch = BracketMatch;

});

ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var lang = acequire("./lib/lang");
var config = acequire("./config");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var Selection = acequire("./selection").Selection;
var TextMode = acequire("./mode/text").Mode;
var Range = acequire("./range").Range;
var Document = acequire("./document").Document;
var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
var SearchHighlight = acequire("./search_highlight").SearchHighlight;

var EditSession = function(text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;

    this.$foldData = [];
    this.$foldData.toString = function() {
        return this.join("\n");
    }
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);

    if (typeof text != "object" || !text.getLine)
        text = new Document(text);

    this.setDocument(text);
    this.selection = new Selection(this);

    config.resetOptions(this);
    this.setMode(mode);
    config._signal("session", this);
};


(function() {

    oop.implement(this, EventEmitter);
    this.setDocument = function(doc) {
        if (this.doc)
            this.doc.removeListener("change", this.$onChange);

        this.doc = doc;
        doc.on("change", this.$onChange);

        if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    };
    this.getDocument = function() {
        return this.doc;
    };
    this.$resetRowCache = function(docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };

    this.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    };

    this.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer)
            this.bgTokenizer.start(0);
    };

    this.onChangeFold = function(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(e) {
        var delta = e.data;
        this.$modified = true;

        this.$resetRowCache(delta.range.start.row);

        var removedFolds = this.$updateInternalDataOnChange(e);
        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
                this.$deltasFold.push({
                    action: "removeFolds",
                    folds:  removedFolds
                });
            }

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", e);
    };
    this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    };
    this.getValue =
    this.toString = function() {
        return this.doc.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.getState = function(row) {
        return this.bgTokenizer.getState(row);
    };
    this.getTokens = function(row) {
        return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };
    this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;

            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();

                if (self.$deltasFold.length) {
                    self.$deltas.push({
                        group: "fold",
                        deltas: self.$deltasFold
                    });
                    self.$deltasFold = [];
                }

                if (self.$deltasDoc.length) {
                    self.$deltas.push({
                        group: "doc",
                        deltas: self.$deltasDoc
                    });
                    self.$deltasDoc = [];
                }

                if (self.$deltas.length > 0) {
                    undoManager.execute({
                        action: "aceupdate",
                        args: [self.$deltas, self],
                        merge: self.mergeUndoDeltas
                    });
                }
                self.mergeUndoDeltas = false;
                self.$deltas = [];
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        }
    };
    this.markUndoGroup = function() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };
    
    this.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        reset: function() {}
    };
    this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    };
    this.setUseSoftTabs = function(val) {
        this.setOption("useSoftTabs", val);
    };
    this.getUseSoftTabs = function() {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize);
    };
    this.getTabSize = function() {
        return this.$tabSize;
    };
    this.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    };

    this.$overwrite = false;
    this.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite);
    };
    this.getOverwrite = function() {
        return this.$overwrite;
    };
    this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    };
    this.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    };
    this.getBreakpoints = function() {
        return this.$breakpoints;
    };
    this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    };
    this.setBreakpoint = function(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.addMarker = function(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return id;
    };
    this.addDynamicMarker = function(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return marker;
    };
    this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
            delete (markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        }
    };
    this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    this.highlight = function(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    };
    this.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    };
    this.getAnnotations = function() {
        return this.$annotations || [];
    };
    this.clearAnnotations = function() {
        this.setAnnotations([]);
    };
    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };
    this.getWordRange = function(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    };
    this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };
    this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
    };
    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
    this.getUseWorker = function() { return this.$useWorker; };
    this.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    };

    this.$modes = {};
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = mode || "ace/mode/text";
        }
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };

    this.$onChangeMode = function(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode) 
            return;

        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
                _self._signal("tokenizerUpdate", e);
            });
        } else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;

        
        if (!$isPlaceholder) {
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
        }
    };

    this.$stopWorker = function() {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    };

    this.$startWorker = function() {
        try {
            this.$worker = this.$mode.createWorker(this);
        } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    };
    this.getMode = function() {
        return this.$mode;
    };

    this.$scrollTop = 0;
    this.setScrollTop = function(scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    };
    this.getScrollTop = function() {
        return this.$scrollTop;
    };

    this.$scrollLeft = 0;
    this.setScrollLeft = function(scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    };
    this.getScrollLeft = function() {
        return this.$scrollLeft;
    };
    this.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets) 
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };
    
    this.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    };

    this.$computeWidth = function(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };
    this.getLine = function(row) {
        return this.doc.getLine(row);
    };
    this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function() {
        return this.doc.getLength();
    };
    this.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function(position, text) {
        return this.doc.insert(position, text);
    };
    this.remove = function(range) {
        return this.doc.remove(range);
    };
    this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
                delta.deltas.forEach(function(foldDelta) {
                    this.addFolds(foldDelta.folds);
                }, this);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
        function isInsert(delta) {
            var insert =
                delta.action === "insertText" || delta.action === "insertLines";
            return isUndo ? !insert : insert;
        }

        var delta = deltas[0];
        var range, point;
        var lastDeltaIsInsert = false;
        if (isInsert(delta)) {
            range = Range.fromPoints(delta.range.start, delta.range.end);
            lastDeltaIsInsert = true;
        } else {
            range = Range.fromPoints(delta.range.start, delta.range.start);
            lastDeltaIsInsert = false;
        }

        for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
                point = delta.range.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(delta.range.start);
                }
                point = delta.range.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(delta.range.end);
                }
                lastDeltaIsInsert = true;
            } else {
                point = delta.range.start;
                if (range.compare(point.row, point.column) == -1) {
                    range =
                        Range.fromPoints(delta.range.start, delta.range.start);
                }
                lastDeltaIsInsert = false;
            }
        }
        if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                lastUndoRange.start.column += range.end.column - range.start.column;
                lastUndoRange.end.column += range.end.column - range.start.column;
            }

            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
                range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
                range.setEnd(lastUndoRange.end);
            }
        }

        return range;
    };
    this.replace = function(range, text) {
        return this.doc.replace(range, text);
    };
    this.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    };
    this.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.insert({row: row, column:0}, indentString);
    };
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };

    this.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });

        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeLines(firstRow, lastRow);
        this.doc.insertLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    };
    this.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };


    this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };


    this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    };

    this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min : null,
        max : null
    };
    this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal("changeWrapMode");
        }
    };
    this.getUseWrapMode = function() {
        return this.$useWrapMode;
    };
    this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    };
    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    };

    this.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    };
    this.getWrapLimit = function() {
        return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function() {
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    };

    this.$updateInternalDataOnChange = function(e) {
        var useWrapMode = this.$useWrapMode;
        var len;
        var action = e.data.action;
        var firstRow = e.data.range.start.row;
        var lastRow = e.data.range.end.row;
        var start = e.data.range.start;
        var end = e.data.range.end;
        var removedFolds = null;

        if (action.indexOf("Lines") != -1) {
            if (action == "insertLines") {
                lastRow = firstRow + (e.data.lines.length);
            } else {
                lastRow = firstRow;
            }
            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
        } else {
            len = lastRow - firstRow;
        }

        this.$updating = true;
        if (len != 0) {
            if (action.indexOf("remove") != -1) {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    } else
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            len = Math.abs(e.data.range.start.column - e.data.range.end.column);
            if (action.indexOf("remove") != -1) {
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    };

    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY =  4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;


    this.$computeWrapSplits = function(tokens, wrapLimit) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);
            var len = displayed.length;
            displayed.join("").
                replace(/12/g, function() {
                    len -= 1;
                }).
                replace(/2/g, function() {
                    len -= 1;
                });

            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }

        while (displayLength - lastSplit > wrapLimit) {
            var split = lastSplit + wrapLimit;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        break;
                    }
                }
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }
                addSplit(split);
                continue;
            }
            var minSplit = Math.max(split - (isCode ? 10 : wrapLimit-(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split);
        }
        return splits;
    };
    this.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    };
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    };

    this.lineWidgets = null;
    this.getRowLength = function(row) {
        if (this.lineWidgets)
            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };
    this.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    };
    this.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    };
    this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - screenColumn % this.$tabSize;
    };


    this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };


    this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function(screenRow, screenColumn) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }

        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                var splitIndex = Math.floor(screenRow - row);
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    };
    this.documentToScreenPosition = function(docRow, docColumn) {
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;


        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }
        var textLine = "";
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow ++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(
                    wrapRow[screenRowOffset - 1] || 0, textLine.length
                );
            }
        }

        return {
            row: screenRow,
            column: this.$getStringScreenWidth(textLine)[0]
        };
    };
    this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    };
    this.$setFontMetrics = function(fm) {
    };
    
    this.destroy = function() {
        if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
        }
        this.$stopWorker();
    };
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
               c >= 0x11A3 && c <= 0x11A7 ||
               c >= 0x11FA && c <= 0x11FF ||
               c >= 0x2329 && c <= 0x232A ||
               c >= 0x2E80 && c <= 0x2E99 ||
               c >= 0x2E9B && c <= 0x2EF3 ||
               c >= 0x2F00 && c <= 0x2FD5 ||
               c >= 0x2FF0 && c <= 0x2FFB ||
               c >= 0x3000 && c <= 0x303E ||
               c >= 0x3041 && c <= 0x3096 ||
               c >= 0x3099 && c <= 0x30FF ||
               c >= 0x3105 && c <= 0x312D ||
               c >= 0x3131 && c <= 0x318E ||
               c >= 0x3190 && c <= 0x31BA ||
               c >= 0x31C0 && c <= 0x31E3 ||
               c >= 0x31F0 && c <= 0x321E ||
               c >= 0x3220 && c <= 0x3247 ||
               c >= 0x3250 && c <= 0x32FE ||
               c >= 0x3300 && c <= 0x4DBF ||
               c >= 0x4E00 && c <= 0xA48C ||
               c >= 0xA490 && c <= 0xA4C6 ||
               c >= 0xA960 && c <= 0xA97C ||
               c >= 0xAC00 && c <= 0xD7A3 ||
               c >= 0xD7B0 && c <= 0xD7C6 ||
               c >= 0xD7CB && c <= 0xD7FB ||
               c >= 0xF900 && c <= 0xFAFF ||
               c >= 0xFE10 && c <= 0xFE19 ||
               c >= 0xFE30 && c <= 0xFE52 ||
               c >= 0xFE54 && c <= 0xFE66 ||
               c >= 0xFE68 && c <= 0xFE6B ||
               c >= 0xFF01 && c <= 0xFF60 ||
               c >= 0xFFE0 && c <= 0xFFE6;
    };

}).call(EditSession.prototype);

acequire("./edit_session/folding").Folding.call(EditSession.prototype);
acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },    
    wrapMethod: {
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$modified = true;
                    this.$resetRowCache(0);
                    this.$updateWrapData(0, this.getLength() - 1);
                }
            }
        },
        initialValue: "auto"
    },
    firstLineNumber: {
        set: function() {this._signal("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
        },
        initialValue: 4,
        handlesSet: true
    },
    overwrite: {
        set: function(val) {this._signal("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val)},
        get: function() {return this.doc.getNewLineMode()},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val) },
        get: function() { return this.$modeId }
    }
});

exports.EditSession = EditSession;
});

ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
"use strict";

var lang = acequire("./lib/lang");
var oop = acequire("./lib/oop");
var Range = acequire("./range").Range;

var Search = function() {
    this.$options = {};
};

(function() {
    this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
    };
    this.getOptions = function() {
        return lang.copyObject(this.$options);
    };
    this.setOptions = function(options) {
        this.$options = options;
    };
    this.find = function(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(range, row, offset) {
            if (!range.start) {
                var column = range.offset + (offset || 0);
                firstRange = new Range(row, column, row, column + range.length);
                if (!range.length && options.start && options.start.start
                    && options.skipCurrent != false && firstRange.isEqual(options.start)
                ) {
                    firstRange = null;
                    return false;
                }
            } else
                firstRange = range;
            return true;
        });

        return firstRange;
    };
    this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;
                
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;
                
                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex
                ) {
                    continue;
                }
                ranges.push(prevRange = new Range(
                    row, startIndex, row + len - 1, endIndex
                ));
                if (len > 2)
                    row = row + len - 2;
            }
        } else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                i++;

            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                j--;
            
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    };
    this.replace = function(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }
        
        return replacement;
    };

    this.$matchIterator = function(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;

        var callback;
        if (options.$isMultiLine) {
            var len = re.length;
            var matchIterator = function(line, row, offset) {
                var startIndex = line.search(re[0]);
                if (startIndex == -1)
                    return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(row + i);
                    if (line.search(re[i]) == -1)
                        return;
                }

                var endIndex = line.match(re[len - 1])[0].length;

                var range = new Range(row, startIndex, row + len - 1, endIndex);
                if (re.offset == 1) {
                    range.start.row--;
                    range.start.column = Number.MAX_VALUE;
                } else if (offset)
                    range.start.column += offset;

                if (callback(range))
                    return true;
            };
        } else if (options.backwards) {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = matches.length-1; i >= 0; i--)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        } else {
            var matchIterator = function(line, row, startIndex) {
                var matches = lang.getMatchOffsets(line, re);
                for (var i = 0; i < matches.length; i++)
                    if (callback(matches[i], row, startIndex))
                        return true;
            };
        }

        var lineIterator = this.$lineIterator(session, options);

        return {
            forEach: function(_callback) {
                callback = _callback;
                lineIterator.forEach(matchIterator);
            }
        };
    };

    this.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        if (options.wholeWord)
            needle = "\\b" + needle + "\\b";

        var modifier = options.caseSensitive ? "gm" : "gmi";

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    };

    this.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        if (parts[0] == "") {
            re.shift();
            re.offset = 1;
        } else {
            re.offset = 0;
        }
        return re;
    };

    this.$lineIterator = function(session, options) {
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
         
        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;

        var forEach = backwards ? function(callback) {
                var row = start.row;

                var line = session.getLine(row).substring(0, start.column);
                if (callback(line, row))
                    return;

                for (row--; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (callback(session.getLine(row), row))
                        return;
            } : function(callback) {
                var row = start.row;

                var line = session.getLine(row).substr(start.column);
                if (callback(line, row, start.column))
                    return;

                for (row = row+1; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;

                if (options.wrap == false)
                    return;

                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (callback(session.getLine(row), row))
                        return;
            };
        
        return {forEach: forEach};
    };

}).call(Search.prototype);

exports.Search = Search;
});

ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
"use strict";

var keyUtil = acequire("../lib/keys");
var useragent = acequire("../lib/useragent");
var KEY_MODS = keyUtil.KEY_MODS;

function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
}

function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
}

MultiHashHandler.prototype = HashHandler.prototype;

(function() {


    this.addCommand = function(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    };

    this.removeCommand = function(command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    };

    this.bindKey = function(key, command, asDefault) {
        if (typeof key == "object")
            key = key[this.platform];
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({exec: command, bindKey: key, name: command.name || key});

        key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, asDefault);
        }, this);
    };

    this._addCommandToBinding = function(keyId, command, asDefault) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        } else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }

            if (asDefault || command.isDefault)
                ckb[keyId].unshift(command);
            else
                ckb[keyId].push(command);
        }
    };

    this.addCommands = function(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;
            
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    };

    this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    };

    this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };

    this._buildKeyHash = function(command) {
        this.bindKey(command.bindKey, command);
    };
    this.parseKeys = function(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    };

    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    };

    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }

        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return {command: "null"};
            }
        }

        if (data.$keyChain && keyCode > 0)
            data.$keyChain = "";
        return {command: command};
    };

}).call(HashHandler.prototype);

exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;
});

ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../lib/oop");
var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var CommandManager = function(platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function(e) {
        return e.command.exec(e.editor, e.args || {});
    });
};

oop.inherits(CommandManager, MultiHashHandler);

(function() {

    oop.implement(this, EventEmitter);

    this.exec = function(command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args)) return true;
            }
            return false;
        }

        if (typeof command === "string")
            command = this.commands[command];

        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        var e = {editor: editor, command: command, args: args};
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);

        return e.returnValue === false ? false : true;
    };

    this.toggleRecording = function(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    };

    this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    };

    this.trimMacro = function(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };

}).call(CommandManager.prototype);

exports.CommandManager = CommandManager;

});

ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(acequire, exports, module) {
"use strict";

var lang = acequire("../lib/lang");
var config = acequire("../config");
var Range = acequire("../range").Range;

function bindKey(win, mac) {
    return {win: win, mac: mac};
}
exports.commands = [{
    name: "showSettingsMenu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    bindKey: bindKey("Alt-E", "Ctrl-E"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "goToPreviousError",
    bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selectall",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor) {
        var line = parseInt(prompt("Enter line number:"), 10);
        if (!isNaN(line)) {
            editor.gotoLine(line);
        }
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) { 
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findprevious",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectOrFindNext",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext(); 
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) { 
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
    },
    readOnly: true
}, {
    name: "overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    bindKey: bindKey("Shift-Up", "Shift-Up"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golineup",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttoend",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    bindKey: bindKey("Shift-Down", "Shift-Down"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    bindKey: bindKey("Shift-Left", "Shift-Left"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectlineend",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "togglerecording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selecttomatching",
    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "expandToMatching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "passKeysToBrowser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
},
{
    name: "cut",
    exec: function(editor) {
        var range = editor.getSelectionRange();
        editor._emit("cut", range);

        if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
        }
    },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "removeline",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    scrollIntoView: "selection",
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "modifyNumberUp",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
    }
}, {
    name: "undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesup",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "copylinesdown",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesdown",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "del",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "cut_or_delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) { 
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestart",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineend",
    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordleft",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordright",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "splitline",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "transposeletters",
    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); },
    scrollIntoView: "cursor"
}, {
    name: "touppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "tolowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "expandtoline",
    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
    exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "joinlines",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
                curLine = " " + curLine;
            }
            insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
    },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "invertSelection",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];
        if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                }
            }

            if (i === 0) {
                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                }
            } else {
                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
        }
    },
    readOnly: true,
    scrollIntoView: "none"
}];

});

ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator"], function(acequire, exports, module) {
"use strict";

acequire("./lib/fixoldbrowsers");

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var lang = acequire("./lib/lang");
var useragent = acequire("./lib/useragent");
var TextInput = acequire("./keyboard/textinput").TextInput;
var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
var EditSession = acequire("./edit_session").EditSession;
var Search = acequire("./search").Search;
var Range = acequire("./range").Range;
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var CommandManager = acequire("./commands/command_manager").CommandManager;
var defaultCommands = acequire("./commands/default_commands").commands;
var config = acequire("./config");
var TokenIterator = acequire("./token_iterator").TokenIterator;
var Editor = function(renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
    this.renderer.textarea = this.textInput.getElement();
    this.keyBinding = new KeyBinding(this);
    this.$mouseHandler = new MouseHandler(this);
    new FoldHandler(this);

    this.$blockScrolling = 0;
    this.$search = new Search().set({
        wrap: true
    });

    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);

    this.$initOperationListeners();
    
    this._$emitInputEvent = lang.delayedCall(function() {
        this._signal("input", {});
        if (this.session && this.session.bgTokenizer)
            this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    
    this.on("change", function(_, _self) {
        _self._$emitInputEvent.schedule(31);
    });

    this.setSession(session || new EditSession(""));
    config.resetOptions(this);
    config._signal("editor", this);
};

(function(){

    oop.implement(this, EventEmitter);

    this.$initOperationListeners = function() {
        function last(a) {return a[a.length - 1]}

        this.selections = [];
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);

        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

        this.on("change", function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
        }.bind(this), true);

        this.on("changeSelection", function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };

    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function(commadEvent) {
        if (this.curOp) {
            if (!commadEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
        }

        this.$opResetTimer.schedule();
        this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
            this.$blockScrolling++;
    };

    this.endOperation = function(e) {
        if (this.curOp) {
            if (e && e.returnValue === false)
                return this.curOp = null;
            this._signal("beforeEndOperation");
            var command = this.curOp.command;
            if (command.name && this.$blockScrolling > 0)
                this.$blockScrolling--;
            if (command && command.scrollIntoView) {
                switch (command.scrollIntoView) {
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (command.scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };
    this.$mergeableCommands = ["backspace", "del", "insertstring"];
    this.$historyTracker = function(e) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function(keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    };
    this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function(session) {
        if (this.session == session)
            return;

        var oldSession = this.session;
        if (oldSession) {
            this.session.removeEventListener("change", this.$onDocumentChange);
            this.session.removeEventListener("changeMode", this.$onChangeMode);
            this.session.removeEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.removeEventListener("changeTabSize", this.$onChangeTabSize);
            this.session.removeEventListener("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.removeEventListener("changeWrapMode", this.$onChangeWrapMode);
            this.session.removeEventListener("onChangeFold", this.$onChangeFold);
            this.session.removeEventListener("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.removeEventListener("changeBackMarker", this.$onChangeBackMarker);
            this.session.removeEventListener("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.removeEventListener("changeAnnotation", this.$onChangeAnnotation);
            this.session.removeEventListener("changeOverwrite", this.$onCursorChange);
            this.session.removeEventListener("changeScrollTop", this.$onScrollTopChange);
            this.session.removeEventListener("changeScrollLeft", this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.removeEventListener("changeCursor", this.$onCursorChange);
            selection.removeEventListener("changeSelection", this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.addEventListener("change", this.$onDocumentChange);
            this.renderer.setSession(session);
    
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.addEventListener("changeMode", this.$onChangeMode);
    
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.addEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
    
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.addEventListener("changeTabSize", this.$onChangeTabSize);
    
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.addEventListener("changeWrapLimit", this.$onChangeWrapLimit);
    
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.addEventListener("changeWrapMode", this.$onChangeWrapMode);
    
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.addEventListener("changeFold", this.$onChangeFold);
    
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.addEventListener("changeFrontMarker", this.$onChangeFrontMarker);
    
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.addEventListener("changeBackMarker", this.$onChangeBackMarker);
    
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.addEventListener("changeBreakpoint", this.$onChangeBreakpoint);
    
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.addEventListener("changeAnnotation", this.$onChangeAnnotation);
    
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.addEventListener("changeOverwrite", this.$onCursorChange);
    
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.addEventListener("changeScrollTop", this.$onScrollTopChange);
    
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.addEventListener("changeScrollLeft", this.$onScrollLeftChange);
    
            this.selection = session.getSelection();
            this.selection.addEventListener("changeCursor", this.$onCursorChange);
    
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.addEventListener("changeSelection", this.$onSelectionChange);
    
            this.onChangeMode();
    
            this.$blockScrolling += 1;
            this.onCursorChange();
            this.$blockScrolling -= 1;
    
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        } else {
            this.selection = null;
            this.renderer.setSession(session);
        }

        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });
        
        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        session && session._signal("changeEditor", {editor: this});
    };
    this.getSession = function() {
        return this.session;
    };
    this.setValue = function(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    };
    this.getValue = function() {
        return this.session.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.resize = function(force) {
        this.renderer.onResize(force);
    };
    this.setTheme = function(theme, cb) {
        this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function() {
        return this.renderer.getTheme();
    };
    this.setStyle = function(style) {
        this.renderer.setStyle(style);
    };
    this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
        return this.getOption("fontSize") ||
           dom.computedStyle(this.container, "fontSize");
    };
    this.setFontSize = function(size) {
        this.setOption("fontSize", size);
    };

    this.$highlightBrackets = function() {
        if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
        }

        if (this.$highlightPending) {
            return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            var pos = session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (session.$mode.getMatching) {
                var range = session.$mode.getMatching(self.session);
            }
            if (range)
                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.$highlightTags = function() {
        if (this.$highlightTagPending)
            return;
        var self = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
            self.$highlightTagPending = false;
            
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            
            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();
            
            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }

            if (token.type.indexOf("tag-open") != -1) {
                token = iterator.stepForward();
                if (!token)
                    return;
            }

            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();
            
            if (prevToken.value == '<'){
                do {
                    prevToken = token;
                    token = iterator.stepForward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<'){
                            depth++;
                        } else if (prevToken.value === '</'){
                            depth--;
                        }
                    }
                    
                } while (token && depth >= 0);
            } else {
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<') {
                            depth++;
                        } else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                } while (prevToken && depth <= 0);
                iterator.stepForward();
            }
            
            if (!token) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }
            
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column+token.value.length);
            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range)!==0) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
            }
            
            if (range && !session.$tagHighlight)
                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.focus = function() {
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    };
    this.isFocused = function() {
        return this.textInput.isFocused();
    };
    this.blur = function() {
        this.textInput.blur();
    };
    this.onFocus = function(e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    };
    this.onBlur = function(e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    };

    this.$cursorChange = function() {
        this.renderer.updateCursor();
    };
    this.onDocumentChange = function(e) {
        var delta = e.data;
        var range = delta.range;
        var lastRow;

        if (range.start.row == range.end.row && delta.action != "insertLines" && delta.action != "removeLines")
            lastRow = range.end.row;
        else
            lastRow = Infinity;
        this.renderer.updateLines(range.start.row, lastRow, this.session.$useWrapMode);

        this._signal("change", e);
        this.$cursorChange();
        this.$updateHighlightActiveLine();
    };

    this.onTokenizerUpdate = function(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };


    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function() {
        this.$cursorChange();

        if (!this.$blockScrolling) {
            config.warn("Automatically scrolling cursor into view after selection change",
                "this will be disabled in the next version",
                "set editor.$blockScrolling = Infinity to disable this message"
            );
            this.renderer.scrollCursorIntoView();
        }

        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
        this._signal("changeSelection");
    };

    this.$updateHighlightActiveLine = function() {
        var session = this.getSession();

        var highlight;
        if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
                highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    };

    this.onSelectionChange = function(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal("changeSelection");
    };

    this.$getSelectionHighLightRegexp = function() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0),
                                    Math.min(endOuter, lineCols));
        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return;

        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        return re;
    };


    this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
    };


    this.onChangeBreakpoint = function() {
        this.renderer.updateBreakpoints();
    };

    this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };


    this.onChangeMode = function(e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    };


    this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
    };


    this.onChangeFold = function() {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
    };
    this.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function() {
        var text = this.getSelectedText();
        this._signal("copy", text);
        return text;
    };
    this.onCopy = function() {
        this.commands.exec("copy", this);
    };
    this.onCut = function() {
        this.commands.exec("cut", this);
    };
    this.onPaste = function(text) {
        if (this.$readOnly)
            return;

        var e = {text: text};
        this._signal("paste", e);
        text = e.text;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            this.insert(text);
        } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;

            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
                return this.commands.exec("insertstring", this, text);

            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    this.session.remove(range);

                this.session.insert(range.start, lines[i]);
            }
        }
        this.renderer.scrollCursorIntoView();
    };

    this.execCommand = function(command, args) {
        return this.commands.exec(command, this, args);
    };
    this.insert = function(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    this.session.mergeUndoDeltas = false;
                    this.$mergeNextCommand = false;
                }
                text = transform.text;

            }
        }
        
        if (text == "\t")
            text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite()) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        var end = session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }

        if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

            session.insert({row: cursor.row+1, column: 0}, lineIndent);
        }
        if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
    };

    this.onTextInput = function(text) {
        this.keyBinding.onTextInput(text);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function() {
        return this.session.getOverwrite();
    };
    this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
    };
    this.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
    };
    this.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    };
    this.getDragDelay = function() {
        return this.getOption("dragDelay");
    };
    this.setSelectionStyle = function(val) {
        this.setOption("selectionStyle", val);
    };
    this.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
    };
    this.setHighlightActiveLine = function(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    };
    this.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };
    this.setHighlightSelectedWord = function(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    };
    this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
    };

    this.setAnimatedScroll = function(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    };

    this.getAnimatedScroll = function(){
        return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
    };

    this.setDisplayIndentGuides = function(display) {
        this.renderer.setDisplayIndentGuides(display);
    };

    this.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
    };
    this.getReadOnly = function() {
        return this.getOption("readOnly");
    };
    this.setBehavioursEnabled = function (enabled) {
        this.setOption("behavioursEnabled", enabled);
    };
    this.getBehavioursEnabled = function () {
        return this.getOption("behavioursEnabled");
    };
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    };
    this.getWrapBehavioursEnabled = function () {
        return this.getOption("wrapBehavioursEnabled");
    };
    this.setShowFoldWidgets = function(show) {
        this.setOption("showFoldWidgets", show);

    };
    this.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
    };

    this.setFadeFoldWidgets = function(fade) {
        this.setOption("fadeFoldWidgets", fade);
    };

    this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
    };
    this.remove = function(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.removeWordRight = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeWordLeft = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineStart = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.splitLine = function() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
    };
    this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }
        
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    };
    this.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    };
    this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    };
    this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    };
    this.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        }
    };
    this.removeLines = function() {
        var rows = this.$getSelectedRows();
        var range;
        if (rows.first === 0 || rows.last+1 < this.session.getLength())
            range = new Range(rows.first, 0, rows.last+1, 0);
        else
            range = new Range(
                rows.first-1, this.session.getLine(rows.first-1).length,
                rows.last, this.session.getLine(rows.last).length
            );
        this.session.remove(range);
        this.clearSelection();
    };

    this.duplicateSelection = function() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    };
    this.moveLinesDown = function() {
        this.$moveLines(1, false);
    };
    this.moveLinesUp = function() {
        this.$moveLines(-1, false);
    };
    this.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function() {
        this.$moveLines(-1, true);
    };
    this.copyLinesDown = function() {
        this.$moveLines(1, true);
    };
    this.$moveLines = function(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;

            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1) rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy) diff = 0;
                totalDiff += diff;
            }

            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    };
    this.$getSelectedRows = function(range) {
        range = (range || this.getSelectionRange()).collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };

    this.onCompositionStart = function(text) {
        this.renderer.showComposition(this.getCursorPosition());
    };

    this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
        this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        this.$blockScrolling++;
        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        this.$blockScrolling--;

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function() {
        this.$moveByPage(1, true);
    };
    this.selectPageUp = function() {
        this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function() {
       this.$moveByPage(1, false);
    };
    this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function() {
        this.$moveByPage(1);
    };
    this.scrollPageUp = function() {
        this.$moveByPage(-1);
    };
    this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function() {
        return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function() {
        return this.selection.getRange();
    };
    this.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    };
    this.clearSelection = function() {
        this.selection.clearSelection();
    };
    this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken || iterator.stepForward();

        if (!token) return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };
        
        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                        break;
                    }
                }
            }
            else if (token && token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }
                
                if (prevToken.value === '<') {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }
                
                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);
        if (!matchType)
            return;

        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1) 
                var tag = token.value;
            else
                return;

            range = new Range(
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2
            );
            if (range.compare(cursor.row, cursor.column) === 0) {
                found = false;
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (prevToken) {
                        if (prevToken.type.indexOf('tag-close') !== -1) {
                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                        }

                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                            if (prevToken.value === '<') {
                                depth[tag]++;
                            }
                            else if (prevToken.value === '</') {
                                depth[tag]--;
                            }
                            
                            if (depth[tag] === 0)
                                found = true;
                        }
                    }
                } while (prevToken && !found);
            }
            if (token && token.type.indexOf('tag-name')) {
                pos = range.start;
                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    pos = range.end;
            }
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                } else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            } else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    };
    this.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        this.$blockScrolling += 1;
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        this.$blockScrolling -= 1;

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function(row, column) {
        this.selection.moveTo(row, column);
    };
    this.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };
    this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };
    this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };
    this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };
    this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };
    this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };
    this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };
    this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };
    this.replace = function(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
        }

        return replaced;
    };
    this.replaceAll = function(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        this.$blockScrolling += 1;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;

        return replaced;
    };

    this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    };
    this.getLastSearchOptions = function() {
        return this.$search.getOptions();
    };
    this.find = function(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };
    this.findNext = function(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    };
    this.findPrevious = function(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    };

    this.revealRange = function(range, animate) {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function() {
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session) {
            this.session.destroy();
        }
    };
    this.setAutoScrollEditorIntoView = function(enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())
            ) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.removeEventListener("changeSelection", onChangeSelection);
            this.renderer.removeEventListener("afterRender", onAfterRender);
            this.renderer.removeEventListener("beforeRender", onBeforeRender);
        };
    };


    this.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    };

}).call(Editor.prototype);



config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            this.$resetCursorStyle(); 
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    autoScrollEditorIntoView: {
        set: function(val) {this.setAutoScrollEditorIntoView(val)}
    },

    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    showLineNumbers: "renderer",
    showGutter: "renderer",
    displayIndentGuides: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    foldStyle: "session",
    mode: "session"
});

exports.Editor = Editor;
});

ace.define("ace/undomanager",["require","exports","module"], function(acequire, exports, module) {
"use strict";
var UndoManager = function() {
    this.reset();
};

(function() {
    this.execute = function(options) {
        var deltas = options.args[0];
        this.$doc  = options.args[1];
        if (options.merge && this.hasUndo()){
            this.dirtyCounter--;
            deltas = this.$undoStack.pop().concat(deltas);
        }
        this.$undoStack.push(deltas);
        this.$redoStack = [];

        if (this.dirtyCounter < 0) {
            this.dirtyCounter = NaN;
        }
        this.dirtyCounter++;
    };
    this.undo = function(dontSelect) {
        var deltas = this.$undoStack.pop();
        var undoSelectionRange = null;
        if (deltas) {
            undoSelectionRange =
                this.$doc.undoChanges(deltas, dontSelect);
            this.$redoStack.push(deltas);
            this.dirtyCounter--;
        }

        return undoSelectionRange;
    };
    this.redo = function(dontSelect) {
        var deltas = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltas) {
            redoSelectionRange =
                this.$doc.redoChanges(deltas, dontSelect);
            this.$undoStack.push(deltas);
            this.dirtyCounter++;
        }

        return redoSelectionRange;
    };
    this.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
        this.dirtyCounter = 0;
    };
    this.hasUndo = function() {
        return this.$undoStack.length > 0;
    };
    this.hasRedo = function() {
        return this.$redoStack.length > 0;
    };
    this.markClean = function() {
        this.dirtyCounter = 0;
    };
    this.isClean = function() {
        return this.dirtyCounter === 0;
    };

}).call(UndoManager.prototype);

exports.UndoManager = UndoManager;
});

ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter"], function(acequire, exports, module) {
"use strict";

var dom = acequire("../lib/dom");
var oop = acequire("../lib/oop");
var lang = acequire("../lib/lang");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    
    this.gutterWidth = 0;

    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);

    this.$cells = [];
};

(function() {

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
        if (this.session)
            this.session.removeEventListener("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    };

    this.addGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    };

    this.removeGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    };

    this.setAnnotations = function(annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: []};
           
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);

            var type = annotation.type;
            if (type == "error")
                rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
                rowInfo.className = " ace_info";
        }
    };

    this.$updateAnnotations = function (e) {
        if (!this.$annotations.length)
            return;
        var delta = e.data;
        var range = delta.range;
        var firstRow = range.start.row;
        var len = range.end.row - firstRow;
        if (len === 0) {
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };

    this.update = function(config) {
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineNumber = 0;
        
        var gutterRenderer = session.gutterRenderer || this.$renderer;

        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$cells.length > index + 1) {
                    cell = this.$cells.pop();
                    this.element.removeChild(cell.element);
                }
                break;
            }

            cell = this.$cells[++index];
            if (!cell) {
                cell = {element: null, textNode: null, foldWidget: null};
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode('');
                cell.element.appendChild(cell.textNode);
                this.element.appendChild(cell.element);
                this.$cells[index] = cell;
            }

            var className = "ace_gutter-cell ";
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (this.$annotations[row])
                className += this.$annotations[row].className;
            if (cell.element.className != className)
                cell.element.className = className;

            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
                cell.element.style.height = height;

            if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                if (!cell.foldWidget) {
                    cell.foldWidget = dom.createElement("span");
                    cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (cell.foldWidget.className != className)
                    cell.foldWidget.className = className;

                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                    cell.foldWidget.style.height = height;
            } else {
                if (cell.foldWidget) {
                    cell.element.removeChild(cell.foldWidget);
                    cell.foldWidget = null;
                }
            }
            
            var text = lastLineNumber = gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber;
            if (text != cell.textNode.data)
                cell.textNode.data = text;

            row++;
        }

        this.element.style.height = config.minHeight + "px";

        if (this.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineNumber, config)
            : lastLineNumber.toString().length * config.characterWidth;
        
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
        }
    };

    this.$fixedWidth = false;
    
    this.$showLineNumbers = true;
    this.$renderer = "";
    this.setShowLineNumbers = function(show) {
        this.$renderer = !show && {
            getWidth: function() {return ""},
            getText: function() {return ""}
        };
    };
    
    this.getShowLineNumbers = function() {
        return this.$showLineNumbers;
    };
    
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    };
    
    this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
    };

    this.$computePadding = function() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
        this.$padding.right = parseInt(style.paddingRight) || 0;
        return this.$padding;
    };

    this.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    };

}).call(Gutter.prototype);

exports.Gutter = Gutter;

});

ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(acequire, exports, module) {
"use strict";

var Range = acequire("../range").Range;
var dom = acequire("../lib/dom");

var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};

(function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
    };
    this.setSession = function(session) {
        this.session = session;
    };
    
    this.setMarkers = function(markers) {
        this.markers = markers;
    };

    this.update = function(config) {
        var config = config || this.config;
        if (!config)
            return;

        this.config = config;


        var html = [];
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start", config);
            }
        }
        this.element.innerHTML = html.join("");
    };

    this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var row = range.start.row;

        var lineRange = new Range(
            row, range.start.column,
            row, this.session.getScreenLastRowColumn(row)
        );
        this.drawSingleLineMarker(stringBuilder, lineRange, clazz + " ace_start", layerConfig, 1, extraStyle);
        row = range.end.row;
        lineRange = new Range(row, 0, row, range.end.column);
        this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, extraStyle);

        for (row = range.start.row + 1; row < range.end.row; row++) {
            lineRange.start.row = row;
            lineRange.end.row = row;
            lineRange.end.column = this.session.getScreenLastRowColumn(row);
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, extraStyle);
        }
    };
    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height = config.lineHeight;
        var top = this.$getTop(range.start.row, config);
        var left = padding + range.start.column * config.characterWidth;
        extraStyle = extraStyle || "";

        stringBuilder.push(
            "<div class='", clazz, " ace_start' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle, "'></div>"
        );
        top = this.$getTop(range.end.row, config);
        var width = range.end.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height < 0)
            return;
        top = this.$getTop(range.start.row + 1, config);

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
    };
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle || "", "'></div>"
        );
    };

    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };
    
    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };

}).call(Marker.prototype);

exports.Marker = Marker;

});

ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../lib/oop");
var dom = acequire("../lib/dom");
var lang = acequire("../lib/lang");
var useragent = acequire("../lib/useragent");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var Text = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
};

(function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6";
    this.EOL_CHAR_LF = "\xAC";
    this.EOL_CHAR_CRLF = "\xa4";
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = "\u2192"; //"\u21E5";
    this.SPACE_CHAR = "\xB7";
    this.$padding = 0;

    this.$updateEolChar = function() {
        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
           ? this.EOL_CHAR_LF
           : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    }

    this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.padding = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
        return this.$fontMetrics.$characterSize.height || 0;
    };

    this.getCharacterWidth = function() {
        return this.$fontMetrics.$characterSize.width || 0;
    };
    
    this.$setFontMetrics = function(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function(e) {
            this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    }

    this.checkForSizeChanges = function() {
        this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function(session) {
        this.session = session;
        if (session)
            this.$computeTabString();
    };

    this.showInvisibles = false;
    this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        this.$computeTabString();
        return true;
    };

    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };

    this.$tabStrings = [];
    this.onChangeTabSize =
    this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
                    + this.TAB_CHAR
                    + lang.stringRepeat(" ", i - 1)
                    + "</span>");
            } else {
                tabStr.push(lang.stringRepeat(" ", i));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = "";
            var tabClass = "";
            if (this.showInvisibles) {
                className += " ace_invisible";
                spaceClass = " ace_invisible_space";
                tabClass = " ace_invisible_tab";
                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                var tabContent = this.TAB_CHAR + lang.stringRepeat(" ", this.tabSize - 1);
            } else{
                var spaceContent = lang.stringRepeat(" ", this.tabSize);
                var tabContent = spaceContent;
            }

            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
        }
    };

    this.updateLines = function(config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
        }
        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                var html = [];
                this.$renderLine(
                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
                );
                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                lineElement.innerHTML = html.join("");
            }
            row++;
        }
    };

    this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        var el = this.element;
        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                el.removeChild(el.firstChild);

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                el.removeChild(el.lastChild);

        if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
                el.insertBefore(fragment, el.firstChild);
            else
                el.appendChild(fragment);
        }

        if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
        }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = this.element.ownerDocument.createDocumentFragment();
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var container = dom.createElement("div");

            var html = [];
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
                container.className = 'ace_line_group';
                fragment.appendChild(container);
                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

            } else {
                while(container.firstChild)
                    fragment.appendChild(container.firstChild);
            }

            row++;
        }
        return fragment;
    };

    this.update = function(config) {
        this.config = config;

        var html = [];
        var firstRow = config.firstRow, lastRow = config.lastRow;

        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > lastRow)
                break;

            if (this.$useLineGroups())
                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

            if (this.$useLineGroups())
                html.push("</div>"); // end the line group

            row++;
        }
        this.element.innerHTML = html.join("");
    };

    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };

    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
        var self = this;
        var replaceReg = /\t|&|<|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
        var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (a) {
                return self.showInvisibles
                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
                    : c;
            } else if (c == "&") {
                return "&#38;";
            } else if (c == "<") {
                return "&#60;";
            } else if (c == "\t") {
                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                screenColumn += tabSize - 1;
                return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                var space = self.showInvisibles ? self.SPACE_CHAR : "";
                screenColumn += 1;
                return "<span class='" + classToUse + "' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + space + "</span>";
            } else if (b) {
                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
                screenColumn += 1;
                return "<span class='ace_cjk' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + c + "</span>";
            }
        };

        var output = value.replace(replaceReg, replaceFunc);

        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
        }
        else {
            stringBuilder.push(output);
        }
        return screenColumn + value.length;
    };

    this.renderIndentGuide = function(stringBuilder, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
            return value.substr(cols);
        } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
        }
        return value;
    };

    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(stringBuilder, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    if (!onlyContents) {
                        stringBuilder.push("</div>",
                            "<div class='ace_line' style='height:",
                            this.config.lineHeight, "px'>"
                        );
                    }

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn, token, value
                    );
                }
            }
        }
    };

    this.$renderSimpleLine = function(stringBuilder, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
            value = this.renderIndentGuide(stringBuilder, value);
        if (value)
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        }
    };
    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);


        if (!onlyContents) {
            stringBuilder.push(
                "<div class='ace_line' style='height:", 
                    this.config.lineHeight * (
                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
                    ), "px'>"
            );
        }

        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length)
                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
            else
                this.$renderSimpleLine(stringBuilder, tokens);
        }

        if (this.showInvisibles) {
            if (foldLine)
                row = foldLine.end.row

            stringBuilder.push(
                "<span class='ace_invisible ace_invisible_eol'>",
                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
                "</span>"
            );
        }
        if (!onlyContents)
            stringBuilder.push("</div>");
    };

    this.$getFoldLineTokens = function(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    };

    this.$useLineGroups = function() {
        return this.session.getUseWrapMode();
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
        delete this.$measureNode;
    };

}).call(Text.prototype);

exports.Text = Text;

});

ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
"use strict";

var dom = acequire("../lib/dom");
var IE8;

var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);
    
    if (IE8 === undefined)
        IE8 = "opacity" in this.element;

    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;

    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
    this.$updateCursors = this.$updateVisibility.bind(this);
};

(function() {
    
    this.$updateVisibility = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.visibility = val ? "" : "hidden";
    };
    this.$updateOpacity = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.opacity = val ? "" : "0";
    };
    

    this.$padding = 0;
    this.setPadding = function(padding) {
        this.$padding = padding;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.setBlinking = function(blinking) {
        if (blinking != this.isBlinking){
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };

    this.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval != this.blinkInterval){
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };

    this.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking && !IE8) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.$updateCursors = (smoothBlinking 
                ? this.$updateOpacity
                : this.$updateVisibility).bind(this);
            this.restartTimer();
        }
    };

    this.addCursor = function() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };

    this.removeCursor = function() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };

    this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.restartTimer = function() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        
        update(true);

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
            return;

        if (this.smoothBlinking) {
            setTimeout(function(){
                dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
        }
        
        var blink = function(){
            this.timeoutId = setTimeout(function() {
                update(false);
            }, 0.6 * this.blinkInterval);
        }.bind(this);

        this.intervalId = setInterval(function() {
            update(true);
            blink();
        }, this.blinkInterval);

        blink();
    };

    this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    };

    this.update = function(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < 0) && i > 1) {
                continue;
            }

            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

            if (!this.drawCursor) {
                style.left = pixelPos.left + "px";
                style.top = pixelPos.top + "px";
                style.width = config.characterWidth + "px";
                style.height = config.lineHeight + "px";
            } else {
                this.drawCursor(style, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };

    this.drawCursor = null;

    this.$setOverwrite = function(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    };

    this.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };

}).call(Cursor.prototype);

exports.Cursor = Cursor;

});

ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var event = acequire("./lib/event");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    this.setVisible(false);
    this.skipEvent = false;

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
};

(function() {
    oop.implement(this, EventEmitter);

    this.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    renderer.$scrollbarWidth = 
    this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
    this.element.style.width = (this.width || 15) + 5 + "px";
};

oop.inherits(VScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-v';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    };
    this.getWidth = function() {
        return this.isVisible ? this.width : 0;
    };
    this.setHeight = function(height) {
        this.element.style.height = height + "px";
    };
    this.setInnerHeight = function(height) {
        this.inner.style.height = height + "px";
    };
    this.setScrollHeight = function(height) {
        this.inner.style.height = height + "px";
    };
    this.setScrollTop = function(scrollTop) {
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = this.element.scrollTop = scrollTop;
        }
    };

}).call(VScrollBar.prototype);
var HScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
    this.element.style.height = (this.height || 15) + 5 + "px";
};

oop.inherits(HScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-h';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    };
    this.getHeight = function() {
        return this.isVisible ? this.height : 0;
    };
    this.setWidth = function(width) {
        this.element.style.width = width + "px";
    };
    this.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollLeft = function(scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };

}).call(HScrollBar.prototype);


exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility

exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;
});

ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(acequire, exports, module) {
"use strict";

var event = acequire("./lib/event");


var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
};

(function() {


    this.schedule = function(change) {
        this.changes = this.changes | change;
        if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function() {
                _self.pending = false;
                var changes;
                while (changes = _self.changes) {
                    _self.changes = 0;
                    _self.onRender(changes);
                }
            }, this.window);
        }
    };

}).call(RenderLoop.prototype);

exports.RenderLoop = RenderLoop;
});

ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("../lib/oop");
var dom = acequire("../lib/dom");
var lang = acequire("../lib/lang");
var useragent = acequire("../lib/useragent");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var CHAR_COUNT = 0;

var FontMetrics = exports.FontMetrics = function(parentEl, interval) {
    this.el = dom.createElement("div");
    this.$setMeasureNodeStyles(this.el.style, true);
    
    this.$main = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$main.style);
    
    this.$measureNode = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$measureNode.style);
    
    
    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);
    
    if (!CHAR_COUNT)
        this.$testFractionalRect();
    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
    
    this.$characterSize = {width: 0, height: 0};
    this.checkForSizeChanges();
};

(function() {

    oop.implement(this, EventEmitter);
        
    this.$characterSize = {width: 0, height: 0};
    
    this.$testFractionalRect = function() {
        var el = dom.createElement("div");
        this.$setMeasureNodeStyles(el.style);
        el.style.width = "0.2px";
        document.documentElement.appendChild(el);
        var w = el.getBoundingClientRect().width;
        if (w > 0 && w < 1)
            CHAR_COUNT = 50;
        else
            CHAR_COUNT = 100;
        el.parentNode.removeChild(el);
    };
    
    this.$setMeasureNodeStyles = function(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";

        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        } else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    };

    this.checkForSizeChanges = function() {
        var size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    };

    this.$pollSizeChanges = function() {
        if (this.$pollSizeChangesTimer)
            return this.$pollSizeChangesTimer;
        var self = this;
        return this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
        }, 500);
    };
    
    this.setPolling = function(val) {
        if (val) {
            this.$pollSizeChanges();
        } else {
            if (this.$pollSizeChangesTimer)
                this.$pollSizeChangesTimer;
        }
    };

    this.$measureSizes = function() {
        if (CHAR_COUNT === 50) {
            var rect = null;
            try { 
               rect = this.$measureNode.getBoundingClientRect();
            } catch(e) {
               rect = {width: 0, height:0 };
            };
            var size = {
                height: rect.height,
                width: rect.width / CHAR_COUNT
            };
        } else {
            var size = {
                height: this.$measureNode.clientHeight,
                width: this.$measureNode.clientWidth / CHAR_COUNT
            };
        }
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    };

    this.$measureCharWidth = function(ch) {
        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    };
    
    this.getCharacterWidth = function(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    };

}).call(FontMetrics.prototype);

});

ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/lib/useragent","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var config = acequire("./config");
var useragent = acequire("./lib/useragent");
var GutterLayer = acequire("./layer/gutter").Gutter;
var MarkerLayer = acequire("./layer/marker").Marker;
var TextLayer = acequire("./layer/text").Text;
var CursorLayer = acequire("./layer/cursor").Cursor;
var HScrollBar = acequire("./scrollbar").HScrollBar;
var VScrollBar = acequire("./scrollbar").VScrollBar;
var RenderLoop = acequire("./renderloop").RenderLoop;
var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
";

dom.importCssString(editorCss, "ace_editor.css");

var VirtualRenderer = function(container, theme) {
    var _self = this;

    this.container = container || dom.createElement("div");
    this.$keepTextAreaAtCursor = !useragent.isOldIE;

    dom.addCssClass(this.container, "ace_editor");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;

    this.scrollBar = 
    this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.cursorPos = {
        row : 0,
        column : 0
    };

    this.$fontMetrics = new FontMetrics(this.container, 500);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize", e);
    });

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 0,
        characterWidth : 0,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1,
        gutterOffset: 1
    };
    
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._emit("renderer", this);
};

(function() {

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    oop.implement(this, EventEmitter);

    this.updateCharacterSize = function() {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
    };
    this.setSession = function(session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            
        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;
        
        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode()
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    };
    this.updateLines = function(firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };

    this.onChangeNewLineMode = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
    };
    
    this.onChangeTabSize = function() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };
    this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
    };

    this.$changes = 0;
    this.$updateSizeAsync = function() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    this.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

        
        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
    };
    
    this.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            changes = changes | this.CHANGE_SCROLL;
        }

        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            
            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            
            this.gutterWidth = gutterWidth;
            
            this.scrollBarH.element.style.left = 
            this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
            
            this.scrollBarH.element.style.right = 
            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                changes |= this.CHANGE_FULL;
        }
        
        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    };

    this.onGutterResize = function() {
        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
        }
    };
    this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    };
    this.getAnimatedScroll = function() {
        return this.$animatedScroll;
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
    };

    this.setDisplayIndentGuides = function(display) {
        this.setOption("displayIndentGuides", display);
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
    };
    this.getShowGutter = function(){
        return this.getOption("showGutter");
    };
    this.setShowGutter = function(show){
        return this.setOption("showGutter", show);
    };

    this.getFadeFoldWidgets = function(){
        return this.getOption("fadeFoldWidgets")
    };

    this.setFadeFoldWidgets = function(show) {
        this.setOption("fadeFoldWidgets", show);
    };

    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };

    this.$updateGutterLineHighlight = function() {
        var pos = this.$cursorLayer.$pixelPos;
        var height = this.layerConfig.lineHeight;
        if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
        }
        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
        this.$gutterLineHighlight.style.height = height + "px";
    };

    this.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        
        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    };
    this.getContainerElement = function() {
        return this.container;
    };
    this.getMouseEventTarget = function() {
        return this.content;
    };
    this.getTextAreaContainer = function() {
        return this.container;
    };
    this.$moveTextAreaToCursor = function() {
        if (!this.$keepTextAreaAtCursor)
            return;
        var config = this.layerConfig;
        var posTop = this.$cursorLayer.$pixelPos.top;
        var posLeft = this.$cursorLayer.$pixelPos.left;
        posTop -= config.offset;

        var style = this.textarea.style;
        var h = this.lineHeight;
        if (posTop < 0 || posTop > config.height - h) {
            style.top = style.left = "0";
            return;
        }

        var w = this.characterWidth;
        if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= (this.session.$getStringScreenWidth(val)[0]+2);
            h += 2;
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft += this.gutterWidth;
        style.height = h + "px";
        style.width = w + "px";
        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
        style.top = Math.min(posTop, this.$size.height - h) + "px";
    };
    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function() {
        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
        return this.layerConfig.firstRow - 1 + flint;
    };
    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };

    this.$padding = null;
    this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };
    
    this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function() {
        return this.$vScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };

    this.$updateScrollBarV = function() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    
    this.$frozen = false;
    this.freeze = function() {
        this.$frozen = true;
    };
    
    this.unfreeze = function() {
        this.$frozen = false;
    };

    this.$renderChanges = function(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return; 
        } 
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        
        this._signal("beforeRender");
        var config = this.layerConfig;
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st > 0) {
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig();
                }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
            this.content.style.marginTop = (-config.offset) + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
        }
        if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return;
        }
        if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender");
    };

    
    this.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.max(
            (this.$minLines||1) * this.lineHeight,
            Math.min(maxHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        var vScroll = height > maxHeight;
        
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            
            this._signal("autosize");
        }
    };
    
    this.$computeLayerConfig = function() {
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var session = this.session;
        var size = this.$size;
        
        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var offset = this.scrollTop % this.lineHeight;
        var minHeight = size.scrollerHeight + this.lineHeight;

        var longestLine = this.$getLongestLine();
        
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        
        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;

        this.session.setScrollTop(Math.max(-this.scrollMargin.top,
            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));

        this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft,
            longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));
        
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop);
        var vScrollChanged = this.$vScroll !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }

        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;

        var changes = 0;
        if (this.layerConfig.width != longestLine) 
            changes = this.CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }
        
        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            gutterOffset : Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
            height : this.$size.scrollerHeight
        };

        return changes;
    };

    this.$updateLines = function() {
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };

    this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function(rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
    };
    this.showCursor = function() {
        this.$cursorLayer.showCursor();
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var left = pos.left;
        var top = pos.top;
        
        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
        
        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        
        if (scrollTop + topMargin > top) {
            if (offset)
                top -= offset * this.$size.scrollerHeight;
            if (top === 0)
                top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset)
                top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
        }
    };
    this.getScrollTop = function() {
        return this.session.getScrollTop();
    };
    this.getScrollLeft = function() {
        return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
    };

    this.alignCursor = function(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    };
    this.scrollToLine = function(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;
        
        if (fromValue == toValue)
            return;
        
        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }
        
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                callback && callback();
            }
        }, 10);
    };
    this.scrollToY = function(scrollTop) {
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };
    this.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(y);
    };
    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    };

    this.pixelToScreenCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
    };

    this.screenToTextCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var col = Math.round(
            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
        );

        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
    };
    this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + Math.round(pos.column * this.characterWidth);
        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };
    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
    };
    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
    };
    this.showComposition = function(position) {
        if (!this.$composition)
            this.$composition = {
                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                cssText: this.textarea.style.cssText
            };

        this.$keepTextAreaAtCursor = true;
        dom.addCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = "";
        this.$moveTextAreaToCursor();
    };
    this.setCompositionText = function(text) {
        this.$moveTextAreaToCursor();
    };
    this.hideComposition = function() {
        if (!this.$composition)
            return;

        dom.removeCssClass(this.textarea, "ace_composition");
        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
        this.textarea.style.cssText = this.$composition.cssText;
        this.$composition = null;
    };
    this.setTheme = function(theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module.cssClass)
                return;
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container.ownerDocument
            );

            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);

            var padding = "padding" in module ? module.padding 
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();
        }
    };
    this.getTheme = function() {
        return this.$themeId;
    };
    this.setStyle = function(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function(style) {
        dom.removeCssClass(this.container, style);
    };
    
    this.setCursorStyle = function(style) {
        if (this.scroller.style.cursor != style)
            this.scroller.style.cursor = style;
    };
    this.setMouseCursor = function(cursorStyle) {
        this.scroller.style.cursor = cursorStyle;
    };
    this.destroy = function() {
        this.$textLayer.destroy();
        this.$cursorLayer.destroy();
    };

}).call(VirtualRenderer.prototype);


config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn; 
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
        initialValue: true
    },
    showLineNumbers: {
        set: function(show) {
            this.$gutterLayer.setShowLineNumbers(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
                this.$gutterLineHighlight = dom.createElement("div");
                this.$gutterLineHighlight.className = "ace_gutter-active-line";
                this.$gutter.appendChild(this.$gutterLineHighlight);
                return;
            }

            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            if (this.$cursorLayer.$pixelPos)
                this.$updateGutterLineHighlight();
        },
        initialValue: false,
        value: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize:  {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    scrollPastEnd: {
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    theme: {
        set: function(val) { this.setTheme(val) },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    }
});

exports.VirtualRenderer = VirtualRenderer;
});

ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../lib/oop");
var net = acequire("../lib/net");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
var config = acequire("../config");

var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);
    if (acequire.nameToUrl && !acequire.toUrl)
        acequire.toUrl = acequire.nameToUrl;
    
    if (config.get("packaged") || !acequire.toUrl) {
        workerUrl = workerUrl || config.moduleUrl(mod.id, "worker")
    } else {
        var normalizePath = this.$normalizePath;
        workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));

        var tlns = {};
        topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
        });
    }

    try {
            var workerSrc = mod.src;
    var Blob = require('w3c-blob');
    var blob = new Blob([ workerSrc ], { type: 'application/javascript' });
    var blobUrl = (window.URL || window.webkitURL).createObjectURL(blob);

    this.$worker = new Worker(blobUrl);

    } catch(e) {
        if (e instanceof window.DOMException) {
            var blob = this.$workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);

            this.$worker = new Worker(blobURL);
            URL.revokeObjectURL(blobURL);
        } else {
            throw e;
        }
    }
    this.$worker.postMessage({
        init : true,
        tlns : tlns,
        module : mod.id,
        classname : classname
    });

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.onMessage = function(e) {
        var msg = e.data;
        switch(msg.type) {
            case "event":
                this._signal(msg.name, {data: msg.data});
                break;
            case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
            case "error":
                this.reportError(msg.data);
                break;
            case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;
        }
    };

    this.reportError = function(err) {
        window.console && console.error && console.error(err);
    };

    this.$normalizePath = function(path) {
        return net.qualifyURL(path);
    };

    this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
            this.$doc.off("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {
            console.error(ex.stack);
        }
    };

    this.attachToDocument = function(doc) {
        if(this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
    };

    this.changeListener = function(e) {
        if (!this.deltaQueue) {
            this.deltaQueue = [e.data];
            setTimeout(this.$sendDeltaQueue, 0);
        } else
            this.deltaQueue.push(e.data);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 20 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
        } else
            this.emit("change", {data: q});
    };

    this.$workerBlob = function(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
            return new Blob([script], {"type": "application/javascript"});
        } catch (e) { // Backwards-compatibility
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
        }
    };

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.callbackId = 1;
    this.callbacks = {};
    this.messageBuffer = [];

    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);
    var _self = this;

    this.$worker = {};
    this.$worker.terminate = function() {};
    this.$worker.postMessage = function(e) {
        _self.messageBuffer.push(e);
        if (main) {
            if (emitSync)
                setTimeout(processNext);
            else
                processNext();
        }
    };
    this.setEmitSync = function(val) { emitSync = val };

    var processNext = function() {
        var msg = _self.messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        _self.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (_self.messageBuffer.length)
            processNext();
    });
};

UIWorkerClient.prototype = WorkerClient.prototype;

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;

});

ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(acequire, exports, module) {
"use strict";

var Range = acequire("./range").Range;
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var oop = acequire("./lib/oop");

var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;
    
    this.$onCursorChange = function() {
        setTimeout(function() {
            _self.onCursorChange();
        });
    };
    
    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth =  undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
};

(function() {

    oop.implement(this, EventEmitter);
    this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        var pos = this.$pos;
        
        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();

        this.pos = doc.createAnchor(pos.row, pos.column);
        this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.pos.on("change", function(event) {
            session.removeMarker(_self.markerId);
            _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.mainClass, null, false);
        });
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    this.showOtherMarkers = function() {
        if(this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
            anchor.on("change", function(event) {
                session.removeMarker(anchor.markerId);
                anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.othersClass, null, false);
            });
        });
    };
    this.hideOtherMarkers = function() {
        if(!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };
    this.onUpdate = function(event) {
        var delta = event.data;
        var range = delta.range;
        if(range.start.row !== range.end.row) return;
        if(range.start.row !== this.pos.row) return;
        if (this.$updating) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insertText" ? range.end.column - range.start.column : range.start.column - range.end.column;
        
        if(range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {
            var distanceFromStart = range.start.column - this.pos.column;
            this.length += lengthDiff;
            if(!this.session.$fromUndo) {
                if(delta.action === "insertText") {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.insert(newPos, delta.text);
                    }
                } else if(delta.action === "removeText") {
                    for (var i = this.others.length - 1; i >= 0; i--) {
                        var otherPos = this.others[i];
                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
                            newPos.column += lengthDiff;
                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                    }
                }
                if(range.start.column === this.pos.column && delta.action === "insertText") {
                    setTimeout(function() {
                        this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            var newPos = {row: other.row, column: other.column - lengthDiff};
                            if(other.row === range.start.row && range.start.column < other.column)
                                newPos.column += lengthDiff;
                            other.setPosition(newPos.row, newPos.column);
                        }
                    }.bind(this), 0);
                }
                else if(range.start.column === this.pos.column && delta.action === "removeText") {
                    setTimeout(function() {
                        for (var i = 0; i < this.others.length; i++) {
                            var other = this.others[i];
                            if(other.row === range.start.row && range.start.column < other.column) {
                                other.setPosition(other.row, other.column - lengthDiff);
                            }
                        }
                    }.bind(this), 0);
                }
            }
            this.pos._emit("change", {value: this.pos});
            for (var i = 0; i < this.others.length; i++) {
                this.others[i]._emit("change", {value: this.others[i]});
            }
        }
        this.$updating = false;
    };

    this.onCursorChange = function(event) {
        if (this.$updating || !this.session) return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };    
    this.detach = function() {
        this.session.removeMarker(this.markerId);
        this.hideOtherMarkers();
        this.doc.removeEventListener("change", this.$onUpdate);
        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
        this.pos.detach();
        for (var i = 0; i < this.others.length; i++) {
            this.others[i].detach();
        }
        this.session.setUndoSelect(true);
        this.session = null;
    };
    this.cancel = function() {
        if(this.$undoStackDepth === -1)
            throw Error("Canceling placeholders only supported with undo manager attached to session.");
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    };
}).call(PlaceHolder.prototype);


exports.PlaceHolder = PlaceHolder;
});

ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    
    if (ctrl && useragent.isMac)
        button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    
    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    
    if (button !== 0)
        return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = "add";
        else if (alt)
            selectionMode = "block";
    } else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        } else if (alt) {
            selectionMode = "block";
        }
    }
    
    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);
        
        
        editor.$blockScrolling++;
        editor.inVirtualSelectionMode = true;
        
        if (shift) {
            oldRange = null;
            range = selection.ranges[0];
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                } else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
            editor.inVirtualSelectionMode = false;
        });

    } else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;        
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;

            editor.$blockScrolling++;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();

            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
            editor.$blockScrolling--;
        };
        editor.$blockScrolling++;
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);            
        else
            selection.moveToPosition(pos);
        editor.$blockScrolling--;
        
        screenCursor = {row: -1, column: -1};

        var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            editor.$blockScrolling++;
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
            editor.$blockScrolling--;
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.onMouseDown = onMouseDown;

});

ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(acequire, exports, module) {
exports.defaultCommands = [{
    name: "addCursorAbove",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "addCursorBelow",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "addCursorAboveSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "addCursorBelowSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "selectMoreBefore",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "selectMoreAfter",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "selectNextBefore",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "selectNextAfter",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readonly: true
}, {
    name: "splitIntoLines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readonly: true
}, {
    name: "alignCursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
}, {
    name: "findAll",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readonly: true
}];
exports.multiSelectCommands = [{
    name: "singleSelection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readonly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
}];

var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(acequire, exports, module) {

var RangeList = acequire("./range_list").RangeList;
var Range = acequire("./range").Range;
var Selection = acequire("./selection").Selection;
var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
var event = acequire("./lib/event");
var lang = acequire("./lib/lang");
var commands = acequire("./commands/multi_select_commands");
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
var Search = acequire("./search").Search;
var search = new Search();

function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}
var EditSession = acequire("./edit_session").EditSession;
(function() {
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);
(function() {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };

    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
        else if(this.ranges[0])
            this.fromOrientedRange(this.ranges[0]);
    };

    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range: range});
    };

    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._signal("removeRange", {ranges: removed});

        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    this.splitIntoLines = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
                if (isBackwards)
                    var start = range.end, end = range.start;
                else
                    var start = range.start, end = range.end;
                
                this.addRange(Range.fromPoints(end, end));
                this.addRange(Range.fromPoints(start, start));
                return;
            }

            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);

            for (var i = startRow + 1; i < endRow; i++)
                rectSel.push(this.getLineRange(i, true));

            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);

            rectSel.forEach(this.addRange, this);
        }
    };
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn),
                this.session.screenToDocumentPosition(row, endColumn)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);
var Editor = acequire("./editor").Editor;
(function() {
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };

    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    }; 
    this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        
        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};

        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
        
        return result;
    };
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };
    
    this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
        }
    };
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }    
        this.$search.set(options);
        
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        this.$blockScrolling += 1;
        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
        
        this.$blockScrolling -= 1;

        return ranges.length;
    };
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
    };
    this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });
        
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);
                
                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.doc.removeLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.doc.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
            });

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW, " ")
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);


function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}
exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change",  this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change",  this.$checkMultiselectChange);
    }

    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change",  this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change",  this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

function addAltCursorListeners(editor){
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        if (e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey)) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    });

    event.addListener(el, "keyup", reset);
    event.addListener(el, "blur", reset);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
        }
    }
}

exports.MultiSelect = MultiSelect;


acequire("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
            } else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    }
});



});

ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(acequire, exports, module) {
"use strict";

var Range = acequire("../../range").Range;

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel)
                break;

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});

ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
"use strict";

exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
border-radius: 2px;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

var dom = acequire("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

ace.define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"], function(acequire, exports, module) {
"use strict";

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var Range = acequire("./range").Range;


function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);
    
    this.session.on("change", this.updateOnChange);
    this.session.on("changeEditor", this.$onChangeEditor);
}

(function() {
    this.getRowLength = function(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };

    this.$getWidgetScreenLength = function() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount)
                screenRows +=w.rowCount;
        });
        return screenRows;
    };    
    
    this.$onChangeEditor = function(e) {
        this.attach(e.editor);
    };

    this.attach = function(editor) {
        if (editor  && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        this.editor = editor;
        
        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    };
    this.detach = function(e) {
        var editor = this.editor;
        if (!editor)
            return;
        
        this.editor = null;
        editor.widgetManager = null;
        
        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };

    this.updateOnChange = function(e) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
            
        var delta = e.data;
        var range = delta.range;
        var startRow = range.start.row;
        var len = range.end.row - startRow;

        if (len === 0) {
        } else if (delta.action == "removeText" || delta.action == "removeLines") {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };
    
    this.$updateRows = function() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };

    this.addLineWidget = function(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
        
        this.session.lineWidgets[w.row] = w;
        
        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
        }
        
        if (!w.coverGutter) {
            w.el.style.zIndex = 3;
        }
        if (!w.pixelHeight) {
            w.pixelHeight = w.el.offsetHeight;
        }
        if (w.rowCount == null)
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        
        this.$updateRows();
        this.renderWidgets(null, renderer);
        return w;
    };
    
    this.removeLineWidget = function(w) {
        w._inDocument = false;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets)
            this.session.lineWidgets[w.row] = undefined;
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    };
    
    this.onWidgetChanged = function(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    };
    
    this.measureWidgets = function(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        
        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            
            w.h = w.el.offsetHeight;
            
            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };
    
    this.renderWidgets = function(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        
        while (first > 0 && !lineWidgets[first])
            first--;
        
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el) continue;

            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";

            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    };
    
}).call(LineWidgets.prototype);


exports.LineWidgets = LineWidgets;

});

ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(acequire, exports, module) {
"use strict";
var LineWidgets = acequire("../line_widgets").LineWidgets;
var dom = acequire("../lib/dom");
var Range = acequire("../range").Range;

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }
    return -(first + 1);
}

function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    
    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    
    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    
    
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }
    
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.lineWidgets && session.lineWidgets[row];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    
    var w = {
        row: pos.row, 
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div")
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");
    
    el.appendChild(dom.createElement("div"));
    
    var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
        }
    };
    
    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };
    
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    
    editor.session.widgetManager.addLineWidget(w);
    
    w.el.onmousedown = editor.focus.bind(editor);
    
    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
};


dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

});

ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(acequire, exports, module) {
"use strict";

acequire("./lib/fixoldbrowsers");

var dom = acequire("./lib/dom");
var event = acequire("./lib/event");

var Editor = acequire("./editor").Editor;
var EditSession = acequire("./edit_session").EditSession;
var UndoManager = acequire("./undomanager").UndoManager;
var Renderer = acequire("./virtual_renderer").VirtualRenderer;
acequire("./worker/worker_client");
acequire("./keyboard/hash_handler");
acequire("./placeholder");
acequire("./multi_select");
acequire("./mode/folding/fold_mode");
acequire("./theme/textmate");
acequire("./ext/error_marker");

exports.config = acequire("./config");
exports.acequire = acequire;
exports.edit = function(el) {
    if (typeof(el) == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    } else {
        value = dom.getInnerText(el);
        el.innerHTML = '';
    }

    var doc = exports.createEditSession(value);

    var editor = new Editor(new Renderer(el));
    editor.setSession(doc);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
}
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
});
            (function() {
                ace.acequire(["ace/ace"], function(a) {
                    a && a.config.init(true);
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                });
            })();
        
module.exports = window.ace.acequire("ace/ace");
},{"w3c-blob":134}],27:[function(require,module,exports){
ace.define("ace/theme/chrome",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-chrome";
exports.cssText = ".ace-chrome .ace_gutter {\
background: #ebebeb;\
color: #333;\
overflow : hidden;\
}\
.ace-chrome .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-chrome {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-chrome .ace_cursor {\
color: black;\
}\
.ace-chrome .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-chrome .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-chrome .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-chrome .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-chrome .ace_invalid {\
background-color: rgb(153, 0, 0);\
color: white;\
}\
.ace-chrome .ace_fold {\
}\
.ace-chrome .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-chrome .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-chrome .ace_support.ace_type,\
.ace-chrome .ace_support.ace_class\
.ace-chrome .ace_support.ace_other {\
color: rgb(109, 121, 222);\
}\
.ace-chrome .ace_variable.ace_parameter {\
font-style:italic;\
color:#FD971F;\
}\
.ace-chrome .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-chrome .ace_comment {\
color: #236e24;\
}\
.ace-chrome .ace_comment.ace_doc {\
color: #236e24;\
}\
.ace-chrome .ace_comment.ace_doc.ace_tag {\
color: #236e24;\
}\
.ace-chrome .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-chrome .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-chrome .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-chrome .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-chrome .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-chrome .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-chrome .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-chrome .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-chrome .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-chrome .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-chrome .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-chrome .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-chrome .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-chrome .ace_storage,\
.ace-chrome .ace_keyword,\
.ace-chrome .ace_meta.ace_tag {\
color: rgb(147, 15, 128);\
}\
.ace-chrome .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-chrome .ace_string {\
color: #1A1AA6;\
}\
.ace-chrome .ace_entity.ace_other.ace_attribute-name {\
color: #994409;\
}\
.ace-chrome .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

var dom = acequire("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

},{}],28:[function(require,module,exports){

},{}],29:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":24,"ieee754":92,"is-array":95}],30:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],31:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],32:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],33:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufSJdfQ==
},{"../../is-buffer/index.js":96}],34:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');

var Spray = require('spray-wrtc');
var CausalBroadcast = require('causal-broadcast-definition');
var VVwE = require('version-vector-with-exceptions');
var LSEQTree = require('lseqtree');
var GUID = require('./guid.js');

var MInsertOperation = require('./messages.js').MInsertOperation;
var MAEInsertOperation = require('./messages.js').MAEInsertOperation;
var MRemoveOperation = require('./messages.js').MRemoveOperation;
var MCaretMovedOperation = require('./messages.js').MCaretMovedOperation;

util.inherits(CrateCore, EventEmitter);

/*!
 * \brief link together all components of the model of the CRATE editor
 * \param id the unique site identifier
 * \param options the webrtc specific options 
 */
function CrateCore(id, options){
    EventEmitter.call(this);
    
    this.id = id || GUID();
    this.options = options;
    this.broadcast = new CausalBroadcast(new Spray(this.id, this.options),
                                         new VVwE(this.id));
    this.sequence = new LSEQTree(this.id);

    var self = this;
    // #A regular receive
    this.broadcast.on('receive', function(receivedBroadcastMessage){
        switch (receivedBroadcastMessage.type){
        case 'MRemoveOperation':
            self.remoteRemove(receivedBroadcastMessage.remove,
                              receivedBroadcastMessage.origin);
            break;
        case 'MInsertOperation':
            self.remoteInsert(receivedBroadcastMessage.insert,
                              receivedBroadcastMessage.origin);
            break;
        case 'MCaretMovedOperation':
            self.remoteCaretMoved(receivedBroadcastMessage.range,
                                  receivedBroadcastMessage.origin);
            break;
        };
    });
    // #B anti-entropy for the missing operation
    this.broadcast.on('antiEntropy', function(socket, remoteVVwE, localVVwE){
        var remoteVVwE = (new VVwE(null)).fromJSON(remoteVVwE); // cast
        var toSearch = [];
        // #1 for each entry of our VVwE, look if the remote VVwE knows less
        for (var i=0; i<localVVwE.vector.arr.length; ++i){
            var localEntry = localVVwE.vector.arr[i];
            var index = remoteVVwE.vector.indexOf(localVVwE.vector.arr[i]);
            var start = 1;
            // #A check if the entry exists in the remote vvwe
            if (index >=0){ start = remoteVVwE.vector.arr[index].v + 1; };
            for (var j=start; j<=localEntry.v; ++j){
                // #B check if not one of the local exceptions
                if (localEntry.x.indexOf(j)<0){
                    toSearch.push({_e: localEntry.e, _c: j});
                };
            };
            // #C handle the exceptions of the remote vector
            if (index >=0){
                for (var j=0; j<remoteVVwE.vector.arr[index].x.length;++j){
                    var except = remoteVVwE.vector.arr[index].x[j];
                    if (localEntry.x.indexOf(except)<0 && except<=localEntry.v){
                        toSearch.push({_e: localEntry.e, _c: except});
                    };
                };
            };
        };
        var elements = self.getElements(toSearch);
        //var elements = [];
        // #2 send back the found elements
        self.broadcast.sendAntiEntropyResponse(socket, localVVwE, elements);
    });
};

/*!
 * \brief create the core from an existing object
 * \param object the object to initialize the core model of crate containing a 
 * sequence and causality tracking metadata
 */
CrateCore.prototype.init = function(object){
    // import the sequence and version vector, yet it keeps the identifier of
    // this instance of the core.
    var local = this.broadcast.causality.local;
    this.broadcast.causality.fromJSON(object.causality);
    this.broadcast.causality.local = local;
    this.broadcast.causality.vector.insert(this.broadcast.causality.local);
    
    this.sequence.fromJSON(object.sequence);
    this.sequence._s = local.e;
    this.sequence._c = local.v;
};

/*!
 * \brief local insertion of a character inside the sequence structure. It
 * broadcasts the operation to the rest of the network.
 * \param character the character to insert in the sequence
 * \param index the index in the sequence to insert
 * \return the identifier freshly allocated
 */
CrateCore.prototype.insert = function(character, index){
    var ei = this.sequence.insert(character, index);
    var id = {_e: ei._i._s[ei._i._s.length-1], _c: ei._i._c[ei._i._c.length-1]};
    this.broadcast.send(new MInsertOperation(ei, id._e), id, null);
    return ei;
};

/*!
 * \brief local deletion of a character from the sequence structure. It 
 * broadcasts the operation to the rest of the network.
 * \param index the index of the element to remove
 * \return the identifier freshly removed
 */
CrateCore.prototype.remove = function(index){
    var i = this.sequence.remove(index);
    var isReady = {_e: i._s[i._s.length-1], _c: i._c[i._c.length-1]};
    this.sequence._c += 1;
    var id = {_e:this.sequence._s, _c: this.sequence._c } // (TODO) fix uglyness
    this.broadcast.send(new MRemoveOperation(i, id._e), id, isReady);
    return i;
};

CrateCore.prototype.caretMoved = function(range){
    this.sequence._c += 1;
    var id = {_e:this.sequence._s, _c: this.sequence._c } // (TODO) fix uglyness
    this.broadcast.send(new MCaretMovedOperation(range, id._e), id, null);
    return range;
};

/*!
 * \brief insertion of an element from a remote site. It emits 'remoteInsert' 
 * with the index of the element to insert, -1 if already existing.
 * \param ei the result of the remote insert operation
 * \param origin the origin id of the insert operation
 */
CrateCore.prototype.remoteInsert = function(ei, origin){
    var index = this.sequence.applyInsert(ei._e, ei._i, false);
    this.emit('remoteInsert', ei._e, index);
    if (index >= 0 && origin){
        this.emit('remoteCaretMoved', {start: index, end: index}, origin);
    };
};

/*!
 * \brief removal of an element from a remote site.  It emits 'remoteRemove'
 * with the index of the element to remove, -1 if does not exist
 * \param id the result of the remote insert operation
 * \param origin the origin id of the removal
 */
CrateCore.prototype.remoteRemove = function(id, origin){
    var index = this.sequence.applyRemove(id);
    this.emit('remoteRemove', index);
    if (index >= 0 && origin){
        this.emit('remoteCaretMoved', {start: index-1, end: index-1}, origin);
    };
};

CrateCore.prototype.remoteCaretMoved = function(range, origin){
    this.emit('remoteCaretMoved', range, origin);
};


/*!
 * \brief search a set of elements in our sequence and return them
 * \param toSearch the array of elements {_e, _c} to search
 * \returns an array of nodes
 */
CrateCore.prototype.getElements = function(toSearch){
    var result = [], found, node, tempNode, i=this.sequence.length, j=0;
    // (TODO) improve research by exploiting the fact that if a node is
    // missing, all its children are missing too.
    // (TODO) improve the returned representation: either a tree to factorize
    // common parts of the structure or identifiers to get the polylog size
    // (TODO) improve the search by using the fact that toSearch is a sorted
    // array, possibly restructure this argument to be even more efficient
    while (toSearch.length > 0 && i<=this.sequence.length && i>0){
        node = this.sequence.get(i);
        tempNode = node;
        while( tempNode.children.length > 0){
            tempNode = tempNode.children[0];
        };
        j = 0;
        found = false;
        while (j < toSearch.length && !found){
            if (tempNode.t.s === toSearch[j]._e &&
                tempNode.t.c === toSearch[j]._c){
                found = true;
                result.push(new MAEInsertOperation({_e: tempNode.e, _i:node},
                                                   {_e: toSearch[j]._e,
                                                    _c: toSearch[j]._c} ));
                toSearch.splice(j,1);
            } else {
                ++j;
            };
        };
        //        ++i;
        --i;
    };
    return result;
};

module.exports = CrateCore;

},{"./guid.js":35,"./messages.js":36,"causal-broadcast-definition":37,"events":88,"lseqtree":45,"spray-wrtc":55,"util":133,"version-vector-with-exceptions":68}],35:[function(require,module,exports){
module.exports=require(6)
},{"/Users/chat-wane/Desktop/project/jquery-crate/lib/model/guid.js":6}],36:[function(require,module,exports){
/*!
 * \brief object that represents the result of an insert operation
 * \param insert the result of the local insert operation
 * \param origin the origin of the insertion
 */
function MInsertOperation(insert, origin){
    this.type = "MInsertOperation";
    this.insert = insert;
    this.origin = origin;
};
module.exports.MInsertOperation = MInsertOperation;

function MAEInsertOperation(insert, id){
    this.type = "MAEInsertOperation";
    this.payload = new MInsertOperation(insert);
    this.id = id;
    this.isReady = null;
};
module.exports.MAEInsertOperation = MAEInsertOperation;

/*!
 * \brief object that represents the result of a delete operation
 * \param remove the result of the local delete operation
 * \param origin the origin of the removal
 */
function MRemoveOperation(remove, origin){
    this.type = "MRemoveOperation";
    this.remove = remove;
    this.origin = origin;
};
module.exports.MRemoveOperation = MRemoveOperation;

/*!
 * \brief object that represents the result of a caretMoved Operation
 * \param range the selection range
 * \param origin the origin of the selection
 */
function MCaretMovedOperation(range, origin){
    this.type = "MCaretMovedOperation";
    this.range = range;
    this.origin = origin;
};
module.exports.MCaretMovedOperation = MCaretMovedOperation;

},{}],37:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var GUID = require('./guid.js');

var MBroadcast = require('./messages').MBroadcast;
var MAntiEntropyRequest = require('./messages.js').MAntiEntropyRequest;
var MAntiEntropyResponse = require('./messages.js').MAntiEntropyResponse;

var Unicast = require('unicast-definition');

util.inherits(CausalBroadcast, EventEmitter);

/*!
 * It takes a unique value for peer and a counter to distinguish a message. It
 * emits 'receive' event when the message is considered ready
 * \param source the protocol receiving the messages
 * \param causality the causality tracking structure
 */
function CausalBroadcast(source, causality, name) {
    EventEmitter.call(this);
    this.name = name || 'causal';
    this.source = source;
    this.causality = causality;
    this.deltaAntiEntropy = 1000*60*1/2; // (TODO) configurable (currently 30s)
    this.unicast = new Unicast(this.source, this.name+'-unicast');

    // buffer of operations
    this.buffer = []; 
    // buffer of anti-entropy messages (chunkified because of large size)
    this.bufferAntiEntropy = new MAntiEntropyResponse('init');
    
    var self = this;
    this.source.on(self.name+'-broadcast-receive', function(socket, message){
        self.receiveBroadcast(message);
    });
    this.unicast.on('receive', function(socket, message){
        self.receiveUnicast(socket, message);
    });
    this.source.on('statechange', function(state){
        if (state==='connect'){
            self.unicast.send(new MAntiEntropyRequest(self.causality));
        };
    });
    setInterval(function(){
        self.unicast.send(new MAntiEntropyRequest(self.causality));
    }, self.deltaAntiEntropy);    
};

/*!
 * \brief broadcast the message to all participants
 * \param message the message to broadcast
 * \param id the id of the message
 * \param isReady the id(s) that must exist to deliver the message
 */
CausalBroadcast.prototype.send = function(message, id, isReady){
    // #1 get the neighborhood and create the message
    var links = this.source.getPeers(Number.MAX_VALUE);
    var mBroadcast = new MBroadcast(this.name, id || GUID(), isReady, message);
    // #2 register the message in the structure
    this.causality.incrementFrom(id);
    // #3 send the message to the neighborhood
    for (var i = 0; i < links.length; ++i){
        if (links[i].connected &&
            links[i]._channel && links[i]._channel.readyState==='open'){
            links[i].send(mBroadcast);
        };
    };
};

/*!
 * \brief answers to an antientropy request message with the missing elements
 * \param socket the origin of the request
 * \param causalityAtReceipt the local causality structure when the message was
 * received
 * \param messages the missing messages
 */ 
CausalBroadcast.prototype.sendAntiEntropyResponse =
    function(socket, causalityAtReceipt, messages){
        var id = GUID();
        // #1 metadata of the antientropy response
        this.unicast.send(new MAntiEntropyResponse(id,
                                                   causalityAtReceipt,
                                                   messages.length), socket);
        for (var i = 0; i < messages.length; ++i){
            this.unicast.send(new MAntiEntropyResponse(id,
                                                       null,
                                                       messages.length,
                                                       messages[i]),  socket);
        };
    };

/*!
 * \brief receive a broadcast message
 * \param message the received message
 */
CausalBroadcast.prototype.receiveBroadcast = function(message){
    var id = message.id,
        isReady = message.isReady;

    if (!this.stopPropagation(message)){
        // #1 register the operation
        this.buffer.push(message);
        // #2 deliver
        this.reviewBuffer();
        // #3 rebroadcast
        var links = this.source.getPeers(Number.MAX_VALUE);
        for (var i = 0; i < links.length; ++i){
            if (links[i].connected &&
                links[i]._channel && links[i]._channel.readyState==='open'){
                links[i].send(message);
            };
        };
    };
};

/*!
 * \brief go through the buffer of messages and delivers all
 * ready operations
 */
CausalBroadcast.prototype.reviewBuffer = function(){
    var found = false,
        i = this.buffer.length - 1;
    while(i>=0){
        var message = this.buffer[i];
        if (this.causality.isLower(message.id)){
            this.buffer.splice(i, 1);
        } else {
            if (this.causality.isReady(message.isReady)){
                found = true;
                this.causality.incrementFrom(message.id);
                this.buffer.splice(i, 1);
                this.emit('receive', message.payload);
            };
        };
        --i;
    };
    if (found){ this.reviewBuffer();  };
};

/*!
 * \brief receive a unicast message, i.e., either an antientropy request or an
 * antientropy response
 * \brief socket the origin of the message
 * \brief message the message received 
 */
CausalBroadcast.prototype.receiveUnicast = function(socket, message){
    switch (message.type){
    case 'MAntiEntropyRequest':
        this.emit('antiEntropy',
                  socket, message.causality, this.causality.clone());
        break;
    case 'MAntiEntropyResponse':
        // #A replace the buffered message
        if (this.bufferAntiEntropy.id !== message.id){
            this.bufferAntiEntropy = message;
        };
        // #B add the new element to the buffer        
        if (message.element){
            this.bufferAntiEntropy.elements.push(message.element);
        };
        // #C add causality metadata
        if (message.causality){
            this.bufferAntiEntropy.causality = message.causality;
        };
        // #D the buffered message is fully arrived, deliver
        if (this.bufferAntiEntropy.elements.length ===
            this.bufferAntiEntropy.nbElements){
            // #1 considere each message in the response independantly
            for (var i = 0; i<this.bufferAntiEntropy.elements.length; ++i){
                var element = this.bufferAntiEntropy.elements[i];
                // #2 only check if the message has not been received yet
                if (!this.stopPropagation(element)){
                    this.causality.incrementFrom(element.id);
                    this.emit('receive', element.payload);
                };
            };
            // #3 merge causality structures
            this.causality.merge(this.bufferAntiEntropy.causality);
        };
        break;
    };
};

/*!
 * \brief gets called when a broadcast message reaches this node.  this
 * function evaluates if the node should propagate the message further or if it
 * should stop sending it.
 * \param message a broadcast message
 * \return true if the message is already known, false otherwise
 */
CausalBroadcast.prototype.stopPropagation = function (message) {
    return this.causality.isLower(message.id) ||
        this.bufferIndexOf(message.id)>=0;
};

/*!
 * \brief get the index in the buffer of the message identified by id
 * \param id the identifier to search
 * \return the index of the message in the buffer, -1 if not found
 */
CausalBroadcast.prototype.bufferIndexOf = function(id){
    var found = false,
        index = -1,
        i = 0;
    while (!found && i<this.buffer.length){
        // (TODO) fix uglyness
        if (JSON.stringify(this.buffer[i].id) === JSON.stringify(id)){ 
            found = true; index = i;
        };
        ++i
    };
    return index;
};

module.exports = CausalBroadcast;

},{"./guid.js":38,"./messages":39,"./messages.js":39,"events":88,"unicast-definition":41,"util":133}],38:[function(require,module,exports){
module.exports=require(6)
},{"/Users/chat-wane/Desktop/project/jquery-crate/lib/model/guid.js":6}],39:[function(require,module,exports){

/*!
 * \brief message containing data to broadcast
 * \param name the name of the protocol, default 'causal'
 * \param id the identifier of the broadcast message
 * \param isReady the identifier(s) that must exist to deliver this message
 * \param payload the broadcasted data
 */
function MBroadcast(name, id, isReady, payload){
    this.protocol = (name && name+'-broadcast') || 'causal-broadcast';
    this.id = id;
    this.isReady = isReady;
    this.payload = payload;
};
module.exports.MBroadcast = MBroadcast;

/*!
 * \brief message that request an AntiEntropy 
 * \param causality the causality structure
 */
function MAntiEntropyRequest(causality){
    this.type = 'MAntiEntropyRequest';
    this.causality = causality;
};
module.exports.MAntiEntropyRequest = MAntiEntropyRequest;

/*!
 * \brief message responding to the AntiEntropy request
 * \param id the identifier of the response message
 * \param causality the causality structure
 * \param nbElements the number of element to send
 * \param element each element to send 
 */
function MAntiEntropyResponse(id, causality, nbElements, element){
    this.type = 'MAntiEntropyResponse';
    this.id = id;
    this.causality = causality;
    this.nbElements = nbElements;
    this.element = element;
    this.elements = [];
};
module.exports.MAntiEntropyResponse = MAntiEntropyResponse;


},{}],40:[function(require,module,exports){

/*!
 * \brief message containing data to unicast
 * \param name the protocol name
 * \param payload the sent data
 */
function MUnicast(name, payload){
    this.protocol = name || 'unicast';
    this.payload = payload;
};
module.exports.MUnicast = MUnicast;

},{}],41:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');

var MUnicast = require('./messages').MUnicast;

util.inherits(Unicast, EventEmitter);

/*!
 * Unicast component that simply chose a random peer and send a message
 * \param source the protocol receiving the messages
 * \param name the name of the protocol, default is 'unicast'
 */
function Unicast(source, max, name) {
    EventEmitter.call(this);
    this.name = name || 'unicast';
    this.source = source;
    var self = this;
    this.source.on(self.name+'-receive', function(socket, message){
        self.emit('receive', socket, message.payload);
    });
};

/*!
 * \brief send the message to one random participant
 * \param message the message to send
 * \param socket optional known socket
 */
Unicast.prototype.send = function(message, socket){
    // #1 get the neighborhood and create the message
    var links = (socket && [socket]) || this.source.getPeers(1);
    var mUnicast = new MUnicast(this.name, message);
    // #2 send the message
    if (links.length>0 && links[0].connected){
        links[0].send(mUnicast);
    };
};

module.exports = Unicast;

},{"./messages":40,"events":88,"util":133}],42:[function(require,module,exports){
var BI = require('BigInt');

/*!
 * \class Base
 * \brief provides basic function to bit manipulation
 * \param b the number of bits at level 0 of the dense space
 */
function Base(b){    
    var DEFAULT_BASE = 3;
    this._b = b || DEFAULT_BASE;
};

/*!
 * \brief Process the number of bits usage at a certain level of dense space
 * \param level the level in dense space, i.e., the number of concatenation
 */
Base.prototype.getBitBase = function(level){
    return this._b + level;
};

/*!
 * \brief Process the total number of bits usage to get to a certain level
 * \param level the level in dense space
 */
Base.prototype.getSumBit = function(level){
    var n = this.getBitBase(level),
        m = this._b-1;
    return (n * (n + 1)) / 2 - (m * (m + 1) / 2);
};

/*!
  \brief process the interval between two LSEQNode
  \param p the previous LSEQNode
  \param q the next LSEQNode
  \param level the depth of the tree to process
  \return an integer which is the interval between the two node at the depth
*/
Base.prototype.getInterval = function(p, q, level){
    var sum = 0, i = 0,
        pIsGreater = false, commonRoot = true,
        prevValue = 0, nextValue = 0;
    
    while (i<=level){
        prevValue = 0; if (p !== null){ prevValue = p.t.p; }
        nextValue = 0; if (q !== null){ nextValue = q.t.p; }
        if (commonRoot && prevValue !== nextValue){
            commonRoot = false;
            pIsGreater = prevValue > nextValue;
        }
        if (pIsGreater){ nextValue = Math.pow(2,this.getBitBase(i))-1; }
        if (commonRoot || pIsGreater || i!==level){
            sum += nextValue - prevValue; 
        } else {
            sum += nextValue - prevValue - 1;
        }
        if (i!==level){
            sum *= Math.pow(2,this.getBitBase(i+1));
        };
        if (p!==null && p.children.length!==0){p=p.children[0];} else{p=null;};
        if (q!==null && q.children.length!==0){q=q.children[0];} else{q=null;};
        ++i;
    }
    return sum;
};

Base.instance = null;

module.exports = function(args){
    if (args){
        Base.instance = new Base(args);
    } else {
        if (Base.instance === null){
            Base.instance = new Base();
        };
    };
    return Base.instance;
};

},{"BigInt":49}],43:[function(require,module,exports){
var BI = require('BigInt');
var Base = require('./base.js')();
var Triple = require('./triple.js');
var LSEQNode = require('./lseqnode.js');

/*!
 * \class Identifier
 * \brief Unique and immutable identifier composed of digit, sources, counters
 * \param d the digit (position in dense space)
 * \param s the list of sources
 * \param c the list of counters
 */
function Identifier(d, s, c){
    this._d = d;
    this._s = s;
    this._c = c;
};

/*!
 * \brief set the d,s,c values according to the node in argument
 * \param node the lseqnode containing the path in the tree structure
 */
Identifier.prototype.fromNode = function(node){
    // #1 process the length of the path
    var length = 1, tempNode = node, i = 0;
    
    while (tempNode.children.length !== 0){
	++length;
        tempNode = tempNode.children[0];
    };
    // #1 copy the values contained in the path
    this._d = BI.int2bigInt(0,Base.getSumBit(length - 1));
    
    for (var i = 0; i < length ; ++i){
        // #1a copy the site id
        this._s.push(node.t.s);
        // #1b copy the counter
        this._c.push(node.t.c);
        // #1c copy the digit
        BI.addInt_(this._d, node.t.p);
        if (i!==(length-1)){
            BI.leftShift_(this._d, Base.getBitBase(i+1));
        };
        node = node.children[0];
    };
};

/*!
 * \brief convert the identifier into a node without element
 * \param e the element associated with the node
 */
Identifier.prototype.toNode = function(e){
    var resultPath = [], dBitLength = Base.getSumBit(this._c.length -1), i = 0,
        mine;
    // #1 deconstruct the digit 
    for (var i = 0; i < this._c.length; ++i){
        // #1 truncate mine
        mine = BI.dup(this._d);
        // #1a shift right to erase the tail of the path
        BI.rightShift_(mine, dBitLength - Base.getSumBit(i));
        // #1b copy value in the result
        resultPath.push(new Triple(BI.modInt(mine,
                                             Math.pow(2,Base.getBitBase(i))),
                                   this._s[i],
                                   this._c[i]));
    };
    return new LSEQNode(resultPath, e);
};

/*!
 * \brief compare two identifiers
 * \param o the other identifier
 * \return -1 if this is lower, 0 if they are equal, 1 if this is greater
 */
Identifier.prototype.compare = function(o){
    var dBitLength = Base.getSumBit(this._c.length - 1),
        odBitLength = Base.getSumBit(o._c.length - 1),
        comparing = true,
        comp = 0, i = 0,
        sum, mine, other;
    
    // #1 Compare the list of <d,s,c>
    while (comparing && i < Math.min(this._c.length, o._c.length) ) {
        // can stop before the end of for loop wiz return
        sum = Base.getSumBit(i);
        // #1a truncate mine
        mine = BI.dup(this._d);
        BI.rightShift_(mine, dBitLength - sum);
        // #1b truncate other
        other = BI.dup(o._d);
        BI.rightShift_(other, odBitLength - sum);
        // #2 Compare triples
        if (!BI.equals(mine,other)) {  // #2a digit
            if (BI.greater(mine,other)){comp = 1;}else{comp = -1;};
            comparing = false;
        } else {
            comp = this._s[i] - o._s[i]; // #2b source
            if (comp !== 0) {
                comparing = false;
            } else {
                comp = this._c[i] - o._c[i]; // 2c clock
                if (comp !== 0) {
                    comparing = false;
                };
            };
        };
        ++i;
    };
    
    if (comp===0){
        comp = this._c.length - o._c.length; // #3 compare list size
    };
    return comp;
};


module.exports = Identifier;

},{"./base.js":42,"./lseqnode.js":44,"./triple.js":47,"BigInt":49}],44:[function(require,module,exports){
var Triple = require('./triple.js');
require('./util.js');

/*!
 * \brief a node of the LSEQ tree
 * \param tripleList the list of triple composing the path to the element
 * \param element the element to insert in the structure
 */
function LSEQNode(tripleList, element){
    this.t = tripleList.shift();
    if (tripleList.length === 0){
        this.e = element;
        this.subCounter = 0; // count the number of children and subchildren
        this.children = [];
    } else {
        this.e = null;
        this.subCounter = 1;
        this.children = [];
        this.children.push(new LSEQNode(tripleList, element));
    };
};

/*!
 * \brief add a path element to the current node
 * \param node the node to add as a children of this node
 * \return -1 if the element already exists
 */
LSEQNode.prototype.add = function(node){
    var index = this.children.binaryIndexOf(node);
    
    // #1 if the path do no exist, create it
    if (index < 0 || this.children.length === 0  ||
        (index === 0 && this.children.length > 0 && 
         this.children[0].compare(node)!==0)){
        this.children.splice(-index, 0, node);
        this.subCounter+=1;
    } else {
        // #2 otherwise, continue to explore the subtrees
        if (node.children.length === 0){
            // #2a check if the element already exists
            if (this.children[index].e !== null){
                return -1;
            } else {
                this.children[index].e = node.e;
                this.subCounter+=1;
            };
        } else {
            // #3 if didnot exist, increment the counter
            if (this.children[index].add(node.children[0])!==-1){
                this.subCounter+=1;
            };
        };
    };
};

/*! 
 * \brief remove the node of the tree and all node within path being useless
 * \param node the node containing the path to remove
 * \return -1 if the node does not exist
 */
LSEQNode.prototype.del = function(node){
    var indexes = this.getIndexes(node),
        currentTree = this, i = 0, isSplitted = false;

    if (indexes === -1) { return -1; }; // it does not exists
    this.subCounter -= 1;
    while (i < indexes.length && !(isSplitted)){
        if (!(currentTree.children[indexes[i]].e !== null &&
              i===(indexes.length - 1))){
            currentTree.children[indexes[i]].subCounter -= 1;     
        };
        if (currentTree.children[indexes[i]].subCounter <= 0
            && (currentTree.children[indexes[i]].e === null ||
                (currentTree.children[indexes[i]].e !== null &&
                 i===(indexes.length - 1)))){
            currentTree.children.splice(indexes[i],1);
            isSplitted = true;
        };
        currentTree = currentTree.children[indexes[i]];
        ++i;
    };
    if (!isSplitted){ currentTree.e = null;};
};

/*!
 * \brief comparison function used to order the list of children at each node
 * \param o the other node to compare with
 */
LSEQNode.prototype.compare = function(o){
    return this.t.compare(o.t);
};

/*!
 * \brief the ordered tree can be linearized into a sequence. This function get
 * the index of the path represented by the list of triples
 * \param node the node containing the path
 * \return the index of the path in the node
 */
LSEQNode.prototype.indexOf = function(node){
    var indexes = this.getIndexes(node),
        sum = 0, currentTree = this,
        j = 0;
    if (indexes === -1){return -1;}; // node does not exist
    if (this.e !== null){ sum +=1; };
    
    for (var i = 0; i<indexes.length; ++i){
        if (indexes[i] < (currentTree.children.length/2)){
            // #A start from the beginning
            for (var j = 0; j<indexes[i]; ++j){
                if (currentTree.children[j].e !== null){ sum+=1; };
                sum += currentTree.children[j].subCounter;
            };
        } else {
            // #B start from the end
            sum += currentTree.subCounter;
            for (var j = currentTree.children.length-1; j>=indexes[i];--j){
                if (currentTree.children[j].e !== null){ sum-=1; };
                sum -= currentTree.children[j].subCounter;  
            };
            j += 1;
        };
        if (currentTree.children[j].e !== null){ sum+=1; };
        currentTree = currentTree.children[j];
    };
    return sum-1; // -1 because algorithm counted the element itself
};

/*!
 * \brief get the list of indexes of the arrays representing the children in
 * the tree
 * \param node the node containing the path
 * \return a list of integer
 */
LSEQNode.prototype.getIndexes = function(node){
    function _getIndexes(indexes, currentTree, currentNode){
        var index = currentTree.children.binaryIndexOf(currentNode);
        if (index < 0 ||
            (index===0 && currentTree.children.length===0)){ return -1; }
        indexes.push(index);
        if (currentNode.children.length===0 ||
            currentTree.children.length===0){
            return indexes;
        };
        return _getIndexes(indexes,
                           currentTree.children[index],
                           currentNode.children[0]);
        
    };
    return _getIndexes([], this, node);
};

/*!
 * \brief the ordered tree can be linearized. This function gets the node at
 * the index in the projected sequence.
 * \param index the index in the sequence
 * \returns the node at the index
 */
LSEQNode.prototype.get = function(index){
    function _get(leftSum, buildingNode, queue, currentNode){
        var startBeginning = true, useFunction, i = 0,
            p, temp;
        // #0 the node is found, return the incrementally built node and praise
        // #the sun !
        if (leftSum === index && currentNode.e !== null){
            // 1a copy the value of the element in the path
            queue.e = currentNode.e;
            return buildingNode;
        };
        if (currentNode.e !== null){ leftSum += 1; };

        // #1 search: do I start from the beginning or the end
        startBeginning = ((index-leftSum)<(currentNode.subCounter/2));
        if (startBeginning){
            useFunction = function(a,b){return a+b;};
        } else {
            leftSum += currentNode.subCounter;
            useFunction = function(a,b){return a-b;};
        }

        // #2a counting the element from left to right
        if (!startBeginning) { i = currentNode.children.length-1; };
        while ((startBeginning && leftSum <= index) ||
               (!startBeginning && leftSum > index)){
            if (currentNode.children[i].e!==null){
                leftSum = useFunction(leftSum, 1);
            };
            leftSum = useFunction(leftSum,currentNode.children[i].subCounter);
            i = useFunction(i, 1);
        };

        // #2b decreasing the incrementation
        i = useFunction(i,-1);
        if (startBeginning){
            if (currentNode.children[i].e!==null){
                leftSum = useFunction(leftSum, -1);
            };
            leftSum = useFunction(leftSum,-currentNode.children[i].subCounter);
        };
        
        // #3 build path
        p = []; p.push(currentNode.children[i].t);
        if (buildingNode === null){
            buildingNode = new LSEQNode(p,null);
            queue = buildingNode;
        } else {
            temp = new LSEQNode(p,null);
            queue.add(temp);
            queue = temp;
        };
        return _get(leftSum, buildingNode, queue,
                    currentNode.children[i]);
    };
    return _get(0, null, null, this);
};

/*!
 * \brief cast the JSON object to a LSEQNode
 * \param object the JSON object
 * \return a self reference
 */
LSEQNode.prototype.fromJSON = function(object){
    this.t = new Triple(object.t.p, object.t.s, object.t.c);
    if (object.children.length === 0){
        this.e = object.e;
        this.subCounter = 0;
        this.children = [];
    } else {
        this.e = null;
        this.subCounter = 1;
        this.children = [];
        this.children.push(
            (new LSEQNode([], null).fromJSON(object.children[0])));
    };
    return this;
};

module.exports = LSEQNode;

},{"./triple.js":47,"./util.js":48}],45:[function(require,module,exports){
var BI = require('BigInt');
var Base = require('./base.js')(15);
var S = require('./strategy.js')(10);
var ID = require('./identifier.js');
var Triple = require('./triple.js');
var LSEQNode = require('./lseqnode.js');

/*!
 * \class LSEQTree
 *
 * \brief Distributed array using LSEQ allocation strategy with an underlying
 * exponential tree model
 */
function LSEQTree(s){
    var listTriple;
    
    this._s = s;
    this._c = 0;
    this._hash = function(depth) { return depth%2; };
    this.length = 0;

    this.root = new LSEQNode([],null);
    listTriple = []; listTriple.push(new Triple(0,0,0));  // min bound
    this.root.add(new LSEQNode(listTriple, ""));
    listTriple = [];
    listTriple.push(new Triple(Math.pow(2,Base.getBitBase(0))-1,
                               Number.MAX_VALUE,
                               Number.MAX_VALUE)); // max bound
    this.root.add(new LSEQNode(listTriple, ""));
};

/*!
 * \brief return the LSEQNode of the element at  targeted index
 * \param index the index of the element in the flattened array
 * \return the LSEQNode targeting the element at index
 */
LSEQTree.prototype.get = function(index){
    // #1 search in the tree to get the value
    return this.root.get(index);
};

/*!
 * \brief insert a value at the targeted index
 * \param element the element to insert
 * \param index the position in the array
 * \return a pair {_e: element , _i: identifier}
 */
LSEQTree.prototype.insert = function(element, index){
    var pei = this.get(index), // #1a previous bound
        qei = this.get(index+1), // #1b next bound
        id, couple;
    this._c += 1; // #2a incrementing the local counter
    id = this.alloc(pei, qei); // #2b generating the id inbetween the bounds
    // #3 add it to the structure and return value
    couple = {_e: element, _i: id}
    this.applyInsert(element, id, true);
    return couple;
};

/*!
 * \brief delete the element at the index
 * \param index the index of the element to delete in the array
 * \return the identifier of the element at the index
 */
LSEQTree.prototype.remove = function(index){
    var ei = this.get(index+1),
        i = new ID(null, [], []);
    i.fromNode(ei); // from node -> id
    this.applyRemove(ei); 
    return i;
};

/*!
 * \brief generate the digit part of the identifiers  between p and q
 * \param p the digit part of the previous identifier
 * \param q the digit part of the next identifier
 * \return the digit part located between p and q
 */
LSEQTree.prototype.alloc = function (p,q){
    var interval = 0, level = 0;
    // #1 process the level of the new identifier
    while (interval<=0){ // no room for insertion
        interval = Base.getInterval(p, q, level); // (TODO) optimize
        ++level;
    };
    level -= 1;
    if (this._hash(level) === 0){
        return S.bPlus(p, q, level, interval, this._s, this._c);
    } else {
        return S.bMinus(p, q, level, interval, this._s, this._c);
    };
};

/*!
 * \brief insert an element created from a remote site into the array
 * \param e the element to insert
 * \param i the identifier of the element
 * \param noIndex whether or not it should return the index of the insert
 * \return the index of the newly inserted element in the array
 */
LSEQTree.prototype.applyInsert = function(e, i, noIndex){
    var node, result;
    // #0 cast from the proper type
    // #0A the identifier is an ID
    if (i && i._d && i._s && i._c){
        node = (new ID(i._d, i._s, i._c).toNode(e));
    };
    // #0B the identifier is a LSEQNode
    if (i && i.t && i.children){
        node = (new LSEQNode([],null)).fromJSON(i);
    };
    // #2 integrates the new element to the data structure
    result = this.root.add(node);
    if (result !== -1){
        // #3 if the element as been added
        this.length += 1;
    };
    return result || (!noIndex && this.root.indexOf(node));
};

/*!
 * \brief delete the element with the targeted identifier
 * \param i the identifier of the element
 * \return the index of the element feshly deleted, -1 if no removal
 */
LSEQTree.prototype.applyRemove = function(i){
    var node, position;
    // #0 cast from the proper type
    if (i && i._d && i._s && i._c){
        node = (new ID(i._d, i._s, i._c)).toNode(null);
    };
    // #0B the identifier is a LSEQNode
    if (i && i.t && i.children){
        node = (new LSEQNode([],null)).fromJSON(i);
    };
    // #1 get the index of the element to remove
    position = this.root.indexOf(node);
    if (position !== -1){
        // #2 if it exists remove it
        this.root.del(node);
        this.length -= 1;
    };
    return position;
};


/*!
 * \brief cast the JSON object into a proper LSEQTree.
 * \param object the JSON object to cast
 * \return a self reference
 */
LSEQTree.prototype.fromJSON = function(object){
    // #1 copy the source, counter, and length of the object
    this._s = object._s;
    this._c = object._c;
    this.length = object.length;
    // #2 depth first adding
    var self = this;
    function depthFirst(currentNode, currentPath){
        var triple = new Triple(currentNode.t.p,
                                currentNode.t.s,
                                currentNode.t.c);
        currentPath.push(triple); // stack
        if (currentNode.e!==null){
            var copy = currentPath.slice();
            self.root.add(new LSEQNode(copy, currentNode.e));
        };
        for (var i = 0; i<currentNode.children.length; ++i){
            depthFirst(currentNode.children[i], currentPath);
        };
        currentPath.pop(); // unstack
    };
    for (var i = 0; i<object.root.children.length; ++i){
        depthFirst(object.root.children[i], []);
    };
    return this;
};

module.exports = LSEQTree;

},{"./base.js":42,"./identifier.js":43,"./lseqnode.js":44,"./strategy.js":46,"./triple.js":47,"BigInt":49}],46:[function(require,module,exports){
var BI = require('BigInt');
var Base = require('./base.js')();
var ID = require('./identifier.js');

/*!
 * \class Strategy
 * \brief Enumerate the available sub-allocation strategies. The signature of
 * these functions is f(Id, Id, N+, N+, N, N): Id.
 * \param boundary the value used as the default maximum spacing between ids
 */
function Strategy(boundary){
    var DEFAULT_BOUNDARY = 10;
    this._boundary = boundary || DEFAULT_BOUNDARY;
};

/*!
 * \brief Choose an id starting from previous bound and adding random number
 * \param p the previous identifier
 * \param q the next identifier
 * \param level the number of concatenation composing the new identifier
 * \param interval the interval between p and q
 * \param s the source that creates the new identifier
 * \param c the counter of that source
 */
Strategy.prototype.bPlus = function (p, q, level, interval, s, c){
    var copyP = p, copyQ = q,
        step = Math.min(this._boundary, interval), //#0 the min interval
        digit = BI.int2bigInt(0,Base.getSumBit(level)),
        value;
    
    // #1 copy the previous identifier
    for (var i = 0; i<=level;++i){
	      value = 0;
        if (p!==null){ value = p.t.p; };
        BI.addInt_(digit,value);
        if (i!==level){ BI.leftShift_(digit,Base.getBitBase(i+1)); };
        if (p!==null && p.children.length!==0){
            p = p.children[0];
        } else {
            p = null;
        };
    };
    // #2 create a digit for an identifier by adding a random value
    // #2a Digit
    BI.addInt_(digit, Math.floor(Math.random()*step+1));
    // #2b Source & counter
    return getSC(digit, copyP, copyQ, level, s, c);
};


/*!
 * \brief Choose an id starting from next bound and substract a random number
 * \param p the previous identifier
 * \param q the next identifier
 * \param level the number of concatenation composing the new identifier
 * \param interval the interval between p and q
 * \param s the source that creates the new identifier
 * \param c the counter of that source
 */
Strategy.prototype.bMinus = function (p, q, level, interval, s, c){
    var copyP = p, copyQ = q,
        step = Math.min(this._boundary, interval), // #0 process min interval
        digit = BI.int2bigInt(0,Base.getSumBit(level)),
        pIsGreater = false, commonRoot = true,
        prevValue, nextValue;
    
    // #1 copy next, if previous is greater, copy maxValue @ depth
    for (var i = 0; i<=level;++i){
        prevValue = 0; if (p !== null){ prevValue = p.t.p; }
        nextValue = 0; if (q !== null){ nextValue = q.t.p; }
        if (commonRoot && prevValue !== nextValue){
            commonRoot = false;
            pIsGreater = prevValue > nextValue;
        }
        if (pIsGreater){ nextValue = Math.pow(2,Base.getBitBase(i))-1; }
        BI.addInt_(digit, nextValue);
        if (i!==level){ BI.leftShift_(digit,Base.getBitBase(i+1)); }
        if (q!==null && q.children.length!==0){
            q = q.children[0];
        } else {
            q = null;
        };
        if (p!==null && p.children.length!==0){
            p = p.children[0];
        } else {
            p = null;
        };
    };
    // #3 create a digit for an identifier by subing a random value
    // #3a Digit
    if (pIsGreater){
        BI.addInt_(digit, -Math.floor(Math.random()*step) );
    } else {
        BI.addInt_(digit, -Math.floor(Math.random()*step)-1 );
    };
    
    // #3b Source & counter
    return getSC(digit, copyP, copyQ, level, s, c);
};

/*!
 * \brief copies the appropriates source and counter from the adjacent 
 * identifiers at the insertion position.
 * \param d the digit part of the new identifier
 * \param p the previous identifier
 * \param q the next identifier
 * \param level the size of the new identifier
 * \param s the local site identifier 
 * \param c the local monotonic counter
 */
function getSC(d, p, q, level, s, c){
    var sources = [], counters = [],
        i = 0,
        sumBit = Base.getSumBit(level),
        tempDigit, value;
    
    while (i<=level){
        tempDigit = BI.dup(d);
        BI.rightShift_(tempDigit, sumBit - Base.getSumBit(i));
        value = BI.modInt(tempDigit,Math.pow(2,Base.getBitBase(i)));
        sources[i]=s;
        counters[i]=c
        if (q!==null && q.t.p===value){ sources[i]=q.t.s; counters[i]=q.t.c};
        if (p!==null && p.t.p===value){ sources[i]=p.t.s; counters[i]=p.t.c};
        if (q!==null && q.children.length!==0){
            q = q.children[0];
        } else {
            q = null;
        };
        if (p!==null && p.children.length!==0){
            p = p.children[0];
        } else {
            p = null;
        };
        ++i;
    };
    
    return new ID(d, sources, counters);
};

Strategy.instance = null;

module.exports = function(args){
    if (args){
        Strategy.instance = new Strategy(args);
    } else {
        if (Strategy.instance === null){
            Strategy.instance = new Strategy();
        };
    };
    return Strategy.instance;
};

},{"./base.js":42,"./identifier.js":43,"BigInt":49}],47:[function(require,module,exports){

/*!
 * \brief triple that contains a <path site counter>
 * \param path the part of the path in the tree
 * \param site the unique site identifier that created the triple
 * \param counter the counter of the site when it created the triple
 */
function Triple(path, site, counter){
    this.p = path;
    this.s = site;
    this.c = counter;
};

/*!
 * \brief compare two triples prioritizing the path, then site, then counter
 * \param o the other triple to compare
 * \return -1 if this is lower than o, 1 if this is greater than o, 0 otherwise
 */
Triple.prototype.compare = function(o){
    if (this.s === Number.MAX_VALUE && this.c === Number.MAX_VALUE){
        return 1;
    };
    if (o.s === Number.MAX_VALUE && o.s === Number.MAX_VALUE){
        return -1;
    };
    
    if (this.p < o.p) { return -1;};
    if (this.p > o.p) { return 1 ;};
    if (this.s < o.s) { return -1;};
    if (this.s > o.s) { return 1 ;};
    if (this.c < o.c) { return -1;};
    if (this.c > o.c) { return 1 ;};
    return 0;
};

module.exports = Triple;

},{}],48:[function(require,module,exports){

function binaryIndexOf(){

/**
 * \from: [https://gist.github.com/Wolfy87/5734530]
 * Performs a binary search on the host array. This method can either be
 * injected into Array.prototype or called with a specified scope like this:
 * binaryIndexOf.call(someArray, searchElement);
 *
 *
 * @param {*} searchElement The item to search for within the array.
 * @return {Number} The index of the element which defaults to -1 when not
 * found.
 */
Array.prototype.binaryIndexOf = function(searchElement) {
    var minIndex = 0;
    var maxIndex = this.length - 1;
    var currentIndex;
    var currentElement;

    while (minIndex <= maxIndex) {
        currentIndex = Math.floor((minIndex + maxIndex) / 2);
        currentElement = this[currentIndex];
        if (currentElement.compare(searchElement) < 0) {
            minIndex = currentIndex + 1;
        }
        else if (currentElement.compare(searchElement) > 0) {
            maxIndex = currentIndex - 1;
        }
        else {
            return currentIndex;
        }
    };
    return ~maxIndex;
};

}

module.exports = binaryIndexOf();
},{}],49:[function(require,module,exports){
// Vjeux: Customized bigInt2str and str2bigInt in order to accept custom base.

////////////////////////////////////////////////////////////////////////////////////////
// Big Integer Library v. 5.4
// Created 2000, last modified 2009
// Leemon Baird
// www.leemon.com
//
// Version history:
// v 5.4  3 Oct 2009
//   - added "var i" to greaterShift() so i is not global. (Thanks to P�ter Szab� for finding that bug)
//
// v 5.3  21 Sep 2009
//   - added randProbPrime(k) for probable primes
//   - unrolled loop in mont_ (slightly faster)
//   - millerRabin now takes a bigInt parameter rather than an int
//
// v 5.2  15 Sep 2009
//   - fixed capitalization in call to int2bigInt in randBigInt
//     (thanks to Emili Evripidou, Reinhold Behringer, and Samuel Macaleese for finding that bug)
//
// v 5.1  8 Oct 2007
//   - renamed inverseModInt_ to inverseModInt since it doesn't change its parameters
//   - added functions GCD and randBigInt, which call GCD_ and randBigInt_
//   - fixed a bug found by Rob Visser (see comment with his name below)
//   - improved comments
//
// This file is public domain.   You can use it for any purpose without restriction.
// I do not guarantee that it is correct, so use it at your own risk.  If you use
// it for something interesting, I'd appreciate hearing about it.  If you find
// any bugs or make any improvements, I'd appreciate hearing about those too.
// It would also be nice if my name and URL were left in the comments.  But none
// of that is required.
//
// This code defines a bigInt library for arbitrary-precision integers.
// A bigInt is an array of integers storing the value in chunks of bpe bits,
// little endian (buff[0] is the least significant word).
// Negative bigInts are stored two's complement.  Almost all the functions treat
// bigInts as nonnegative.  The few that view them as two's complement say so
// in their comments.  Some functions assume their parameters have at least one
// leading zero element. Functions with an underscore at the end of the name put
// their answer into one of the arrays passed in, and have unpredictable behavior
// in case of overflow, so the caller must make sure the arrays are big enough to
// hold the answer.  But the average user should never have to call any of the
// underscored functions.  Each important underscored function has a wrapper function
// of the same name without the underscore that takes care of the details for you.
// For each underscored function where a parameter is modified, that same variable
// must not be used as another argument too.  So, you cannot square x by doing
// multMod_(x,x,n).  You must use squareMod_(x,n) instead, or do y=dup(x); multMod_(x,y,n).
// Or simply use the multMod(x,x,n) function without the underscore, where
// such issues never arise, because non-underscored functions never change
// their parameters; they always allocate new memory for the answer that is returned.
//
// These functions are designed to avoid frequent dynamic memory allocation in the inner loop.
// For most functions, if it needs a BigInt as a local variable it will actually use
// a global, and will only allocate to it only when it's not the right size.  This ensures
// that when a function is called repeatedly with same-sized parameters, it only allocates
// memory on the first call.
//
// Note that for cryptographic purposes, the calls to Math.random() must
// be replaced with calls to a better pseudorandom number generator.
//
// In the following, "bigInt" means a bigInt with at least one leading zero element,
// and "integer" means a nonnegative integer less than radix.  In some cases, integer
// can be negative.  Negative bigInts are 2s complement.
//
// The following functions do not modify their inputs.
// Those returning a bigInt, string, or Array will dynamically allocate memory for that value.
// Those returning a boolean will return the integer 0 (false) or 1 (true).
// Those returning boolean or int will not allocate memory except possibly on the first
// time they're called with a given parameter size.
//
// bigInt  add(x,y)               //return (x+y) for bigInts x and y.
// bigInt  addInt(x,n)            //return (x+n) where x is a bigInt and n is an integer.
// string  bigInt2str(x,base)     //return a string form of bigInt x in a given base, with 2 <= base <= 95
// int     bitSize(x)             //return how many bits long the bigInt x is, not counting leading zeros
// bigInt  dup(x)                 //return a copy of bigInt x
// boolean equals(x,y)            //is the bigInt x equal to the bigint y?
// boolean equalsInt(x,y)         //is bigint x equal to integer y?
// bigInt  expand(x,n)            //return a copy of x with at least n elements, adding leading zeros if needed
// Array   findPrimes(n)          //return array of all primes less than integer n
// bigInt  GCD(x,y)               //return greatest common divisor of bigInts x and y (each with same number of elements).
// boolean greater(x,y)           //is x>y?  (x and y are nonnegative bigInts)
// boolean greaterShift(x,y,shift)//is (x <<(shift*bpe)) > y?
// bigInt  int2bigInt(t,n,m)      //return a bigInt equal to integer t, with at least n bits and m array elements
// bigInt  inverseMod(x,n)        //return (x**(-1) mod n) for bigInts x and n.  If no inverse exists, it returns null
// int     inverseModInt(x,n)     //return x**(-1) mod n, for integers x and n.  Return 0 if there is no inverse
// boolean isZero(x)              //is the bigInt x equal to zero?
// boolean millerRabin(x,b)       //does one round of Miller-Rabin base integer b say that bigInt x is possibly prime? (b is bigInt, 1<b<x)
// boolean millerRabinInt(x,b)    //does one round of Miller-Rabin base integer b say that bigInt x is possibly prime? (b is int,    1<b<x)
// bigInt  mod(x,n)               //return a new bigInt equal to (x mod n) for bigInts x and n.
// int     modInt(x,n)            //return x mod n for bigInt x and integer n.
// bigInt  mult(x,y)              //return x*y for bigInts x and y. This is faster when y<x.
// bigInt  multMod(x,y,n)         //return (x*y mod n) for bigInts x,y,n.  For greater speed, let y<x.
// boolean negative(x)            //is bigInt x negative?
// bigInt  powMod(x,y,n)          //return (x**y mod n) where x,y,n are bigInts and ** is exponentiation.  0**0=1. Faster for odd n.
// bigInt  randBigInt(n,s)        //return an n-bit random BigInt (n>=1).  If s=1, then the most significant of those n bits is set to 1.
// bigInt  randTruePrime(k)       //return a new, random, k-bit, true prime bigInt using Maurer's algorithm.
// bigInt  randProbPrime(k)       //return a new, random, k-bit, probable prime bigInt (probability it's composite less than 2^-80).
// bigInt  str2bigInt(s,b,n,m)    //return a bigInt for number represented in string s in base b with at least n bits and m array elements
// bigInt  sub(x,y)               //return (x-y) for bigInts x and y.  Negative answers will be 2s complement
// bigInt  trim(x,k)              //return a copy of x with exactly k leading zero elements
//
//
// The following functions each have a non-underscored version, which most users should call instead.
// These functions each write to a single parameter, and the caller is responsible for ensuring the array
// passed in is large enough to hold the result.
//
// void    addInt_(x,n)          //do x=x+n where x is a bigInt and n is an integer
// void    add_(x,y)             //do x=x+y for bigInts x and y
// void    copy_(x,y)            //do x=y on bigInts x and y
// void    copyInt_(x,n)         //do x=n on bigInt x and integer n
// void    GCD_(x,y)             //set x to the greatest common divisor of bigInts x and y, (y is destroyed).  (This never overflows its array).
// boolean inverseMod_(x,n)      //do x=x**(-1) mod n, for bigInts x and n. Returns 1 (0) if inverse does (doesn't) exist
// void    mod_(x,n)             //do x=x mod n for bigInts x and n. (This never overflows its array).
// void    mult_(x,y)            //do x=x*y for bigInts x and y.
// void    multMod_(x,y,n)       //do x=x*y  mod n for bigInts x,y,n.
// void    powMod_(x,y,n)        //do x=x**y mod n, where x,y,n are bigInts (n is odd) and ** is exponentiation.  0**0=1.
// void    randBigInt_(b,n,s)    //do b = an n-bit random BigInt. if s=1, then nth bit (most significant bit) is set to 1. n>=1.
// void    randTruePrime_(ans,k) //do ans = a random k-bit true random prime (not just probable prime) with 1 in the msb.
// void    sub_(x,y)             //do x=x-y for bigInts x and y. Negative answers will be 2s complement.
//
// The following functions do NOT have a non-underscored version.
// They each write a bigInt result to one or more parameters.  The caller is responsible for
// ensuring the arrays passed in are large enough to hold the results.
//
// void addShift_(x,y,ys)       //do x=x+(y<<(ys*bpe))
// void carry_(x)               //do carries and borrows so each element of the bigInt x fits in bpe bits.
// void divide_(x,y,q,r)        //divide x by y giving quotient q and remainder r
// int  divInt_(x,n)            //do x=floor(x/n) for bigInt x and integer n, and return the remainder. (This never overflows its array).
// int  eGCD_(x,y,d,a,b)        //sets a,b,d to positive bigInts such that d = GCD_(x,y) = a*x-b*y
// void halve_(x)               //do x=floor(|x|/2)*sgn(x) for bigInt x in 2's complement.  (This never overflows its array).
// void leftShift_(x,n)         //left shift bigInt x by n bits.  n<bpe.
// void linComb_(x,y,a,b)       //do x=a*x+b*y for bigInts x and y and integers a and b
// void linCombShift_(x,y,b,ys) //do x=x+b*(y<<(ys*bpe)) for bigInts x and y, and integers b and ys
// void mont_(x,y,n,np)         //Montgomery multiplication (see comments where the function is defined)
// void multInt_(x,n)           //do x=x*n where x is a bigInt and n is an integer.
// void rightShift_(x,n)        //right shift bigInt x by n bits.  0 <= n < bpe. (This never overflows its array).
// void squareMod_(x,n)         //do x=x*x  mod n for bigInts x,n
// void subShift_(x,y,ys)       //do x=x-(y<<(ys*bpe)). Negative answers will be 2s complement.
//
// The following functions are based on algorithms from the _Handbook of Applied Cryptography_
//    powMod_()           = algorithm 14.94, Montgomery exponentiation
//    eGCD_,inverseMod_() = algorithm 14.61, Binary extended GCD_
//    GCD_()              = algorothm 14.57, Lehmer's algorithm
//    mont_()             = algorithm 14.36, Montgomery multiplication
//    divide_()           = algorithm 14.20  Multiple-precision division
//    squareMod_()        = algorithm 14.16  Multiple-precision squaring
//    randTruePrime_()    = algorithm  4.62, Maurer's algorithm
//    millerRabin()       = algorithm  4.24, Miller-Rabin algorithm
//
// Profiling shows:
//     randTruePrime_() spends:
//         10% of its time in calls to powMod_()
//         85% of its time in calls to millerRabin()
//     millerRabin() spends:
//         99% of its time in calls to powMod_()   (always with a base of 2)
//     powMod_() spends:
//         94% of its time in calls to mont_()  (almost always with x==y)
//
// This suggests there are several ways to speed up this library slightly:
//     - convert powMod_ to use a Montgomery form of k-ary window (or maybe a Montgomery form of sliding window)
//         -- this should especially focus on being fast when raising 2 to a power mod n
//     - convert randTruePrime_() to use a minimum r of 1/3 instead of 1/2 with the appropriate change to the test
//     - tune the parameters in randTruePrime_(), including c, m, and recLimit
//     - speed up the single loop in mont_() that takes 95% of the runtime, perhaps by reducing checking
//       within the loop when all the parameters are the same length.
//
// There are several ideas that look like they wouldn't help much at all:
//     - replacing trial division in randTruePrime_() with a sieve (that speeds up something taking almost no time anyway)
//     - increase bpe from 15 to 30 (that would help if we had a 32*32->64 multiplier, but not with JavaScript's 32*32->32)
//     - speeding up mont_(x,y,n,np) when x==y by doing a non-modular, non-Montgomery square
//       followed by a Montgomery reduction.  The intermediate answer will be twice as long as x, so that
//       method would be slower.  This is unfortunate because the code currently spends almost all of its time
//       doing mont_(x,x,...), both for randTruePrime_() and powMod_().  A faster method for Montgomery squaring
//       would have a large impact on the speed of randTruePrime_() and powMod_().  HAC has a couple of poorly-worded
//       sentences that seem to imply it's faster to do a non-modular square followed by a single
//       Montgomery reduction, but that's obviously wrong.
////////////////////////////////////////////////////////////////////////////////////////

(function () {
//globals
bpe=0;         //bits stored per array element
mask=0;        //AND this with an array element to chop it down to bpe bits
radix=mask+1;  //equals 2^bpe.  A single 1 bit to the left of the last bit of mask.

//the digits for converting to different bases
digitsStr='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_=!@#$%^&*()[]{}|;:,.<>/?`~ \\\'\"+-';

//initialize the global variables
for (bpe=0; (1<<(bpe+1)) > (1<<bpe); bpe++);  //bpe=number of bits in the mantissa on this platform
bpe>>=1;                   //bpe=number of bits in one element of the array representing the bigInt
mask=(1<<bpe)-1;           //AND the mask with an integer to get its bpe least significant bits
radix=mask+1;              //2^bpe.  a single 1 bit to the left of the first bit of mask
one=int2bigInt(1,1,1);     //constant used in powMod_()

//the following global variables are scratchpad memory to
//reduce dynamic memory allocation in the inner loop
t=new Array(0);
ss=t;       //used in mult_()
s0=t;       //used in multMod_(), squareMod_()
s1=t;       //used in powMod_(), multMod_(), squareMod_()
s2=t;       //used in powMod_(), multMod_()
s3=t;       //used in powMod_()
s4=t; s5=t; //used in mod_()
s6=t;       //used in bigInt2str()
s7=t;       //used in powMod_()
T=t;        //used in GCD_()
sa=t;       //used in mont_()
mr_x1=t; mr_r=t; mr_a=t;                                      //used in millerRabin()
eg_v=t; eg_u=t; eg_A=t; eg_B=t; eg_C=t; eg_D=t;               //used in eGCD_(), inverseMod_()
md_q1=t; md_q2=t; md_q3=t; md_r=t; md_r1=t; md_r2=t; md_tt=t; //used in mod_()

primes=t; pows=t; s_i=t; s_i2=t; s_R=t; s_rm=t; s_q=t; s_n1=t;
  s_a=t; s_r2=t; s_n=t; s_b=t; s_d=t; s_x1=t; s_x2=t, s_aa=t; //used in randTruePrime_()

rpprb=t; //used in randProbPrimeRounds() (which also uses "primes")

////////////////////////////////////////////////////////////////////////////////////////


//return array of all primes less than integer n
function findPrimes(n) {
  var i,s,p,ans;
  s=new Array(n);
  for (i=0;i<n;i++)
    s[i]=0;
  s[0]=2;
  p=0;    //first p elements of s are primes, the rest are a sieve
  for(;s[p]<n;) {                  //s[p] is the pth prime
    for(i=s[p]*s[p]; i<n; i+=s[p]) //mark multiples of s[p]
      s[i]=1;
    p++;
    s[p]=s[p-1]+1;
    for(; s[p]<n && s[s[p]]; s[p]++); //find next prime (where s[p]==0)
  }
  ans=new Array(p);
  for(i=0;i<p;i++)
    ans[i]=s[i];
  return ans;
}


//does a single round of Miller-Rabin base b consider x to be a possible prime?
//x is a bigInt, and b is an integer, with b<x
function millerRabinInt(x,b) {
  if (mr_x1.length!=x.length) {
    mr_x1=dup(x);
    mr_r=dup(x);
    mr_a=dup(x);
  }

  copyInt_(mr_a,b);
  return millerRabin(x,mr_a);
}

//does a single round of Miller-Rabin base b consider x to be a possible prime?
//x and b are bigInts with b<x
function millerRabin(x,b) {
  var i,j,k,s;

  if (mr_x1.length!=x.length) {
    mr_x1=dup(x);
    mr_r=dup(x);
    mr_a=dup(x);
  }

  copy_(mr_a,b);
  copy_(mr_r,x);
  copy_(mr_x1,x);

  addInt_(mr_r,-1);
  addInt_(mr_x1,-1);

  //s=the highest power of two that divides mr_r
  k=0;
  for (i=0;i<mr_r.length;i++)
    for (j=1;j<mask;j<<=1)
      if (x[i] & j) {
        s=(k<mr_r.length+bpe ? k : 0);
         i=mr_r.length;
         j=mask;
      } else
        k++;

  if (s)
    rightShift_(mr_r,s);

  powMod_(mr_a,mr_r,x);

  if (!equalsInt(mr_a,1) && !equals(mr_a,mr_x1)) {
    j=1;
    while (j<=s-1 && !equals(mr_a,mr_x1)) {
      squareMod_(mr_a,x);
      if (equalsInt(mr_a,1)) {
        return 0;
      }
      j++;
    }
    if (!equals(mr_a,mr_x1)) {
      return 0;
    }
  }
  return 1;
}

//returns how many bits long the bigInt is, not counting leading zeros.
function bitSize(x) {
  var j,z,w;
  for (j=x.length-1; (x[j]==0) && (j>0); j--);
  for (z=0,w=x[j]; w; (w>>=1),z++);
  z+=bpe*j;
  return z;
}

//return a copy of x with at least n elements, adding leading zeros if needed
function expand(x,n) {
  var ans=int2bigInt(0,(x.length>n ? x.length : n)*bpe,0);
  copy_(ans,x);
  return ans;
}

//return a k-bit true random prime using Maurer's algorithm.
function randTruePrime(k) {
  var ans=int2bigInt(0,k,0);
  randTruePrime_(ans,k);
  return trim(ans,1);
}

//return a k-bit random probable prime with probability of error < 2^-80
function randProbPrime(k) {
  if (k>=600) return randProbPrimeRounds(k,2); //numbers from HAC table 4.3
  if (k>=550) return randProbPrimeRounds(k,4);
  if (k>=500) return randProbPrimeRounds(k,5);
  if (k>=400) return randProbPrimeRounds(k,6);
  if (k>=350) return randProbPrimeRounds(k,7);
  if (k>=300) return randProbPrimeRounds(k,9);
  if (k>=250) return randProbPrimeRounds(k,12); //numbers from HAC table 4.4
  if (k>=200) return randProbPrimeRounds(k,15);
  if (k>=150) return randProbPrimeRounds(k,18);
  if (k>=100) return randProbPrimeRounds(k,27);
              return randProbPrimeRounds(k,40); //number from HAC remark 4.26 (only an estimate)
}

//return a k-bit probable random prime using n rounds of Miller Rabin (after trial division with small primes)
function randProbPrimeRounds(k,n) {
  var ans, i, divisible, B;
  B=30000;  //B is largest prime to use in trial division
  ans=int2bigInt(0,k,0);

  //optimization: try larger and smaller B to find the best limit.

  if (primes.length==0)
    primes=findPrimes(30000);  //check for divisibility by primes <=30000

  if (rpprb.length!=ans.length)
    rpprb=dup(ans);

  for (;;) { //keep trying random values for ans until one appears to be prime
    //optimization: pick a random number times L=2*3*5*...*p, plus a
    //   random element of the list of all numbers in [0,L) not divisible by any prime up to p.
    //   This can reduce the amount of random number generation.

    randBigInt_(ans,k,0); //ans = a random odd number to check
    ans[0] |= 1;
    divisible=0;

    //check ans for divisibility by small primes up to B
    for (i=0; (i<primes.length) && (primes[i]<=B); i++)
      if (modInt(ans,primes[i])==0 && !equalsInt(ans,primes[i])) {
        divisible=1;
        break;
      }

    //optimization: change millerRabin so the base can be bigger than the number being checked, then eliminate the while here.

    //do n rounds of Miller Rabin, with random bases less than ans
    for (i=0; i<n && !divisible; i++) {
      randBigInt_(rpprb,k,0);
      while(!greater(ans,rpprb)) //pick a random rpprb that's < ans
        randBigInt_(rpprb,k,0);
      if (!millerRabin(ans,rpprb))
        divisible=1;
    }

    if(!divisible)
      return ans;
  }
}

//return a new bigInt equal to (x mod n) for bigInts x and n.
function mod(x,n) {
  var ans=dup(x);
  mod_(ans,n);
  return trim(ans,1);
}

//return (x+n) where x is a bigInt and n is an integer.
function addInt(x,n) {
  var ans=expand(x,x.length+1);
  addInt_(ans,n);
  return trim(ans,1);
}

//return x*y for bigInts x and y. This is faster when y<x.
function mult(x,y) {
  var ans=expand(x,x.length+y.length);
  mult_(ans,y);
  return trim(ans,1);
}

//return (x**y mod n) where x,y,n are bigInts and ** is exponentiation.  0**0=1. Faster for odd n.
function powMod(x,y,n) {
  var ans=expand(x,n.length);
  powMod_(ans,trim(y,2),trim(n,2),0);  //this should work without the trim, but doesn't
  return trim(ans,1);
}

//return (x-y) for bigInts x and y.  Negative answers will be 2s complement
function sub(x,y) {
  var ans=expand(x,(x.length>y.length ? x.length+1 : y.length+1));
  sub_(ans,y);
  return trim(ans,1);
}

//return (x+y) for bigInts x and y.
function add(x,y) {
  var ans=expand(x,(x.length>y.length ? x.length+1 : y.length+1));
  add_(ans,y);
  return trim(ans,1);
}

//return (x**(-1) mod n) for bigInts x and n.  If no inverse exists, it returns null
function inverseMod(x,n) {
  var ans=expand(x,n.length);
  var s;
  s=inverseMod_(ans,n);
  return s ? trim(ans,1) : null;
}

//return (x*y mod n) for bigInts x,y,n.  For greater speed, let y<x.
function multMod(x,y,n) {
  var ans=expand(x,n.length);
  multMod_(ans,y,n);
  return trim(ans,1);
}

//generate a k-bit true random prime using Maurer's algorithm,
//and put it into ans.  The bigInt ans must be large enough to hold it.
function randTruePrime_(ans,k) {
  var c,m,pm,dd,j,r,B,divisible,z,zz,recSize;

  if (primes.length==0)
    primes=findPrimes(30000);  //check for divisibility by primes <=30000

  if (pows.length==0) {
    pows=new Array(512);
    for (j=0;j<512;j++) {
      pows[j]=Math.pow(2,j/511.-1.);
    }
  }

  //c and m should be tuned for a particular machine and value of k, to maximize speed
  c=0.1;  //c=0.1 in HAC
  m=20;   //generate this k-bit number by first recursively generating a number that has between k/2 and k-m bits
  recLimit=20; //stop recursion when k <=recLimit.  Must have recLimit >= 2

  if (s_i2.length!=ans.length) {
    s_i2=dup(ans);
    s_R =dup(ans);
    s_n1=dup(ans);
    s_r2=dup(ans);
    s_d =dup(ans);
    s_x1=dup(ans);
    s_x2=dup(ans);
    s_b =dup(ans);
    s_n =dup(ans);
    s_i =dup(ans);
    s_rm=dup(ans);
    s_q =dup(ans);
    s_a =dup(ans);
    s_aa=dup(ans);
  }

  if (k <= recLimit) {  //generate small random primes by trial division up to its square root
    pm=(1<<((k+2)>>1))-1; //pm is binary number with all ones, just over sqrt(2^k)
    copyInt_(ans,0);
    for (dd=1;dd;) {
      dd=0;
      ans[0]= 1 | (1<<(k-1)) | Math.floor(Math.random()*(1<<k));  //random, k-bit, odd integer, with msb 1
      for (j=1;(j<primes.length) && ((primes[j]&pm)==primes[j]);j++) { //trial division by all primes 3...sqrt(2^k)
        if (0==(ans[0]%primes[j])) {
          dd=1;
          break;
        }
      }
    }
    carry_(ans);
    return;
  }

  B=c*k*k;    //try small primes up to B (or all the primes[] array if the largest is less than B).
  if (k>2*m)  //generate this k-bit number by first recursively generating a number that has between k/2 and k-m bits
    for (r=1; k-k*r<=m; )
      r=pows[Math.floor(Math.random()*512)];   //r=Math.pow(2,Math.random()-1);
  else
    r=.5;

  //simulation suggests the more complex algorithm using r=.333 is only slightly faster.

  recSize=Math.floor(r*k)+1;

  randTruePrime_(s_q,recSize);
  copyInt_(s_i2,0);
  s_i2[Math.floor((k-2)/bpe)] |= (1<<((k-2)%bpe));   //s_i2=2^(k-2)
  divide_(s_i2,s_q,s_i,s_rm);                        //s_i=floor((2^(k-1))/(2q))

  z=bitSize(s_i);

  for (;;) {
    for (;;) {  //generate z-bit numbers until one falls in the range [0,s_i-1]
      randBigInt_(s_R,z,0);
      if (greater(s_i,s_R))
        break;
    }                //now s_R is in the range [0,s_i-1]
    addInt_(s_R,1);  //now s_R is in the range [1,s_i]
    add_(s_R,s_i);   //now s_R is in the range [s_i+1,2*s_i]

    copy_(s_n,s_q);
    mult_(s_n,s_R);
    multInt_(s_n,2);
    addInt_(s_n,1);    //s_n=2*s_R*s_q+1

    copy_(s_r2,s_R);
    multInt_(s_r2,2);  //s_r2=2*s_R

    //check s_n for divisibility by small primes up to B
    for (divisible=0,j=0; (j<primes.length) && (primes[j]<B); j++)
      if (modInt(s_n,primes[j])==0 && !equalsInt(s_n,primes[j])) {
        divisible=1;
        break;
      }

    if (!divisible)    //if it passes small primes check, then try a single Miller-Rabin base 2
      if (!millerRabinInt(s_n,2)) //this line represents 75% of the total runtime for randTruePrime_
        divisible=1;

    if (!divisible) {  //if it passes that test, continue checking s_n
      addInt_(s_n,-3);
      for (j=s_n.length-1;(s_n[j]==0) && (j>0); j--);  //strip leading zeros
      for (zz=0,w=s_n[j]; w; (w>>=1),zz++);
      zz+=bpe*j;                             //zz=number of bits in s_n, ignoring leading zeros
      for (;;) {  //generate z-bit numbers until one falls in the range [0,s_n-1]
        randBigInt_(s_a,zz,0);
        if (greater(s_n,s_a))
          break;
      }                //now s_a is in the range [0,s_n-1]
      addInt_(s_n,3);  //now s_a is in the range [0,s_n-4]
      addInt_(s_a,2);  //now s_a is in the range [2,s_n-2]
      copy_(s_b,s_a);
      copy_(s_n1,s_n);
      addInt_(s_n1,-1);
      powMod_(s_b,s_n1,s_n);   //s_b=s_a^(s_n-1) modulo s_n
      addInt_(s_b,-1);
      if (isZero(s_b)) {
        copy_(s_b,s_a);
        powMod_(s_b,s_r2,s_n);
        addInt_(s_b,-1);
        copy_(s_aa,s_n);
        copy_(s_d,s_b);
        GCD_(s_d,s_n);  //if s_b and s_n are relatively prime, then s_n is a prime
        if (equalsInt(s_d,1)) {
          copy_(ans,s_aa);
          return;     //if we've made it this far, then s_n is absolutely guaranteed to be prime
        }
      }
    }
  }
}

//Return an n-bit random BigInt (n>=1).  If s=1, then the most significant of those n bits is set to 1.
function randBigInt(n,s) {
  var a,b;
  a=Math.floor((n-1)/bpe)+2; //# array elements to hold the BigInt with a leading 0 element
  b=int2bigInt(0,0,a);
  randBigInt_(b,n,s);
  return b;
}

//Set b to an n-bit random BigInt.  If s=1, then the most significant of those n bits is set to 1.
//Array b must be big enough to hold the result. Must have n>=1
function randBigInt_(b,n,s) {
  var i,a;
  for (i=0;i<b.length;i++)
    b[i]=0;
  a=Math.floor((n-1)/bpe)+1; //# array elements to hold the BigInt
  for (i=0;i<a;i++) {
    b[i]=Math.floor(Math.random()*(1<<(bpe-1)));
  }
  b[a-1] &= (2<<((n-1)%bpe))-1;
  if (s==1)
    b[a-1] |= (1<<((n-1)%bpe));
}

//Return the greatest common divisor of bigInts x and y (each with same number of elements).
function GCD(x,y) {
  var xc,yc;
  xc=dup(x);
  yc=dup(y);
  GCD_(xc,yc);
  return xc;
}

//set x to the greatest common divisor of bigInts x and y (each with same number of elements).
//y is destroyed.
function GCD_(x,y) {
  var i,xp,yp,A,B,C,D,q,sing;
  if (T.length!=x.length)
    T=dup(x);

  sing=1;
  while (sing) { //while y has nonzero elements other than y[0]
    sing=0;
    for (i=1;i<y.length;i++) //check if y has nonzero elements other than 0
      if (y[i]) {
        sing=1;
        break;
      }
    if (!sing) break; //quit when y all zero elements except possibly y[0]

    for (i=x.length;!x[i] && i>=0;i--);  //find most significant element of x
    xp=x[i];
    yp=y[i];
    A=1; B=0; C=0; D=1;
    while ((yp+C) && (yp+D)) {
      q =Math.floor((xp+A)/(yp+C));
      qp=Math.floor((xp+B)/(yp+D));
      if (q!=qp)
        break;
      t= A-q*C;   A=C;   C=t;    //  do (A,B,xp, C,D,yp) = (C,D,yp, A,B,xp) - q*(0,0,0, C,D,yp)
      t= B-q*D;   B=D;   D=t;
      t=xp-q*yp; xp=yp; yp=t;
    }
    if (B) {
      copy_(T,x);
      linComb_(x,y,A,B); //x=A*x+B*y
      linComb_(y,T,D,C); //y=D*y+C*T
    } else {
      mod_(x,y);
      copy_(T,x);
      copy_(x,y);
      copy_(y,T);
    }
  }
  if (y[0]==0)
    return;
  t=modInt(x,y[0]);
  copyInt_(x,y[0]);
  y[0]=t;
  while (y[0]) {
    x[0]%=y[0];
    t=x[0]; x[0]=y[0]; y[0]=t;
  }
}

//do x=x**(-1) mod n, for bigInts x and n.
//If no inverse exists, it sets x to zero and returns 0, else it returns 1.
//The x array must be at least as large as the n array.
function inverseMod_(x,n) {
  var k=1+2*Math.max(x.length,n.length);

  if(!(x[0]&1)  && !(n[0]&1)) {  //if both inputs are even, then inverse doesn't exist
    copyInt_(x,0);
    return 0;
  }

  if (eg_u.length!=k) {
    eg_u=new Array(k);
    eg_v=new Array(k);
    eg_A=new Array(k);
    eg_B=new Array(k);
    eg_C=new Array(k);
    eg_D=new Array(k);
  }

  copy_(eg_u,x);
  copy_(eg_v,n);
  copyInt_(eg_A,1);
  copyInt_(eg_B,0);
  copyInt_(eg_C,0);
  copyInt_(eg_D,1);
  for (;;) {
    while(!(eg_u[0]&1)) {  //while eg_u is even
      halve_(eg_u);
      if (!(eg_A[0]&1) && !(eg_B[0]&1)) { //if eg_A==eg_B==0 mod 2
        halve_(eg_A);
        halve_(eg_B);
      } else {
        add_(eg_A,n);  halve_(eg_A);
        sub_(eg_B,x);  halve_(eg_B);
      }
    }

    while (!(eg_v[0]&1)) {  //while eg_v is even
      halve_(eg_v);
      if (!(eg_C[0]&1) && !(eg_D[0]&1)) { //if eg_C==eg_D==0 mod 2
        halve_(eg_C);
        halve_(eg_D);
      } else {
        add_(eg_C,n);  halve_(eg_C);
        sub_(eg_D,x);  halve_(eg_D);
      }
    }

    if (!greater(eg_v,eg_u)) { //eg_v <= eg_u
      sub_(eg_u,eg_v);
      sub_(eg_A,eg_C);
      sub_(eg_B,eg_D);
    } else {                   //eg_v > eg_u
      sub_(eg_v,eg_u);
      sub_(eg_C,eg_A);
      sub_(eg_D,eg_B);
    }

    if (equalsInt(eg_u,0)) {
      if (negative(eg_C)) //make sure answer is nonnegative
        add_(eg_C,n);
      copy_(x,eg_C);

      if (!equalsInt(eg_v,1)) { //if GCD_(x,n)!=1, then there is no inverse
        copyInt_(x,0);
        return 0;
      }
      return 1;
    }
  }
}

//return x**(-1) mod n, for integers x and n.  Return 0 if there is no inverse
function inverseModInt(x,n) {
  var a=1,b=0,t;
  for (;;) {
    if (x==1) return a;
    if (x==0) return 0;
    b-=a*Math.floor(n/x);
    n%=x;

    if (n==1) return b; //to avoid negatives, change this b to n-b, and each -= to +=
    if (n==0) return 0;
    a-=b*Math.floor(x/n);
    x%=n;
  }
}

//this deprecated function is for backward compatibility only.
function inverseModInt_(x,n) {
   return inverseModInt(x,n);
}


//Given positive bigInts x and y, change the bigints v, a, and b to positive bigInts such that:
//     v = GCD_(x,y) = a*x-b*y
//The bigInts v, a, b, must have exactly as many elements as the larger of x and y.
function eGCD_(x,y,v,a,b) {
  var g=0;
  var k=Math.max(x.length,y.length);
  if (eg_u.length!=k) {
    eg_u=new Array(k);
    eg_A=new Array(k);
    eg_B=new Array(k);
    eg_C=new Array(k);
    eg_D=new Array(k);
  }
  while(!(x[0]&1)  && !(y[0]&1)) {  //while x and y both even
    halve_(x);
    halve_(y);
    g++;
  }
  copy_(eg_u,x);
  copy_(v,y);
  copyInt_(eg_A,1);
  copyInt_(eg_B,0);
  copyInt_(eg_C,0);
  copyInt_(eg_D,1);
  for (;;) {
    while(!(eg_u[0]&1)) {  //while u is even
      halve_(eg_u);
      if (!(eg_A[0]&1) && !(eg_B[0]&1)) { //if A==B==0 mod 2
        halve_(eg_A);
        halve_(eg_B);
      } else {
        add_(eg_A,y);  halve_(eg_A);
        sub_(eg_B,x);  halve_(eg_B);
      }
    }

    while (!(v[0]&1)) {  //while v is even
      halve_(v);
      if (!(eg_C[0]&1) && !(eg_D[0]&1)) { //if C==D==0 mod 2
        halve_(eg_C);
        halve_(eg_D);
      } else {
        add_(eg_C,y);  halve_(eg_C);
        sub_(eg_D,x);  halve_(eg_D);
      }
    }

    if (!greater(v,eg_u)) { //v<=u
      sub_(eg_u,v);
      sub_(eg_A,eg_C);
      sub_(eg_B,eg_D);
    } else {                //v>u
      sub_(v,eg_u);
      sub_(eg_C,eg_A);
      sub_(eg_D,eg_B);
    }
    if (equalsInt(eg_u,0)) {
      if (negative(eg_C)) {   //make sure a (C)is nonnegative
        add_(eg_C,y);
        sub_(eg_D,x);
      }
      multInt_(eg_D,-1);  ///make sure b (D) is nonnegative
      copy_(a,eg_C);
      copy_(b,eg_D);
      leftShift_(v,g);
      return;
    }
  }
}


//is bigInt x negative?
function negative(x) {
  return ((x[x.length-1]>>(bpe-1))&1);
}


//is (x << (shift*bpe)) > y?
//x and y are nonnegative bigInts
//shift is a nonnegative integer
function greaterShift(x,y,shift) {
  var i, kx=x.length, ky=y.length;
  k=((kx+shift)<ky) ? (kx+shift) : ky;
  for (i=ky-1-shift; i<kx && i>=0; i++)
    if (x[i]>0)
      return 1; //if there are nonzeros in x to the left of the first column of y, then x is bigger
  for (i=kx-1+shift; i<ky; i++)
    if (y[i]>0)
      return 0; //if there are nonzeros in y to the left of the first column of x, then x is not bigger
  for (i=k-1; i>=shift; i--)
    if      (x[i-shift]>y[i]) return 1;
    else if (x[i-shift]<y[i]) return 0;
  return 0;
}

//is x > y? (x and y both nonnegative)
function greater(x,y) {
  var i;
  var k=(x.length<y.length) ? x.length : y.length;

  for (i=x.length;i<y.length;i++)
    if (y[i])
      return 0;  //y has more digits

  for (i=y.length;i<x.length;i++)
    if (x[i])
      return 1;  //x has more digits

  for (i=k-1;i>=0;i--)
    if (x[i]>y[i])
      return 1;
    else if (x[i]<y[i])
      return 0;
  return 0;
}

//divide x by y giving quotient q and remainder r.  (q=floor(x/y),  r=x mod y).  All 4 are bigints.
//x must have at least one leading zero element.
//y must be nonzero.
//q and r must be arrays that are exactly the same length as x. (Or q can have more).
//Must have x.length >= y.length >= 2.
function divide_(x,y,q,r) {
  var kx, ky;
  var i,j,y1,y2,c,a,b;
  copy_(r,x);
  for (ky=y.length;y[ky-1]==0;ky--); //ky is number of elements in y, not including leading zeros

  //normalize: ensure the most significant element of y has its highest bit set
  b=y[ky-1];
  for (a=0; b; a++)
    b>>=1;
  a=bpe-a;  //a is how many bits to shift so that the high order bit of y is leftmost in its array element
  leftShift_(y,a);  //multiply both by 1<<a now, then divide both by that at the end
  leftShift_(r,a);

  //Rob Visser discovered a bug: the following line was originally just before the normalization.
  for (kx=r.length;r[kx-1]==0 && kx>ky;kx--); //kx is number of elements in normalized x, not including leading zeros

  copyInt_(q,0);                      // q=0
  while (!greaterShift(y,r,kx-ky)) {  // while (leftShift_(y,kx-ky) <= r) {
    subShift_(r,y,kx-ky);             //   r=r-leftShift_(y,kx-ky)
    q[kx-ky]++;                       //   q[kx-ky]++;
  }                                   // }

  for (i=kx-1; i>=ky; i--) {
    if (r[i]==y[ky-1])
      q[i-ky]=mask;
    else
      q[i-ky]=Math.floor((r[i]*radix+r[i-1])/y[ky-1]);

    //The following for(;;) loop is equivalent to the commented while loop,
    //except that the uncommented version avoids overflow.
    //The commented loop comes from HAC, which assumes r[-1]==y[-1]==0
    //  while (q[i-ky]*(y[ky-1]*radix+y[ky-2]) > r[i]*radix*radix+r[i-1]*radix+r[i-2])
    //    q[i-ky]--;
    for (;;) {
      y2=(ky>1 ? y[ky-2] : 0)*q[i-ky];
      c=y2>>bpe;
      y2=y2 & mask;
      y1=c+q[i-ky]*y[ky-1];
      c=y1>>bpe;
      y1=y1 & mask;

      if (c==r[i] ? y1==r[i-1] ? y2>(i>1 ? r[i-2] : 0) : y1>r[i-1] : c>r[i])
        q[i-ky]--;
      else
        break;
    }

    linCombShift_(r,y,-q[i-ky],i-ky);    //r=r-q[i-ky]*leftShift_(y,i-ky)
    if (negative(r)) {
      addShift_(r,y,i-ky);         //r=r+leftShift_(y,i-ky)
      q[i-ky]--;
    }
  }

  rightShift_(y,a);  //undo the normalization step
  rightShift_(r,a);  //undo the normalization step
}

//do carries and borrows so each element of the bigInt x fits in bpe bits.
function carry_(x) {
  var i,k,c,b;
  k=x.length;
  c=0;
  for (i=0;i<k;i++) {
    c+=x[i];
    b=0;
    if (c<0) {
      b=-(c>>bpe);
      c+=b*radix;
    }
    x[i]=c & mask;
    c=(c>>bpe)-b;
  }
}

//return x mod n for bigInt x and integer n.
function modInt(x,n) {
  var i,c=0;
  for (i=x.length-1; i>=0; i--)
    c=(c*radix+x[i])%n;
  return c;
}

//convert the integer t into a bigInt with at least the given number of bits.
//the returned array stores the bigInt in bpe-bit chunks, little endian (buff[0] is least significant word)
//Pad the array with leading zeros so that it has at least minSize elements.
//There will always be at least one leading 0 element.
function int2bigInt(t,bits,minSize) {
  var i,k;
  k=Math.ceil(bits/bpe)+1;
  k=minSize>k ? minSize : k;
  buff=new Array(k);
  copyInt_(buff,t);
  return buff;
}

//return the bigInt given a string representation in a given base.
//Pad the array with leading zeros so that it has at least minSize elements.
//If base=-1, then it reads in a space-separated list of array elements in decimal.
//The array will always have at least one leading zero, unless base=-1.
function str2bigInt(s,b,minSize) {
  var d, i, j, base, str, x, y, kk;
  if (typeof b === 'string') {
	  base = b.length;
	  str = b;
  } else {
	  base = b;
	  str = digitsStr;
  }
  var k=s.length;
  if (base==-1) { //comma-separated list of array elements in decimal
    x=new Array(0);
    for (;;) {
      y=new Array(x.length+1);
      for (i=0;i<x.length;i++)
        y[i+1]=x[i];
      y[0]=parseInt(s,10);
      x=y;
      d=s.indexOf(',',0);
      if (d<1)
        break;
      s=s.substring(d+1);
      if (s.length==0)
        break;
    }
    if (x.length<minSize) {
      y=new Array(minSize);
      copy_(y,x);
      return y;
    }
    return x;
  }

  x=int2bigInt(0,base*k,0);
  for (i=0;i<k;i++) {
    d=str.indexOf(s.substring(i,i+1),0);
//    if (base<=36 && d>=36)  //convert lowercase to uppercase if base<=36
//      d-=26;
    if (d>=base || d<0) {   //ignore illegal characters
      continue;
    }
    multInt_(x,base);
    addInt_(x,d);
  }

  for (k=x.length;k>0 && !x[k-1];k--); //strip off leading zeros
  k=minSize>k+1 ? minSize : k+1;
  y=new Array(k);
  kk=k<x.length ? k : x.length;
  for (i=0;i<kk;i++)
    y[i]=x[i];
  for (;i<k;i++)
    y[i]=0;
  return y;
}

//is bigint x equal to integer y?
//y must have less than bpe bits
function equalsInt(x,y) {
  var i;
  if (x[0]!=y)
    return 0;
  for (i=1;i<x.length;i++)
    if (x[i])
      return 0;
  return 1;
}

//are bigints x and y equal?
//this works even if x and y are different lengths and have arbitrarily many leading zeros
function equals(x,y) {
  var i;
  var k=x.length<y.length ? x.length : y.length;
  for (i=0;i<k;i++)
    if (x[i]!=y[i])
      return 0;
  if (x.length>y.length) {
    for (;i<x.length;i++)
      if (x[i])
        return 0;
  } else {
    for (;i<y.length;i++)
      if (y[i])
        return 0;
  }
  return 1;
}

//is the bigInt x equal to zero?
function isZero(x) {
  var i;
  for (i=0;i<x.length;i++)
    if (x[i])
      return 0;
  return 1;
}

//convert a bigInt into a string in a given base, from base 2 up to base 95.
//Base -1 prints the contents of the array representing the number.
function bigInt2str(x,b) {
  var i,t,base,str,s="";
  if (typeof b === 'string') {
	  base = b.length;
	  str = b;
  } else {
	  base = b;
	  str = digitsStr;
  }

  if (s6.length!=x.length)
    s6=dup(x);
  else
    copy_(s6,x);

  if (base==-1) { //return the list of array contents
    for (i=x.length-1;i>0;i--)
      s+=x[i]+',';
    s+=x[0];
  }
  else { //return it in the given base
    while (!isZero(s6)) {
      t=divInt_(s6,base);  //t=s6 % base; s6=floor(s6/base);
      s=str.substring(t,t+1)+s;
    }
  }
  if (s.length==0)
    s=str[0];
  return s;
}

//returns a duplicate of bigInt x
function dup(x) {
  var i;
  buff=new Array(x.length);
  copy_(buff,x);
  return buff;
}

//do x=y on bigInts x and y.  x must be an array at least as big as y (not counting the leading zeros in y).
function copy_(x,y) {
  var i;
  var k=x.length<y.length ? x.length : y.length;
  for (i=0;i<k;i++)
    x[i]=y[i];
  for (i=k;i<x.length;i++)
    x[i]=0;
}

//do x=y on bigInt x and integer y.
function copyInt_(x,n) {
  var i,c;
  for (c=n,i=0;i<x.length;i++) {
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x+n where x is a bigInt and n is an integer.
//x must be large enough to hold the result.
function addInt_(x,n) {
  var i,k,c,b;
  x[0]+=n;
  k=x.length;
  c=0;
  for (i=0;i<k;i++) {
    c+=x[i];
    b=0;
    if (c<0) {
      b=-(c>>bpe);
      c+=b*radix;
    }
    x[i]=c & mask;
    c=(c>>bpe)-b;
    if (!c) return; //stop carrying as soon as the carry is zero
  }
}

//right shift bigInt x by n bits.  0 <= n < bpe.
function rightShift_(x,n) {
  var i;
  var k=Math.floor(n/bpe);
  if (k) {
    for (i=0;i<x.length-k;i++) //right shift x by k elements
      x[i]=x[i+k];
    for (;i<x.length;i++)
      x[i]=0;
    n%=bpe;
  }
  for (i=0;i<x.length-1;i++) {
    x[i]=mask & ((x[i+1]<<(bpe-n)) | (x[i]>>n));
  }
  x[i]>>=n;
}

//do x=floor(|x|/2)*sgn(x) for bigInt x in 2's complement
function halve_(x) {
  var i;
  for (i=0;i<x.length-1;i++) {
    x[i]=mask & ((x[i+1]<<(bpe-1)) | (x[i]>>1));
  }
  x[i]=(x[i]>>1) | (x[i] & (radix>>1));  //most significant bit stays the same
}

//left shift bigInt x by n bits.
function leftShift_(x,n) {
  var i;
  var k=Math.floor(n/bpe);
  if (k) {
    for (i=x.length; i>=k; i--) //left shift x by k elements
      x[i]=x[i-k];
    for (;i>=0;i--)
      x[i]=0;
    n%=bpe;
  }
  if (!n)
    return;
  for (i=x.length-1;i>0;i--) {
    x[i]=mask & ((x[i]<<n) | (x[i-1]>>(bpe-n)));
  }
  x[i]=mask & (x[i]<<n);
}

//do x=x*n where x is a bigInt and n is an integer.
//x must be large enough to hold the result.
function multInt_(x,n) {
  var i,k,c,b;
  if (!n)
    return;
  k=x.length;
  c=0;
  for (i=0;i<k;i++) {
    c+=x[i]*n;
    b=0;
    if (c<0) {
      b=-(c>>bpe);
      c+=b*radix;
    }
    x[i]=c & mask;
    c=(c>>bpe)-b;
  }
}

//do x=floor(x/n) for bigInt x and integer n, and return the remainder
function divInt_(x,n) {
  var i,r=0,s;
  for (i=x.length-1;i>=0;i--) {
    s=r*radix+x[i];
    x[i]=Math.floor(s/n);
    r=s%n;
  }
  return r;
}

//do the linear combination x=a*x+b*y for bigInts x and y, and integers a and b.
//x must be large enough to hold the answer.
function linComb_(x,y,a,b) {
  var i,c,k,kk;
  k=x.length<y.length ? x.length : y.length;
  kk=x.length;
  for (c=0,i=0;i<k;i++) {
    c+=a*x[i]+b*y[i];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;i<kk;i++) {
    c+=a*x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do the linear combination x=a*x+b*(y<<(ys*bpe)) for bigInts x and y, and integers a, b and ys.
//x must be large enough to hold the answer.
function linCombShift_(x,y,b,ys) {
  var i,c,k,kk;
  k=x.length<ys+y.length ? x.length : ys+y.length;
  kk=x.length;
  for (c=0,i=ys;i<k;i++) {
    c+=x[i]+b*y[i-ys];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<kk;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x+(y<<(ys*bpe)) for bigInts x and y, and integers a,b and ys.
//x must be large enough to hold the answer.
function addShift_(x,y,ys) {
  var i,c,k,kk;
  k=x.length<ys+y.length ? x.length : ys+y.length;
  kk=x.length;
  for (c=0,i=ys;i<k;i++) {
    c+=x[i]+y[i-ys];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<kk;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x-(y<<(ys*bpe)) for bigInts x and y, and integers a,b and ys.
//x must be large enough to hold the answer.
function subShift_(x,y,ys) {
  var i,c,k,kk;
  k=x.length<ys+y.length ? x.length : ys+y.length;
  kk=x.length;
  for (c=0,i=ys;i<k;i++) {
    c+=x[i]-y[i-ys];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<kk;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x-y for bigInts x and y.
//x must be large enough to hold the answer.
//negative answers will be 2s complement
function sub_(x,y) {
  var i,c,k,kk;
  k=x.length<y.length ? x.length : y.length;
  for (c=0,i=0;i<k;i++) {
    c+=x[i]-y[i];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<x.length;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x+y for bigInts x and y.
//x must be large enough to hold the answer.
function add_(x,y) {
  var i,c,k,kk;
  k=x.length<y.length ? x.length : y.length;
  for (c=0,i=0;i<k;i++) {
    c+=x[i]+y[i];
    x[i]=c & mask;
    c>>=bpe;
  }
  for (i=k;c && i<x.length;i++) {
    c+=x[i];
    x[i]=c & mask;
    c>>=bpe;
  }
}

//do x=x*y for bigInts x and y.  This is faster when y<x.
function mult_(x,y) {
  var i;
  if (ss.length!=2*x.length)
    ss=new Array(2*x.length);
  copyInt_(ss,0);
  for (i=0;i<y.length;i++)
    if (y[i])
      linCombShift_(ss,x,y[i],i);   //ss=1*ss+y[i]*(x<<(i*bpe))
  copy_(x,ss);
}

//do x=x mod n for bigInts x and n.
function mod_(x,n) {
  if (s4.length!=x.length)
    s4=dup(x);
  else
    copy_(s4,x);
  if (s5.length!=x.length)
    s5=dup(x);
  divide_(s4,n,s5,x);  //x = remainder of s4 / n
}

//do x=x*y mod n for bigInts x,y,n.
//for greater speed, let y<x.
function multMod_(x,y,n) {
  var i;
  if (s0.length!=2*x.length)
    s0=new Array(2*x.length);
  copyInt_(s0,0);
  for (i=0;i<y.length;i++)
    if (y[i])
      linCombShift_(s0,x,y[i],i);   //s0=1*s0+y[i]*(x<<(i*bpe))
  mod_(s0,n);
  copy_(x,s0);
}

//do x=x*x mod n for bigInts x,n.
function squareMod_(x,n) {
  var i,j,d,c,kx,kn,k;
  for (kx=x.length; kx>0 && !x[kx-1]; kx--);  //ignore leading zeros in x
  k=kx>n.length ? 2*kx : 2*n.length; //k=# elements in the product, which is twice the elements in the larger of x and n
  if (s0.length!=k)
    s0=new Array(k);
  copyInt_(s0,0);
  for (i=0;i<kx;i++) {
    c=s0[2*i]+x[i]*x[i];
    s0[2*i]=c & mask;
    c>>=bpe;
    for (j=i+1;j<kx;j++) {
      c=s0[i+j]+2*x[i]*x[j]+c;
      s0[i+j]=(c & mask);
      c>>=bpe;
    }
    s0[i+kx]=c;
  }
  mod_(s0,n);
  copy_(x,s0);
}

//return x with exactly k leading zero elements
function trim(x,k) {
  var i,y;
  for (i=x.length; i>0 && !x[i-1]; i--);
  y=new Array(i+k);
  copy_(y,x);
  return y;
}

//do x=x**y mod n, where x,y,n are bigInts and ** is exponentiation.  0**0=1.
//this is faster when n is odd.  x usually needs to have as many elements as n.
function powMod_(x,y,n) {
  var k1,k2,kn,np;
  if(s7.length!=n.length)
    s7=dup(n);

  //for even modulus, use a simple square-and-multiply algorithm,
  //rather than using the more complex Montgomery algorithm.
  if ((n[0]&1)==0) {
    copy_(s7,x);
    copyInt_(x,1);
    while(!equalsInt(y,0)) {
      if (y[0]&1)
        multMod_(x,s7,n);
      divInt_(y,2);
      squareMod_(s7,n);
    }
    return;
  }

  //calculate np from n for the Montgomery multiplications
  copyInt_(s7,0);
  for (kn=n.length;kn>0 && !n[kn-1];kn--);
  np=radix-inverseModInt(modInt(n,radix),radix);
  s7[kn]=1;
  multMod_(x ,s7,n);   // x = x * 2**(kn*bp) mod n

  if (s3.length!=x.length)
    s3=dup(x);
  else
    copy_(s3,x);

  for (k1=y.length-1;k1>0 & !y[k1]; k1--);  //k1=first nonzero element of y
  if (y[k1]==0) {  //anything to the 0th power is 1
    copyInt_(x,1);
    return;
  }
  for (k2=1<<(bpe-1);k2 && !(y[k1] & k2); k2>>=1);  //k2=position of first 1 bit in y[k1]
  for (;;) {
    if (!(k2>>=1)) {  //look at next bit of y
      k1--;
      if (k1<0) {
        mont_(x,one,n,np);
        return;
      }
      k2=1<<(bpe-1);
    }
    mont_(x,x,n,np);

    if (k2 & y[k1]) //if next bit is a 1
      mont_(x,s3,n,np);
  }
}


//do x=x*y*Ri mod n for bigInts x,y,n,
//  where Ri = 2**(-kn*bpe) mod n, and kn is the
//  number of elements in the n array, not
//  counting leading zeros.
//x array must have at least as many elemnts as the n array
//It's OK if x and y are the same variable.
//must have:
//  x,y < n
//  n is odd
//  np = -(n^(-1)) mod radix
function mont_(x,y,n,np) {
  var i,j,c,ui,t,ks;
  var kn=n.length;
  var ky=y.length;

  if (sa.length!=kn)
    sa=new Array(kn);

  copyInt_(sa,0);

  for (;kn>0 && n[kn-1]==0;kn--); //ignore leading zeros of n
  for (;ky>0 && y[ky-1]==0;ky--); //ignore leading zeros of y
  ks=sa.length-1; //sa will never have more than this many nonzero elements.

  //the following loop consumes 95% of the runtime for randTruePrime_() and powMod_() for large numbers
  for (i=0; i<kn; i++) {
    t=sa[0]+x[i]*y[0];
    ui=((t & mask) * np) & mask;  //the inner "& mask" was needed on Safari (but not MSIE) at one time
    c=(t+ui*n[0]) >> bpe;
    t=x[i];

    //do sa=(sa+x[i]*y+ui*n)/b   where b=2**bpe.  Loop is unrolled 5-fold for speed
    j=1;
    for (;j<ky-4;) { c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++; }
    for (;j<ky;)   { c+=sa[j]+ui*n[j]+t*y[j];   sa[j-1]=c & mask;   c>>=bpe;   j++; }
    for (;j<kn-4;) { c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++;
                     c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++; }
    for (;j<kn;)   { c+=sa[j]+ui*n[j];          sa[j-1]=c & mask;   c>>=bpe;   j++; }
    for (;j<ks;)   { c+=sa[j];                  sa[j-1]=c & mask;   c>>=bpe;   j++; }
    sa[j-1]=c & mask;
  }

  if (!greater(n,sa))
    sub_(sa,n);
  copy_(x,sa);
}

if (typeof module === 'undefined') {
	module = {};
}
BigInt = module.exports = {
	'add': add, 'addInt': addInt, 'bigInt2str': bigInt2str, 'bitSize': bitSize,
	'dup': dup, 'equals': equals, 'equalsInt': equalsInt, 'expand': expand,
	'findPrimes': findPrimes, 'GCD': GCD, 'greater': greater,
	'greaterShift': greaterShift, 'int2bigInt': int2bigInt,
	'inverseMod': inverseMod, 'inverseModInt': inverseModInt, 'isZero': isZero,
	'millerRabin': millerRabin, 'millerRabinInt': millerRabinInt, 'mod': mod,
	'modInt': modInt, 'mult': mult, 'multMod': multMod, 'negative': negative,
	'powMod': powMod, 'randBigInt': randBigInt, 'randTruePrime': randTruePrime,
	'randProbPrime': randProbPrime, 'str2bigInt': str2bigInt, 'sub': sub,
	'trim': trim, 'addInt_': addInt_, 'add_': add_, 'copy_': copy_,
	'copyInt_': copyInt_, 'GCD_': GCD_, 'inverseMod_': inverseMod_, 'mod_': mod_,
	'mult_': mult_, 'multMod_': multMod_, 'powMod_': powMod_,
	'randBigInt_': randBigInt_, 'randTruePrime_': randTruePrime_, 'sub_': sub_,
	'addShift_': addShift_, 'carry_': carry_, 'divide_': divide_,
	'divInt_': divInt_, 'eGCD_': eGCD_, 'halve_': halve_, 'leftShift_': leftShift_,
	'linComb_': linComb_, 'linCombShift_': linCombShift_, 'mont_': mont_,
	'multInt_': multInt_, 'rightShift_': rightShift_, 'squareMod_': squareMod_,
	'subShift_': subShift_, 'powMod_': powMod_, 'eGCD_': eGCD_,
	'inverseMod_': inverseMod_, 'GCD_': GCD_, 'mont_': mont_, 'divide_': divide_,
	'squareMod_': squareMod_, 'randTruePrime_': randTruePrime_,
	'millerRabin': millerRabin
};

})();

},{}],50:[function(require,module,exports){
module.exports=require(6)
},{"/Users/chat-wane/Desktop/project/jquery-crate/lib/model/guid.js":6}],51:[function(require,module,exports){
var SortedArray = require('sorted-cmp-array');

/*!
 * \brief array containing the list of sockets targeting this peer
 */
function InView(){
    this.sockets = new SortedArray(function(a,b){
        var first = a.id || a;
        var second = b.id || b;
        if (first < second) { return -1};
        if (first > second) { return  1};
        return 0;
    });
};

/*!
 * \brief add an element to the inview
 * \param socket the socket to add in the inview
 * \param id a unique identifier of the socket
 */
InView.prototype.add = function(socket, id){
    this.sockets.insert({id:id, socket:socket});
};

/*!
 * \brief remove the targeted socket from the inview
 * \param id the identifier of the inview
 * \return the socket removed from the inview, null if not found
 */
InView.prototype.remove = function(id){
    var index = this.sockets.indexOf(id),
        socket = null;
    if (index >= 0){
        socket = this.sockets.arr[index];
        this.sockets.arr.splice(index, 1);
    };
    return socket;
};

/*!
 * \brief get the length of the array
 */
InView.prototype.length = function(){
    return this.sockets.arr.length;
};

/*!
 * \brief clear the whole inview and close the sockets
 */
InView.prototype.clear = function(){
    for (var i = 0; i < this.sockets.arr.length; ++i){
        this.sockets.arr[i].socket.destroy();
    };
    this.sockets.arr.splice(0, this.sockets.arr.length);
};

module.exports = InView;

},{"sorted-cmp-array":66}],52:[function(require,module,exports){
/*!
 * MJoin(id)
 * MRequestTicket(id)
 * MOfferTicket(id, ticket, peer)
 * MStampedTicket(id, ticket, peer)
 * MExchange(id, peer)
 */

/*!
 * \brief message requesting to join the network
 * \param id the identifier of the join message
 */
function MJoin(id){
    this.protocol = 'spray';
    this.type = 'MJoin';
    this.id = id;
};
module.exports.MJoin = MJoin;

/*!
 * \brief message requesting an offer ticket
 * \param id the identifier of the request message
 */
function MRequestTicket(id){
    this.protocol = 'spray';
    this.type = 'MRequestTicket';
    this.id = id;
};
module.exports.MRequestTicket = MRequestTicket;

/*!
 * \brief an offer ticket containing the first part of the webrtc connection
 * establishment
 * \param id the unique identifier of the request message
 * \param ticket the first step of the connection establishement data
 * \param peer the peer that emit the offer ticket
 */
function MOfferTicket(id, ticket, peer){
    this.protocol = 'spray';
    this.type = 'MOfferTicket';
    this.id = id;
    this.ticket = ticket;
    this.peer = peer;
};
module.exports.MOfferTicket = MOfferTicket;

/*!
 * \brief an stamped ticket containing the second part of the webrtc connection
 * establishement
 * \param id the unique identifier of the request ticket
 * \param ticket the second step of the connection establishement data
 * \param peer the peer that emit the stamped ticket
 */
function MStampedTicket(id, ticket, peer){
    this.protocol = 'spray';
    this.type = 'MStampedTicket';
    this.id = id;
    this.ticket = ticket;
    this.peer = peer;
};
module.exports.MStampedTicket = MStampedTicket;

/*!
 * \brief message requesting an exchange of neighborhood
 * \param id the identifier of the request message
 * \param peer the identity of the initiator of the exchange
 */
function MExchange(id, peer){
    this.protocol = 'spray';
    this.type = 'MExchange';
    this.id = id;
    this.peer = peer;
};
module.exports.MExchange = MExchange;

},{}],53:[function(require,module,exports){
var SortedArray = require("sorted-cmp-array");

/*!
 * \brief comparator
 * \param a the first object including an 'age' property
 * \param b the second object including an 'age' property
 * \return 1 if a.age > b.age, -1 if a.age < b.age, 0 otherwise
 */
function comp(a, b){
    if (a.age < b.age){ return -1;};
    if (a.age > b.age){ return  1;};
    return 0;
};

/*!
 * \brief structure containing the neighborhood of a peer.
 */
function PartialView(){
    // #1 initialize the partial view as an array sorted by age
    this.array = new SortedArray(comp);
};

/*!
 * \return the oldest peer in the array
 */
PartialView.prototype.getOldest = function(){
    return this.array.arr[0];
};

/*!
 * \brief increment the age of the whole partial view
 */
PartialView.prototype.incrementAge = function(){
    for (var i=0; i<this.array.arr.length; ++i){
        this.array.arr[i].age += 1;
    };
};

/*!
 * \brief get a sample of the partial to send to the neighbor
 * \param neighbor the neighbor which performs the exchange with us
 * \param isInitiator whether or not the caller is the initiator of the
 * exchange
 * \return an array containing neighbors from this partial view
 */
PartialView.prototype.getSample = function(neighbor, isInitiator){
    var sample = [];
    // #1 copy the partial view
    var clone = new SortedArray(comp);
    for (var i = 0; i < this.array.arr.length; ++i){
        clone.arr.push(this.array.arr[i]);
    };

    // #2 process the size of the sample
    var sampleSize = Math.ceil(this.array.arr.length/2);
    
    if (isInitiator){
        // #A remove an occurrence of the chosen neighbor
        var index = clone.indexOf(neighbor);
        sample.push(clone.arr[index]); 
        clone.arr.splice(index, 1);
    };
    
    // #3 randomly add neighbors to the sample
    while (sample.length < sampleSize){
        var rn = Math.floor(Math.random()*clone.arr.length);
        sample.push(clone.arr[rn]);
        clone.arr.splice(rn, 1);
    };
    
    return sample;
};



/*!
 * \brief replace the occurrences of the old peer by the fresh one
 * \param sample the sample to modify
 * \param old the old reference to replace
 * \param fresh the new reference to insert
 * \return an array with the replaced occurences
 */
PartialView.prototype.replace = function(sample, old, fresh){
    var result = [];
    for (var i = 0; i < sample.length; ++i){
        if (sample[i].id === old.id){
            result.push(fresh);
        } else {
            result.push(sample[i]);
        };
    };
    return result;
};

/*!
 * \brief add the neigbhor to the partial view with an age of 0
 * \param peer the peer to add to the partial view
 */
PartialView.prototype.addNeighbor = function(peer){
    peer.age = 0;
    this.array.arr.push(peer);
};


/*!
 * \brief get the index of the peer in the partialview
 * \return the index of the peer in the array, -1 if not found
 */
PartialView.prototype.getIndex = function(peer){
    var i = 0,
        index = -1;
        found = false;
    while (!found && i < this.array.arr.length){
        if (peer.id === this.array.arr[i].id){
            found = true;
            index = i;
        };
        ++i;
    };
    return index;
};

/*!
 * \brief remove the peer from the partial view
 * \param peer the peer to remove
 * \return the removed entry if it exists, null otherwise
 */
PartialView.prototype.removePeer = function(peer){
    var index = this.getIndex(peer),
        removedEntry = null;
    if (index > -1){
        removedEntry = this.array.arr[index];
        this.array.arr.splice(index, 1);
    };
    return removedEntry;
};

/*!
 * \brief remove the peer with the associated age from the partial view
 * \param peer the peer to remove
 * \param age the age of the peer to remove
 * \return the removed entry if it exists, null otherwise
 */
PartialView.prototype.removePeerAge = function(peer, age){
    var found = false,
        i = 0,
        removedEntry = null;
    while(!found && i < this.array.arr.length){
        if (peer.id === this.array.arr[i].id && age === this.array.arr[i].age){
            found = true;
            removedEntry = this.array.arr[i];
            this.array.arr.splice(i, 1);
        };
        ++i;
    };
    return removedEntry;
};

/*!
 * \brief remove all occurrences of the peer and return the number of removals
 * \param peer the peer to remove
 * \return the number of occurrences of the removed peer
 */
PartialView.prototype.removeAll = function(peer){
    var occ = 0,
        i = 0;
    while (i < this.array.arr.length){
        if (this.array.arr[i].id === peer.id){
            this.array.arr.splice(i, 1);
            occ += 1;
        } else {
            ++i;
        };
    };
    return occ;
};

/*!
 * \brief remove all the elements contained in the sample in argument
 * \param sample the elements to remove
 */
PartialView.prototype.removeSample = function(sample){
    for (var i = 0; i < sample.length; ++i){
        this.removePeerAge(sample[i], sample[i].age);
    };
};

/*!
 * \brief get the size of the partial view
 * \return the size of the partial view
 */
PartialView.prototype.length = function(){
    return this.array.arr.length;
};

/*!
 * \brief check if the partial view contains the reference
 * \param peer the peer to check
 * \return true if the peer is in the partial view, false otherwise
 */
PartialView.prototype.contains = function(peer){
    return this.getIndex(peer)>=0;
};

/*!
 * \brief remove all elements from the partial view
 */
PartialView.prototype.clear = function(){
    this.array.arr.splice(0, this.array.arr.length);
};

module.exports = PartialView;

},{"sorted-cmp-array":66}],54:[function(require,module,exports){
var SortedArray = require("sorted-cmp-array");

/*!
 * \brief represent the array containing the sockets associated with
 * a unique identifier id
 */
function Sockets(){
    this.array = new SortedArray(
        function(a, b){
            if (a.id < b.id){ return -1; };
            if (a.id > b.id){ return  1; };
            return 0;
        }
    );
    this.lastChance = null; // last chance socket.
};

/*!
 * \brief add the socket with an object containing an identifier 
 * \param socket the socket to communicate with peer
 * \param object the object containing the identifier
 * \return true if the socket as been added, false otherwise
 */ 
Sockets.prototype.addSocket = function(socket, object){
    var contains = this.contains(object);
    if (!contains){
        this.array.insert({id:object.id, socket:socket});
    };
    return !contains;
};

/*!
 * \brief remove the object and its associated socket from the array
 * \param object the object containing the identifier to remove
 * \return the socket targeted by the removal, null if it does not exist
 */
Sockets.prototype.removeSocket = function(object){
    var socket = this.getSocket(object);
    if (socket !== null){
        this.array.remove(object);
        this.lastChance = socket;
    };
    return socket;
};

/*!
 * \brief get the socket attached to the object identity
 * \param object the object containing the identifier to search
 * \return the socket if the object exists, null otherwise
 */
Sockets.prototype.getSocket = function(object){
    var index = this.array.indexOf(object),
        socket = null;
    if (index !== -1){
        socket = this.array.arr[index].socket;
    };
    return socket;
};

/*!
 * \brief check if there is a socket associated to the object
 * \param object the object containing the identifier to check
 * \return true if a socket associated to the object exists, false otherwise
 */
Sockets.prototype.contains = function(object){
    return (this.array.indexOf(object) !== -1);
};

/*!
 * \brief get the length of the underlying array
 * \return the length of the array
 */
Sockets.prototype.length = function(){
    return this.array.arr.length;
};

/*!
 * \brief remove all the sockets from this register, and close them
 */
Sockets.prototype.clear = function(){
    for (var i=0; i<this.array.arr.length; ++i){
        this.array.arr[i].socket.destroy();        
    };
    this.array.arr.splice(0, this.array.arr.length);
};

module.exports = Sockets;

},{"sorted-cmp-array":66}],55:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var Socket = require('simple-peer');
var util = require('util');

var PartialView = require('./partialview.js');
var InView = require('./inview.js');
var Sockets = require('./sockets.js');
var GUID = require('./guid.js');

var Messages = require('./messages.js');
var MJoin = Messages.MJoin;
var MRequestTicket = Messages.MRequestTicket;
var MOfferTicket = Messages.MOfferTicket;
var MStampedTicket = Messages.MStampedTicket;
var MExchange = Messages.MExchange;

util.inherits(Spray, EventEmitter);

/*!
 * \brief Implementation of the random peer sampling called Spray on top of
 * socket.io
 * \param id the unique identifier of our peer
 * \param options the WebRTC options, for more informations: 
 * \url https://github.com/feross/simple-peer
 */
function Spray(id, options){
    EventEmitter.call(this);
    // #A constants
    this.DELTATIME = (options && options.deltatime) || 1000 * 60 * 2; // 2min
    this.TIMEOUT = (options && options.timeout) || 1000 * 60 * 1; // 1min
    this.ID = (id && ''+id+'') || GUID();
    this.OPTIONS = options || {};
    
    // #B protocol variables
    this.partialView = new PartialView();
    this.inView = new InView();
    
    this.sockets = new Sockets();
    this.pending = new Sockets();
    this.forwards = new Sockets();
    this.state = 'disconnect';
    
    // #C webrtc specifics
    var self = this;
    setInterval(function(){
        if (self.partialView.length()>0){
            self.exchange();
        };
    }, this.DELTATIME);

    // #D events
    this.on('spray-receive', function(socket, message){
        self.onSprayReceive(socket, message);
    });
};

/*!
 * \brief check if the network is ready and callback, nothing otherwise
 * \param callback the function to call if the network is ready
 */
Spray.prototype.ready = function(callback){
    if (this.partialView.length() > 0){ callback(); };
};

/*!
 * \brief get a set of neighbors. (TODO) include the sockets from the inView
 * \param k the number of neighbors requested
 * \return a list of sockets
 */
Spray.prototype.getPeers = function(k){
    var result = [];
    // #A copy the sockets of the partial view
    var cloneSockets = [];
    for (var i = 0; i < this.sockets.length(); ++i){
        cloneSockets[i] = this.sockets.array.arr[i];
    };
    // #B get as much neighbors as possible
    while (0 < cloneSockets.length && result.length < k){
        var rn = Math.floor(Math.random()*cloneSockets.length);
        result.push(cloneSockets[rn].socket);
        cloneSockets.splice(rn, 1);
    };
    // #C last chance socket
    if (k>0 && result.length===0 && this.sockets.lastChance!==null){
        result.push(this.sockets.lastChance);
    };
    return result;
};

/*!
 * \brief update the local connection state of the peer and emit an event
 * if the state is different than at the previous call of this function.
 * The emitted event is 'statechange' with the 
 * arguments 'connect' | 'partial' | 'disconnect'
 */
Spray.prototype.updateState = function(){
    if (this.partialView.length() > 0 && this.state !== 'connect'){
        this.state = 'connect';
        this.emit('statechange', 'connect');
    } else if ((this.partialView.length() === 0 && this.inView.length() > 0 ||
                this.partialView.length() > 0 && this.inView.length() === 0 ) &&
               this.state !== 'partial'){
        this.state = 'partial';
        this.emit('statechange', 'partial');
    } else if (this.partialView.length() === 0 && this.pending.length() === 0 &&
               this.state !== 'disconnect'){
        this.state = 'disconnect';
        this.emit('statechange', 'disconnect');
    };
};

/*!
 * \brief leave the network by closing the inview and partialview
 */
Spray.prototype.leave = function(){
    this.partialView.clear();
    this.inView.clear();
    
    this.sockets.clear();
    this.pending.clear();
    this.forwards.clear();
};

/*******************************************************************************
 * Bootstrap the first WebRTC connection
 ******************************************************************************/

/*!
 * \brief the very first part of a connection establishment to join the network.
 * This part corresponds to the first part of the 'onStampedTicketRequest' of
 * the spray protocol.
 * \param callback a callback function taking a 'message' in argument and
 * called when we receive the data from the stun server
 */
Spray.prototype.launch = function(callback){
    var options=this.OPTIONS; options.initiator=true; options.trickle=false;
    var socket = new Socket(options),
        id = GUID(),
        self = this;
    socket.on('signal', function(data){
        var message = new MOfferTicket(id, data, {id: self.ID});
        self.pending.addSocket(socket, message);
        callback(message);
    });
    setTimeout(function(){
        if (self.pending.contains({id:id})){
            self.pending.removeSocket({id:id});
            socket.destroy();
        };
    }, this.TIMEOUT);
};

/*!
 * \brief the second part of the connection establishment. This function is
 * called at the peer already inside the network. It corresponds to the function
 * 'onTicketRequest' of the Spray protocol
 * \param message the message generated by the launch function at the joining
 * peer
 * \param callback the function called when we receive the stamped ticket from
 * the stun server. It has a 'message' argument.
 */
Spray.prototype.answer = function(message, callback){
    var options=this.OPTIONS; options.initiator=false; options.trickle=false;
    var socket = new Socket(options),
        id = message.id,
        ticket = message.ticket,
        peer = message.peer,
        self = this;
    socket.on('signal', function(data){
        var stampedTicket = new MStampedTicket(id, data, {id:self.ID});
        self.pending.addSocket(socket, stampedTicket);
        callback(stampedTicket);
    });
    socket.on('connect', function(){
        console.log('wrtc: successful connection establishment');
        self.pending.removeSocket(message);
        self.inView.add(socket, id);
        self.updateState();
    });
    socket.on('data', function(receivedMessage){
        self.receive(socket, receivedMessage);
    });
    socket.on('stream', function(stream){
        self.emit('stream', socket, stream);
    });
    socket.on('close', function(){
        console.log('wrtc: a connection has been closed');
        self.inView.remove(id);
        self.updateState();
    });
    socket.signal(ticket);
    setTimeout(function(){
        if (self.pending.contains({id:id})){
            var socket = self.pending.removeSocket({id:id});
            socket.destroy();
        };
    }, this.TIMEOUT);
};

/*!
 * \brief the third part of the very first connection establishment to join the
 * network. It corresponds to the last part of the function of
 * 'onStampedTicketRequest' of the Spray protocol.
 * \param message the message containing the stamped ticket from the contact
 * peer
 */
Spray.prototype.handshake = function(message){
    var socket = this.pending.removeSocket(message),
        id = message.id,
        ticket = message.ticket,
        peer = message.peer,
        self = this;
    socket.on('connect', function(){
        console.log('wrtc: successful connection establishment');
        self.partialView.addNeighbor(peer);
        self.sockets.addSocket(socket, peer);
        self.join(peer);
        self.updateState();
    });
    socket.on('data', function(receivedMessage){
        self.receive(socket, receivedMessage);
    });
    socket.on('stream', function(stream){
        self.emit('stream', socket, stream);
    });
    socket.on('close', function(){
        console.log('wrtc: a connection has been closed');
        self.updateState();
    });
    socket.signal(ticket);
};


/*******************************************************************************
 * Spray's protocol implementation
 ******************************************************************************/

/*!
 * \brief join the network using the kwnon contact peer 
 * \param contact the known peer that will introduce us to the network
 */
Spray.prototype.join = function(contact){
    // #A ask to the contact peer to advertise your presence in the network
    var message = new MJoin(GUID());
    this.send(message, contact);
};

/*!
 * \brief event executer when "this" receives a join message
 * \param id the identifier of the request
 */
Spray.prototype.onJoin = function(id){
    // #A if it is the very first connection, establish a connection from
    // us to the newcomer
    if (this.partialView.length()===0){
        var mRequestTicket = new MRequestTicket(GUID());
        this.send(mRequestTicket, {id:id});
    } else {
        // #B if there is an already established network, we request that
        // the newcomer sends us an offer ticket for each of our neighbors
        for (var i = 0; i < this.partialView.length(); ++i){
            // #1 create the ticket with an original identifier
            var mRequestTicket = new MRequestTicket(GUID());
            // #2 register the forwarding route for the answers
            this.forwards.addSocket(
                this.sockets.getSocket(this.partialView.array.arr[i]),
                mRequestTicket);
            // #3 send the request to the new comer
            this.send(mRequestTicket, {id:id});
        };
    };
};

/*!
 * \brief periodically called function that aims to balance the partial view
 * and to mix the neighbors inside them
 */
Spray.prototype.exchange = function(){
    var self = this;
    var socketOldest = null;
    // #1 get the oldest neighbor reachable
    while ((socketOldest===null) ||
           (socketOldest!==null && !socketOldest.connected) &&
           this.partialView.length()>0){
        var oldest = this.partialView.getOldest();
        socketOldest = this.sockets.getSocket(oldest);
        if (socketOldest===null ||
            (socketOldest!==null && !socketOldest.connected)) {
            this.onPeerDown(oldest);
        };
    };
    if (this.partialView.length()===0){return;}; // ugly return
    // #2 notify the oldest neighbor that it is the chosen one
    var mExchange = new MExchange(GUID(), {id:this.ID});
    this.send(mExchange, oldest);
    // #3 get a sample from our partial view
    var sample = this.partialView.getSample(oldest, true);
    // #4 ask to the neighbors in the sample to create the offer tickets in
    // order to forward them to the oldest neighbor
    for (var i = 0; i < sample.length; ++i){
        if (sample[i].id !== oldest.id){
            // #5 if the neighbor is not the oldest neighbor
            // #5A register the forwarding destination
            var message = new MRequestTicket(GUID());
            this.forwards.addSocket(this.sockets.getSocket(oldest),message);
            // #5B send a ticket request to the neighbor in the sample
            this.send(message, sample[i]);
        } else {
            // #6 otherwise, create an offer ticket ourself and send it to the
            // oldest neigbhor
            var idTicket = GUID();
            this.forwards.addSocket(this.sockets.getSocket(oldest),
                                    {id:idTicket});
            this.onTicketRequest(idTicket);
        };
    };
    // #7 remove the sent sample from our partial view
    this.partialView.removeSample(sample);
    // #8 remove from the sockets dictionnary
    for (var i = 0; i < sample.length; ++i){
        // #8A check if the partial view still contains references to the socket
        if (!this.partialView.contains(sample[i])){
            // #8B otherwise remove the socket from the dictionnary
            var socket = this.sockets.removeSocket(sample[i]);
            // #8C close the socket after a while
            if (socket!==null){
                setTimeout(function(s){
                    s.destroy();
                }, this.TIMEOUT, socket);
            };
        };
    };    
};

/*!
 * \brief event executed when we receive an exchange request
 * \param id the identifier of the request message
 * \param initiator the peer that requested the exchange
 */
Spray.prototype.onExchange = function(id, initiator){
    // #1 get a sample of neighbors from our partial view
    var sample = this.partialView.getSample(initiator, false);
    // #2 ask to each neighbor in the sample to create an offer ticket to
    // give to the initiator peer
    for (var i = 0; i < sample.length; ++i){
        if (sample[i].id !== initiator.id){
            // #2A if the neigbhor is not the initiator, request an offer ticket
            // from it
            var message = new MRequestTicket(GUID());
            // #2B register the forwarding route
            this.forwards.addSocket(this.forwards.getSocket({id:id}), message);
            // #2C send the ticket request to the neigbhor
            this.send(message, sample[i]);
        } else {
            // #3A if the neigbhor is the initiator, create an offer ticket
            // ourself            
            var idTicket = GUID();
            // #3B register the forwarding route for our own offer ticket
            this.forwards.addSocket(this.forwards.getSocket({id:id}),
                                    {id:idTicket});
            // #3C create the offer ticket and send it
            this.onTicketRequest(idTicket);
        };
    };
    // #4 remove the sample from our partial view
    this.partialView.removeSample(sample);
    // #5 remove the sample from the sockets dictionnary
    for (var i = 0; i < sample.length; ++i){
        // #5A check if the partial view still contains references to the socket
        if (!this.partialView.contains(sample[i])){
            // #5B otherwise remove the socket from the dictionnary
            var socket = this.sockets.removeSocket(sample[i])
            // #5C close the socket after a while
            if (socket!==null){
                setTimeout(function(s){
                    s.destroy();
                }, this.TIMEOUT, socket);
            };
        };
    };
};

/*!
 * \brief the function called when a neighbor is unreachable and supposedly
 * crashed/departed. It probabilistically keeps an arc up
 * \param peer the peer that cannot be reached
 */
Spray.prototype.onPeerDown = function(peer){
    console.log('wrtc: a neighbor crashed/left');
    // #A remove all occurrences of the peer in the partial view
    var occ = this.partialView.removeAll(peer);
    this.sockets.removeSocket(peer);
    // #B probabilistically recreate an arc to a known peer
    if (this.partialView.length() > 0){
        for (var i = 0; i < occ; ++i){
            if (Math.random() > (1/(this.partialView.length()+occ))){
                var rn = Math.floor(Math.random()*this.partialView.length());
                this.partialView.addNeighbor(this.partialView.array.arr[rn]);
                console.log('wrtc: create a duplicate');
            };
        };
    };
    this.updateState();
};

/*!
 * \brief a connection failed to establish properly, systematically duplicates
 * an element of the partial view.
 */
Spray.prototype.onArcDown = function(){
    console.log('wrtc: an arc did not properly established');
    if (this.partialView.length()>0){
        var rn = Math.floor(Math.random()*this.partialView.length());
        this.partialView.addNeighbor(this.partialView.array.arr[rn]);
    };
    this.updateState();
};

/*!
 * \brief WebRTC specific event. A neighbor wants us to connect to another peer.
 * To do so, the former requests an offer ticket it can exchange with one of
 * its neighbor.
 * \param peer the identifier of the request message
 */
Spray.prototype.onTicketRequest = function(id){
    var options=this.OPTIONS; options.initiator=true; options.trickle=false;
    var socket = new Socket(options),
        self = this;
    // #1 get the offer ticket from the stun service    
    socket.on('signal', function(data){
        // #A register this socket in pending sockets dictionnary
        var message = new MOfferTicket(id, data, {id: self.ID});
        self.pending.addSocket(socket, message);
        // #B send the offer ticket to the requester along with our identifier
        self.send(message, message);
        // #C remove the forwarding route 
        self.forwards.removeSocket(message);
    });
    // #2 successful connection establishment
    socket.on('connect', function(){
        console.log('wrtc: successful connection establishment');
        // #A remove from the pending sockets dictionnary
        self.pending.removeSocket({id:id});
        self.inView.add(socket, id);
        self.updateState();
    });
    // #3 closed connection
    socket.on('close', function(){
        console.log('wrtc: a connection has been closed');
        self.inView.remove(id);
        self.updateState();
    });
    // #4 receive a message
    socket.on('data', function(message){
        self.receive(socket, message);
    });
    socket.on('stream', function(stream){
        self.emit('stream', socket, stream);
    });
    
    // #5 timeout on connection establishment
    setTimeout(function(){
        // #A check if it the connection established, otherwise, clean socket
        if (self.pending.contains({id:id})){
            self.pending.removeSocket({id:id});
            socket.destroy();
        };
    }, this.TIMEOUT);
};

/*!
 * \brief WebRTC specific event. A neighbor sent a ticket to stamp. We must
 * stamp it back to establish a connection.
 * \param id the identifier of the message carrying the offer ticket
 * \param ticket the offer ticket to stamp
 * \param peer the emitting peer containing its identifier
 */
Spray.prototype.onStampedTicketRequest = function(id, ticket, peer){
    var self = this;
    // #1 if the partial view already contains this neigbhor, duplicate the
    // entry and stop the processus
    if (this.partialView.contains(peer)){
        console.log("wrtc: create a duplicate");
        this.partialView.addNeighbor(peer);
        // #2 send an empty stamped ticket to close the pending and forwardings
        var message = new MStampedTicket(id, null, {id:self.ID});
        self.send(message, message);
        self.forwards.removeSocket({id:id});
        return; // do nothing else. Ugly return
    };
    // #2 otherwise creates an answer
    var options=this.OPTIONS; options.initiator=false; options.trickle=false;
    var socket = new Socket(options);
    // #3 get the stamped ticket from the stun service
    socket.on('signal', function(data){
        // #A create the message containing the stamped ticket
        var message = new MStampedTicket(id, data, {id:self.ID});
        // #B send it back from where it arrives
        self.send(message, message);
        // #C remove the forwarding route
        self.forwards.removeSocket(message);
    });
    // #4 successful connection establishment
    socket.on('connect', function(){
        console.log('wrtc: successful connection establishment');
        // #A remove from pending
        self.pending.removeSocket({id:id});        
        // #B add the neigbhor to our partial view
        self.partialView.addNeighbor(peer);
        // #C add the neigbhor to the socket dictionnary, if it does not exist
        if (!self.sockets.addSocket(socket, peer)){
            socket.destroy();
        };
        self.updateState();
    });
    // #5 closed connection
    socket.on('close', function(){
        console.log('wrtc: a connection has been closed');
        self.updateState();
    });
    // #6 receive a message
    socket.on('data', function(message){
        self.receive(socket, message);
    });
    socket.on('stream', function(stream){
        self.emit('stream', socket, stream);
    });
    // #7 signal the offer ticket to the fresh socket
    socket.signal(ticket);
    this.pending.addSocket(socket, {id:id});
    // #8 a timeout on connection establishment
    setTimeout(function(){
        if (self.pending.contains({id:id})){
            // #A if the connection is not successful, remove the socket and
            // create a duplicate
            self.pending.removeSocket({id:id});
            socket.destroy();
            self.onArcDown();
        };
    }, this.TIMEOUT);
};

/*!
 * \brief send a message to a particular peer. If no peer are passed in
 * arguments, it will try to forwards it the appropriate peer.
 * \param message the message to send
 * \param object the object containing the id to send the message
 * \param return true if the message as been sent, false otherwise
 */
Spray.prototype.send = function(message, object){
    var sent = false;
    var id = (object && object.id) || message.id;
    var socket = this.sockets.getSocket({id:id});
    if (socket !== null){
        if (socket.connected &&
            socket._channel && socket._channel.readyState === 'open'){
            socket.send(message);
            sent = true;
        } else {
            this.onPeerDown({id:id});            
        };
    } else {
        socket = this.forwards.getSocket({id:id});
        if (socket !== null && socket.connected &&
            socket._channel && socket._channel.readyState === 'open'){
            socket.send(message);
            sent = true;
        };
    };
    return sent;
};

/*!
 * \brief receive a membership message and process it accordingly
 * \param socket the socket from which we receive the message
 * \param message the received message
 */
Spray.prototype.receive = function(socket, message){
    if (message && message.protocol){
        this.emit(message.protocol+'-receive', socket, message);
    };
};

Spray.prototype.onSprayReceive = function(socket, message){
    switch (message.type){
    case 'MJoin':
        console.log('wrtc: a new member joins the network');
        var self = this;
        setTimeout(function(){
            self.forwards.addSocket(socket, message);
            self.onJoin(message.id);
            self.forwards.removeSocket(message);
        }, 1000); // make sure that the socket is undoubtedly opened
        break;
    case 'MRequestTicket':
        console.log('wrtc: a member request an offer ticket');
        this.forwards.addSocket(socket, message);
        this.onTicketRequest(message.id);
        break;
    case 'MOfferTicket':
        console.log('wrtc: you received an offer ticket');
        if (!this.forwards.contains(message)){
            // #1 if there is no forwarding route, the offer ticket is for us to
            // stamp
            this.forwards.addSocket(socket, message);
            this.onStampedTicketRequest(message.id,message.ticket,message.peer);
        } else {
            // #2A otherwise, we forward the offer ticket accordingly
            if (this.send(message, message)){
                // #2B invert the direction of forwarding route in order to
                // consistently redirect the stamped ticket
                this.forwards.removeSocket(message);
                this.forwards.addSocket(socket, message);
            } else {
                // #2C if the message has not been sent, simply remove the route
                this.forwards.removeSocket(message);
            };
        };
        break;
    case 'MStampedTicket':
        console.log('wrtc: you received a stamped ticket');
        if (!this.forwards.contains(message)){
            // #1 if there is no forwarding route, the message is for us to
            // finalize
            if (message.ticket === null){
                // #1A empty ticket meaning the remote peer already knows us,
                // therefore, simply close the pending offer
                var socket = this.pending.removeSocket(message);
                socket.destroy();
            } else {
                // #1B otherwise, finalize the connection
                this.pending.getSocket(message).signal(message.ticket);
            };
        } else {
            // #2A otherwise, we forward the stamped ticket accordingly
            this.send(message, message);
            // #2B remove the direction from the known forwarding routes
            this.forwards.removeSocket(message);
        };
        break;
    case 'MExchange':
        console.log('wrtc: a peer starts to exchange with you');
        this.forwards.addSocket(socket, message);
        this.onExchange(message.id, message.peer);
        this.forwards.removeSocket(message);
        break;
    };
};

module.exports = Spray;

},{"./guid.js":50,"./inview.js":51,"./messages.js":52,"./partialview.js":53,"./sockets.js":54,"events":88,"simple-peer":56,"util":133}],56:[function(require,module,exports){
(function (Buffer){
/* global Blob */

module.exports = Peer

var debug = require('debug')('simple-peer')
var hat = require('hat')
var inherits = require('inherits')
var isTypedArray = require('is-typedarray')
var once = require('once')
var stream = require('stream')
var toBuffer = require('typedarray-to-buffer')

inherits(Peer, stream.Duplex)

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer (opts) {
  var self = this
  if (!(self instanceof Peer)) return new Peer(opts)
  self._debug('new peer %o', opts)

  if (!opts) opts = {}
  opts.allowHalfOpen = false
  if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024

  stream.Duplex.call(self, opts)

  self.initiator = opts.initiator || false
  self.channelConfig = opts.channelConfig || Peer.channelConfig
  self.channelName = opts.channelName || hat(160)
  if (!opts.initiator) self.channelName = null
  self.config = opts.config || Peer.config
  self.constraints = opts.constraints || Peer.constraints
  self.reconnectTimer = opts.reconnectTimer || 0
  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
  self.stream = opts.stream || false
  self.trickle = opts.trickle !== undefined ? opts.trickle : true

  self.destroyed = false
  self.connected = false

  // so Peer object always has same shape (V8 optimization)
  self.remoteAddress = undefined
  self.remoteFamily = undefined
  self.remotePort = undefined
  self.localAddress = undefined
  self.localPort = undefined

  self._wrtc = opts.wrtc || getBrowserRTC()
  if (!self._wrtc) {
    if (typeof window === 'undefined') {
      throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment')
    } else {
      throw new Error('No WebRTC support: Not a supported browser')
    }
  }

  self._maxBufferedAmount = opts.highWaterMark
  self._pcReady = false
  self._channelReady = false
  self._iceComplete = false // ice candidate trickle done (got null candidate)
  self._channel = null

  self._chunk = null
  self._cb = null
  self._interval = null
  self._reconnectTimeout = null

  self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)
  self._pc.oniceconnectionstatechange = self._onIceConnectionStateChange.bind(self)
  self._pc.onsignalingstatechange = self._onSignalingStateChange.bind(self)
  self._pc.onicecandidate = self._onIceCandidate.bind(self)

  if (self.stream) self._pc.addStream(self.stream)
  self._pc.onaddstream = self._onAddStream.bind(self)

  if (self.initiator) {
    self._setupData({ channel: self._pc.createDataChannel(self.channelName, self.channelConfig) })
    self._pc.onnegotiationneeded = once(self._createOffer.bind(self))
    // Only Chrome triggers "negotiationneeded"; this is a workaround for other
    // implementations
    if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {
      self._pc.onnegotiationneeded()
    }
  } else {
    self._pc.ondatachannel = self._setupData.bind(self)
  }

  self.on('finish', function () {
    if (self.connected) {
      // When local peer is finished writing, close connection to remote peer.
      // Half open connections are currently not supported.
      // Wait a bit before destroying so the datachannel flushes.
      // TODO: is there a more reliable way to accomplish this?
      setTimeout(function () {
        self._destroy()
      }, 100)
    } else {
      // If data channel is not connected when local peer is finished writing, wait until
      // data is flushed to network at "connect" event.
      // TODO: is there a more reliable way to accomplish this?
      self.once('connect', function () {
        setTimeout(function () {
          self._destroy()
        }, 100)
      })
    }
  })
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose config, constraints, and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      url: 'stun:23.21.150.121', // deprecated, replaced by `urls`
      urls: 'stun:23.21.150.121'
    }
  ]
}
Peer.constraints = {}
Peer.channelConfig = {}

Object.defineProperty(Peer.prototype, 'bufferSize', {
  get: function () {
    var self = this
    return (self._channel && self._channel.bufferedAmount) || 0
  }
})

Peer.prototype.address = function () {
  var self = this
  return { port: self.localPort, family: 'IPv4', address: self.localAddress }
}

Peer.prototype.signal = function (data) {
  var self = this
  if (self.destroyed) throw new Error('cannot signal after peer is destroyed')
  if (typeof data === 'string') {
    try {
      data = JSON.parse(data)
    } catch (err) {
      data = {}
    }
  }
  self._debug('signal()')
  if (data.sdp) {
    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data), function () {
      if (self.destroyed) return
      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()
    }, self._onError.bind(self))
  }
  if (data.candidate) {
    try {
      self._pc.addIceCandidate(
        new (self._wrtc.RTCIceCandidate)(data.candidate), noop, self._onError.bind(self)
      )
    } catch (err) {
      self._destroy(new Error('error adding candidate: ' + err.message))
    }
  }
  if (!data.sdp && !data.candidate) {
    self._destroy(new Error('signal() called with invalid signal data'))
  }
}

/**
 * Send text/binary data to the remote peer.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Peer.prototype.send = function (chunk) {
  var self = this

  if (!isTypedArray.strict(chunk) && !(chunk instanceof ArrayBuffer) &&
    !Buffer.isBuffer(chunk) && typeof chunk !== 'string' &&
    (typeof Blob === 'undefined' || !(chunk instanceof Blob))) {
    chunk = JSON.stringify(chunk)
  }

  // `wrtc` module doesn't accept node.js buffer
  if (Buffer.isBuffer(chunk) && !isTypedArray.strict(chunk)) {
    chunk = new Uint8Array(chunk)
  }

  var len = chunk.length || chunk.byteLength || chunk.size
  self._channel.send(chunk)
  self._debug('write: %d bytes', len)
}

Peer.prototype.destroy = function (onclose) {
  var self = this
  self._destroy(null, onclose)
}

Peer.prototype._destroy = function (err, onclose) {
  var self = this
  if (self.destroyed) return
  if (onclose) self.once('close', onclose)

  self._debug('destroy (error: %s)', err && err.message)

  self.readable = self.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.destroyed = true
  self.connected = false
  self._pcReady = false
  self._channelReady = false

  self._chunk = null
  self._cb = null
  clearInterval(self._interval)
  clearTimeout(self._reconnectTimeout)

  if (self._pc) {
    try {
      self._pc.close()
    } catch (err) {}

    self._pc.oniceconnectionstatechange = null
    self._pc.onsignalingstatechange = null
    self._pc.onicecandidate = null
  }

  if (self._channel) {
    try {
      self._channel.close()
    } catch (err) {}

    self._channel.onmessage = null
    self._channel.onopen = null
    self._channel.onclose = null
  }
  self._pc = null
  self._channel = null

  if (err) self.emit('error', err)
  self.emit('close')
}

Peer.prototype._setupData = function (event) {
  var self = this
  self._channel = event.channel
  self.channelName = self._channel.label

  self._channel.binaryType = 'arraybuffer'
  self._channel.onmessage = self._onChannelMessage.bind(self)
  self._channel.onopen = self._onChannelOpen.bind(self)
  self._channel.onclose = self._onChannelClose.bind(self)
}

Peer.prototype._read = function () {}

Peer.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'))

  if (self.connected) {
    self.send(chunk)
    if (self._channel.bufferedAmount > self._maxBufferedAmount) {
      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    self._debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

Peer.prototype._createOffer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createOffer(function (offer) {
    if (self.destroyed) return
    speedHack(offer)
    offer.sdp = self.sdpTransform(offer.sdp)
    self._pc.setLocalDescription(offer, noop, self._onError.bind(self))
    var sendOffer = function () {
      self._debug('signal')
      self.emit('signal', self._pc.localDescription || offer)
    }
    if (self.trickle || self._iceComplete) sendOffer()
    else self.once('_iceComplete', sendOffer) // wait for candidates
  }, self._onError.bind(self), self.offerConstraints)
}

Peer.prototype._createAnswer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createAnswer(function (answer) {
    if (self.destroyed) return
    speedHack(answer)
    answer.sdp = self.sdpTransform(answer.sdp)
    self._pc.setLocalDescription(answer, noop, self._onError.bind(self))
    var sendAnswer = function () {
      self._debug('signal')
      self.emit('signal', self._pc.localDescription || answer)
    }
    if (self.trickle || self._iceComplete) sendAnswer()
    else self.once('_iceComplete', sendAnswer)
  }, self._onError.bind(self), self.answerConstraints)
}

Peer.prototype._onIceConnectionStateChange = function () {
  var self = this
  if (self.destroyed) return
  var iceGatheringState = self._pc.iceGatheringState
  var iceConnectionState = self._pc.iceConnectionState
  self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState)
  self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState)
  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
    clearTimeout(self._reconnectTimeout)
    self._pcReady = true
    self._maybeReady()
  }
  if (iceConnectionState === 'disconnected') {
    if (self.reconnectTimer) {
      // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect
      clearTimeout(self._reconnectTimeout)
      self._reconnectTimeout = setTimeout(function () {
        self._destroy()
      }, self.reconnectTimer)
    } else {
      self._destroy()
    }
  }
  if (iceConnectionState === 'closed') {
    self._destroy()
  }
}

Peer.prototype._maybeReady = function () {
  var self = this
  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return
  self._connecting = true

  if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) {
    self._pc.getStats(null, function (res) {
      var items = []
      res.forEach(function (item) {
        items.push(item)
      })
      onStats(items)
    }, self._onError.bind(self))
  } else {
    self._pc.getStats(function (res) {
      var items = []
      res.result().forEach(function (result) {
        var item = {}
        result.names().forEach(function (name) {
          item[name] = result.stat(name)
        })
        item.id = result.id
        item.type = result.type
        item.timestamp = result.timestamp
        items.push(item)
      })
      onStats(items)
    })
  }

  function onStats (items) {
    items.forEach(function (item) {
      if (item.type === 'remotecandidate') {
        self.remoteAddress = item.ipAddress
        self.remoteFamily = 'IPv4'
        self.remotePort = Number(item.portNumber)
        self._debug(
          'connect remote: %s:%s (%s)',
          self.remoteAddress, self.remotePort, self.remoteFamily
        )
      } else if (item.type === 'localcandidate' && item.candidateType === 'host') {
        self.localAddress = item.ipAddress
        self.localPort = Number(item.portNumber)
        self._debug('connect local: %s:%s', self.localAddress, self.localPort)
      }
    })

    self._connecting = false
    self.connected = true

    if (self._chunk) {
      self.send(self._chunk)
      self._chunk = null
      self._debug('sent chunk from "write before connect"')

      var cb = self._cb
      self._cb = null
      cb(null)
    }

    self._interval = setInterval(function () {
      if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return
      self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      var cb = self._cb
      self._cb = null
      cb(null)
    }, 150)
    if (self._interval.unref) self._interval.unref()

    self._debug('connect')
    self.emit('connect')
  }
}

Peer.prototype._onSignalingStateChange = function () {
  var self = this
  if (self.destroyed) return
  self._debug('signalingStateChange %s', self._pc.signalingState)
  self.emit('signalingStateChange', self._pc.signalingState)
}

Peer.prototype._onIceCandidate = function (event) {
  var self = this
  if (self.destroyed) return
  if (event.candidate && self.trickle) {
    self.emit('signal', { candidate: event.candidate })
  } else if (!event.candidate) {
    self._iceComplete = true
    self.emit('_iceComplete')
  }
}

Peer.prototype._onChannelMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  self._debug('read: %d bytes', data.byteLength || data.length)

  if (data instanceof ArrayBuffer) {
    data = toBuffer(new Uint8Array(data))
    self.push(data)
  } else {
    try {
      data = JSON.parse(data)
    } catch (err) {}
    self.emit('data', data)
  }
}

Peer.prototype._onChannelOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self._debug('on channel open')
  self._channelReady = true
  self._maybeReady()
}

Peer.prototype._onChannelClose = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on channel close')
  self._destroy()
}

Peer.prototype._onAddStream = function (event) {
  var self = this
  if (self.destroyed) return
  self._debug('on add stream')
  self.emit('stream', event.stream)
}

Peer.prototype._onError = function (err) {
  var self = this
  if (self.destroyed) return
  self._debug('error %s', err.message || err)
  self._destroy(err)
}

Peer.prototype._debug = function () {
  var self = this
  var args = [].slice.call(arguments)
  var id = self.channelName && self.channelName.substring(0, 7)
  args[0] = '[' + id + '] ' + args[0]
  debug.apply(null, args)
}

function getBrowserRTC () {
  if (typeof window === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: window.mozRTCPeerConnection || window.RTCPeerConnection ||
      window.webkitRTCPeerConnection,
    RTCSessionDescription: window.mozRTCSessionDescription ||
      window.RTCSessionDescription || window.webkitRTCSessionDescription,
    RTCIceCandidate: window.mozRTCIceCandidate || window.RTCIceCandidate ||
      window.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

function speedHack (obj) {
  var s = obj.sdp.split('b=AS:30')
  if (s.length > 1) obj.sdp = s[0] + 'b=AS:1638400' + s[1]
}

function noop () {}

}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL25vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBCbG9iICovXG5cbm1vZHVsZS5leHBvcnRzID0gUGVlclxuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzaW1wbGUtcGVlcicpXG52YXIgaGF0ID0gcmVxdWlyZSgnaGF0JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZGFycmF5JylcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciB0b0J1ZmZlciA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktdG8tYnVmZmVyJylcblxuaW5oZXJpdHMoUGVlciwgc3RyZWFtLkR1cGxleClcblxuLyoqXG4gKiBXZWJSVEMgcGVlciBjb25uZWN0aW9uLiBTYW1lIEFQSSBhcyBub2RlIGNvcmUgYG5ldC5Tb2NrZXRgLCBwbHVzIGEgZmV3IGV4dHJhIG1ldGhvZHMuXG4gKiBEdXBsZXggc3RyZWFtLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZnVuY3Rpb24gUGVlciAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFBlZXIpKSByZXR1cm4gbmV3IFBlZXIob3B0cylcbiAgc2VsZi5fZGVidWcoJ25ldyBwZWVyICVvJywgb3B0cylcblxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBvcHRzLmFsbG93SGFsZk9wZW4gPSBmYWxzZVxuICBpZiAob3B0cy5oaWdoV2F0ZXJNYXJrID09IG51bGwpIG9wdHMuaGlnaFdhdGVyTWFyayA9IDEwMjQgKiAxMDI0XG5cbiAgc3RyZWFtLkR1cGxleC5jYWxsKHNlbGYsIG9wdHMpXG5cbiAgc2VsZi5pbml0aWF0b3IgPSBvcHRzLmluaXRpYXRvciB8fCBmYWxzZVxuICBzZWxmLmNoYW5uZWxDb25maWcgPSBvcHRzLmNoYW5uZWxDb25maWcgfHwgUGVlci5jaGFubmVsQ29uZmlnXG4gIHNlbGYuY2hhbm5lbE5hbWUgPSBvcHRzLmNoYW5uZWxOYW1lIHx8IGhhdCgxNjApXG4gIGlmICghb3B0cy5pbml0aWF0b3IpIHNlbGYuY2hhbm5lbE5hbWUgPSBudWxsXG4gIHNlbGYuY29uZmlnID0gb3B0cy5jb25maWcgfHwgUGVlci5jb25maWdcbiAgc2VsZi5jb25zdHJhaW50cyA9IG9wdHMuY29uc3RyYWludHMgfHwgUGVlci5jb25zdHJhaW50c1xuICBzZWxmLnJlY29ubmVjdFRpbWVyID0gb3B0cy5yZWNvbm5lY3RUaW1lciB8fCAwXG4gIHNlbGYuc2RwVHJhbnNmb3JtID0gb3B0cy5zZHBUcmFuc2Zvcm0gfHwgZnVuY3Rpb24gKHNkcCkgeyByZXR1cm4gc2RwIH1cbiAgc2VsZi5zdHJlYW0gPSBvcHRzLnN0cmVhbSB8fCBmYWxzZVxuICBzZWxmLnRyaWNrbGUgPSBvcHRzLnRyaWNrbGUgIT09IHVuZGVmaW5lZCA/IG9wdHMudHJpY2tsZSA6IHRydWVcblxuICBzZWxmLmRlc3Ryb3llZCA9IGZhbHNlXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcblxuICAvLyBzbyBQZWVyIG9iamVjdCBhbHdheXMgaGFzIHNhbWUgc2hhcGUgKFY4IG9wdGltaXphdGlvbilcbiAgc2VsZi5yZW1vdGVBZGRyZXNzID0gdW5kZWZpbmVkXG4gIHNlbGYucmVtb3RlRmFtaWx5ID0gdW5kZWZpbmVkXG4gIHNlbGYucmVtb3RlUG9ydCA9IHVuZGVmaW5lZFxuICBzZWxmLmxvY2FsQWRkcmVzcyA9IHVuZGVmaW5lZFxuICBzZWxmLmxvY2FsUG9ydCA9IHVuZGVmaW5lZFxuXG4gIHNlbGYuX3dydGMgPSBvcHRzLndydGMgfHwgZ2V0QnJvd3NlclJUQygpXG4gIGlmICghc2VsZi5fd3J0Yykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBXZWJSVEMgc3VwcG9ydDogU3BlY2lmeSBgb3B0cy53cnRjYCBvcHRpb24gaW4gdGhpcyBlbnZpcm9ubWVudCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IE5vdCBhIHN1cHBvcnRlZCBicm93c2VyJylcbiAgICB9XG4gIH1cblxuICBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCA9IG9wdHMuaGlnaFdhdGVyTWFya1xuICBzZWxmLl9wY1JlYWR5ID0gZmFsc2VcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gZmFsc2VcbiAgc2VsZi5faWNlQ29tcGxldGUgPSBmYWxzZSAvLyBpY2UgY2FuZGlkYXRlIHRyaWNrbGUgZG9uZSAoZ290IG51bGwgY2FuZGlkYXRlKVxuICBzZWxmLl9jaGFubmVsID0gbnVsbFxuXG4gIHNlbGYuX2NodW5rID0gbnVsbFxuICBzZWxmLl9jYiA9IG51bGxcbiAgc2VsZi5faW50ZXJ2YWwgPSBudWxsXG4gIHNlbGYuX3JlY29ubmVjdFRpbWVvdXQgPSBudWxsXG5cbiAgc2VsZi5fcGMgPSBuZXcgKHNlbGYuX3dydGMuUlRDUGVlckNvbm5lY3Rpb24pKHNlbGYuY29uZmlnLCBzZWxmLmNvbnN0cmFpbnRzKVxuICBzZWxmLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IHNlbGYuX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlLmJpbmQoc2VsZilcbiAgc2VsZi5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IHNlbGYuX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UuYmluZChzZWxmKVxuICBzZWxmLl9wYy5vbmljZWNhbmRpZGF0ZSA9IHNlbGYuX29uSWNlQ2FuZGlkYXRlLmJpbmQoc2VsZilcblxuICBpZiAoc2VsZi5zdHJlYW0pIHNlbGYuX3BjLmFkZFN0cmVhbShzZWxmLnN0cmVhbSlcbiAgc2VsZi5fcGMub25hZGRzdHJlYW0gPSBzZWxmLl9vbkFkZFN0cmVhbS5iaW5kKHNlbGYpXG5cbiAgaWYgKHNlbGYuaW5pdGlhdG9yKSB7XG4gICAgc2VsZi5fc2V0dXBEYXRhKHsgY2hhbm5lbDogc2VsZi5fcGMuY3JlYXRlRGF0YUNoYW5uZWwoc2VsZi5jaGFubmVsTmFtZSwgc2VsZi5jaGFubmVsQ29uZmlnKSB9KVxuICAgIHNlbGYuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBvbmNlKHNlbGYuX2NyZWF0ZU9mZmVyLmJpbmQoc2VsZikpXG4gICAgLy8gT25seSBDaHJvbWUgdHJpZ2dlcnMgXCJuZWdvdGlhdGlvbm5lZWRlZFwiOyB0aGlzIGlzIGEgd29ya2Fyb3VuZCBmb3Igb3RoZXJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnNcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgc2VsZi5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCgpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3BjLm9uZGF0YWNoYW5uZWwgPSBzZWxmLl9zZXR1cERhdGEuYmluZChzZWxmKVxuICB9XG5cbiAgc2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgICAgLy8gV2hlbiBsb2NhbCBwZWVyIGlzIGZpbmlzaGVkIHdyaXRpbmcsIGNsb3NlIGNvbm5lY3Rpb24gdG8gcmVtb3RlIHBlZXIuXG4gICAgICAvLyBIYWxmIG9wZW4gY29ubmVjdGlvbnMgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlxuICAgICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgZGF0YWNoYW5uZWwgZmx1c2hlcy5cbiAgICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgbW9yZSByZWxpYWJsZSB3YXkgdG8gYWNjb21wbGlzaCB0aGlzP1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgfSwgMTAwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBkYXRhIGNoYW5uZWwgaXMgbm90IGNvbm5lY3RlZCB3aGVuIGxvY2FsIHBlZXIgaXMgZmluaXNoZWQgd3JpdGluZywgd2FpdCB1bnRpbFxuICAgICAgLy8gZGF0YSBpcyBmbHVzaGVkIHRvIG5ldHdvcmsgYXQgXCJjb25uZWN0XCIgZXZlbnQuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNlbGYub25jZSgnY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICAgIH0sIDEwMClcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5QZWVyLldFQlJUQ19TVVBQT1JUID0gISFnZXRCcm93c2VyUlRDKClcblxuLyoqXG4gKiBFeHBvc2UgY29uZmlnLCBjb25zdHJhaW50cywgYW5kIGRhdGEgY2hhbm5lbCBjb25maWcgZm9yIG92ZXJyaWRpbmcgYWxsIFBlZXJcbiAqIGluc3RhbmNlcy4gT3RoZXJ3aXNlLCBqdXN0IHNldCBvcHRzLmNvbmZpZywgb3B0cy5jb25zdHJhaW50cywgb3Igb3B0cy5jaGFubmVsQ29uZmlnXG4gKiB3aGVuIGNvbnN0cnVjdGluZyBhIFBlZXIuXG4gKi9cblBlZXIuY29uZmlnID0ge1xuICBpY2VTZXJ2ZXJzOiBbXG4gICAge1xuICAgICAgdXJsOiAnc3R1bjoyMy4yMS4xNTAuMTIxJywgLy8gZGVwcmVjYXRlZCwgcmVwbGFjZWQgYnkgYHVybHNgXG4gICAgICB1cmxzOiAnc3R1bjoyMy4yMS4xNTAuMTIxJ1xuICAgIH1cbiAgXVxufVxuUGVlci5jb25zdHJhaW50cyA9IHt9XG5QZWVyLmNoYW5uZWxDb25maWcgPSB7fVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGVlci5wcm90b3R5cGUsICdidWZmZXJTaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICByZXR1cm4gKHNlbGYuX2NoYW5uZWwgJiYgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCkgfHwgMFxuICB9XG59KVxuXG5QZWVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHsgcG9ydDogc2VsZi5sb2NhbFBvcnQsIGZhbWlseTogJ0lQdjQnLCBhZGRyZXNzOiBzZWxmLmxvY2FsQWRkcmVzcyB9XG59XG5cblBlZXIucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRhdGEgPSB7fVxuICAgIH1cbiAgfVxuICBzZWxmLl9kZWJ1Zygnc2lnbmFsKCknKVxuICBpZiAoZGF0YS5zZHApIHtcbiAgICBzZWxmLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgKHNlbGYuX3dydGMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShkYXRhKSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgIGlmIChzZWxmLl9wYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInKSBzZWxmLl9jcmVhdGVBbnN3ZXIoKVxuICAgIH0sIHNlbGYuX29uRXJyb3IuYmluZChzZWxmKSlcbiAgfVxuICBpZiAoZGF0YS5jYW5kaWRhdGUpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5fcGMuYWRkSWNlQ2FuZGlkYXRlKFxuICAgICAgICBuZXcgKHNlbGYuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKShkYXRhLmNhbmRpZGF0ZSksIG5vb3AsIHNlbGYuX29uRXJyb3IuYmluZChzZWxmKVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2VsZi5fZGVzdHJveShuZXcgRXJyb3IoJ2Vycm9yIGFkZGluZyBjYW5kaWRhdGU6ICcgKyBlcnIubWVzc2FnZSkpXG4gICAgfVxuICB9XG4gIGlmICghZGF0YS5zZHAgJiYgIWRhdGEuY2FuZGlkYXRlKSB7XG4gICAgc2VsZi5fZGVzdHJveShuZXcgRXJyb3IoJ3NpZ25hbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgc2lnbmFsIGRhdGEnKSlcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgcmVtb3RlIHBlZXIuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlWaWV3fEFycmF5QnVmZmVyfEJ1ZmZlcnxzdHJpbmd8QmxvYnxPYmplY3R9IGNodW5rXG4gKi9cblBlZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKCFpc1R5cGVkQXJyYXkuc3RyaWN0KGNodW5rKSAmJiAhKGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJlxuICAgICh0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcgfHwgIShjaHVuayBpbnN0YW5jZW9mIEJsb2IpKSkge1xuICAgIGNodW5rID0gSlNPTi5zdHJpbmdpZnkoY2h1bmspXG4gIH1cblxuICAvLyBgd3J0Y2AgbW9kdWxlIGRvZXNuJ3QgYWNjZXB0IG5vZGUuanMgYnVmZmVyXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmICFpc1R5cGVkQXJyYXkuc3RyaWN0KGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gIH1cblxuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoIHx8IGNodW5rLmJ5dGVMZW5ndGggfHwgY2h1bmsuc2l6ZVxuICBzZWxmLl9jaGFubmVsLnNlbmQoY2h1bmspXG4gIHNlbGYuX2RlYnVnKCd3cml0ZTogJWQgYnl0ZXMnLCBsZW4pXG59XG5cblBlZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob25jbG9zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fZGVzdHJveShudWxsLCBvbmNsb3NlKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIG9uY2xvc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIGlmIChvbmNsb3NlKSBzZWxmLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSlcblxuICBzZWxmLl9kZWJ1ZygnZGVzdHJveSAoZXJyb3I6ICVzKScsIGVyciAmJiBlcnIubWVzc2FnZSlcblxuICBzZWxmLnJlYWRhYmxlID0gc2VsZi53cml0YWJsZSA9IGZhbHNlXG5cbiAgaWYgKCFzZWxmLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBzZWxmLnB1c2gobnVsbClcbiAgaWYgKCFzZWxmLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSBzZWxmLmVuZCgpXG5cbiAgc2VsZi5kZXN0cm95ZWQgPSB0cnVlXG4gIHNlbGYuY29ubmVjdGVkID0gZmFsc2VcbiAgc2VsZi5fcGNSZWFkeSA9IGZhbHNlXG4gIHNlbGYuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG5cbiAgc2VsZi5fY2h1bmsgPSBudWxsXG4gIHNlbGYuX2NiID0gbnVsbFxuICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKVxuICBjbGVhclRpbWVvdXQoc2VsZi5fcmVjb25uZWN0VGltZW91dClcblxuICBpZiAoc2VsZi5fcGMpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5fcGMuY2xvc2UoKVxuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIHNlbGYuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgc2VsZi5fcGMub25pY2VjYW5kaWRhdGUgPSBudWxsXG4gIH1cblxuICBpZiAoc2VsZi5fY2hhbm5lbCkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLl9jaGFubmVsLmNsb3NlKClcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBzZWxmLl9jaGFubmVsLm9ubWVzc2FnZSA9IG51bGxcbiAgICBzZWxmLl9jaGFubmVsLm9ub3BlbiA9IG51bGxcbiAgICBzZWxmLl9jaGFubmVsLm9uY2xvc2UgPSBudWxsXG4gIH1cbiAgc2VsZi5fcGMgPSBudWxsXG4gIHNlbGYuX2NoYW5uZWwgPSBudWxsXG5cbiAgaWYgKGVycikgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgc2VsZi5lbWl0KCdjbG9zZScpXG59XG5cblBlZXIucHJvdG90eXBlLl9zZXR1cERhdGEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2NoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gIHNlbGYuY2hhbm5lbE5hbWUgPSBzZWxmLl9jaGFubmVsLmxhYmVsXG5cbiAgc2VsZi5fY2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICBzZWxmLl9jaGFubmVsLm9ubWVzc2FnZSA9IHNlbGYuX29uQ2hhbm5lbE1lc3NhZ2UuYmluZChzZWxmKVxuICBzZWxmLl9jaGFubmVsLm9ub3BlbiA9IHNlbGYuX29uQ2hhbm5lbE9wZW4uYmluZChzZWxmKVxuICBzZWxmLl9jaGFubmVsLm9uY2xvc2UgPSBzZWxmLl9vbkNoYW5uZWxDbG9zZS5iaW5kKHNlbGYpXG59XG5cblBlZXIucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge31cblxuUGVlci5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIGNiKG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJykpXG5cbiAgaWYgKHNlbGYuY29ubmVjdGVkKSB7XG4gICAgc2VsZi5zZW5kKGNodW5rKVxuICAgIGlmIChzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgIHNlbGYuX2NiID0gY2JcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICBzZWxmLl9jaHVuayA9IGNodW5rXG4gICAgc2VsZi5fY2IgPSBjYlxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9jcmVhdGVPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcGMuY3JlYXRlT2ZmZXIoZnVuY3Rpb24gKG9mZmVyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzcGVlZEhhY2sob2ZmZXIpXG4gICAgb2ZmZXIuc2RwID0gc2VsZi5zZHBUcmFuc2Zvcm0ob2ZmZXIuc2RwKVxuICAgIHNlbGYuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIsIG5vb3AsIHNlbGYuX29uRXJyb3IuYmluZChzZWxmKSlcbiAgICB2YXIgc2VuZE9mZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHNlbGYuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgb2ZmZXIpXG4gICAgfVxuICAgIGlmIChzZWxmLnRyaWNrbGUgfHwgc2VsZi5faWNlQ29tcGxldGUpIHNlbmRPZmZlcigpXG4gICAgZWxzZSBzZWxmLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRPZmZlcikgLy8gd2FpdCBmb3IgY2FuZGlkYXRlc1xuICB9LCBzZWxmLl9vbkVycm9yLmJpbmQoc2VsZiksIHNlbGYub2ZmZXJDb25zdHJhaW50cylcbn1cblxuUGVlci5wcm90b3R5cGUuX2NyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgc2VsZi5fcGMuY3JlYXRlQW5zd2VyKGZ1bmN0aW9uIChhbnN3ZXIpIHtcbiAgICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICAgIHNwZWVkSGFjayhhbnN3ZXIpXG4gICAgYW5zd2VyLnNkcCA9IHNlbGYuc2RwVHJhbnNmb3JtKGFuc3dlci5zZHApXG4gICAgc2VsZi5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIsIG5vb3AsIHNlbGYuX29uRXJyb3IuYmluZChzZWxmKSlcbiAgICB2YXIgc2VuZEFuc3dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdzaWduYWwnKVxuICAgICAgc2VsZi5lbWl0KCdzaWduYWwnLCBzZWxmLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IGFuc3dlcilcbiAgICB9XG4gICAgaWYgKHNlbGYudHJpY2tsZSB8fCBzZWxmLl9pY2VDb21wbGV0ZSkgc2VuZEFuc3dlcigpXG4gICAgZWxzZSBzZWxmLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRBbnN3ZXIpXG4gIH0sIHNlbGYuX29uRXJyb3IuYmluZChzZWxmKSwgc2VsZi5hbnN3ZXJDb25zdHJhaW50cylcbn1cblxuUGVlci5wcm90b3R5cGUuX29uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgdmFyIGljZUdhdGhlcmluZ1N0YXRlID0gc2VsZi5fcGMuaWNlR2F0aGVyaW5nU3RhdGVcbiAgdmFyIGljZUNvbm5lY3Rpb25TdGF0ZSA9IHNlbGYuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZVxuICBzZWxmLl9kZWJ1ZygnaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlICVzICVzJywgaWNlR2F0aGVyaW5nU3RhdGUsIGljZUNvbm5lY3Rpb25TdGF0ZSlcbiAgc2VsZi5lbWl0KCdpY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UnLCBpY2VHYXRoZXJpbmdTdGF0ZSwgaWNlQ29ubmVjdGlvblN0YXRlKVxuICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYuX3JlY29ubmVjdFRpbWVvdXQpXG4gICAgc2VsZi5fcGNSZWFkeSA9IHRydWVcbiAgICBzZWxmLl9tYXliZVJlYWR5KClcbiAgfVxuICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgIGlmIChzZWxmLnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAvLyBJZiB1c2VyIGhhcyBzZXQgYG9wdC5yZWNvbm5lY3RUaW1lcmAsIGFsbG93IHRpbWUgZm9yIElDRSB0byBhdHRlbXB0IGEgcmVjb25uZWN0XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVjb25uZWN0VGltZW91dClcbiAgICAgIHNlbGYuX3JlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgICB9LCBzZWxmLnJlY29ubmVjdFRpbWVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9kZXN0cm95KClcbiAgICB9XG4gIH1cbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBzZWxmLl9kZXN0cm95KClcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fbWF5YmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2RlYnVnKCdtYXliZVJlYWR5IHBjICVzIGNoYW5uZWwgJXMnLCBzZWxmLl9wY1JlYWR5LCBzZWxmLl9jaGFubmVsUmVhZHkpXG4gIGlmIChzZWxmLmNvbm5lY3RlZCB8fCBzZWxmLl9jb25uZWN0aW5nIHx8ICFzZWxmLl9wY1JlYWR5IHx8ICFzZWxmLl9jaGFubmVsUmVhZHkpIHJldHVyblxuICBzZWxmLl9jb25uZWN0aW5nID0gdHJ1ZVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHNlbGYuX3BjLmdldFN0YXRzKG51bGwsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICByZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG4gICAgICB9KVxuICAgICAgb25TdGF0cyhpdGVtcylcbiAgICB9LCBzZWxmLl9vbkVycm9yLmJpbmQoc2VsZikpXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fcGMuZ2V0U3RhdHMoZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIGl0ZW1zID0gW11cbiAgICAgIHJlcy5yZXN1bHQoKS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7fVxuICAgICAgICByZXN1bHQubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaXRlbVtuYW1lXSA9IHJlc3VsdC5zdGF0KG5hbWUpXG4gICAgICAgIH0pXG4gICAgICAgIGl0ZW0uaWQgPSByZXN1bHQuaWRcbiAgICAgICAgaXRlbS50eXBlID0gcmVzdWx0LnR5cGVcbiAgICAgICAgaXRlbS50aW1lc3RhbXAgPSByZXN1bHQudGltZXN0YW1wXG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSlcbiAgICAgIH0pXG4gICAgICBvblN0YXRzKGl0ZW1zKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBvblN0YXRzIChpdGVtcykge1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdyZW1vdGVjYW5kaWRhdGUnKSB7XG4gICAgICAgIHNlbGYucmVtb3RlQWRkcmVzcyA9IGl0ZW0uaXBBZGRyZXNzXG4gICAgICAgIHNlbGYucmVtb3RlRmFtaWx5ID0gJ0lQdjQnXG4gICAgICAgIHNlbGYucmVtb3RlUG9ydCA9IE51bWJlcihpdGVtLnBvcnROdW1iZXIpXG4gICAgICAgIHNlbGYuX2RlYnVnKFxuICAgICAgICAgICdjb25uZWN0IHJlbW90ZTogJXM6JXMgKCVzKScsXG4gICAgICAgICAgc2VsZi5yZW1vdGVBZGRyZXNzLCBzZWxmLnJlbW90ZVBvcnQsIHNlbGYucmVtb3RlRmFtaWx5XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAnbG9jYWxjYW5kaWRhdGUnICYmIGl0ZW0uY2FuZGlkYXRlVHlwZSA9PT0gJ2hvc3QnKSB7XG4gICAgICAgIHNlbGYubG9jYWxBZGRyZXNzID0gaXRlbS5pcEFkZHJlc3NcbiAgICAgICAgc2VsZi5sb2NhbFBvcnQgPSBOdW1iZXIoaXRlbS5wb3J0TnVtYmVyKVxuICAgICAgICBzZWxmLl9kZWJ1ZygnY29ubmVjdCBsb2NhbDogJXM6JXMnLCBzZWxmLmxvY2FsQWRkcmVzcywgc2VsZi5sb2NhbFBvcnQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHNlbGYuX2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHNlbGYuY29ubmVjdGVkID0gdHJ1ZVxuXG4gICAgaWYgKHNlbGYuX2NodW5rKSB7XG4gICAgICBzZWxmLnNlbmQoc2VsZi5fY2h1bmspXG4gICAgICBzZWxmLl9jaHVuayA9IG51bGxcbiAgICAgIHNlbGYuX2RlYnVnKCdzZW50IGNodW5rIGZyb20gXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiJylcblxuICAgICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICB9XG5cbiAgICBzZWxmLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5fY2IgfHwgIXNlbGYuX2NoYW5uZWwgfHwgc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50KSByZXR1cm5cbiAgICAgIHNlbGYuX2RlYnVnKCdlbmRpbmcgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gICAgICB2YXIgY2IgPSBzZWxmLl9jYlxuICAgICAgc2VsZi5fY2IgPSBudWxsXG4gICAgICBjYihudWxsKVxuICAgIH0sIDE1MClcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwudW5yZWYpIHNlbGYuX2ludGVydmFsLnVucmVmKClcblxuICAgIHNlbGYuX2RlYnVnKCdjb25uZWN0JylcbiAgICBzZWxmLmVtaXQoJ2Nvbm5lY3QnKVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlICVzJywgc2VsZi5fcGMuc2lnbmFsaW5nU3RhdGUpXG4gIHNlbGYuZW1pdCgnc2lnbmFsaW5nU3RhdGVDaGFuZ2UnLCBzZWxmLl9wYy5zaWduYWxpbmdTdGF0ZSlcbn1cblxuUGVlci5wcm90b3R5cGUuX29uSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAoZXZlbnQuY2FuZGlkYXRlICYmIHNlbGYudHJpY2tsZSkge1xuICAgIHNlbGYuZW1pdCgnc2lnbmFsJywgeyBjYW5kaWRhdGU6IGV2ZW50LmNhbmRpZGF0ZSB9KVxuICB9IGVsc2UgaWYgKCFldmVudC5jYW5kaWRhdGUpIHtcbiAgICBzZWxmLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICBzZWxmLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICBzZWxmLl9kZWJ1ZygncmVhZDogJWQgYnl0ZXMnLCBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGgpXG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGRhdGEgPSB0b0J1ZmZlcihuZXcgVWludDhBcnJheShkYXRhKSlcbiAgICBzZWxmLnB1c2goZGF0YSlcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgc2VsZi5lbWl0KCdkYXRhJywgZGF0YSlcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25DaGFubmVsT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmNvbm5lY3RlZCB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdvbiBjaGFubmVsIG9wZW4nKVxuICBzZWxmLl9jaGFubmVsUmVhZHkgPSB0cnVlXG4gIHNlbGYuX21heWJlUmVhZHkoKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25DaGFubmVsQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gY2hhbm5lbCBjbG9zZScpXG4gIHNlbGYuX2Rlc3Ryb3koKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25BZGRTdHJlYW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdvbiBhZGQgc3RyZWFtJylcbiAgc2VsZi5lbWl0KCdzdHJlYW0nLCBldmVudC5zdHJlYW0pXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ2Vycm9yICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKVxuICBzZWxmLl9kZXN0cm95KGVycilcbn1cblxuUGVlci5wcm90b3R5cGUuX2RlYnVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgdmFyIGlkID0gc2VsZi5jaGFubmVsTmFtZSAmJiBzZWxmLmNoYW5uZWxOYW1lLnN1YnN0cmluZygwLCA3KVxuICBhcmdzWzBdID0gJ1snICsgaWQgKyAnXSAnICsgYXJnc1swXVxuICBkZWJ1Zy5hcHBseShudWxsLCBhcmdzKVxufVxuXG5mdW5jdGlvbiBnZXRCcm93c2VyUlRDICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbFxuICB2YXIgd3J0YyA9IHtcbiAgICBSVENQZWVyQ29ubmVjdGlvbjogd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLFxuICAgIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogd2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fFxuICAgICAgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICAgIFJUQ0ljZUNhbmRpZGF0ZTogd2luZG93Lm1velJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8XG4gICAgICB3aW5kb3cud2Via2l0UlRDSWNlQ2FuZGlkYXRlXG4gIH1cbiAgaWYgKCF3cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSByZXR1cm4gbnVsbFxuICByZXR1cm4gd3J0Y1xufVxuXG5mdW5jdGlvbiBzcGVlZEhhY2sgKG9iaikge1xuICB2YXIgcyA9IG9iai5zZHAuc3BsaXQoJ2I9QVM6MzAnKVxuICBpZiAocy5sZW5ndGggPiAxKSBvYmouc2RwID0gc1swXSArICdiPUFTOjE2Mzg0MDAnICsgc1sxXVxufVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG4iXX0=
},{"../../../../../is-buffer/index.js":96,"debug":57,"hat":60,"inherits":61,"is-typedarray":62,"once":64,"stream":116,"typedarray-to-buffer":65}],57:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":58}],58:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":59}],59:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],60:[function(require,module,exports){
var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};

},{}],61:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],62:[function(require,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],63:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],64:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},{"wrappy":63}],65:[function(require,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict

module.exports = function (arr) {
  // If `Buffer` is the browser `buffer` module, and the browser supports typed arrays,
  // then avoid a copy. Otherwise, create a `Buffer` with a copy.
  var constructor = Buffer.TYPED_ARRAY_SUPPORT
    ? Buffer._augment
    : function (arr) { return new Buffer(arr) }

  if (arr instanceof Uint8Array) {
    return constructor(arr)
  } else if (arr instanceof ArrayBuffer) {
    return constructor(new Uint8Array(arr))
  } else if (isTypedArray(arr)) {
    // Use the typed array's underlying ArrayBuffer to back new Buffer. This respects
    // the "view" on the ArrayBuffer, i.e. byteOffset and byteLength. No copy.
    return constructor(new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength))
  } else {
    // Unsupported type, just pass it through to the `Buffer` constructor.
    return new Buffer(arr)
  }
}

}).call(this,require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL25vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS10by1idWZmZXIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udmVydCBhIHR5cGVkIGFycmF5IHRvIGEgQnVmZmVyIHdpdGhvdXQgYSBjb3B5XG4gKlxuICogQXV0aG9yOiAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBMaWNlbnNlOiAgTUlUXG4gKlxuICogYG5wbSBpbnN0YWxsIHR5cGVkYXJyYXktdG8tYnVmZmVyYFxuICovXG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZGFycmF5Jykuc3RyaWN0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycikge1xuICAvLyBJZiBgQnVmZmVyYCBpcyB0aGUgYnJvd3NlciBgYnVmZmVyYCBtb2R1bGUsIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMsXG4gIC8vIHRoZW4gYXZvaWQgYSBjb3B5LiBPdGhlcndpc2UsIGNyZWF0ZSBhIGBCdWZmZXJgIHdpdGggYSBjb3B5LlxuICB2YXIgY29uc3RydWN0b3IgPSBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gQnVmZmVyLl9hdWdtZW50XG4gICAgOiBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBuZXcgQnVmZmVyKGFycikgfVxuXG4gIGlmIChhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yKGFycilcbiAgfSBlbHNlIGlmIChhcnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3RvcihuZXcgVWludDhBcnJheShhcnIpKVxuICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShhcnIpKSB7XG4gICAgLy8gVXNlIHRoZSB0eXBlZCBhcnJheSdzIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIgdG8gYmFjayBuZXcgQnVmZmVyLiBUaGlzIHJlc3BlY3RzXG4gICAgLy8gdGhlIFwidmlld1wiIG9uIHRoZSBBcnJheUJ1ZmZlciwgaS5lLiBieXRlT2Zmc2V0IGFuZCBieXRlTGVuZ3RoLiBObyBjb3B5LlxuICAgIHJldHVybiBjb25zdHJ1Y3RvcihuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIFVuc3VwcG9ydGVkIHR5cGUsIGp1c3QgcGFzcyBpdCB0aHJvdWdoIHRvIHRoZSBgQnVmZmVyYCBjb25zdHJ1Y3Rvci5cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcnIpXG4gIH1cbn1cbiJdfQ==
},{"buffer":29,"is-typedarray":62}],66:[function(require,module,exports){
'use strict';
module.exports = SortedArray
var search = require('binary-search')

function SortedArray(cmp, arr) {
  if (typeof cmp != 'function')
    throw new TypeError('comparator must be a function')

  this.arr = arr || []
  this.cmp = cmp
}

SortedArray.prototype.insert = function(element) {
  var index = search(this.arr, element, this.cmp)
  if (index < 0)
    index = ~index

  this.arr.splice(index, 0, element)
}

SortedArray.prototype.indexOf = function(element) {
  var index = search(this.arr, element, this.cmp)
  return index >= 0
    ? index
    : -1
}

SortedArray.prototype.remove = function(element) {
  var index = search(this.arr, element, this.cmp)
  if (index < 0)
    return false

  this.arr.splice(index, 1)
  return true
}

},{"binary-search":67}],67:[function(require,module,exports){
module.exports = function(haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low < 0 || low >= haystack.length)
      throw new RangeError("invalid lower bound");
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high < low || high >= haystack.length)
      throw new RangeError("invalid upper bound");
  }

  while(low <= high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    /* Too low. */
    if(cmp < 0.0) 
      low  = mid + 1;

    /* Too high. */
    else if(cmp > 0.0)
      high = mid - 1;
    
    /* Key found. */
    else
      return mid;
  }

  /* Key not found. */
  return ~low;
}

},{}],68:[function(require,module,exports){
var SortedArray = require('sorted-cmp-array');
var Comparator = require('./vvweentry.js').Comparator;
var VVwEEntry = require('./vvweentry.js');

/**
 * \class VVwE
 * \brief class version vector with exception keeps track of events in a 
 * concise way
 * \param e the entry chosen by the local site (1 entry <-> 1 site)
 */
function VVwE(e){
    this.local = new VVwEEntry(e);
    this.vector = new SortedArray(Comparator);
    this.vector.insert(this.local);
};

/*!
 * \brief clone of this vvwe
 */
VVwE.prototype.clone = function(){
    var cloneVVwE = new VVwE(this.local.e);
    for (var i=0; i<this.vector.arr.length; ++i){
        cloneVVwE.vector.arr[i] = new VVwEEntry(this.vector.arr[i].e);
        cloneVVwE.vector.arr[i].v = this.vector.arr[i].v;
        for (var j=0; j<this.vector.arr[i].x.length; ++j){
            cloneVVwE.vector.arr[i].x.push(this.vector.arr[i].x[j]);
        };
        if (cloneVVwE.vector.arr[i].e === this.local.e){
            cloneVVwE.local = cloneVVwE.vector.arr[i];
        };
    };
    return cloneVVwE;
};

VVwE.prototype.fromJSON = function(object){
    for (var i=0; i<object.vector.arr.length; ++i){
        this.vector.arr[i] = new VVwEEntry(object.vector.arr[i].e);
        this.vector.arr[i].v = object.vector.arr[i].v;
        for (var j=0; j<object.vector.arr[i].x.length; ++j){
            this.vector.arr[i].x.push(object.vector.arr[i].x[j]);
        };
        if (object.vector.arr[i].e === object.local.e){
            this.local = this.vector.arr[i];
        };
    };
    return this;
};

/**
 * \brief increment the entry of the vector on local update
 * \return {_e: entry, _c: counter} uniquely identifying the operation
 */
VVwE.prototype.increment = function(){
    this.local.increment();
    return {_e: this.local.e, _c:this.local.v}; 
};


/**
 * \brief increment from a remote operation
 * \param ec the entry and clock of the received event to add supposedly rdy
 * the type is {_e: entry, _c: counter}
 */
VVwE.prototype.incrementFrom = function (ec){
    if (!ec || (ec && !ec._e) || (ec && !ec._c)) {return;}
    // #0 find the entry within the array of VVwEntries
    var index = this.vector.indexOf(ec._e);
    if (index < 0){
        // #1 if the entry does not exist, initialize and increment
        this.vector.insert(new VVwEEntry(ec._e));
        this.vector.arr[this.vector.indexOf(ec._e)].incrementFrom(ec._c);
    } else {
        // #2 otherwise, only increment
        this.vector.arr[index].incrementFrom(ec._c);
    };
};


/**
 * \brief check if the argument are causally ready regards to this vector
 * \param ec the site clock that happen-before the current event
 */
VVwE.prototype.isReady = function(ec){
    var ready = !ec;
    if (!ready){
        var index = this.vector.indexOf(ec._e);
        ready = index >=0 && ec._c <= this.vector.arr[index].v &&
            this.vector.arr[index].x.indexOf(ec._c)<0;
    };
    return ready;
};

/**
 * \brief check if the message contains information already delivered
 * \param ec the site clock to check
 */
VVwE.prototype.isLower = function(ec){
    return (ec && this.isReady(ec));
};

/**
 * \brief merge the version vector in argument with this
 * \param other the other version vector to merge
 */
VVwE.prototype.merge = function(other){
    for (var i = 0; i < other.vector.arr.length; ++i){
        var entry = other.vector.arr[i];
        var index = this.vector.indexOf(entry);
        if (index < 0){
            // #1 entry does not exist, fully copy it
            var newEntry = new VVwEEntry(entry.e);
            newEntry.v = entry.v;
            for (var j = 0; j < entry.x.length; ++j){
                newEntry.x.push(entry.x[j]);
            };
            this.vector.insert(newEntry);
        }else{
            // #2 otherwise merge the entries
            var currEntry = this.vector.arr[i];
            // #2A remove the exception from our vector
            var j = 0;
            while (j<currEntry.x.length){
                if (currEntry.x[j]<entry.v &&
                    entry.x.indexOf(currEntry.x[j])<0){
                    currEntry.x.splice(j, 1);
                } else {
                    ++j;
                };
            };
            // #2B add the new exceptions
            j = 0;
            while (j<entry.x.length){
                if (entry.x[j] > currEntry.v &&
                    currEntry.x.indexOf(entry.x[j])<0){
                    currEntry.x.push(entry.x[j]);
                };
                ++j;
            };
            currEntry.v = Math.max(currEntry.v, entry.v);
        };
    };
};

module.exports = VVwE;


},{"./vvweentry.js":69,"sorted-cmp-array":70}],69:[function(require,module,exports){

/*!
  \brief create an entry of the version vector with exceptions containing the
  index of the entry, the value v that creates a contiguous interval
  from 0 to v, an array of integers that contain the operations lower to v that
  have not been received yet
  \param e the entry in the interval version vector
*/
function VVwEEntry(e){
    this.e = e;   
    this.v = 0;
    this.x = [];
};

/*!
 * \brief local counter incremented
 */
VVwEEntry.prototype.increment = function(){
    this.v += 1;
};

/**
 * \brief increment from a remote operation
 * \param c the counter of the operation to add to this 
 */
VVwEEntry.prototype.incrementFrom = function(c){
    // #1 check if the counter is included in the exceptions
    if (c < this.v){
        var index = this.x.indexOf(c);
        if (index>=0){ // the exception is found
            this.x.splice(index, 1);
        };
    };
    // #2 if the value is +1 compared to the current value of the vector
    if (c == (this.v + 1)){
        this.v += 1;
    };
    // #3 otherwise exception are made
    if (c > (this.v + 1)){
        for (var i = (this.v + 1); i<c; ++i){
            this.x.push(i);
        };
        this.v = c;
    };
};

/*!
 * \brief comparison function between two VVwE entries
 * \param a the first element
 * \param b the second element
 * \return -1 if a < b, 1 if a > b, 0 otherwise
 */
function Comparator (a, b){
    var aEntry = (a.e) || a;
    var bEntry = (b.e) || b;
    if (aEntry < bEntry){ return -1; };
    if (aEntry > bEntry){ return  1; };
    return 0;
};

module.exports = VVwEEntry;
module.exports.Comparator = Comparator;

},{}],70:[function(require,module,exports){
module.exports=require(66)
},{"/Users/chat-wane/Desktop/project/jquery-crate/node_modules/crate-core/node_modules/spray-wrtc/node_modules/sorted-cmp-array/index.js":66,"binary-search":71}],71:[function(require,module,exports){
module.exports=require(67)
},{"/Users/chat-wane/Desktop/project/jquery-crate/node_modules/crate-core/node_modules/spray-wrtc/node_modules/sorted-cmp-array/node_modules/binary-search/index.js":67}],72:[function(require,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],73:[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":74}],74:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":75,"engine.io-parser":86}],75:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZWpzb24gPSByZXF1aXJlKCdwYXJzZWpzb24nKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe31cblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdCA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6XG4gICAgKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdCkge1xuICAgIHZhciBwaWVjZXMgPSBvcHRzLmhvc3Quc3BsaXQoJzonKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGllY2VzLnNoaWZ0KCk7XG4gICAgaWYgKHBpZWNlcy5sZW5ndGgpIHtcbiAgICAgIG9wdHMucG9ydCA9IHBpZWNlcy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG4gICAgICAgbG9jYXRpb24ucG9ydCA6XG4gICAgICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZFxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHZhciB0cmFuc3BvcnQ7XG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuICAgICwgZmFpbGVkID0gZmFsc2VcbiAgICAsIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcbiAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKXtcbiAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCgpe1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwdWJsaWNcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcmV2QnVmZmVyTGVuOyBpKyspIHtcbiAgICBpZiAodGhpcy5jYWxsYmFja0J1ZmZlcltpXSkge1xuICAgICAgdGhpcy5jYWxsYmFja0J1ZmZlcltpXSgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBmbikge1xuICBpZiAoJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFja2V0ID0geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIucHVzaChmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuICAgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgaW4gbmV4dCB0aWNrLCBzbyBkZXZlbG9wZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgICBzZWxmLmNhbGxiYWNrQnVmZmVyID0gW107XG4gICAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgIH0sIDApO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG4iXX0=
},{"./transport":76,"./transports":77,"component-emitter":31,"debug":83,"engine.io-parser":86,"indexof":93,"parsejson":103,"parseqs":104,"parseuri":85}],76:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":31,"engine.io-parser":86}],77:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nKG9wdHMpe1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIl19
},{"./polling-jsonp":78,"./polling-xhr":79,"./websocket":81,"xmlhttprequest":82}],78:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJysgc2VsZi5pZnJhbWVJZCArJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiJdfQ==
},{"./polling":80,"component-inherit":32}],79:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGZuKXtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3Qob3B0cyl7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gJ29rJztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcbiAgUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIl19
},{"./polling":80,"component-emitter":31,"component-inherit":32,"debug":83,"xmlhttprequest":82}],80:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":76,"component-inherit":32,"debug":83,"engine.io-parser":86,"parseqs":104,"xmlhttprequest":82}],81:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = require('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":76,"component-inherit":32,"debug":83,"engine.io-parser":86,"parseqs":104,"ws":135}],82:[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":91}],83:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":84}],84:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"/Users/chat-wane/Desktop/project/jquery-crate/node_modules/crate-core/node_modules/spray-wrtc/node_modules/simple-peer/node_modules/debug/debug.js":58,"ms":101}],85:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],86:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBzdXBwb3J0c0JpbmFyeSkge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dGY4ZW5jb2RlKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIl19
},{"./keys":87,"after":18,"arraybuffer.slice":21,"base64-arraybuffer":23,"blob":25,"has-binary":90,"utf8":131}],87:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],88:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],89:[function(require,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],90:[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9oYXMtYmluYXJ5L2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cbiJdfQ==
},{"isarray":97}],91:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = require('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":89}],92:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],93:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],94:[function(require,module,exports){
module.exports=require(61)
},{"/Users/chat-wane/Desktop/project/jquery-crate/node_modules/crate-core/node_modules/spray-wrtc/node_modules/simple-peer/node_modules/inherits/inherits_browser.js":61}],95:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],96:[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],97:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],98:[function(require,module,exports){
/* jQuery.qrcode 0.12.0 - http://larsjung.de/jquery-qrcode/ - uses //github.com/kazuhikoarase/qrcode-generator (MIT) */
(function (qrcode) {
    'use strict';

    var $ = jQuery;

    // Wrapper for the original QR code generator.
    function QRCode(text, level, version, quiet) {

        var qr = qrcode(version, level);
        qr.addData(text);
        qr.make();

        quiet = quiet || 0;

        var qrModuleCount = qr.getModuleCount();
        var quietModuleCount = qr.getModuleCount() + 2 * quiet;

        function isDark(row, col) {

            row -= quiet;
            col -= quiet;

            if (row < 0 || row >= qrModuleCount || col < 0 || col >= qrModuleCount) {
                return false;
            }

            return qr.isDark(row, col);
        }

        var addBlank = function (l, t, r, b) {

            var prevIsDark = this.isDark;
            var moduleSize = 1 / quietModuleCount;

            this.isDark = function (row, col) {

                var ml = col * moduleSize;
                var mt = row * moduleSize;
                var mr = ml + moduleSize;
                var mb = mt + moduleSize;

                return prevIsDark(row, col) && (l > mr || ml > r || t > mb || mt > b);
            };
        };

        this.text = text;
        this.level = level;
        this.version = version;
        this.moduleCount = quietModuleCount;
        this.isDark = isDark;
        this.addBlank = addBlank;
    }

    // Check if canvas is available in the browser (as Modernizr does)
    var hasCanvas = (function () {

        var elem = document.createElement('canvas');
        return Boolean(elem.getContext && elem.getContext('2d'));
    }());
    var hasArcTo = Object.prototype.toString.call(window.opera) !== '[object Opera]';

    // Returns a minimal QR code for the given text starting with version `minVersion`.
    // Returns `undefined` if `text` is too long to be encoded in `maxVersion`.
    function createQRCode(text, level, minVersion, maxVersion, quiet) {

        minVersion = Math.max(1, minVersion || 1);
        maxVersion = Math.min(40, maxVersion || 40);
        for (var version = minVersion; version <= maxVersion; version += 1) {
            try {
                return new QRCode(text, level, version, quiet);
            } catch (err) {}
        }
    }

    function drawBackgroundLabel(qr, context, settings) {

        var size = settings.size;
        var font = 'bold ' + (settings.mSize * size) + 'px ' + settings.fontname;
        var ctx = $('<canvas/>')[0].getContext('2d');

        ctx.font = font;

        var w = ctx.measureText(settings.label).width;
        var sh = settings.mSize;
        var sw = w / size;
        var sl = (1 - sw) * settings.mPosX;
        var st = (1 - sh) * settings.mPosY;
        var sr = sl + sw;
        var sb = st + sh;
        var pad = 0.01;

        if (settings.mode === 1) {
            // Strip
            qr.addBlank(0, st - pad, size, sb + pad);
        } else {
            // Box
            qr.addBlank(sl - pad, st - pad, sr + pad, sb + pad);
        }

        context.fillStyle = settings.fontcolor;
        context.font = font;
        context.fillText(settings.label, sl * size, st * size + 0.75 * settings.mSize * size);
    }

    function drawBackgroundImage(qr, context, settings) {

        var size = settings.size;
        var w = settings.image.naturalWidth || 1;
        var h = settings.image.naturalHeight || 1;
        var sh = settings.mSize;
        var sw = sh * w / h;
        var sl = (1 - sw) * settings.mPosX;
        var st = (1 - sh) * settings.mPosY;
        var sr = sl + sw;
        var sb = st + sh;
        var pad = 0.01;

        if (settings.mode === 3) {
            // Strip
            qr.addBlank(0, st - pad, size, sb + pad);
        } else {
            // Box
            qr.addBlank(sl - pad, st - pad, sr + pad, sb + pad);
        }

        context.drawImage(settings.image, sl * size, st * size, sw * size, sh * size);
    }

    function drawBackground(qr, context, settings) {

        if ($(settings.background).is('img')) {
            context.drawImage(settings.background, 0, 0, settings.size, settings.size);
        } else if (settings.background) {
            context.fillStyle = settings.background;
            context.fillRect(settings.left, settings.top, settings.size, settings.size);
        }

        var mode = settings.mode;
        if (mode === 1 || mode === 2) {
            drawBackgroundLabel(qr, context, settings);
        } else if (mode === 3 || mode === 4) {
            drawBackgroundImage(qr, context, settings);
        }
    }

    function drawModuleDefault(qr, context, settings, left, top, width, row, col) {

        if (qr.isDark(row, col)) {
            context.rect(left, top, width, width);
        }
    }

    function drawModuleRoundedDark(ctx, l, t, r, b, rad, nw, ne, se, sw) {

        if (nw) {
            ctx.moveTo(l + rad, t);
        } else {
            ctx.moveTo(l, t);
        }

        if (ne) {
            ctx.lineTo(r - rad, t);
            ctx.arcTo(r, t, r, b, rad);
        } else {
            ctx.lineTo(r, t);
        }

        if (se) {
            ctx.lineTo(r, b - rad);
            ctx.arcTo(r, b, l, b, rad);
        } else {
            ctx.lineTo(r, b);
        }

        if (sw) {
            ctx.lineTo(l + rad, b);
            ctx.arcTo(l, b, l, t, rad);
        } else {
            ctx.lineTo(l, b);
        }

        if (nw) {
            ctx.lineTo(l, t + rad);
            ctx.arcTo(l, t, r, t, rad);
        } else {
            ctx.lineTo(l, t);
        }
    }

    function drawModuleRoundendLight(ctx, l, t, r, b, rad, nw, ne, se, sw) {

        if (nw) {
            ctx.moveTo(l + rad, t);
            ctx.lineTo(l, t);
            ctx.lineTo(l, t + rad);
            ctx.arcTo(l, t, l + rad, t, rad);
        }

        if (ne) {
            ctx.moveTo(r - rad, t);
            ctx.lineTo(r, t);
            ctx.lineTo(r, t + rad);
            ctx.arcTo(r, t, r - rad, t, rad);
        }

        if (se) {
            ctx.moveTo(r - rad, b);
            ctx.lineTo(r, b);
            ctx.lineTo(r, b - rad);
            ctx.arcTo(r, b, r - rad, b, rad);
        }

        if (sw) {
            ctx.moveTo(l + rad, b);
            ctx.lineTo(l, b);
            ctx.lineTo(l, b - rad);
            ctx.arcTo(l, b, l + rad, b, rad);
        }
    }

    function drawModuleRounded(qr, context, settings, left, top, width, row, col) {

        var isDark = qr.isDark;
        var right = left + width;
        var bottom = top + width;
        var radius = settings.radius * width;
        var rowT = row - 1;
        var rowB = row + 1;
        var colL = col - 1;
        var colR = col + 1;
        var center = isDark(row, col);
        var northwest = isDark(rowT, colL);
        var north = isDark(rowT, col);
        var northeast = isDark(rowT, colR);
        var east = isDark(row, colR);
        var southeast = isDark(rowB, colR);
        var south = isDark(rowB, col);
        var southwest = isDark(rowB, colL);
        var west = isDark(row, colL);

        if (center) {
            drawModuleRoundedDark(context, left, top, right, bottom, radius, !north && !west, !north && !east, !south && !east, !south && !west);
        } else {
            drawModuleRoundendLight(context, left, top, right, bottom, radius, north && west && northwest, north && east && northeast, south && east && southeast, south && west && southwest);
        }
    }

    function drawModules(qr, context, settings) {

        var moduleCount = qr.moduleCount;
        var moduleSize = settings.size / moduleCount;
        var fn = drawModuleDefault;
        var row;
        var col;

        if (hasArcTo && settings.radius > 0 && settings.radius <= 0.5) {
            fn = drawModuleRounded;
        }

        context.beginPath();
        for (row = 0; row < moduleCount; row += 1) {
            for (col = 0; col < moduleCount; col += 1) {

                var l = settings.left + col * moduleSize;
                var t = settings.top + row * moduleSize;
                var w = moduleSize;

                fn(qr, context, settings, l, t, w, row, col);
            }
        }
        if ($(settings.fill).is('img')) {
            context.strokeStyle = 'rgba(0,0,0,0.5)';
            context.lineWidth = 2;
            context.stroke();
            var prev = context.globalCompositeOperation;
            context.globalCompositeOperation = 'destination-out';
            context.fill();
            context.globalCompositeOperation = prev;

            context.clip();
            context.drawImage(settings.fill, 0, 0, settings.size, settings.size);
            context.restore();
        } else {
            context.fillStyle = settings.fill;
            context.fill();
        }
    }

    // Draws QR code to the given `canvas` and returns it.
    function drawOnCanvas(canvas, settings) {

        var qr = createQRCode(settings.text, settings.ecLevel, settings.minVersion, settings.maxVersion, settings.quiet);
        if (!qr) {
            return null;
        }

        var $canvas = $(canvas).data('qrcode', qr);
        var context = $canvas[0].getContext('2d');

        drawBackground(qr, context, settings);
        drawModules(qr, context, settings);

        return $canvas;
    }

    // Returns a `canvas` element representing the QR code for the given settings.
    function createCanvas(settings) {

        var $canvas = $('<canvas/>').attr('width', settings.size).attr('height', settings.size);
        return drawOnCanvas($canvas, settings);
    }

    // Returns an `image` element representing the QR code for the given settings.
    function createImage(settings) {

        return $('<img/>').attr('src', createCanvas(settings)[0].toDataURL('image/png'));
    }

    // Returns a `div` element representing the QR code for the given settings.
    function createDiv(settings) {

        var qr = createQRCode(settings.text, settings.ecLevel, settings.minVersion, settings.maxVersion, settings.quiet);
        if (!qr) {
            return null;
        }

        // some shortcuts to improve compression
        var settings_size = settings.size;
        var settings_bgColor = settings.background;
        var math_floor = Math.floor;

        var moduleCount = qr.moduleCount;
        var moduleSize = math_floor(settings_size / moduleCount);
        var offset = math_floor(0.5 * (settings_size - moduleSize * moduleCount));

        var row;
        var col;

        var containerCSS = {
                position: 'relative',
                left: 0,
                top: 0,
                padding: 0,
                margin: 0,
                width: settings_size,
                height: settings_size
            };
        var darkCSS = {
                position: 'absolute',
                padding: 0,
                margin: 0,
                width: moduleSize,
                height: moduleSize,
                'background-color': settings.fill
            };

        var $div = $('<div/>').data('qrcode', qr).css(containerCSS);

        if (settings_bgColor) {
            $div.css('background-color', settings_bgColor);
        }

        for (row = 0; row < moduleCount; row += 1) {
            for (col = 0; col < moduleCount; col += 1) {
                if (qr.isDark(row, col)) {
                    $('<div/>')
                        .css(darkCSS)
                        .css({
                            left: offset + col * moduleSize,
                            top: offset + row * moduleSize
                        })
                        .appendTo($div);
                }
            }
        }

        return $div;
    }

    function createHTML(settings) {

        if (hasCanvas && settings.render === 'canvas') {
            return createCanvas(settings);
        } else if (hasCanvas && settings.render === 'image') {
            return createImage(settings);
        }

        return createDiv(settings);
    }

    // Plugin
    // ======

    // Default settings
    // ----------------
    var defaults = {

        // render method: `'canvas'`, `'image'` or `'div'`
        render: 'canvas',

        // version range somewhere in 1 .. 40
        minVersion: 1,
        maxVersion: 40,

        // error correction level: `'L'`, `'M'`, `'Q'` or `'H'`
        ecLevel: 'L',

        // offset in pixel if drawn onto existing canvas
        left: 0,
        top: 0,

        // size in pixel
        size: 200,

        // code color or image element
        fill: '#000',

        // background color or image element, `null` for transparent background
        background: null,

        // content
        text: 'no text',

        // corner radius relative to module width: 0.0 .. 0.5
        radius: 0,

        // quiet zone in modules
        quiet: 0,

        // modes
        // 0: normal
        // 1: label strip
        // 2: label box
        // 3: image strip
        // 4: image box
        mode: 0,

        mSize: 0.1,
        mPosX: 0.5,
        mPosY: 0.5,

        label: 'no label',
        fontname: 'sans',
        fontcolor: '#000',

        image: null
    };

    // Register the plugin
    // -------------------
    $.fn.qrcode = function (options) {

        var settings = $.extend({}, defaults, options);

        return this.each(function () {

            if (this.nodeName.toLowerCase() === 'canvas') {
                drawOnCanvas(this, settings);
            } else {
                $(this).append(createHTML(settings));
            }
        });
    };
}(function () {

    // `qrcode` is the single public function defined by the `QR Code Generator`
    //---------------------------------------------------------------------
    //
    // QR Code Generator for JavaScript
    //
    // Copyright (c) 2009 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //  http://www.opensource.org/licenses/mit-license.php
    //
    // The word 'QR Code' is registered trademark of
    // DENSO WAVE INCORPORATED
    //  http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------

    var qrcode = function() {

      //---------------------------------------------------------------------
      // qrcode
      //---------------------------------------------------------------------

      /**
       * qrcode
       * @param typeNumber 1 to 40
       * @param errorCorrectLevel 'L','M','Q','H'
       */
      var qrcode = function(typeNumber, errorCorrectLevel) {

        var PAD0 = 0xEC;
        var PAD1 = 0x11;

        var _typeNumber = typeNumber;
        var _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];
        var _modules = null;
        var _moduleCount = 0;
        var _dataCache = null;
        var _dataList = new Array();

        var _this = {};

        var makeImpl = function(test, maskPattern) {

          _moduleCount = _typeNumber * 4 + 17;
          _modules = function(moduleCount) {
            var modules = new Array(moduleCount);
            for (var row = 0; row < moduleCount; row += 1) {
              modules[row] = new Array(moduleCount);
              for (var col = 0; col < moduleCount; col += 1) {
                modules[row][col] = null;
              }
            }
            return modules;
          }(_moduleCount);

          setupPositionProbePattern(0, 0);
          setupPositionProbePattern(_moduleCount - 7, 0);
          setupPositionProbePattern(0, _moduleCount - 7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test, maskPattern);

          if (_typeNumber >= 7) {
            setupTypeNumber(test);
          }

          if (_dataCache == null) {
            _dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList);
          }

          mapData(_dataCache, maskPattern);
        };

        var setupPositionProbePattern = function(row, col) {

          for (var r = -1; r <= 7; r += 1) {

            if (row + r <= -1 || _moduleCount <= row + r) continue;

            for (var c = -1; c <= 7; c += 1) {

              if (col + c <= -1 || _moduleCount <= col + c) continue;

              if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
                  || (0 <= c && c <= 6 && (r == 0 || r == 6) )
                  || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        };

        var getBestMaskPattern = function() {

          var minLostPoint = 0;
          var pattern = 0;

          for (var i = 0; i < 8; i += 1) {

            makeImpl(true, i);

            var lostPoint = QRUtil.getLostPoint(_this);

            if (i == 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i;
            }
          }

          return pattern;
        };

        var setupTimingPattern = function() {

          for (var r = 8; r < _moduleCount - 8; r += 1) {
            if (_modules[r][6] != null) {
              continue;
            }
            _modules[r][6] = (r % 2 == 0);
          }

          for (var c = 8; c < _moduleCount - 8; c += 1) {
            if (_modules[6][c] != null) {
              continue;
            }
            _modules[6][c] = (c % 2 == 0);
          }
        };

        var setupPositionAdjustPattern = function() {

          var pos = QRUtil.getPatternPosition(_typeNumber);

          for (var i = 0; i < pos.length; i += 1) {

            for (var j = 0; j < pos.length; j += 1) {

              var row = pos[i];
              var col = pos[j];

              if (_modules[row][col] != null) {
                continue;
              }

              for (var r = -2; r <= 2; r += 1) {

                for (var c = -2; c <= 2; c += 1) {

                  if (r == -2 || r == 2 || c == -2 || c == 2
                      || (r == 0 && c == 0) ) {
                    _modules[row + r][col + c] = true;
                  } else {
                    _modules[row + r][col + c] = false;
                  }
                }
              }
            }
          }
        };

        var setupTypeNumber = function(test) {

          var bits = QRUtil.getBCHTypeNumber(_typeNumber);

          for (var i = 0; i < 18; i += 1) {
            var mod = (!test && ( (bits >> i) & 1) == 1);
            _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
          }

          for (var i = 0; i < 18; i += 1) {
            var mod = (!test && ( (bits >> i) & 1) == 1);
            _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
          }
        };

        var setupTypeInfo = function(test, maskPattern) {

          var data = (_errorCorrectLevel << 3) | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);

          // vertical
          for (var i = 0; i < 15; i += 1) {

            var mod = (!test && ( (bits >> i) & 1) == 1);

            if (i < 6) {
              _modules[i][8] = mod;
            } else if (i < 8) {
              _modules[i + 1][8] = mod;
            } else {
              _modules[_moduleCount - 15 + i][8] = mod;
            }
          }

          // horizontal
          for (var i = 0; i < 15; i += 1) {

            var mod = (!test && ( (bits >> i) & 1) == 1);

            if (i < 8) {
              _modules[8][_moduleCount - i - 1] = mod;
            } else if (i < 9) {
              _modules[8][15 - i - 1 + 1] = mod;
            } else {
              _modules[8][15 - i - 1] = mod;
            }
          }

          // fixed module
          _modules[_moduleCount - 8][8] = (!test);
        };

        var mapData = function(data, maskPattern) {

          var inc = -1;
          var row = _moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          var maskFunc = QRUtil.getMaskFunction(maskPattern);

          for (var col = _moduleCount - 1; col > 0; col -= 2) {

            if (col == 6) col -= 1;

            while (true) {

              for (var c = 0; c < 2; c += 1) {

                if (_modules[row][col - c] == null) {

                  var dark = false;

                  if (byteIndex < data.length) {
                    dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
                  }

                  var mask = maskFunc(row, col - c);

                  if (mask) {
                    dark = !dark;
                  }

                  _modules[row][col - c] = dark;
                  bitIndex -= 1;

                  if (bitIndex == -1) {
                    byteIndex += 1;
                    bitIndex = 7;
                  }
                }
              }

              row += inc;

              if (row < 0 || _moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };

        var createBytes = function(buffer, rsBlocks) {

          var offset = 0;

          var maxDcCount = 0;
          var maxEcCount = 0;

          var dcdata = new Array(rsBlocks.length);
          var ecdata = new Array(rsBlocks.length);

          for (var r = 0; r < rsBlocks.length; r += 1) {

            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;

            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);

            dcdata[r] = new Array(dcCount);

            for (var i = 0; i < dcdata[r].length; i += 1) {
              dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
            }
            offset += dcCount;

            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (var i = 0; i < ecdata[r].length; i += 1) {
              var modIndex = i + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
            }
          }

          var totalCodeCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalCodeCount += rsBlocks[i].totalCount;
          }

          var data = new Array(totalCodeCount);
          var index = 0;

          for (var i = 0; i < maxDcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < dcdata[r].length) {
                data[index] = dcdata[r][i];
                index += 1;
              }
            }
          }

          for (var i = 0; i < maxEcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < ecdata[r].length) {
                data[index] = ecdata[r][i];
                index += 1;
              }
            }
          }

          return data;
        };

        var createData = function(typeNumber, errorCorrectLevel, dataList) {

          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);

          var buffer = qrBitBuffer();

          for (var i = 0; i < dataList.length; i += 1) {
            var data = dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          // calc num max data.
          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw new Error('code length overflow. ('
              + buffer.getLengthInBits()
              + '>'
              + totalDataCount * 8
              + ')');
          }

          // end code
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }

          // padding
          while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
          }

          // padding
          while (true) {

            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD0, 8);

            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD1, 8);
          }

          return createBytes(buffer, rsBlocks);
        };

        _this.addData = function(data) {
          var newData = qr8BitByte(data);
          _dataList.push(newData);
          _dataCache = null;
        };

        _this.isDark = function(row, col) {
          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
            throw new Error(row + ',' + col);
          }
          return _modules[row][col];
        };

        _this.getModuleCount = function() {
          return _moduleCount;
        };

        _this.make = function() {
          makeImpl(false, getBestMaskPattern() );
        };

        _this.createTableTag = function(cellSize, margin) {

          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

          var qrHtml = '';

          qrHtml += '<table style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
          qrHtml += '">';
          qrHtml += '<tbody>';

          for (var r = 0; r < _this.getModuleCount(); r += 1) {

            qrHtml += '<tr>';

            for (var c = 0; c < _this.getModuleCount(); c += 1) {
              qrHtml += '<td style="';
              qrHtml += ' border-width: 0px; border-style: none;';
              qrHtml += ' border-collapse: collapse;';
              qrHtml += ' padding: 0px; margin: 0px;';
              qrHtml += ' width: ' + cellSize + 'px;';
              qrHtml += ' height: ' + cellSize + 'px;';
              qrHtml += ' background-color: ';
              qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
              qrHtml += ';';
              qrHtml += '"/>';
            }

            qrHtml += '</tr>';
          }

          qrHtml += '</tbody>';
          qrHtml += '</table>';

          return qrHtml;
        };

        _this.createImgTag = function(cellSize, margin) {

          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;

          return createImgTag(size, size, function(x, y) {
            if (min <= x && x < max && min <= y && y < max) {
              var c = Math.floor( (x - min) / cellSize);
              var r = Math.floor( (y - min) / cellSize);
              return _this.isDark(r, c)? 0 : 1;
            } else {
              return 1;
            }
          } );
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // qrcode.stringToBytes
      //---------------------------------------------------------------------

      qrcode.stringToBytes = function(s) {
        var bytes = new Array();
        for (var i = 0; i < s.length; i += 1) {
          var c = s.charCodeAt(i);
          bytes.push(c & 0xff);
        }
        return bytes;
      };

      //---------------------------------------------------------------------
      // qrcode.createStringToBytes
      //---------------------------------------------------------------------

      /**
       * @param unicodeData base64 string of byte array.
       * [16bit Unicode],[16bit Bytes], ...
       * @param numChars
       */
      qrcode.createStringToBytes = function(unicodeData, numChars) {

        // create conversion map.

        var unicodeMap = function() {

          var bin = base64DecodeInputStream(unicodeData);
          var read = function() {
            var b = bin.read();
            if (b == -1) throw new Error();
            return b;
          };

          var count = 0;
          var unicodeMap = {};
          while (true) {
            var b0 = bin.read();
            if (b0 == -1) break;
            var b1 = read();
            var b2 = read();
            var b3 = read();
            var k = String.fromCharCode( (b0 << 8) | b1);
            var v = (b2 << 8) | b3;
            unicodeMap[k] = v;
            count += 1;
          }
          if (count != numChars) {
            throw new Error(count + ' != ' + numChars);
          }

          return unicodeMap;
        }();

        var unknownChar = '?'.charCodeAt(0);

        return function(s) {
          var bytes = new Array();
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            if (c < 128) {
              bytes.push(c);
            } else {
              var b = unicodeMap[s.charAt(i)];
              if (typeof b == 'number') {
                if ( (b & 0xff) == b) {
                  // 1byte
                  bytes.push(b);
                } else {
                  // 2bytes
                  bytes.push(b >>> 8);
                  bytes.push(b & 0xff);
                }
              } else {
                bytes.push(unknownChar);
              }
            }
          }
          return bytes;
        };
      };

      //---------------------------------------------------------------------
      // QRMode
      //---------------------------------------------------------------------

      var QRMode = {
        MODE_NUMBER :    1 << 0,
        MODE_ALPHA_NUM : 1 << 1,
        MODE_8BIT_BYTE : 1 << 2,
        MODE_KANJI :     1 << 3
      };

      //---------------------------------------------------------------------
      // QRErrorCorrectLevel
      //---------------------------------------------------------------------

      var QRErrorCorrectLevel = {
        L : 1,
        M : 0,
        Q : 3,
        H : 2
      };

      //---------------------------------------------------------------------
      // QRMaskPattern
      //---------------------------------------------------------------------

      var QRMaskPattern = {
        PATTERN000 : 0,
        PATTERN001 : 1,
        PATTERN010 : 2,
        PATTERN011 : 3,
        PATTERN100 : 4,
        PATTERN101 : 5,
        PATTERN110 : 6,
        PATTERN111 : 7
      };

      //---------------------------------------------------------------------
      // QRUtil
      //---------------------------------------------------------------------

      var QRUtil = function() {

        var PATTERN_POSITION_TABLE = [
          [],
          [6, 18],
          [6, 22],
          [6, 26],
          [6, 30],
          [6, 34],
          [6, 22, 38],
          [6, 24, 42],
          [6, 26, 46],
          [6, 28, 50],
          [6, 30, 54],
          [6, 32, 58],
          [6, 34, 62],
          [6, 26, 46, 66],
          [6, 26, 48, 70],
          [6, 26, 50, 74],
          [6, 30, 54, 78],
          [6, 30, 56, 82],
          [6, 30, 58, 86],
          [6, 34, 62, 90],
          [6, 28, 50, 72, 94],
          [6, 26, 50, 74, 98],
          [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106],
          [6, 32, 58, 84, 110],
          [6, 30, 58, 86, 114],
          [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122],
          [6, 30, 54, 78, 102, 126],
          [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134],
          [6, 34, 60, 86, 112, 138],
          [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146],
          [6, 30, 54, 78, 102, 126, 150],
          [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158],
          [6, 32, 58, 84, 110, 136, 162],
          [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ];
        var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
        var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
        var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

        var _this = {};

        var getBCHDigit = function(data) {
          var digit = 0;
          while (data != 0) {
            digit += 1;
            data >>>= 1;
          }
          return digit;
        };

        _this.getBCHTypeInfo = function(data) {
          var d = data << 10;
          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
            d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
          }
          return ( (data << 10) | d) ^ G15_MASK;
        };

        _this.getBCHTypeNumber = function(data) {
          var d = data << 12;
          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
            d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
          }
          return (data << 12) | d;
        };

        _this.getPatternPosition = function(typeNumber) {
          return PATTERN_POSITION_TABLE[typeNumber - 1];
        };

        _this.getMaskFunction = function(maskPattern) {

          switch (maskPattern) {

          case QRMaskPattern.PATTERN000 :
            return function(i, j) { return (i + j) % 2 == 0; };
          case QRMaskPattern.PATTERN001 :
            return function(i, j) { return i % 2 == 0; };
          case QRMaskPattern.PATTERN010 :
            return function(i, j) { return j % 3 == 0; };
          case QRMaskPattern.PATTERN011 :
            return function(i, j) { return (i + j) % 3 == 0; };
          case QRMaskPattern.PATTERN100 :
            return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
          case QRMaskPattern.PATTERN101 :
            return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
          case QRMaskPattern.PATTERN110 :
            return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
          case QRMaskPattern.PATTERN111 :
            return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

          default :
            throw new Error('bad maskPattern:' + maskPattern);
          }
        };

        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
          var a = qrPolynomial([1], 0);
          for (var i = 0; i < errorCorrectLength; i += 1) {
            a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
          }
          return a;
        };

        _this.getLengthInBits = function(mode, type) {

          if (1 <= type && type < 10) {

            // 1 - 9

            switch(mode) {
            case QRMode.MODE_NUMBER    : return 10;
            case QRMode.MODE_ALPHA_NUM : return 9;
            case QRMode.MODE_8BIT_BYTE : return 8;
            case QRMode.MODE_KANJI     : return 8;
            default :
              throw new Error('mode:' + mode);
            }

          } else if (type < 27) {

            // 10 - 26

            switch(mode) {
            case QRMode.MODE_NUMBER    : return 12;
            case QRMode.MODE_ALPHA_NUM : return 11;
            case QRMode.MODE_8BIT_BYTE : return 16;
            case QRMode.MODE_KANJI     : return 10;
            default :
              throw new Error('mode:' + mode);
            }

          } else if (type < 41) {

            // 27 - 40

            switch(mode) {
            case QRMode.MODE_NUMBER    : return 14;
            case QRMode.MODE_ALPHA_NUM : return 13;
            case QRMode.MODE_8BIT_BYTE : return 16;
            case QRMode.MODE_KANJI     : return 12;
            default :
              throw new Error('mode:' + mode);
            }

          } else {
            throw new Error('type:' + type);
          }
        };

        _this.getLostPoint = function(qrcode) {

          var moduleCount = qrcode.getModuleCount();

          var lostPoint = 0;

          // LEVEL1

          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount; col += 1) {

              var sameCount = 0;
              var dark = qrcode.isDark(row, col);

              for (var r = -1; r <= 1; r += 1) {

                if (row + r < 0 || moduleCount <= row + r) {
                  continue;
                }

                for (var c = -1; c <= 1; c += 1) {

                  if (col + c < 0 || moduleCount <= col + c) {
                    continue;
                  }

                  if (r == 0 && c == 0) {
                    continue;
                  }

                  if (dark == qrcode.isDark(row + r, col + c) ) {
                    sameCount += 1;
                  }
                }
              }

              if (sameCount > 5) {
                lostPoint += (3 + sameCount - 5);
              }
            }
          };

          // LEVEL2

          for (var row = 0; row < moduleCount - 1; row += 1) {
            for (var col = 0; col < moduleCount - 1; col += 1) {
              var count = 0;
              if (qrcode.isDark(row, col) ) count += 1;
              if (qrcode.isDark(row + 1, col) ) count += 1;
              if (qrcode.isDark(row, col + 1) ) count += 1;
              if (qrcode.isDark(row + 1, col + 1) ) count += 1;
              if (count == 0 || count == 4) {
                lostPoint += 3;
              }
            }
          }

          // LEVEL3

          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount - 6; col += 1) {
              if (qrcode.isDark(row, col)
                  && !qrcode.isDark(row, col + 1)
                  &&  qrcode.isDark(row, col + 2)
                  &&  qrcode.isDark(row, col + 3)
                  &&  qrcode.isDark(row, col + 4)
                  && !qrcode.isDark(row, col + 5)
                  &&  qrcode.isDark(row, col + 6) ) {
                lostPoint += 40;
              }
            }
          }

          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount - 6; row += 1) {
              if (qrcode.isDark(row, col)
                  && !qrcode.isDark(row + 1, col)
                  &&  qrcode.isDark(row + 2, col)
                  &&  qrcode.isDark(row + 3, col)
                  &&  qrcode.isDark(row + 4, col)
                  && !qrcode.isDark(row + 5, col)
                  &&  qrcode.isDark(row + 6, col) ) {
                lostPoint += 40;
              }
            }
          }

          // LEVEL4

          var darkCount = 0;

          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount; row += 1) {
              if (qrcode.isDark(row, col) ) {
                darkCount += 1;
              }
            }
          }

          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;

          return lostPoint;
        };

        return _this;
      }();

      //---------------------------------------------------------------------
      // QRMath
      //---------------------------------------------------------------------

      var QRMath = function() {

        var EXP_TABLE = new Array(256);
        var LOG_TABLE = new Array(256);

        // initialize tables
        for (var i = 0; i < 8; i += 1) {
          EXP_TABLE[i] = 1 << i;
        }
        for (var i = 8; i < 256; i += 1) {
          EXP_TABLE[i] = EXP_TABLE[i - 4]
            ^ EXP_TABLE[i - 5]
            ^ EXP_TABLE[i - 6]
            ^ EXP_TABLE[i - 8];
        }
        for (var i = 0; i < 255; i += 1) {
          LOG_TABLE[EXP_TABLE[i] ] = i;
        }

        var _this = {};

        _this.glog = function(n) {

          if (n < 1) {
            throw new Error('glog(' + n + ')');
          }

          return LOG_TABLE[n];
        };

        _this.gexp = function(n) {

          while (n < 0) {
            n += 255;
          }

          while (n >= 256) {
            n -= 255;
          }

          return EXP_TABLE[n];
        };

        return _this;
      }();

      //---------------------------------------------------------------------
      // qrPolynomial
      //---------------------------------------------------------------------

      function qrPolynomial(num, shift) {

        if (typeof num.length == 'undefined') {
          throw new Error(num.length + '/' + shift);
        }

        var _num = function() {
          var offset = 0;
          while (offset < num.length && num[offset] == 0) {
            offset += 1;
          }
          var _num = new Array(num.length - offset + shift);
          for (var i = 0; i < num.length - offset; i += 1) {
            _num[i] = num[i + offset];
          }
          return _num;
        }();

        var _this = {};

        _this.getAt = function(index) {
          return _num[index];
        };

        _this.getLength = function() {
          return _num.length;
        };

        _this.multiply = function(e) {

          var num = new Array(_this.getLength() + e.getLength() - 1);

          for (var i = 0; i < _this.getLength(); i += 1) {
            for (var j = 0; j < e.getLength(); j += 1) {
              num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
            }
          }

          return qrPolynomial(num, 0);
        };

        _this.mod = function(e) {

          if (_this.getLength() - e.getLength() < 0) {
            return _this;
          }

          var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

          var num = new Array(_this.getLength() );
          for (var i = 0; i < _this.getLength(); i += 1) {
            num[i] = _this.getAt(i);
          }

          for (var i = 0; i < e.getLength(); i += 1) {
            num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
          }

          // recursive call
          return qrPolynomial(num, 0).mod(e);
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // QRRSBlock
      //---------------------------------------------------------------------

      var QRRSBlock = function() {

        var RS_BLOCK_TABLE = [

          // L
          // M
          // Q
          // H

          // 1
          [1, 26, 19],
          [1, 26, 16],
          [1, 26, 13],
          [1, 26, 9],

          // 2
          [1, 44, 34],
          [1, 44, 28],
          [1, 44, 22],
          [1, 44, 16],

          // 3
          [1, 70, 55],
          [1, 70, 44],
          [2, 35, 17],
          [2, 35, 13],

          // 4
          [1, 100, 80],
          [2, 50, 32],
          [2, 50, 24],
          [4, 25, 9],

          // 5
          [1, 134, 108],
          [2, 67, 43],
          [2, 33, 15, 2, 34, 16],
          [2, 33, 11, 2, 34, 12],

          // 6
          [2, 86, 68],
          [4, 43, 27],
          [4, 43, 19],
          [4, 43, 15],

          // 7
          [2, 98, 78],
          [4, 49, 31],
          [2, 32, 14, 4, 33, 15],
          [4, 39, 13, 1, 40, 14],

          // 8
          [2, 121, 97],
          [2, 60, 38, 2, 61, 39],
          [4, 40, 18, 2, 41, 19],
          [4, 40, 14, 2, 41, 15],

          // 9
          [2, 146, 116],
          [3, 58, 36, 2, 59, 37],
          [4, 36, 16, 4, 37, 17],
          [4, 36, 12, 4, 37, 13],

          // 10
          [2, 86, 68, 2, 87, 69],
          [4, 69, 43, 1, 70, 44],
          [6, 43, 19, 2, 44, 20],
          [6, 43, 15, 2, 44, 16],

          // 11
          [4, 101, 81],
          [1, 80, 50, 4, 81, 51],
          [4, 50, 22, 4, 51, 23],
          [3, 36, 12, 8, 37, 13],

          // 12
          [2, 116, 92, 2, 117, 93],
          [6, 58, 36, 2, 59, 37],
          [4, 46, 20, 6, 47, 21],
          [7, 42, 14, 4, 43, 15],

          // 13
          [4, 133, 107],
          [8, 59, 37, 1, 60, 38],
          [8, 44, 20, 4, 45, 21],
          [12, 33, 11, 4, 34, 12],

          // 14
          [3, 145, 115, 1, 146, 116],
          [4, 64, 40, 5, 65, 41],
          [11, 36, 16, 5, 37, 17],
          [11, 36, 12, 5, 37, 13],

          // 15
          [5, 109, 87, 1, 110, 88],
          [5, 65, 41, 5, 66, 42],
          [5, 54, 24, 7, 55, 25],
          [11, 36, 12, 7, 37, 13],

          // 16
          [5, 122, 98, 1, 123, 99],
          [7, 73, 45, 3, 74, 46],
          [15, 43, 19, 2, 44, 20],
          [3, 45, 15, 13, 46, 16],

          // 17
          [1, 135, 107, 5, 136, 108],
          [10, 74, 46, 1, 75, 47],
          [1, 50, 22, 15, 51, 23],
          [2, 42, 14, 17, 43, 15],

          // 18
          [5, 150, 120, 1, 151, 121],
          [9, 69, 43, 4, 70, 44],
          [17, 50, 22, 1, 51, 23],
          [2, 42, 14, 19, 43, 15],

          // 19
          [3, 141, 113, 4, 142, 114],
          [3, 70, 44, 11, 71, 45],
          [17, 47, 21, 4, 48, 22],
          [9, 39, 13, 16, 40, 14],

          // 20
          [3, 135, 107, 5, 136, 108],
          [3, 67, 41, 13, 68, 42],
          [15, 54, 24, 5, 55, 25],
          [15, 43, 15, 10, 44, 16],

          // 21
          [4, 144, 116, 4, 145, 117],
          [17, 68, 42],
          [17, 50, 22, 6, 51, 23],
          [19, 46, 16, 6, 47, 17],

          // 22
          [2, 139, 111, 7, 140, 112],
          [17, 74, 46],
          [7, 54, 24, 16, 55, 25],
          [34, 37, 13],

          // 23
          [4, 151, 121, 5, 152, 122],
          [4, 75, 47, 14, 76, 48],
          [11, 54, 24, 14, 55, 25],
          [16, 45, 15, 14, 46, 16],

          // 24
          [6, 147, 117, 4, 148, 118],
          [6, 73, 45, 14, 74, 46],
          [11, 54, 24, 16, 55, 25],
          [30, 46, 16, 2, 47, 17],

          // 25
          [8, 132, 106, 4, 133, 107],
          [8, 75, 47, 13, 76, 48],
          [7, 54, 24, 22, 55, 25],
          [22, 45, 15, 13, 46, 16],

          // 26
          [10, 142, 114, 2, 143, 115],
          [19, 74, 46, 4, 75, 47],
          [28, 50, 22, 6, 51, 23],
          [33, 46, 16, 4, 47, 17],

          // 27
          [8, 152, 122, 4, 153, 123],
          [22, 73, 45, 3, 74, 46],
          [8, 53, 23, 26, 54, 24],
          [12, 45, 15, 28, 46, 16],

          // 28
          [3, 147, 117, 10, 148, 118],
          [3, 73, 45, 23, 74, 46],
          [4, 54, 24, 31, 55, 25],
          [11, 45, 15, 31, 46, 16],

          // 29
          [7, 146, 116, 7, 147, 117],
          [21, 73, 45, 7, 74, 46],
          [1, 53, 23, 37, 54, 24],
          [19, 45, 15, 26, 46, 16],

          // 30
          [5, 145, 115, 10, 146, 116],
          [19, 75, 47, 10, 76, 48],
          [15, 54, 24, 25, 55, 25],
          [23, 45, 15, 25, 46, 16],

          // 31
          [13, 145, 115, 3, 146, 116],
          [2, 74, 46, 29, 75, 47],
          [42, 54, 24, 1, 55, 25],
          [23, 45, 15, 28, 46, 16],

          // 32
          [17, 145, 115],
          [10, 74, 46, 23, 75, 47],
          [10, 54, 24, 35, 55, 25],
          [19, 45, 15, 35, 46, 16],

          // 33
          [17, 145, 115, 1, 146, 116],
          [14, 74, 46, 21, 75, 47],
          [29, 54, 24, 19, 55, 25],
          [11, 45, 15, 46, 46, 16],

          // 34
          [13, 145, 115, 6, 146, 116],
          [14, 74, 46, 23, 75, 47],
          [44, 54, 24, 7, 55, 25],
          [59, 46, 16, 1, 47, 17],

          // 35
          [12, 151, 121, 7, 152, 122],
          [12, 75, 47, 26, 76, 48],
          [39, 54, 24, 14, 55, 25],
          [22, 45, 15, 41, 46, 16],

          // 36
          [6, 151, 121, 14, 152, 122],
          [6, 75, 47, 34, 76, 48],
          [46, 54, 24, 10, 55, 25],
          [2, 45, 15, 64, 46, 16],

          // 37
          [17, 152, 122, 4, 153, 123],
          [29, 74, 46, 14, 75, 47],
          [49, 54, 24, 10, 55, 25],
          [24, 45, 15, 46, 46, 16],

          // 38
          [4, 152, 122, 18, 153, 123],
          [13, 74, 46, 32, 75, 47],
          [48, 54, 24, 14, 55, 25],
          [42, 45, 15, 32, 46, 16],

          // 39
          [20, 147, 117, 4, 148, 118],
          [40, 75, 47, 7, 76, 48],
          [43, 54, 24, 22, 55, 25],
          [10, 45, 15, 67, 46, 16],

          // 40
          [19, 148, 118, 6, 149, 119],
          [18, 75, 47, 31, 76, 48],
          [34, 54, 24, 34, 55, 25],
          [20, 45, 15, 61, 46, 16]
        ];

        var qrRSBlock = function(totalCount, dataCount) {
          var _this = {};
          _this.totalCount = totalCount;
          _this.dataCount = dataCount;
          return _this;
        };

        var _this = {};

        var getRsBlockTable = function(typeNumber, errorCorrectLevel) {

          switch(errorCorrectLevel) {
          case QRErrorCorrectLevel.L :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
          case QRErrorCorrectLevel.M :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
          case QRErrorCorrectLevel.Q :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
          case QRErrorCorrectLevel.H :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
          default :
            return undefined;
          }
        };

        _this.getRSBlocks = function(typeNumber, errorCorrectLevel) {

          var rsBlock = getRsBlockTable(typeNumber, errorCorrectLevel);

          if (typeof rsBlock == 'undefined') {
            throw new Error('bad rs block @ typeNumber:' + typeNumber +
                '/errorCorrectLevel:' + errorCorrectLevel);
          }

          var length = rsBlock.length / 3;

          var list = new Array();

          for (var i = 0; i < length; i += 1) {

            var count = rsBlock[i * 3 + 0];
            var totalCount = rsBlock[i * 3 + 1];
            var dataCount = rsBlock[i * 3 + 2];

            for (var j = 0; j < count; j += 1) {
              list.push(qrRSBlock(totalCount, dataCount) );
            }
          }

          return list;
        };

        return _this;
      }();

      //---------------------------------------------------------------------
      // qrBitBuffer
      //---------------------------------------------------------------------

      var qrBitBuffer = function() {

        var _buffer = new Array();
        var _length = 0;

        var _this = {};

        _this.getBuffer = function() {
          return _buffer;
        };

        _this.getAt = function(index) {
          var bufIndex = Math.floor(index / 8);
          return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
        };

        _this.put = function(num, length) {
          for (var i = 0; i < length; i += 1) {
            _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
          }
        };

        _this.getLengthInBits = function() {
          return _length;
        };

        _this.putBit = function(bit) {

          var bufIndex = Math.floor(_length / 8);
          if (_buffer.length <= bufIndex) {
            _buffer.push(0);
          }

          if (bit) {
            _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
          }

          _length += 1;
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // qr8BitByte
      //---------------------------------------------------------------------

      var qr8BitByte = function(data) {

        var _mode = QRMode.MODE_8BIT_BYTE;
        var _data = data;
        var _bytes = qrcode.stringToBytes(data);

        var _this = {};

        _this.getMode = function() {
          return _mode;
        };

        _this.getLength = function(buffer) {
          return _bytes.length;
        };

        _this.write = function(buffer) {
          for (var i = 0; i < _bytes.length; i += 1) {
            buffer.put(_bytes[i], 8);
          }
        };

        return _this;
      };

      //=====================================================================
      // GIF Support etc.
      //

      //---------------------------------------------------------------------
      // byteArrayOutputStream
      //---------------------------------------------------------------------

      var byteArrayOutputStream = function() {

        var _bytes = new Array();

        var _this = {};

        _this.writeByte = function(b) {
          _bytes.push(b & 0xff);
        };

        _this.writeShort = function(i) {
          _this.writeByte(i);
          _this.writeByte(i >>> 8);
        };

        _this.writeBytes = function(b, off, len) {
          off = off || 0;
          len = len || b.length;
          for (var i = 0; i < len; i += 1) {
            _this.writeByte(b[i + off]);
          }
        };

        _this.writeString = function(s) {
          for (var i = 0; i < s.length; i += 1) {
            _this.writeByte(s.charCodeAt(i) );
          }
        };

        _this.toByteArray = function() {
          return _bytes;
        };

        _this.toString = function() {
          var s = '';
          s += '[';
          for (var i = 0; i < _bytes.length; i += 1) {
            if (i > 0) {
              s += ',';
            }
            s += _bytes[i];
          }
          s += ']';
          return s;
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // base64EncodeOutputStream
      //---------------------------------------------------------------------

      var base64EncodeOutputStream = function() {

        var _buffer = 0;
        var _buflen = 0;
        var _length = 0;
        var _base64 = '';

        var _this = {};

        var writeEncoded = function(b) {
          _base64 += String.fromCharCode(encode(b & 0x3f) );
        };

        var encode = function(n) {
          if (n < 0) {
            // error.
          } else if (n < 26) {
            return 0x41 + n;
          } else if (n < 52) {
            return 0x61 + (n - 26);
          } else if (n < 62) {
            return 0x30 + (n - 52);
          } else if (n == 62) {
            return 0x2b;
          } else if (n == 63) {
            return 0x2f;
          }
          throw new Error('n:' + n);
        };

        _this.writeByte = function(n) {

          _buffer = (_buffer << 8) | (n & 0xff);
          _buflen += 8;
          _length += 1;

          while (_buflen >= 6) {
            writeEncoded(_buffer >>> (_buflen - 6) );
            _buflen -= 6;
          }
        };

        _this.flush = function() {

          if (_buflen > 0) {
            writeEncoded(_buffer << (6 - _buflen) );
            _buffer = 0;
            _buflen = 0;
          }

          if (_length % 3 != 0) {
            // padding
            var padlen = 3 - _length % 3;
            for (var i = 0; i < padlen; i += 1) {
              _base64 += '=';
            }
          }
        };

        _this.toString = function() {
          return _base64;
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // base64DecodeInputStream
      //---------------------------------------------------------------------

      var base64DecodeInputStream = function(str) {

        var _str = str;
        var _pos = 0;
        var _buffer = 0;
        var _buflen = 0;

        var _this = {};

        _this.read = function() {

          while (_buflen < 8) {

            if (_pos >= _str.length) {
              if (_buflen == 0) {
                return -1;
              }
              throw new Error('unexpected end of file./' + _buflen);
            }

            var c = _str.charAt(_pos);
            _pos += 1;

            if (c == '=') {
              _buflen = 0;
              return -1;
            } else if (c.match(/^\s$/) ) {
              // ignore if whitespace.
              continue;
            }

            _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
            _buflen += 6;
          }

          var n = (_buffer >>> (_buflen - 8) ) & 0xff;
          _buflen -= 8;
          return n;
        };

        var decode = function(c) {
          if (0x41 <= c && c <= 0x5a) {
            return c - 0x41;
          } else if (0x61 <= c && c <= 0x7a) {
            return c - 0x61 + 26;
          } else if (0x30 <= c && c <= 0x39) {
            return c - 0x30 + 52;
          } else if (c == 0x2b) {
            return 62;
          } else if (c == 0x2f) {
            return 63;
          } else {
            throw new Error('c:' + c);
          }
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // gifImage (B/W)
      //---------------------------------------------------------------------

      var gifImage = function(width, height) {

        var _width = width;
        var _height = height;
        var _data = new Array(width * height);

        var _this = {};

        _this.setPixel = function(x, y, pixel) {
          _data[y * _width + x] = pixel;
        };

        _this.write = function(out) {

          //---------------------------------
          // GIF Signature

          out.writeString('GIF87a');

          //---------------------------------
          // Screen Descriptor

          out.writeShort(_width);
          out.writeShort(_height);

          out.writeByte(0x80); // 2bit
          out.writeByte(0);
          out.writeByte(0);

          //---------------------------------
          // Global Color Map

          // black
          out.writeByte(0x00);
          out.writeByte(0x00);
          out.writeByte(0x00);

          // white
          out.writeByte(0xff);
          out.writeByte(0xff);
          out.writeByte(0xff);

          //---------------------------------
          // Image Descriptor

          out.writeString(',');
          out.writeShort(0);
          out.writeShort(0);
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(0);

          //---------------------------------
          // Local Color Map

          //---------------------------------
          // Raster Data

          var lzwMinCodeSize = 2;
          var raster = getLZWRaster(lzwMinCodeSize);

          out.writeByte(lzwMinCodeSize);

          var offset = 0;

          while (raster.length - offset > 255) {
            out.writeByte(255);
            out.writeBytes(raster, offset, 255);
            offset += 255;
          }

          out.writeByte(raster.length - offset);
          out.writeBytes(raster, offset, raster.length - offset);
          out.writeByte(0x00);

          //---------------------------------
          // GIF Terminator
          out.writeString(';');
        };

        var bitOutputStream = function(out) {

          var _out = out;
          var _bitLength = 0;
          var _bitBuffer = 0;

          var _this = {};

          _this.write = function(data, length) {

            if ( (data >>> length) != 0) {
              throw new Error('length over');
            }

            while (_bitLength + length >= 8) {
              _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
              length -= (8 - _bitLength);
              data >>>= (8 - _bitLength);
              _bitBuffer = 0;
              _bitLength = 0;
            }

            _bitBuffer = (data << _bitLength) | _bitBuffer;
            _bitLength = _bitLength + length;
          };

          _this.flush = function() {
            if (_bitLength > 0) {
              _out.writeByte(_bitBuffer);
            }
          };

          return _this;
        };

        var getLZWRaster = function(lzwMinCodeSize) {

          var clearCode = 1 << lzwMinCodeSize;
          var endCode = (1 << lzwMinCodeSize) + 1;
          var bitLength = lzwMinCodeSize + 1;

          // Setup LZWTable
          var table = lzwTable();

          for (var i = 0; i < clearCode; i += 1) {
            table.add(String.fromCharCode(i) );
          }
          table.add(String.fromCharCode(clearCode) );
          table.add(String.fromCharCode(endCode) );

          var byteOut = byteArrayOutputStream();
          var bitOut = bitOutputStream(byteOut);

          // clear code
          bitOut.write(clearCode, bitLength);

          var dataIndex = 0;

          var s = String.fromCharCode(_data[dataIndex]);
          dataIndex += 1;

          while (dataIndex < _data.length) {

            var c = String.fromCharCode(_data[dataIndex]);
            dataIndex += 1;

            if (table.contains(s + c) ) {

              s = s + c;

            } else {

              bitOut.write(table.indexOf(s), bitLength);

              if (table.size() < 0xfff) {

                if (table.size() == (1 << bitLength) ) {
                  bitLength += 1;
                }

                table.add(s + c);
              }

              s = c;
            }
          }

          bitOut.write(table.indexOf(s), bitLength);

          // end code
          bitOut.write(endCode, bitLength);

          bitOut.flush();

          return byteOut.toByteArray();
        };

        var lzwTable = function() {

          var _map = {};
          var _size = 0;

          var _this = {};

          _this.add = function(key) {
            if (_this.contains(key) ) {
              throw new Error('dup key:' + key);
            }
            _map[key] = _size;
            _size += 1;
          };

          _this.size = function() {
            return _size;
          };

          _this.indexOf = function(key) {
            return _map[key];
          };

          _this.contains = function(key) {
            return typeof _map[key] != 'undefined';
          };

          return _this;
        };

        return _this;
      };

      var createImgTag = function(width, height, getPixel, alt) {

        var gif = gifImage(width, height);
        for (var y = 0; y < height; y += 1) {
          for (var x = 0; x < width; x += 1) {
            gif.setPixel(x, y, getPixel(x, y) );
          }
        }

        var b = byteArrayOutputStream();
        gif.write(b);

        var base64 = base64EncodeOutputStream();
        var bytes = b.toByteArray();
        for (var i = 0; i < bytes.length; i += 1) {
          base64.writeByte(bytes[i]);
        }
        base64.flush();

        var img = '';
        img += '<img';
        img += '\u0020src="';
        img += 'data:image/gif;base64,';
        img += base64;
        img += '"';
        img += '\u0020width="';
        img += width;
        img += '"';
        img += '\u0020height="';
        img += height;
        img += '"';
        if (alt) {
          img += '\u0020alt="';
          img += alt;
          img += '"';
        }
        img += '/>';

        return img;
      };

      //---------------------------------------------------------------------
      // returns qrcode function.

      return qrcode;
    }();

    (function (factory) {
      if (typeof define === 'function' && define.amd) {
          define([], factory);
      } else if (typeof exports === 'object') {
          module.exports = factory();
      }
    }(function () {
        return qrcode;
    }));
    //---------------------------------------------------------------------
    //
    // QR Code Generator for JavaScript UTF8 Support (optional)
    //
    // Copyright (c) 2011 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //  http://www.opensource.org/licenses/mit-license.php
    //
    // The word 'QR Code' is registered trademark of
    // DENSO WAVE INCORPORATED
    //  http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------

    !function(qrcode) {

      //---------------------------------------------------------------------
      // overwrite qrcode.stringToBytes
      //---------------------------------------------------------------------

      qrcode.stringToBytes = function(s) {
        // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
        function toUTF8Array(str) {
          var utf8 = [];
          for (var i=0; i < str.length; i++) {
            var charcode = str.charCodeAt(i);
            if (charcode < 0x80) utf8.push(charcode);
            else if (charcode < 0x800) {
              utf8.push(0xc0 | (charcode >> 6),
                  0x80 | (charcode & 0x3f));
            }
            else if (charcode < 0xd800 || charcode >= 0xe000) {
              utf8.push(0xe0 | (charcode >> 12),
                  0x80 | ((charcode>>6) & 0x3f),
                  0x80 | (charcode & 0x3f));
            }
            // surrogate pair
            else {
              i++;
              // UTF-16 encodes 0x10000-0x10FFFF by
              // subtracting 0x10000 and splitting the
              // 20 bits of 0x0-0xFFFFF into two halves
              charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                | (str.charCodeAt(i) & 0x3ff));
              utf8.push(0xf0 | (charcode >>18),
                  0x80 | ((charcode>>12) & 0x3f),
                  0x80 | ((charcode>>6) & 0x3f),
                  0x80 | (charcode & 0x3f));
            }
          }
          return utf8;
        }
        return toUTF8Array(s);
      };

    }(qrcode);

    return qrcode;
}()));

},{}],99:[function(require,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],100:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTQsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2hqai9tYXJrZWRcbiAqL1xuXG47KGZ1bmN0aW9uKCkge1xuXG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgYmxvY2sgPSB7XG4gIG5ld2xpbmU6IC9eXFxuKy8sXG4gIGNvZGU6IC9eKCB7NH1bXlxcbl0rXFxuKikrLyxcbiAgZmVuY2VzOiBub29wLFxuICBocjogL14oICpbLSpfXSl7Myx9ICooPzpcXG4rfCQpLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICooW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS8sXG4gIG5wdGFibGU6IG5vb3AsXG4gIGxoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICooPzpcXG4rfCQpLyxcbiAgYmxvY2txdW90ZTogL14oICo+W15cXG5dKyhcXG4oPyFkZWYpW15cXG5dKykqXFxuKikrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudCAqKD86XFxufFxccyokKXxjbG9zZWQgKig/OlxcbnsyLH18XFxzKiQpfGNsb3NpbmcgKig/OlxcbnsyLH18XFxzKiQpKS8sXG4gIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICtbXCIoXShbXlxcbl0rKVtcIildKT8gKig/Olxcbit8JCkvLFxuICB0YWJsZTogbm9vcCxcbiAgcGFyYWdyYXBoOiAvXigoPzpbXlxcbl0rXFxuPyg/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXx0YWd8ZGVmKSkrKVxcbiovLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuXG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkK1xcLikvO1xuYmxvY2suaXRlbSA9IC9eKCAqKShidWxsKSBbXlxcbl0qKD86XFxuKD8hXFwxYnVsbCApW15cXG5dKikqLztcbmJsb2NrLml0ZW0gPSByZXBsYWNlKGJsb2NrLml0ZW0sICdnbScpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgpO1xuXG5ibG9jay5saXN0ID0gcmVwbGFjZShibG9jay5saXN0KVxuICAoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/OlstKl9dICopezMsfSg/OlxcXFxuK3wkKSknKVxuICAoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJylcbiAgKCk7XG5cbmJsb2NrLmJsb2NrcXVvdGUgPSByZXBsYWNlKGJsb2NrLmJsb2NrcXVvdGUpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuYmxvY2suX3RhZyA9ICcoPyEoPzonXG4gICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlJ1xuICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICsgJ3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6L3xbXlxcXFx3XFxcXHNAXSpAKVxcXFxiJztcblxuYmxvY2suaHRtbCA9IHJlcGxhY2UoYmxvY2suaHRtbClcbiAgKCdjb21tZW50JywgLzwhLS1bXFxzXFxTXSo/LS0+LylcbiAgKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgKCdjbG9zaW5nJywgLzx0YWcoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vKVxuICAoL3RhZy9nLCBibG9jay5fdGFnKVxuICAoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gcmVwbGFjZShibG9jay5wYXJhZ3JhcGgpXG4gICgnaHInLCBibG9jay5ocilcbiAgKCdoZWFkaW5nJywgYmxvY2suaGVhZGluZylcbiAgKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAoJ2Jsb2NrcXVvdGUnLCBibG9jay5ibG9ja3F1b3RlKVxuICAoJ3RhZycsICc8JyArIGJsb2NrLl90YWcpXG4gICgnZGVmJywgYmxvY2suZGVmKVxuICAoKTtcblxuLyoqXG4gKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLm5vcm1hbCA9IG1lcmdlKHt9LCBibG9jayk7XG5cbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay5nZm0gPSBtZXJnZSh7fSwgYmxvY2subm9ybWFsLCB7XG4gIGZlbmNlczogL14gKihgezMsfXx+ezMsfSlbIFxcLl0qKFxcUyspPyAqXFxuKFtcXHNcXFNdKj8pXFxzKlxcMSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14vLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKyhbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpL1xufSk7XG5cbmJsb2NrLmdmbS5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCcoPyEnLCAnKD8hJ1xuICAgICsgYmxvY2suZ2ZtLmZlbmNlcy5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmxvY2subGlzdC5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgKCk7XG5cbi8qKlxuICogR0ZNICsgVGFibGVzIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay50YWJsZXMgPSBtZXJnZSh7fSwgYmxvY2suZ2ZtLCB7XG4gIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICB0YWJsZTogL14gKlxcfCguKylcXG4gKlxcfCggKlstOl0rWy18IDpdKilcXG4oKD86ICpcXHwuKig/OlxcbnwkKSkqKVxcbiovXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLnRhYmxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgQmxvY2sgUnVsZXNcbiAqL1xuXG5MZXhlci5ydWxlcyA9IGJsb2NrO1xuXG4vKipcbiAqIFN0YXRpYyBMZXggTWV0aG9kXG4gKi9cblxuTGV4ZXIubGV4ID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzaW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKHNyYykge1xuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpXG4gICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpO1xuXG4gIHJldHVybiB0aGlzLnRva2VuKHNyYywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIExleGluZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wLCBicSkge1xuICB2YXIgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKVxuICAgICwgbmV4dFxuICAgICwgbG9vc2VcbiAgICAsIGNhcFxuICAgICwgYnVsbFxuICAgICwgYlxuICAgICwgaXRlbVxuICAgICwgc3BhY2VcbiAgICAsIGlcbiAgICAsIGw7XG5cbiAgd2hpbGUgKHNyYykge1xuICAgIC8vIG5ld2xpbmVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5uZXdsaW5lLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc3BhY2UnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eIHs0fS9nbSwgJycpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgID8gY2FwLnJlcGxhY2UoL1xcbiskLywgJycpXG4gICAgICAgICAgOiBjYXBcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZmVuY2VzIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZmVuY2VzLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIGxhbmc6IGNhcFsyXSxcbiAgICAgICAgdGV4dDogY2FwWzNdIHx8ICcnXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5oZWFkaW5nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5ucHRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsyXSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaHInXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJsb2NrcXVvdGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ibG9ja3F1b3RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgdGhpcy50b2tlbihjYXAsIHRvcCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlzdFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVsbCA9IGNhcFsyXTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X3N0YXJ0JyxcbiAgICAgICAgb3JkZXJlZDogYnVsbC5sZW5ndGggPiAxXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG4gICAgICBjYXAgPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5pdGVtKTtcblxuICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgbCA9IGNhcC5sZW5ndGg7XG4gICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGNhcFtpXTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxpc3QgaXRlbSdzIGJ1bGxldFxuICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuICAgICAgICBzcGFjZSA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1xcLikgKy8sICcnKTtcblxuICAgICAgICAvLyBPdXRkZW50IHdoYXRldmVyIHRoZVxuICAgICAgICAvLyBsaXN0IGl0ZW0gY29udGFpbnMuIEhhY2t5LlxuICAgICAgICBpZiAofml0ZW0uaW5kZXhPZignXFxuICcpKSB7XG4gICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgID8gaXRlbS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14gezEsJyArIHNwYWNlICsgJ30nLCAnZ20nKSwgJycpXG4gICAgICAgICAgICA6IGl0ZW0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5leHQgbGlzdCBpdGVtIGJlbG9uZ3MgaGVyZS5cbiAgICAgICAgLy8gQmFja3BlZGFsIGlmIGl0IGRvZXMgbm90IGJlbG9uZyBpbiB0aGlzIGxpc3QuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBpICE9PSBsIC0gMSkge1xuICAgICAgICAgIGIgPSBibG9jay5idWxsZXQuZXhlYyhjYXBbaSArIDFdKVswXTtcbiAgICAgICAgICBpZiAoYnVsbCAhPT0gYiAmJiAhKGJ1bGwubGVuZ3RoID4gMSAmJiBiLmxlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICBzcmMgPSBjYXAuc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpICsgc3JjO1xuICAgICAgICAgICAgaSA9IGwgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAvLyBVc2U6IC8oXnxcXG4pKD8hIClbXlxcbl0rXFxuXFxuKD8hXFxzKiQpL1xuICAgICAgICAvLyBmb3IgZGlzY291bnQgYmVoYXZpb3IuXG4gICAgICAgIGxvb3NlID0gbmV4dCB8fCAvXFxuXFxuKD8hXFxzKiQpLy50ZXN0KGl0ZW0pO1xuICAgICAgICBpZiAoaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBuZXh0ID0gaXRlbS5jaGFyQXQoaXRlbS5sZW5ndGggLSAxKSA9PT0gJ1xcbic7XG4gICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogbG9vc2VcbiAgICAgICAgICAgID8gJ2xvb3NlX2l0ZW1fc3RhcnQnXG4gICAgICAgICAgICA6ICdsaXN0X2l0ZW1fc3RhcnQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgIHRoaXMudG9rZW4oaXRlbSwgZmFsc2UsIGJxKTtcblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX2VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICgoIWJxICYmIHRvcCkgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5saW5rc1tjYXBbMV0udG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXVxuICAgICAgICAgIC5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMucGFyYWdyYXBoLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgIHRleHQ6IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgIDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgLy8gVG9wLWxldmVsIHNob3VsZCBuZXZlciByZWFjaCBoZXJlLlxuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cblxudmFyIGlubGluZSA9IHtcbiAgZXNjYXBlOiAvXlxcXFwoW1xcXFxgKnt9XFxbXFxdKCkjK1xcLS4hXz5dKS8sXG4gIGF1dG9saW5rOiAvXjwoW14gPl0rKEB8OlxcLylbXiA+XSspPi8sXG4gIHVybDogbm9vcCxcbiAgdGFnOiAvXjwhLS1bXFxzXFxTXSo/LS0+fF48XFwvP1xcdysoPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPz4vLFxuICBsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXChocmVmXFwpLyxcbiAgcmVmbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gIG5vbGluazogL14hP1xcWygoPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXSkqKVxcXS8sXG4gIHN0cm9uZzogL15fXyhbXFxzXFxTXSs/KV9fKD8hXyl8XlxcKlxcKihbXFxzXFxTXSs/KVxcKlxcKig/IVxcKikvLFxuICBlbTogL15cXGJfKCg/OlteX118X18pKz8pX1xcYnxeXFwqKCg/OlxcKlxcKnxbXFxzXFxTXSkrPylcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXSlcXHMqXFwxKD8hYCkvLFxuICBicjogL14gezIsfVxcbig/IVxccyokKS8sXG4gIGRlbDogbm9vcCxcbiAgdGV4dDogL15bXFxzXFxTXSs/KD89W1xcXFw8IVxcW18qYF18IHsyLH1cXG58JCkvXG59O1xuXG5pbmxpbmUuX2luc2lkZSA9IC8oPzpcXFtbXlxcXV0qXFxdfFteXFxbXFxdXXxcXF0oPz1bXlxcW10qXFxdKSkqLztcbmlubGluZS5faHJlZiA9IC9cXHMqPD8oW1xcc1xcU10qPyk+Pyg/OlxccytbJ1wiXShbXFxzXFxTXSo/KVsnXCJdKT9cXHMqLztcblxuaW5saW5lLmxpbmsgPSByZXBsYWNlKGlubGluZS5saW5rKVxuICAoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICgpO1xuXG5pbmxpbmUucmVmbGluayA9IHJlcGxhY2UoaW5saW5lLnJlZmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5ub3JtYWwgPSBtZXJnZSh7fSwgaW5saW5lKTtcblxuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5wZWRhbnRpYyA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIHN0cm9uZzogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pfF5cXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKS9cbn0pO1xuXG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5nZm0gPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBlc2NhcGU6IHJlcGxhY2UoaW5saW5lLmVzY2FwZSkoJ10pJywgJ358XSknKSgpLFxuICB1cmw6IC9eKGh0dHBzPzpcXC9cXC9bXlxcczxdK1tePC4sOjtcIicpXFxdXFxzXSkvLFxuICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS50ZXh0KVxuICAgICgnXXwnLCAnfl18JylcbiAgICAoJ3wnLCAnfGh0dHBzPzovL3wnKVxuICAgICgpXG59KTtcblxuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogcmVwbGFjZShpbmxpbmUuYnIpKCd7Mix9JywgJyonKSgpLFxuICB0ZXh0OiByZXBsYWNlKGlubGluZS5nZm0udGV4dCkoJ3syLH0nLCAnKicpKClcbn0pO1xuXG4vKipcbiAqIElubGluZSBMZXhlciAmIENvbXBpbGVyXG4gKi9cblxuZnVuY3Rpb24gSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMubGlua3MgPSBsaW5rcztcbiAgdGhpcy5ydWxlcyA9IGlubGluZS5ub3JtYWw7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKCF0aGlzLmxpbmtzKSB7XG4gICAgdGhyb3cgbmV3XG4gICAgICBFcnJvcignVG9rZW5zIGFycmF5IHJlcXVpcmVzIGEgYGxpbmtzYCBwcm9wZXJ0eS4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuYnJlYWtzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gaW5saW5lLmdmbTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgdGhpcy5ydWxlcyA9IGlubGluZS5wZWRhbnRpYztcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBJbmxpbmUgUnVsZXNcbiAqL1xuXG5JbmxpbmVMZXhlci5ydWxlcyA9IGlubGluZTtcblxuLyoqXG4gKiBTdGF0aWMgTGV4aW5nL0NvbXBpbGluZyBNZXRob2RcbiAqL1xuXG5JbmxpbmVMZXhlci5vdXRwdXQgPSBmdW5jdGlvbihzcmMsIGxpbmtzLCBvcHRpb25zKSB7XG4gIHZhciBpbmxpbmUgPSBuZXcgSW5saW5lTGV4ZXIobGlua3MsIG9wdGlvbnMpO1xuICByZXR1cm4gaW5saW5lLm91dHB1dChzcmMpO1xufTtcblxuLyoqXG4gKiBMZXhpbmcvQ29tcGlsaW5nXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKHNyYykge1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGxpbmtcbiAgICAsIHRleHRcbiAgICAsIGhyZWZcbiAgICAsIGNhcDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gZXNjYXBlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZXNjYXBlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBjYXBbMV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhdXRvbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmF1dG9saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gY2FwWzFdLmNoYXJBdCg2KSA9PT0gJzonXG4gICAgICAgICAgPyB0aGlzLm1hbmdsZShjYXBbMV0uc3Vic3RyaW5nKDcpKVxuICAgICAgICAgIDogdGhpcy5tYW5nbGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRoaXMubWFuZ2xlKCdtYWlsdG86JykgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1cmwgKGdmbSlcbiAgICBpZiAoIXRoaXMuaW5MaW5rICYmIChjYXAgPSB0aGlzLnJ1bGVzLnVybC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFnXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGFnLmV4ZWMoc3JjKSkge1xuICAgICAgaWYgKCF0aGlzLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXJcbiAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKVxuICAgICAgICAgIDogZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGxpbmtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgfSk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVmbGluaywgbm9saW5rXG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGxpbmsgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgbGluayA9IHRoaXMubGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgIG91dCArPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICBzcmMgPSBjYXBbMF0uc3Vic3RyaW5nKDEpICsgc3JjO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIG91dCArPSB0aGlzLm91dHB1dExpbmsoY2FwLCBsaW5rKTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzdHJvbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5zdHJvbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuc3Ryb25nKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGVtXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZW0uZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZW0odGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZXNwYW4oZXNjYXBlKGNhcFsyXSwgdHJ1ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5icigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmRlbCh0aGlzLm91dHB1dChjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRleHQoZXNjYXBlKHRoaXMuc21hcnR5cGFudHMoY2FwWzBdKSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKVxuICAgICwgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcblxuICByZXR1cm4gY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnXG4gICAgPyB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgdGl0bGUsIHRoaXMub3V0cHV0KGNhcFsxXSkpXG4gICAgOiB0aGlzLnJlbmRlcmVyLmltYWdlKGhyZWYsIHRpdGxlLCBlc2NhcGUoY2FwWzFdKSk7XG59O1xuXG4vKipcbiAqIFNtYXJ0eXBhbnRzIFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5zbWFydHlwYW50cyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMpIHJldHVybiB0ZXh0O1xuICByZXR1cm4gdGV4dFxuICAgIC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgJ1xcdTIwMTQnKVxuICAgIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCAnXFx1MjAxMycpXG4gICAgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csICckMVxcdTIwMTgnKVxuICAgIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgJ1xcdTIwMTknKVxuICAgIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCAnJDFcXHUyMDFjJylcbiAgICAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgJ1xcdTIwMWQnKVxuICAgIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCAnXFx1MjAyNicpO1xufTtcblxuLyoqXG4gKiBNYW5nbGUgTGlua3NcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUubWFuZ2xlID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5tYW5nbGUpIHJldHVybiB0ZXh0O1xuICB2YXIgb3V0ID0gJydcbiAgICAsIGwgPSB0ZXh0Lmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIGNoO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jb2RlID0gZnVuY3Rpb24oY29kZSwgbGFuZywgZXNjYXBlZCkge1xuICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgY29kZSA9IG91dDtcbiAgICB9XG4gIH1cblxuICBpZiAoIWxhbmcpIHtcbiAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgICArICdcXG48L2NvZGU+PC9wcmU+JztcbiAgfVxuXG4gIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIidcbiAgICArIHRoaXMub3B0aW9ucy5sYW5nUHJlZml4XG4gICAgKyBlc2NhcGUobGFuZywgdHJ1ZSlcbiAgICArICdcIj4nXG4gICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUoY29kZSwgdHJ1ZSkpXG4gICAgKyAnXFxuPC9jb2RlPjwvcHJlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYmxvY2txdW90ZSA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHJldHVybiAnPGJsb2NrcXVvdGU+XFxuJyArIHF1b3RlICsgJzwvYmxvY2txdW90ZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbihodG1sKSB7XG4gIHJldHVybiBodG1sO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhlYWRpbmcgPSBmdW5jdGlvbih0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gIHJldHVybiAnPGgnXG4gICAgKyBsZXZlbFxuICAgICsgJyBpZD1cIidcbiAgICArIHRoaXMub3B0aW9ucy5oZWFkZXJQcmVmaXhcbiAgICArIHJhdy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teXFx3XSsvZywgJy0nKVxuICAgICsgJ1wiPidcbiAgICArIHRleHRcbiAgICArICc8L2gnXG4gICAgKyBsZXZlbFxuICAgICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmhyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihib2R5LCBvcmRlcmVkKSB7XG4gIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICByZXR1cm4gJzwnICsgdHlwZSArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0aXRlbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKGhlYWRlciwgYm9keSkge1xuICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgKyAnPHRoZWFkPlxcbidcbiAgICArIGhlYWRlclxuICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICsgJzx0Ym9keT5cXG4nXG4gICAgKyBib2R5XG4gICAgKyAnPC90Ym9keT5cXG4nXG4gICAgKyAnPC90YWJsZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlcm93ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVjZWxsID0gZnVuY3Rpb24oY29udGVudCwgZmxhZ3MpIHtcbiAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgdmFyIHRhZyA9IGZsYWdzLmFsaWduXG4gICAgPyAnPCcgKyB0eXBlICsgJyBzdHlsZT1cInRleHQtYWxpZ246JyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICA6ICc8JyArIHR5cGUgKyAnPic7XG4gIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdzpdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIHZhciBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gdGV4dDtcbn07XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5cbmZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gIHRoaXMudG9rZW5zID0gW107XG4gIHRoaXMudG9rZW4gPSBudWxsO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xufVxuXG4vKipcbiAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAqL1xuXG5QYXJzZXIucGFyc2UgPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMsIHJlbmRlcmVyKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIHJlbmRlcmVyKTtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShzcmMpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMb29wXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHNyYykge1xuICB0aGlzLmlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihzcmMubGlua3MsIHRoaXMub3B0aW9ucywgdGhpcy5yZW5kZXJlcik7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhlYWRpbmcoXG4gICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpLFxuICAgICAgICB0aGlzLnRva2VuLmRlcHRoLFxuICAgICAgICB0aGlzLnRva2VuLnRleHQpO1xuICAgIH1cbiAgICBjYXNlICdjb2RlJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuY29kZSh0aGlzLnRva2VuLnRleHQsXG4gICAgICAgIHRoaXMudG9rZW4ubGFuZyxcbiAgICAgICAgdGhpcy50b2tlbi5lc2NhcGVkKTtcbiAgICB9XG4gICAgY2FzZSAndGFibGUnOiB7XG4gICAgICB2YXIgaGVhZGVyID0gJydcbiAgICAgICAgLCBib2R5ID0gJydcbiAgICAgICAgLCBpXG4gICAgICAgICwgcm93XG4gICAgICAgICwgY2VsbFxuICAgICAgICAsIGZsYWdzXG4gICAgICAgICwgajtcblxuICAgICAgLy8gaGVhZGVyXG4gICAgICBjZWxsID0gJyc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5oZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmxhZ3MgPSB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfTtcbiAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi5oZWFkZXJbaV0pLFxuICAgICAgICAgIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93ID0gdGhpcy50b2tlbi5jZWxsc1tpXTtcblxuICAgICAgICBjZWxsID0gJyc7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHJvd1tqXSksXG4gICAgICAgICAgICB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2pdIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnYmxvY2txdW90ZV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJydcbiAgICAgICAgLCBvcmRlcmVkID0gdGhpcy50b2tlbi5vcmRlcmVkO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCk7XG4gICAgfVxuICAgIGNhc2UgJ2xpc3RfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRva2VuLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgICAgID8gdGhpcy5wYXJzZVRleHQoKVxuICAgICAgICAgIDogdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2xvb3NlX2l0ZW1fc3RhcnQnOiB7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICB2YXIgaHRtbCA9ICF0aGlzLnRva2VuLnByZSAmJiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgID8gdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dClcbiAgICAgICAgOiB0aGlzLnRva2VuLnRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5odG1sKGh0bWwpO1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKCFlbmNvZGUgPyAvJig/ISM/XFx3KzspL2cgOiAvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoWyNcXHddKyk7L2csIGZ1bmN0aW9uKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb24gc2VsZihuYW1lLCB2YWwpIHtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCBvcHQpO1xuICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8oXnxbXlxcW10pXFxeL2csICckMScpO1xuICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDFcbiAgICAsIHRhcmdldFxuICAgICwga2V5O1xuXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0YXJnZXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgfHwgdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHRcbiAgICAgICwgdG9rZW5zXG4gICAgICAsIHBlbmRpbmdcbiAgICAgICwgaSA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICB9XG5cbiAgICBwZW5kaW5nID0gdG9rZW5zLmxlbmd0aDtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfVxuXG4gICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuXG4gICAgICByZXR1cm4gZXJyXG4gICAgICAgID8gY2FsbGJhY2soZXJyKVxuICAgICAgICA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgfTtcblxuICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuXG4gICAgaWYgKCFwZW5kaW5nKSByZXR1cm4gZG9uZSgpO1xuXG4gICAgZm9yICg7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbihlcnIsIGNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgIGlmIChjb2RlID09IG51bGwgfHwgY29kZSA9PT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIC0tcGVuZGluZyB8fCBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkodG9rZW5zW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0KSBvcHQgPSBtZXJnZSh7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIHJldHVybiBQYXJzZXIucGFyc2UoTGV4ZXIubGV4KHNyYywgb3B0KSwgb3B0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VyZWQ6PC9wPjxwcmU+J1xuICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgKyAnPC9wcmU+JztcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuXG5tYXJrZWQub3B0aW9ucyA9XG5tYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdCkge1xuICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xuXG5tYXJrZWQuZGVmYXVsdHMgPSB7XG4gIGdmbTogdHJ1ZSxcbiAgdGFibGVzOiB0cnVlLFxuICBicmVha3M6IGZhbHNlLFxuICBwZWRhbnRpYzogZmFsc2UsXG4gIHNhbml0aXplOiBmYWxzZSxcbiAgc2FuaXRpemVyOiBudWxsLFxuICBtYW5nbGU6IHRydWUsXG4gIHNtYXJ0TGlzdHM6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxuICBoaWdobGlnaHQ6IG51bGwsXG4gIGxhbmdQcmVmaXg6ICdsYW5nLScsXG4gIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgaGVhZGVyUHJlZml4OiAnJyxcbiAgcmVuZGVyZXI6IG5ldyBSZW5kZXJlcixcbiAgeGh0bWw6IGZhbHNlXG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcblxubWFya2VkLkxleGVyID0gTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG5cbm1hcmtlZC5JbmxpbmVMZXhlciA9IElubGluZUxleGVyO1xubWFya2VkLmlubGluZUxleGVyID0gSW5saW5lTGV4ZXIub3V0cHV0O1xuXG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBtYXJrZWQ7XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXJrZWQ7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5tYXJrZWQgPSBtYXJrZWQ7XG59XG5cbn0pLmNhbGwoZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG59KCkpO1xuIl19
},{}],101:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],102:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],103:[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9wYXJzZWpzb24vaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59OyJdfQ==
},{}],104:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],105:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],106:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],107:[function(require,module,exports){

module.exports = require('./lib/');

},{"./lib/":108}],108:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":109,"./socket":111,"./url":112,"debug":72,"socket.io-parser":114}],109:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var object = require('object-component');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":110,"./socket":111,"./url":112,"backo2":22,"component-bind":30,"component-emitter":31,"debug":72,"engine.io-client":73,"indexof":93,"object-component":102,"socket.io-parser":114}],110:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],111:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":110,"component-bind":30,"component-emitter":31,"debug":72,"has-binary":90,"socket.io-parser":114,"to-array":129}],112:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdG5hbWUgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgb2JqLmhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIG9iai5ob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiJdfQ==
},{"debug":72,"parseuri":105}],113:[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cbiAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmogJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iXX0=
},{"./is-buffer":115,"isarray":97}],114:[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":113,"./is-buffer":115,"component-emitter":31,"debug":72,"isarray":97,"json3":99}],115:[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cbiJdfQ==
},{}],116:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":88,"inherits":94,"readable-stream/duplex.js":117,"readable-stream/passthrough.js":123,"readable-stream/readable.js":124,"readable-stream/transform.js":125,"readable-stream/writable.js":126}],117:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":118}],118:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iXX0=
},{"./_stream_readable":120,"./_stream_writable":122,"_process":106,"core-util-is":33,"inherits":94}],119:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":121,"core-util-is":33,"inherits":94}],120:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgdXRpbC5pc051bGwobikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmICghdXRpbC5pc051bGwocmV0KSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICAgICAgICBzZWxmLnJlYWQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIH1cbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgIGlmICghY2h1bmsgfHwgIXN0YXRlLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiJdfQ==
},{"./_stream_duplex":118,"_process":106,"buffer":29,"core-util-is":33,"events":88,"inherits":94,"isarray":97,"stream":116,"string_decoder/":128,"util":28}],121:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":118,"core-util-is":33,"inherits":94}],122:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oY2IpKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB1dGlsLmlzU3RyaW5nKGNodW5rKSkge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZClcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2Uge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVyKTtcbiAgfVxuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoID4gMSkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgY2JzID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspXG4gICAgICBjYnMucHVzaChzdGF0ZS5idWZmZXJbY10uY2FsbGJhY2spO1xuXG4gICAgLy8gY291bnQgdGhlIG9uZSB3ZSBhcmUgYWRkaW5nLCBhcyB3ZWxsLlxuICAgIC8vIFRPRE8oaXNhYWNzKSBjbGVhbiB0aGlzIHVwXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmJ1ZmZlciwgJycsIGZ1bmN0aW9uKGVycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNic1tpXShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYnVmZmVyXG4gICAgc3RhdGUuYnVmZmVyID0gW107XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBjKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG5cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiJdfQ==
},{"./_stream_duplex":118,"_process":106,"buffer":29,"core-util-is":33,"inherits":94,"stream":116}],123:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":119}],124:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":118,"./lib/_stream_passthrough.js":119,"./lib/_stream_readable.js":120,"./lib/_stream_transform.js":121,"./lib/_stream_writable.js":122,"stream":116}],125:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":121}],126:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":122}],127:[function(require,module,exports){
module.exports = function(str) {
  var hash = 5381,
      i    = str.length

  while(i)
    hash = (hash * 33) ^ str.charCodeAt(--i)

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, if the high bit
   * is set, unset it and add it back in through (64-bit IEEE) addition. */
  return hash >= 0 ? hash : (hash & 0x7FFFFFFF) + 0x80000000
}

},{}],128:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":29}],129:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],130:[function(require,module,exports){
/*!
	unique-random
	Generate random numbers that are consecutively unique
	https://github.com/sindresorhus/unique-random
	by Sindre Sorhus
	MIT License
*/
(function () {
	'use strict';

	function uniqueRandom(min, max) {
		var prev;
		return function rand() {
			var num = Math.floor(Math.random() * (max - min + 1) + min);
			return prev = num === prev && min !== max ? rand() : num;
		};
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = uniqueRandom;
	} else {
		window.uniqueRandom = uniqueRandom;
	}
})();

},{}],131:[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy91dGY4L3V0ZjguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcbiJdfQ==
},{}],132:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],133:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiJdfQ==
},{"./support/isBuffer":132,"_process":106,"inherits":94}],134:[function(require,module,exports){
(function (global){
module.exports = get_blob()

function get_blob() {
  if(global.Blob) {
    try {
      new Blob(['asdf'], {type: 'text/plain'})
      return Blob
    } catch(err) {}
  }

  var Builder = global.WebKitBlobBuilder ||
                global.MozBlobBuilder ||
                global.MSBlobBuilder

  return function(parts, bag) {
    var builder = new Builder
      , endings = bag.endings
      , type = bag.type

    if(endings) for(var i = 0, len = parts.length; i < len; ++i) {
      builder.append(parts[i], endings)
    } else for(var i = 0, len = parts.length; i < len; ++i) {
      builder.append(parts[i])
    }

    return type ? builder.getBlob(type) : builder.getBlob()
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93M2MtYmxvYi9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGdldF9ibG9iKClcblxuZnVuY3Rpb24gZ2V0X2Jsb2IoKSB7XG4gIGlmKGdsb2JhbC5CbG9iKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBCbG9iKFsnYXNkZiddLCB7dHlwZTogJ3RleHQvcGxhaW4nfSlcbiAgICAgIHJldHVybiBCbG9iXG4gICAgfSBjYXRjaChlcnIpIHt9XG4gIH1cblxuICB2YXIgQnVpbGRlciA9IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgICAgIGdsb2JhbC5Nb3pCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgICAgIGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHBhcnRzLCBiYWcpIHtcbiAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyXG4gICAgICAsIGVuZGluZ3MgPSBiYWcuZW5kaW5nc1xuICAgICAgLCB0eXBlID0gYmFnLnR5cGVcblxuICAgIGlmKGVuZGluZ3MpIGZvcih2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBidWlsZGVyLmFwcGVuZChwYXJ0c1tpXSwgZW5kaW5ncylcbiAgICB9IGVsc2UgZm9yKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnRzW2ldKVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlID8gYnVpbGRlci5nZXRCbG9iKHR5cGUpIDogYnVpbGRlci5nZXRCbG9iKClcbiAgfVxufVxuIl19
},{}],135:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}]},{},[5])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY29udHJvbGxlci9jbG9zZWJ1dHRvbi5qcyIsImxpYi9jb250cm9sbGVyL2VkaXRvci5qcyIsImxpYi9jb250cm9sbGVyL3ByZXZpZXcuanMiLCJsaWIvY29udHJvbGxlci9zdGF0ZXNoZWFkZXIuanMiLCJsaWIvY3JhdGlmeS5qcyIsImxpYi9tb2RlbC9ndWlkLmpzIiwibGliL21vZGVsL21vZGVsLmpzIiwibGliL21vZGVsL3NpZ25hbGluZy5qcyIsImxpYi92aWV3L2Nsb3NlYnV0dG9uLmpzIiwibGliL3ZpZXcvZWRpdG9yLmpzIiwibGliL3ZpZXcvbGluay5qcyIsImxpYi92aWV3L21hcmtlci5qcyIsImxpYi92aWV3L21ldGFkYXRhLmpzIiwibGliL3ZpZXcvcHJldmlldy5qcyIsImxpYi92aWV3L3JvdW5kYnV0dG9uLmpzIiwibGliL3ZpZXcvc3RhdGVzaGVhZGVyLmpzIiwibGliL3ZpZXcvc3RydWN0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FuaW1hbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYW5pbWFscy93b3Jkcy5qc29uIiwibm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhY2tvMi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9ibG9iL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JyYWNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JyYWNlL3RoZW1lL2Nocm9tZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1iaW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL2xpYi9jcmF0ZS1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbGliL21lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL2NhdXNhbC1icm9hZGNhc3QtZGVmaW5pdGlvbi9saWIvY2F1c2FsYnJvYWRjYXN0LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL2NhdXNhbC1icm9hZGNhc3QtZGVmaW5pdGlvbi9saWIvbWVzc2FnZXMuanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvY2F1c2FsLWJyb2FkY2FzdC1kZWZpbml0aW9uL25vZGVfbW9kdWxlcy91bmljYXN0LWRlZmluaXRpb24vbGliL21lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL2NhdXNhbC1icm9hZGNhc3QtZGVmaW5pdGlvbi9ub2RlX21vZHVsZXMvdW5pY2FzdC1kZWZpbml0aW9uL2xpYi91bmljYXN0LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL2xzZXF0cmVlL2xpYi9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL2xzZXF0cmVlL2xpYi9pZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL2xzZXF0cmVlL2xpYi9sc2Vxbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9sc2VxdHJlZS9saWIvbHNlcXRyZWUuanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvbHNlcXRyZWUvbGliL3N0cmF0ZWd5LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL2xzZXF0cmVlL2xpYi90cmlwbGUuanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvbHNlcXRyZWUvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvbHNlcXRyZWUvbm9kZV9tb2R1bGVzL0JpZ0ludC9zcmMvQmlnSW50LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL3NwcmF5LXdydGMvbGliL2ludmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL2xpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL2xpYi9wYXJ0aWFsdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL2xpYi9zb2NrZXRzLmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL3NwcmF5LXdydGMvbGliL3NwcmF5LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL3NwcmF5LXdydGMvbm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL3NwcmF5LXdydGMvbm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL3NwcmF5LXdydGMvbm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL25vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL3NwcmF5LXdydGMvbm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9oYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvc3ByYXktd3J0Yy9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvc3ByYXktd3J0Yy9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL2lzLXR5cGVkYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvc3ByYXktd3J0Yy9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL29uY2Uvbm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvc3ByYXktd3J0Yy9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL25vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS10by1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3JhdGUtY29yZS9ub2RlX21vZHVsZXMvc3ByYXktd3J0Yy9ub2RlX21vZHVsZXMvc29ydGVkLWNtcC1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy9zcHJheS13cnRjL25vZGVfbW9kdWxlcy9zb3J0ZWQtY21wLWFycmF5L25vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NyYXRlLWNvcmUvbm9kZV9tb2R1bGVzL3ZlcnNpb24tdmVjdG9yLXdpdGgtZXhjZXB0aW9ucy9saWIvdnZ3ZS5qcyIsIm5vZGVfbW9kdWxlcy9jcmF0ZS1jb3JlL25vZGVfbW9kdWxlcy92ZXJzaW9uLXZlY3Rvci13aXRoLWV4Y2VwdGlvbnMvbGliL3Z2d2VlbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZXVyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iYWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLWJpbmFyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5LXFyY29kZS9kaXN0L2pxdWVyeS5xcmNvZGUuanMiLCJub2RlX21vZHVsZXMvanNvbjMvbGliL2pzb24zLmpzIiwibm9kZV9tb2R1bGVzL21hcmtlZC9saWIvbWFya2VkLmpzIiwibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2Vqc29uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlcXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYmluYXJ5LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyaW5nLWhhc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdW5pcXVlLXJhbmRvbS91bmlxdWUtcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL3V0ZjgvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy93M2MtYmxvYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3dzL2xpYi9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8yakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN2dEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlxuZnVuY3Rpb24gQ2xvc2VCdXR0b24obW9kZWwsIGNsb3NlVmlldywgY29udGFpbmVyKXtcbiAgICAvLyAoVE9ETykgcmVtb3ZlIHRoZSBtb2RlbFxuICAgIGNsb3NlVmlldy5idXR0b24uY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gIzEgcmVtb3ZlIHRoZSB2aWV3XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgLy8gIzIgZGlzY29ubmVjdCB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAgICBpZiAobW9kZWwuc2lnbmFsaW5nLnN0YXJ0ZWRTb2NrZXQpe1xuICAgICAgICAgICAgbW9kZWwuc2lnbmFsaW5nLnN0b3BTaGFyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vICMzIGRpc2Nvbm5lY3QgdGhlIG5ldHdvcmtcbiAgICAgICAgbW9kZWwucnBzLmxlYXZlKCk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb3NlQnV0dG9uO1xuICAgIFxuIiwidmFyIE1hcmtlciA9IHJlcXVpcmUoJy4uL3ZpZXcvbWFya2VyLmpzJyk7XG5cbmZ1bmN0aW9uIEVkaXRvckNvbnRyb2xsZXIobW9kZWwsIHZpZXdFZGl0b3Ipe1xuICAgIHZhciBzZWxmID0gdGhpcywgZWRpdG9yID0gdmlld0VkaXRvci5lZGl0b3I7XG4gICAgdGhpcy52aWV3RWRpdG9yID0gdmlld0VkaXRvcjsgICBcbiAgICB0aGlzLmZyb21SZW1vdGUgPSBmYWxzZTtcbiAgICBcbiAgICAvLyAjQiBpbml0aWFsaXplIHRoZSBzdHJpbmcgd2l0aGluIHRoZSBlZGl0b3JcbiAgICBmdW5jdGlvbiBnZXRTdHJpbmdDaGlsZE5vZGUoY2hpbGROb2RlKXtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBpZiAoY2hpbGROb2RlLmUgIT09IG51bGwpeyByZXN1bHQgPSBjaGlsZE5vZGUuZTsgfTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkTm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICByZXN1bHQgKz0gZ2V0U3RyaW5nQ2hpbGROb2RlKGNoaWxkTm9kZS5jaGlsZHJlbltpXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICBlZGl0b3Iuc2V0VmFsdWUoZ2V0U3RyaW5nQ2hpbGROb2RlKG1vZGVsLnNlcXVlbmNlLnJvb3QpLDEpO1xuICAgIFxuICAgIHZhciBpbnNlcnRSZW1vdmVPcCA9IGZhbHNlO1xuICAgIGVkaXRvci5nZXRTZXNzaW9uKCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBzd2l0Y2goZS5kYXRhLmFjdGlvbil7XG4gICAgICAgIGNhc2UgJ3JlbW92ZUxpbmVzJzpcbiAgICAgICAgY2FzZSAncmVtb3ZlVGV4dCc6XG4gICAgICAgIGNhc2UgJ2luc2VydExpbmVzJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgICAgICBpbnNlcnRSZW1vdmVPcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBlZGl0b3IuZ2V0U2Vzc2lvbigpLmdldFNlbGVjdGlvbigpLm9uKCdjaGFuZ2VDdXJzb3InLCBmdW5jdGlvbihlLCBzZWwpe1xuICAgICAgICBpZiAoIWluc2VydFJlbW92ZU9wKXtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbC5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgbW9kZWwuY29yZS5jYXJldE1vdmVkKHtcbiAgICAgICAgICAgICAgICBzdGFydDogZWRpdG9yLmdldFNlc3Npb24oKS5nZXREb2N1bWVudCgpLnBvc2l0aW9uVG9JbmRleChyYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgZW5kOiBlZGl0b3IuZ2V0U2Vzc2lvbigpLmdldERvY3VtZW50KCkucG9zaXRpb25Ub0luZGV4KHJhbmdlLmVuZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydFJlbW92ZU9wID0gZmFsc2U7XG4gICAgfSk7XG4gICAgXG4gICAgZWRpdG9yLmdldFNlc3Npb24oKS5vbignY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYmVnaW4sIGVuZCwgdGV4dCwgbWVzc2FnZSwgaj0wO1xuXG4gICAgICAgIGlmICghc2VsZi5mcm9tUmVtb3RlKXtcbiAgICAgICAgICAgIC8vICMxIHByb2Nlc3MgdGhlIGJvdW5kYXJpZXMgZnJvbSByYW5nZSB0byBpbmRleCBhbmQgdGV4dFxuICAgICAgICAgICAgYmVnaW4gPSBlZGl0b3IuZ2V0U2Vzc2lvbigpLmdldERvY3VtZW50KCkucG9zaXRpb25Ub0luZGV4KFxuICAgICAgICAgICAgICAgIGUuZGF0YS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLmFjdGlvbil7XG4gICAgICAgICAgICBjYXNlICdyZW1vdmVMaW5lcyc6XG4gICAgICAgICAgICAgICAgZW5kID0gYmVnaW47XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGUuZGF0YS5saW5lcy5sZW5ndGg7KytpKXtcbiAgICAgICAgICAgICAgICAgICAgZW5kICs9IGUuZGF0YS5saW5lc1tpXS5sZW5ndGgrMTsgLy8gKzEgYmVjYXVzZSBvZiBcXG5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlbW90ZUNhcmV0c1VwZGF0ZShiZWdpbiwgYmVnaW4tZW5kKTtcbiAgICAgICAgICAgICAgICBicmVhazsgIFxuICAgICAgICAgICAgY2FzZSAncmVtb3ZlVGV4dCc6XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50ZXh0Lmxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGJlZ2luKzE7IC8vZmFzdGVyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gZWRpdG9yLmdldFNlc3Npb24oKS5nZXREb2N1bWVudCgpLnBvc2l0aW9uVG9JbmRleChcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVtb3RlQ2FyZXRzVXBkYXRlKGJlZ2luLCBiZWdpbi1lbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0TGluZXMnOlxuICAgICAgICAgICAgICAgIHRleHQgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZS5kYXRhLmxpbmVzLmxlbmd0aDsrK2kpe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dCArIChlLmRhdGEubGluZXNbaV0pICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlbmQgPSBiZWdpbiArIHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlbW90ZUNhcmV0c1VwZGF0ZShiZWdpbiwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgICAgICAgICAgdGV4dCA9IGUuZGF0YS50ZXh0O1xuICAgICAgICAgICAgICAgIGVuZCA9IGVkaXRvci5nZXRTZXNzaW9uKCkuZ2V0RG9jdW1lbnQoKS5wb3NpdGlvblRvSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIHJlbW90ZUNhcmV0c1VwZGF0ZShiZWdpbiwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vICMyIHVwZGF0ZSB0aGUgdW5kZXJseWluZyBDUkRUIG1vZGVsIGFuZCBicm9hZGNhc3QgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgIGZvciAodmFyIGk9YmVnaW47IGk8ZW5kOyArK2kpe1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLmFjdGlvbil7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6IG1vZGVsLmNvcmUuaW5zZXJ0KHRleHRbal0sIGkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbnNlcnRMaW5lcyc6IG1vZGVsLmNvcmUuaW5zZXJ0KHRleHRbal0sIGkpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZW1vdmVUZXh0JzogbW9kZWwuY29yZS5yZW1vdmUoYmVnaW4pOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZW1vdmVMaW5lcyc6IG1vZGVsLmNvcmUucmVtb3ZlKGJlZ2luKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIG1vZGVsLmNvcmUub24oJ3JlbW90ZUluc2VydCcsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KXtcbiAgICAgICAgdmFyIGFjZURvY3VtZW50ID0gZWRpdG9yLmdldFNlc3Npb24oKS5nZXREb2N1bWVudCgpLFxuICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICB0ZW1wRnJvbVJlbW90ZTtcbiAgICAgICAgaWYgKGluZGV4IT09LTEpe1xuICAgICAgICAgICAgZGVsdGEgPSB7YWN0aW9uOiAnaW5zZXJ0VGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICByYW5nZTogeyBzdGFydDogYWNlRG9jdW1lbnQuaW5kZXhUb1Bvc2l0aW9uKGluZGV4LTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiAgIGFjZURvY3VtZW50LmluZGV4VG9Qb3NpdGlvbihpbmRleCl9LFxuICAgICAgICAgICAgICAgICAgICAgdGV4dDogZWxlbWVudH0sXG4gICAgICAgICAgICB0ZW1wRnJvbVJlbW90ZSA9IHNlbGYuZnJvbVJlbW90ZTtcbiAgICAgICAgICAgIHNlbGYuZnJvbVJlbW90ZSA9IHRydWU7XG4gICAgICAgICAgICBhY2VEb2N1bWVudC5hcHBseURlbHRhcyhbZGVsdGFdKTtcbiAgICAgICAgICAgIHJlbW90ZUNhcmV0c1VwZGF0ZShpbmRleCwxKTtcbiAgICAgICAgICAgIHNlbGYuZnJvbVJlbW90ZSA9IHRlbXBGcm9tUmVtb3RlO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIG1vZGVsLmNvcmUub24oJ3JlbW90ZVJlbW92ZScsIGZ1bmN0aW9uKGluZGV4KXsgICAgXG4gICAgICAgIHZhciBhY2VEb2N1bWVudCA9IGVkaXRvci5nZXRTZXNzaW9uKCkuZ2V0RG9jdW1lbnQoKSxcbiAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgdGVtcEZyb21SZW1vdGU7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpe1xuICAgICAgICAgICAgZGVsdGEgPSB7YWN0aW9uOiAncmVtb3ZlVGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICByYW5nZTogeyBzdGFydDogYWNlRG9jdW1lbnQuaW5kZXhUb1Bvc2l0aW9uKGluZGV4IC0gMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6ICAgYWNlRG9jdW1lbnQuaW5kZXhUb1Bvc2l0aW9uKGluZGV4KX0sXG4gICAgICAgICAgICAgICAgICAgICB0ZXh0OiBudWxsfTtcbiAgICAgICAgICAgIHRlbXBGcm9tUmVtb3RlID0gc2VsZi5mcm9tUmVtb3RlO1xuICAgICAgICAgICAgc2VsZi5mcm9tUmVtb3RlID0gdHJ1ZTtcbiAgICAgICAgICAgIGFjZURvY3VtZW50LmFwcGx5RGVsdGFzKFtkZWx0YV0pO1xuICAgICAgICAgICAgcmVtb3RlQ2FyZXRzVXBkYXRlKGluZGV4LC0xKTtcbiAgICAgICAgICAgIHNlbGYuZnJvbVJlbW90ZSA9IHRlbXBGcm9tUmVtb3RlO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIG1vZGVsLmNvcmUub24oJ3JlbW90ZUNhcmV0TW92ZWQnLCBmdW5jdGlvbihyYW5nZSwgb3JpZ2luKXtcbiAgICAgICAgaWYgKCFvcmlnaW4pIHJldHVybjtcbiAgICAgICAgaWYgKGVkaXRvci5zZXNzaW9uLnJlbW90ZUNhcmV0c1tvcmlnaW5dKXtcbiAgICAgICAgICAgIC8vICNBIHVwZGF0ZSB0aGUgZXhpc3RpbmcgY3Vyc29yXG4gICAgICAgICAgICB2YXIgbWFya2VyID0gZWRpdG9yLnNlc3Npb24ucmVtb3RlQ2FyZXRzW29yaWdpbl07XG4gICAgICAgICAgICBtYXJrZXIuY3Vyc29ycyA9IFtyYW5nZV07IC8vIHNhdmUgdGhlIGN1cnNvcnMgYXMgaW5kZXhlc1xuICAgICAgICAgICAgZWRpdG9yLmdldFNlc3Npb24oKS5fc2lnbmFsKCdjaGFuZ2VGcm9udE1hcmtlcicpO1xuICAgICAgICAgICAgbWFya2VyLnJlZnJlc2goKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvLyAjQiBjcmVhdGUgYSBuZXcgY3Vyc29yXG4gICAgICAgICAgICB2YXIgbWFya2VyID0gbmV3IE1hcmtlcihlZGl0b3Iuc2Vzc2lvbiwgb3JpZ2luLCByYW5nZSk7XG4gICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5hZGREeW5hbWljTWFya2VyKG1hcmtlciwgdHJ1ZSk7XG4gICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdGVDYXJldHNbb3JpZ2luXSA9IG1hcmtlcjtcbiAgICAgICAgICAgIG1hcmtlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAvLyBjYWxsIG1hcmtlci5zZXNzaW9uLnJlbW92ZU1hcmtlcihtYXJrZXIuaWQpIHRvIHJlbW92ZSBpdFxuICAgICAgICAgICAgLy8gY2FsbCBtYXJrZXIucmVkcmF3IGFmdGVyIGNoYW5naW5nIG9uZSBvZiBjdXJzb3JzXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdGVDYXJldHMgPSB7fTtcbiAgICBmdW5jdGlvbiByZW1vdGVDYXJldHNVcGRhdGUoaW5kZXgsIGxlbmd0aCl7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBmYWxzZSwgZG9jdW1lbnQgPSBlZGl0b3Iuc2Vzc2lvbi5nZXREb2N1bWVudCgpO1xuICAgICAgICBmb3IgKG9yaWdpbiBpbiBlZGl0b3Iuc2Vzc2lvbi5yZW1vdGVDYXJldHMpe1xuICAgICAgICAgICAgdmFyIHJlbW90ZUNhcmV0ID0gZWRpdG9yLnNlc3Npb24ucmVtb3RlQ2FyZXRzW29yaWdpbl07XG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxyZW1vdGVDYXJldC5jdXJzb3JzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVtb3RlQ2FyZXQuY3Vyc29yc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnN0YXJ0ID49IGluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ICs9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPj0gaW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZW5kICs9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZSl7XG4gICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5fc2lnbmFsKCdjaGFuZ2VGcm9udE1hcmtlcicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWRpdG9yQ29udHJvbGxlcjtcbiIsIi8vdmFyIG1hcmtkb3duID0gcmVxdWlyZSgnbWFya2Rvd24nKS5tYXJrZG93bjtcbnZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbm1hcmtlZC5zZXRPcHRpb25zKHtcbiAgICByZW5kZXJlcjogbmV3IG1hcmtlZC5SZW5kZXJlcigpLFxuICAgIGdmbTogdHJ1ZSxcbiAgICB0YWJsZXM6IHRydWUsXG4gICAgYnJlYWtzOiBmYWxzZSxcbiAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgc2FuaXRpemU6IGZhbHNlLFxuICAgIHNtYXJ0TGlzdHM6IHRydWUsXG4gICAgc21hcnR5cGFudHM6IGZhbHNlXG59KTtcblxuXG5mdW5jdGlvbiBQcmV2aWV3KGJ1dHRvblZpZXcsIGVkaXRvclZpZXcsIHByZXZpZXdWaWV3KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgdGhpcy5pc1ByZXZpZXdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0UHJldmlld1RleHQgPSAnPGkgY2xhc3M9XCJmYSBmYS1leWVcIj48L2k+JztcbiAgICB0aGlzLnN0YXJ0UHJldmlld1Rvb2x0aXAgPSAnc3dpdGNoIHRvIHByZXZpZXcnO1xuICAgIHRoaXMuc3RvcFByZXZpZXdUZXh0ID0gJzxpIGNsYXNzPVwiZmEgZmEtZXllLXNsYXNoXCI+PC9pPic7XG4gICAgdGhpcy5zdG9wUHJldmlld1Rvb2x0aXAgPSAnc3dpdGNoIHRvIGVkaXRvcic7XG5cbiAgICB0aGlzLnJlZnJlc2hUaW1lb3V0ID0gNTAwMDsgLy8gKFRPRE8pIGNvbmZpZ3VhYmxlXG4gICAgdGhpcy5yZWZyZXNoID0gbnVsbDtcblxuICAgIGJ1dHRvblZpZXcuYnV0dG9uLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICghc2VsZi5pc1ByZXZpZXdpbmcpe1xuICAgICAgICAgICAgc2VsZi5pc1ByZXZpZXdpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZWRpdG9yVmlldy5kaXYuaGlkZSgpO1xuICAgICAgICAgICAgcHJldmlld1ZpZXcuZGl2Lmh0bWwobWFya2VkKGVkaXRvclZpZXcuZWRpdG9yLmdldFZhbHVlKCkpKTtcbiAgICAgICAgICAgIHByZXZpZXdWaWV3LmRpdi5zaG93KCk7XG4gICAgICAgICAgICBidXR0b25WaWV3LmJ1dHRvbi5odG1sKHNlbGYuc3RvcFByZXZpZXdUZXh0KTtcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuYnV0dG9uLmF0dHIoJ3RpdGxlJywgc2VsZi5zdG9wUHJldmlld1Rvb2x0aXApXG4gICAgICAgICAgICAgICAgLnRvb2x0aXAoJ2ZpeFRpdGxlJyk7XG4gICAgICAgICAgICBzZWxmLnJlZnJlc2ggPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHByZXZpZXdWaWV3LmRpdi5odG1sKG1hcmtlZChlZGl0b3JWaWV3LmVkaXRvci5nZXRWYWx1ZSgpKSk7XG4gICAgICAgICAgICB9LCBzZWxmLnJlZnJlc2hUaW1lb3V0KTsgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pc1ByZXZpZXdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHByZXZpZXdWaWV3LmRpdi5oaWRlKCk7XG4gICAgICAgICAgICBlZGl0b3JWaWV3LmRpdi5zaG93KCk7XG4gICAgICAgICAgICBlZGl0b3JWaWV3LmVkaXRvci5yZXNpemUoKTtcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuYnV0dG9uLmh0bWwoc2VsZi5zdGFydFByZXZpZXdUZXh0KTtcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuYnV0dG9uLmF0dHIoJ3RpdGxlJywgc2VsZi5zdGFydFByZXZpZXdUb29sdGlwKVxuICAgICAgICAgICAgICAgIC50b29sdGlwKCdmaXhUaXRsZScpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYucmVmcmVzaCk7XG4gICAgICAgICAgICBzZWxmLnJlZnJlc2ggPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJldmlldztcbiIsInJlcXVpcmUoJ2pxdWVyeS1xcmNvZGUnKTtcblxuZnVuY3Rpb24gU3RhdGVzSGVhZGVyKG1vZGVsLCBzdGF0ZXNWaWV3LCBsaW5rVmlldywgc2hhcmVWaWV3KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuc3RhdGVzVmlldyA9IHN0YXRlc1ZpZXc7XG5cbiAgICB0aGlzLnN0YXJ0U2hhcmluZ1RleHQgPSAnPGkgY2xhc3M9XCJmYSBmYS1saW5rXCI+PC9pPic7XG4gICAgdGhpcy5zdGFydFNoYXJpbmdUb29sdGlwID0gJ3N0YXJ0IHNoYXJpbmcnO1xuICAgIHRoaXMuc3RvcFNoYXJpbmdUZXh0ID0gJzxpIGNsYXNzPVwiZmEgZmEtdW5saW5rXCI+PC9pPic7XG4gICAgdGhpcy5zdG9wU2hhcmluZ1Rvb2x0aXAgPSAnc3RvcCBzaGFyaW5nJztcbiAgICBcbiAgICBtb2RlbC5icm9hZGNhc3Quc291cmNlLm9uKFwic3RhdGVjaGFuZ2VcIiwgZnVuY3Rpb24oc3RhdGUpe1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKXtcbiAgICAgICAgY2FzZSBcImNvbm5lY3RcIjogc3RhdGVzVmlldy5zZXROZXR3b3JrU3RhdGUoJ2Nvbm5lY3RlZCcpOyBicmVhaztcbiAgICAgICAgY2FzZSBcInBhcnRpYWxcIjogc3RhdGVzVmlldy5zZXROZXR3b3JrU3RhdGUoJ3BhcnRpYWxseUNvbm5lY3RlZCcpOyBicmVhaztcbiAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RcIjogc3RhdGVzVmlldy5zZXROZXR3b3JrU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpOyBicmVhaztcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHNoYXJlVmlldy5idXR0b24udW5iaW5kKFwiY2xpY2tcIikuY2xpY2soIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzb2NrZXQsIGFjdGlvbiwgY2xpZW50O1xuICAgICAgICBpZiAobW9kZWwuc2lnbmFsaW5nLnN0YXJ0ZWRTb2NrZXQpe1xuICAgICAgICAgICAgbW9kZWwuc2lnbmFsaW5nLnN0b3BTaGFyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gOyAvLyB1Z2x5IGFzIGhlbGxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gIzAgY3JlYXRlIHRoZSBwcm9wZXIgY2FsbCB0byB0aGUgc2VydmVyXG4gICAgICAgIHNvY2tldCA9IG1vZGVsLnNpZ25hbGluZy5zdGFydFNoYXJpbmcoKTtcbiAgICAgICAgc3RhdGVzVmlldy5zZXRTaWduYWxpbmdTdGF0ZShcIndhaXRTaWduYWxpbmdcIik7XG4gICAgICAgIHNvY2tldC5vbihcImNvbm5lY3RcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNoYXJlVmlldy5idXR0b24ucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgc3RhdGVzVmlldy5zZXRTaWduYWxpbmdTdGF0ZShcIndhaXRKb2luZXJzXCIpO1xuICAgICAgICAgICAgc2hhcmVWaWV3LmJ1dHRvbi5odG1sKHNlbGYuc3RvcFNoYXJpbmdUZXh0KTtcbiAgICAgICAgICAgIHNoYXJlVmlldy5idXR0b24uYXR0cigndGl0bGUnLCBzZWxmLnN0b3BTaGFyaW5nVG9vbHRpcClcbiAgICAgICAgICAgICAgICAudG9vbHRpcCgnZml4VGl0bGUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNoYXJlVmlldy5idXR0b24uaHRtbChzZWxmLnN0YXJ0U2hhcmluZ1RleHQpO1xuICAgICAgICAgICAgc2hhcmVWaWV3LmJ1dHRvbi5hdHRyKCd0aXRsZScsIHNlbGYuc3RhcnRTaGFyaW5nVG9vbHRpcClcbiAgICAgICAgICAgICAgICAudG9vbHRpcCgnZml4VGl0bGUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNoYXJlVmlldy5idXR0b24uYXR0cihcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgLy8gIzEgbW9kaWZ5IHRoZSB2aWV3XG4gICAgICAgIGlmIChtb2RlbC5zaWduYWxpbmcuc3RhcnRlZFNvY2tldCl7XG4gICAgICAgICAgICAvLyAjQSBjbGVhbiB0aGUgYWRkcmVzcyBmcm9tIGFyZ3NcbiAgICAgICAgICAgIHZhciBhZGRyZXNzID0gKHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5zcGxpdCgnPycpWzBdO1xuICAgICAgICAgICAgLy8gI0IgYWRkIHRoZSBuZXcgYXJndW1lbnRcbiAgICAgICAgICAgIGFjdGlvbiA9IGxpbmtWaWV3LnByaW50TGluayhhZGRyZXNzICtcIj9cIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zaWduYWxpbmdPcHRpb25zLnNlc3Npb24pO1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IFplcm9DbGlwYm9hcmQoYWN0aW9uKTtcbiAgICAgICAgICAgIGNsaWVudC5vbihcInJlYWR5XCIsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICBjbGllbnQub24oIFwiY29weVwiLCBmdW5jdGlvbiggZXZlbnQgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBib2FyZCA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBib2FyZC5zZXREYXRhKCBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtWaWV3LmlucHV0LnZhbCgpICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTsgICAgICAgIFxuICAgIH0pO1xuXG4gICAgbGlua1ZpZXcucXJjb2RlLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhZGRyZXNzID0gbW9kZWwuc2lnbmFsaW5nLmFkZHJlc3MgK1xuICAgICAgICAgICAgXCIvaW5kZXguaHRtbD9cIiArXG4gICAgICAgICAgICBtb2RlbC5zaWduYWxpbmdPcHRpb25zLnNlc3Npb247XG4gICAgICAgIGxpbmtWaWV3LnFyY29kZUNhbnZhcy5odG1sKFwiXCIpO1xuICAgICAgICBsaW5rVmlldy5xcmNvZGVDYW52YXMucXJjb2RlKHtcbiAgICAgICAgICAgIHNpemU6NDAwLFxuICAgICAgICAgICAgdGV4dDphZGRyZXNzXG4gICAgICAgIH0pO1xuICAgIH0pOyAgICBcbn07XG5cblN0YXRlc0hlYWRlci5wcm90b3R5cGUuc3RhcnRKb2luaW5nID0gZnVuY3Rpb24oc2lnbmFsaW5nT3B0aW9ucyl7XG4gICAgdmFyIHNvY2tldCA9IHRoaXMubW9kZWwuc2lnbmFsaW5nLnN0YXJ0Sm9pbmluZyhzaWduYWxpbmdPcHRpb25zKTtcbiAgICB0aGlzLnN0YXRlc1ZpZXcuc2V0U2lnbmFsaW5nU3RhdGUoJ3dhaXRTaWduYWxpbmcnKTtcbiAgICBcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKXsgc2VsZi5zdGF0ZXNWaWV3LnNldFNpZ25hbGluZ1N0YXRlKCd3YWl0U2hhcmVyJyk7IH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZXNIZWFkZXI7XG4iLCJ2YXIgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsL21vZGVsLmpzJyk7XG52YXIgR1VJRCA9IHJlcXVpcmUoJy4vbW9kZWwvZ3VpZC5qcycpO1xudmFyIGFjZSA9IHJlcXVpcmUoJ2JyYWNlJyk7XG5yZXF1aXJlKCdicmFjZS90aGVtZS9jaHJvbWUnKTtcblxudmFyIFZTdHJ1Y3R1cmUgPSByZXF1aXJlKCcuL3ZpZXcvc3RydWN0dXJlLmpzJyk7XG52YXIgVkVkaXRvciA9IHJlcXVpcmUoJy4vdmlldy9lZGl0b3IuanMnKTtcbnZhciBWQ2xvc2VCdXR0b24gPSByZXF1aXJlKCcuL3ZpZXcvY2xvc2VidXR0b24uanMnKTtcbnZhciBWTGluayA9IHJlcXVpcmUoJy4vdmlldy9saW5rLmpzJyk7XG52YXIgVlN0YXRlc0hlYWRlciA9IHJlcXVpcmUoJy4vdmlldy9zdGF0ZXNoZWFkZXIuanMnKTtcbnZhciBWTWV0YWRhdGEgPSByZXF1aXJlKCcuL3ZpZXcvbWV0YWRhdGEuanMnKTtcbnZhciBWUm91bmRCdXR0b24gPSByZXF1aXJlKCcuL3ZpZXcvcm91bmRidXR0b24uanMnKTtcbnZhciBWUHJldmlldyA9IHJlcXVpcmUoJy4vdmlldy9wcmV2aWV3LmpzJyk7XG5cbnZhciBDU3RhdGVzSGVhZGVyID0gcmVxdWlyZSgnLi9jb250cm9sbGVyL3N0YXRlc2hlYWRlci5qcycpO1xudmFyIENDbG9zZUJ1dHRvbiA9IHJlcXVpcmUoJy4vY29udHJvbGxlci9jbG9zZWJ1dHRvbi5qcycpO1xudmFyIENFZGl0b3IgPSByZXF1aXJlKCcuL2NvbnRyb2xsZXIvZWRpdG9yLmpzJyk7XG52YXIgQ1ByZXZpZXcgPSByZXF1aXJlKCcuL2NvbnRyb2xsZXIvcHJldmlldy5qcycpO1xuXG4vKiFcbiAqIFxcYnJpZWYgdHJhbnNmb3JtIHRoZSBzZWxlY3RlZCBkaXZpc2lvbiBpbnRvIGEgZGlzdHJpYnV0ZWQgYW5kIGRlY2VudHJhbGl6ZWQgXG4gKiBjb2xsYWJvcmF0aXZlIGVkaXRvci5cbiAqIFxccGFyYW0gb3B0aW9ucyB7XG4gKiAgIHNpZ25hbGluZ09wdGlvbnM6IGNvbmZpZ3VyZSB0aGUgc2lnbmFsaW5nIHNlcnZpY2UgdG8gam9pbiBvciBzaGFyZSB0aGVcbiAqICAgICBkb2N1bWVudC4ge2FkZHJlc3M6IGh0dHA6Ly9leGFtcGxlLm9mLnNpZ25hbGluZy5zZXJ2aWNlLmFkZHJlc3MsXG4gKiAgICAgICAgICAgICAgICBzZXNzaW9uOiB0aGUtc2Vzc2lvbi11bmlxdWUtaWRlbnRpZmllcixcbiAqICAgICAgICAgICAgICAgIGNvbm5lY3Q6IHRydWV8ZmFsc2V9XG4gKiAgIHdlYlJUQ09wdGlvbnM6IGNvbmZpZ3VyZSB0aGUgU1RVTi9UVVJOIHNlcnZlciB0byBlc3RhYmxpc2ggV2ViUlRDXG4gKiAgICAgY29ubmVjdGlvbnMuXG4gKiAgIHN0eWxlT3B0aW9uczogY2hhbmdlIHRoZSBkZWZhdWx0IHN0eWxpbmcgb3B0aW9ucyBvZiB0aGUgZWRpdG9yLlxuICogICBuYW1lOiB0aGUgbmFtZSBvZiB0aGUgZG9jdW1lbnRcbiAqICAgaW1wb3J0RnJvbUpTT046IHRoZSBqc29uIG9iamVjdCBjb250YWluaW5nIHRoZSBhZm9ybWVudGlvbm5lZCBvcHRpb25zIHBsdXNcbiAqICAgICB0aGUgc2F2ZWQgc2VxdWVuY2UuIElmIGFueSBvZiB0aGUgb3RoZXIgYWJvdmUgb3B0aW9ucyBhcmUgc3BlY2lmaWVkLCB0aGVcbiAqICAgICBvcHRpb24gaW4gdGhlIGpzb24gb2JqZWN0IGFyZSBlcmFzZWQgYnkgdGhlbS5cbiAqIH1cbiAqL1xuJC5mbi5jcmF0aWZ5ID0gZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgLy8gIzAgZXhhbWluZSB0aGUgYXJndW1lbnRzXG4gICAgLy8gKFRPRE8pIGFwcGx5IHN0eWxlIG9wdGlvbnNcbiAgICB2YXIgc3R5bGVPcHRpb25zPSQuZXh0ZW5kKHsnaGVhZGVyQmFja2dyb3VuZENvbG9yJzogJyMyNDJiMzInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWFkZXJDb2xvcic6ICcjZWNlY2VjJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZWRpdG9yQmFja2dyb3VuZENvbG9yJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlZGl0b3JIZWlnaHQnOiAnNDAwcHgnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zICYmIG9wdGlvbnMuc3R5bGVPcHRpb25zKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbXBvcnRGcm9tSlNPTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaW1wb3J0RnJvbUpTT04uc3R5bGVPcHRpb25zKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge30pO1xuICAgIFxuICAgIHZhciB3ZWJSVENPcHRpb25zID0gKG9wdGlvbnMgJiYgb3B0aW9ucy53ZWJSVENPcHRpb25zKSB8fFxuICAgICAgICAob3B0aW9ucyAmJiBvcHRpb25zLmltcG9ydEZyb21KU09OICYmXG4gICAgICAgICBvcHRpb25zLmltcG9ydEZyb21KU09OLndlYlJUQ09wdGlvbnMpIHx8XG4gICAgICAgIHt9O1xuICAgIFxuICAgIHZhciBzaWduYWxpbmdPcHRpb25zPVxuICAgICAgICAkLmV4dGVuZChcbiAgICAgICAgICAgICQuZXh0ZW5kKHsvL3NlcnZlcjogXCJodHRwOi8vMTI3LjAuMC4xOjUwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXI6IFwiaHR0cHM6Ly9hbmNpZW50LXNoZWxmLTkwNjcuaGVyb2t1YXBwLmNvbVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb246IEdVSUQoKSxcbiAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgICAgICAob3B0aW9ucyAmJiBvcHRpb25zLmltcG9ydEZyb21KU09OICYmXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbXBvcnRGcm9tSlNPTi5zaWduYWxpbmdPcHRpb25zKSB8fFxuICAgICAgICAgICAgICAgICAgICAge30pLFxuICAgICAgICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWxpbmdPcHRpb25zKSB8fCB7fSk7XG5cbiAgICB2YXIgbmFtZSA9IChvcHRpb25zICYmIG9wdGlvbnMubmFtZSkgfHxcbiAgICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbXBvcnRGcm9tSlNPTiAmJlxuICAgICAgICAgb3B0aW9ucy5pbXBvcnRGcm9tSlNPTi5uYW1lKSB8fFxuICAgICAgICBcImRlZmF1bHRcIjtcbiAgICBcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vICMxIGluaXRpYWxpemUgdGhlIG1vZGVsXG4gICAgICAgIHZhciBtID0gbmV3IE1vZGVsKHNpZ25hbGluZ09wdGlvbnMsIHdlYlJUQ09wdGlvbnMsIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaW1wb3J0RnJvbUpTT04pO1xuXG4gICAgICAgIC8vICMyIGluaXRpYWxpemUgdGhlIHZpZXdcbiAgICAgICAgdmFyIGRpdklkID0gR1VJRCgpO1xuICAgICAgICB2YXIgdnMgID0gbmV3IFZTdHJ1Y3R1cmUodGhpcyk7XG4gICAgICAgIHZhciB2ZSAgPSBuZXcgVkVkaXRvcih2cy5ib2R5LCBkaXZJZCk7XG4gICAgICAgIHZhciB2Y2IgPSBuZXcgVkNsb3NlQnV0dG9uKHZzLmhlYWRlclJpZ2h0UmlnaHRSaWdodCk7XG4gICAgICAgIHZhciB2bSAgPSBuZXcgVk1ldGFkYXRhKG0sIHZzLmhlYWRlckxlZnQpO1xuICAgICAgICB2YXIgdnNoID0gbmV3IFZTdGF0ZXNIZWFkZXIobSwgdnMuaGVhZGVyUmlnaHQpO1xuICAgICAgICB2YXIgdmwgID0gbmV3IFZMaW5rKHRoaXMsIGRpdklkKTtcbiAgICAgICAgdmFyIHZwYiA9IG5ldyBWUm91bmRCdXR0b24odnMuaGVhZGVyUmlnaHRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtZXllXCI+PC9pPicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzd2l0Y2ggdG8gcHJldmlldycpO1xuICAgICAgICB2YXIgdnAgID0gbmV3IFZQcmV2aWV3KHZzLmJvZHkpO1xuXG4gICAgICAgIHZhciB2c2IgPSBuZXcgVlJvdW5kQnV0dG9uKHZzLmhlYWRlclJpZ2h0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWxpbmtcIj48L2k+JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXJ0IHNoYXJpbmcnKTtcbiAgICAgICAgdmFyIHZzZXQgPSBuZXcgVlJvdW5kQnV0dG9uKHZzLmhlYWRlclJpZ2h0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGkgY2xhc3M9XCJmYSBmYS1jb2dzXCI+PC9pPicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2V0dGluZ3MgKGRpc2FibGVkKScpO1xuICAgICAgICAvLyAjMyBpbml0aWFsaXplIHRoZSBjb250cm9sbGVyc1xuICAgICAgICB2YXIgY2NiID0gbmV3IENDbG9zZUJ1dHRvbihtLCB2Y2IsIHRoaXMpO1xuICAgICAgICB2YXIgY3NoID0gbmV3IENTdGF0ZXNIZWFkZXIobSwgdnNoLCB2bCwgdnNiKTtcbiAgICAgICAgdmFyIGNlICA9IG5ldyBDRWRpdG9yKG0sIHZlKTtcbiAgICAgICAgdmFyIGNwICA9IG5ldyBDUHJldmlldyh2cGIsIHZlLCB2cCk7XG4gICAgICAgIFxuICAgICAgICAvLyAjNCBncmFudCBxdWljayBhY2Nlc3NcbiAgICAgICAgdGhpcy5oZWFkZXIgPSB2cy5oZWFkZXJSaWdodFJpZ2h0O1xuICAgICAgICB0aGlzLmNsb3NlQnV0dG9uID0gdmNiLmJ1dHRvbjtcbiAgICAgICAgdGhpcy5wcmV2aWV3QnV0dG9uID0gdnBiLmJ1dHRvbjtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG07XG5cbiAgICAgICAgLy8gIzUgb3B0aW9ubmFsbHkgam9pbiBhbiBlZGl0aW5nIHNlc3Npb25cbiAgICAgICAgaWYgKHNpZ25hbGluZ09wdGlvbnMuY29ubmVjdCl7XG4gICAgICAgICAgICBjc2guc3RhcnRKb2luaW5nKHNpZ25hbGluZ09wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcbiIsIi8qXG4gKiBcXHVybCBodHRwczovL2dpdGh1Yi5jb20vanVzdGF5YWsveXV0aWxzL2Jsb2IvbWFzdGVyL3l1dGlscy5qc1xuICogXFxhdXRob3IganVzdGF5YWtcbiAqL1xuXG4vKiFcbiAqIFxcYnJpZWYgZ2V0IGEgZ2xvYmFsbHkgdW5pcXVlICh3aXRoIGhpZ2ggcHJvYmFiaWxpdHkpIGlkZW50aWZpZXJcbiAqIFxccmV0dXJuIGEgc3RyaW5nIGJlaW5nIHRoZSBpZGVudGlmaWVyXG4gKi9cbmZ1bmN0aW9uIEdVSUQoKXtcbiAgICB2YXIgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBndWlkID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IChkICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICAgICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICAgICAgcmV0dXJuIChjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpKS50b1N0cmluZygxNik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGd1aWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdVSUQ7XG4iLCJ2YXIgQ29yZSA9IHJlcXVpcmUoJ2NyYXRlLWNvcmUnKTtcblxudmFyIEdVSUQgPSByZXF1aXJlKCcuL2d1aWQuanMnKTtcbnZhciBTaWduYWxpbmcgPSByZXF1aXJlKCcuL3NpZ25hbGluZy5qcycpO1xuXG5cbmZ1bmN0aW9uIE1vZGVsKHNpZ25hbGluZ09wdGlvbnMsIHdlYlJUQ09wdGlvbnMsIG5hbWUsIGltcG9ydEZyb21KU09OKXtcbiAgICAvLyAjMUEgaW5pdGlhbGl6ZSBpbnRlcm5hbCB2YXJpYWJsZXNcbiAgICB0aGlzLnVpZCA9IEdVSUQoKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7IC8vIChUT0RPKSBjaGFuZ2VcbiAgICB0aGlzLndlYlJUQ09wdGlvbnMgPSB3ZWJSVENPcHRpb25zO1xuXG4gICAgdGhpcy5jb3JlID0gbmV3IENvcmUodGhpcy51aWQsIHtjb25maWc6d2ViUlRDT3B0aW9uc30pO1xuICAgIHRoaXMuc2lnbmFsaW5nID0gbmV3IFNpZ25hbGluZyh0aGlzLmNvcmUuYnJvYWRjYXN0LnNvdXJjZSxzaWduYWxpbmdPcHRpb25zKTtcblxuICAgIC8vICMxQiBpZiBpdCBpcyBpbXBvcnRlZCBmcm9tIGFuIGV4aXN0aW5nIG9iamVjdCwgaW5pdGlhbGl6ZSBpdCB3aXRoIHRoZXNlXG4gICAgaWYgKGltcG9ydEZyb21KU09OKXsgdGhpcy5jb3JlLmluaXQoaW1wb3J0RnJvbUpTT04pOyB9OyAgICBcbiAgICBcbiAgICAvLyAjMiBncmFudCBmYXN0IGFjY2Vzc1xuICAgIHRoaXMuYnJvYWRjYXN0ID0gdGhpcy5jb3JlLmJyb2FkY2FzdDtcbiAgICB0aGlzLnJwcyA9IHRoaXMuY29yZS5icm9hZGNhc3Quc291cmNlO1xuICAgIHRoaXMuc2VxdWVuY2UgPSB0aGlzLmNvcmUuc2VxdWVuY2U7XG4gICAgdGhpcy5jYXVzYWxpdHkgPSB0aGlzLmJyb2FkY2FzdC5jYXVzYWxpdHk7XG4gICAgdGhpcy5zaWduYWxpbmdPcHRpb25zID0gdGhpcy5zaWduYWxpbmcuc2lnbmFsaW5nT3B0aW9ucztcbiAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG4iLCJ2YXIgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qIVxuICogXFxicmllZiBoYW5kbGUgdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAqIFxccGFyYW0gcnBzIHRoZSByYW5kb20gcGVlciBzYW1wbGluZyBwcm90b2NvbFxuICogXFxwYXJhbSBzaWduYWxpbmdPcHRpb25zIHNwZWNpZmljIG9wdGlvbnMgZm9yIHRoZSBzaWduYWxpbmcgc2VydmVyKHMpLiBGb3JcbiAqIG5vdywgaXQncyBhbiBvYmplY3QgeyBzZXJ2ZXIsIHNlc3Npb24sIGR1cmF0aW9uIH0gd2hlcmUgc2VydmVyIGlzXG4gKiB0aGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyIHRvIGNvbnRhY3QsIHNlc3Npb24gaXMgdGhlIGVkaXRpbmcgc2Vzc2lvbiB0byBqb2luXG4gKiBvciBzaGFyZSwgZHVyYXRpb24gaXMgdGhlIG9wdGlvbmFsIGR1cmF0aW9uIHRpbWUgZHVyaW5nIHdoaWNoIHRoZSBzb2NrZXQgd2l0aFxuICogdGhlIHNpZ25hbGluZyBzZXJ2ZXIgc3RheXMgb3Blbi5cbiAqL1xuZnVuY3Rpb24gU2lnbmFsaW5nKHJwcywgc2lnbmFsaW5nT3B0aW9ucyl7XG4gICAgdGhpcy5ycHMgPSBycHM7XG4gICAgdGhpcy5zaWduYWxpbmdPcHRpb25zID0gc2lnbmFsaW5nT3B0aW9ucztcbiAgICB0aGlzLnNvY2tldElPQ29uZmlnID0geyAnZm9yY2UgbmV3IGNvbm5lY3Rpb24nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWNvbm5lY3Rpb24nOiBmYWxzZSB9O1xuICAgIHRoaXMuc3RhcnRlZFNvY2tldCA9IGZhbHNlO1xuICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsOyAvLyBldmVudCBpZCBvZiB0aGUgdGVybWluYXRpb25cbiAgICB0aGlzLmpvaW5lcnMgPSAwO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGNyZWF0ZSBhIGNvbm5lY3Rpb24gd2l0aCBhIHNvY2tldC5pbyBzZXJ2ZXIgYW5kIGluaXRpYWxpemUgdGhlIGV2ZW50c1xuICovXG5TaWduYWxpbmcucHJvdG90eXBlLmNyZWF0ZVNvY2tldCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vICNBIGVzdGFibGlzaCB0aGUgZGlhbG9nIHdpdGggdGhlIHNvY2tldC5pbyBzZXJ2ZXJcbiAgICBpZighdGhpcy5zdGFydGVkU29ja2V0KXtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBpbyh0aGlzLnNpZ25hbGluZ09wdGlvbnMuc2VydmVyLCB0aGlzLnNvY2tldElPQ29uZmlnKTtcbiAgICAgICAgdGhpcy5zdGFydGVkU29ja2V0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXIgZXN0YWJsaXNoZWQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKCdsYXVuY2hSZXNwb25zZScsIGZ1bmN0aW9uKGlkSm9pbmVyLCBvZmZlclRpY2tldCl7XG4gICAgICAgICAgICBzZWxmLmpvaW5lcnMgPSBzZWxmLmpvaW5lcnMgKyAxO1xuICAgICAgICAgICAgc2VsZi5ycHMuYW5zd2VyKG9mZmVyVGlja2V0LCBmdW5jdGlvbihzdGFtcGVkVGlja2V0KXsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2VsZi5zb2NrZXQuZW1pdCgnYW5zd2VyJywgaWRKb2luZXIsIHN0YW1wZWRUaWNrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbignYW5zd2VyUmVzcG9uc2UnLCBmdW5jdGlvbihoYW5kc2hha2VNZXNzYWdlKXtcbiAgICAgICAgICAgIHNlbGYucnBzLmhhbmRzaGFrZShoYW5kc2hha2VNZXNzYWdlKTtcbiAgICAgICAgICAgIHNlbGYuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKCdkaXNjb25uZWN0JywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0aW9uIGZyb20gdGhlIHNpZ25hbGluZyBzZXJ2ZXInKTtcbiAgICAgICAgICAgIHNlbGYuc3RhcnRlZFNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5qb2luZXJzID0gMDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gI0IgcmVzZXQgdGltZXIgYmVmb3JlIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb25cbiAgICBpZiAodGhpcy50aW1lb3V0IT09bnVsbCl7IGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpOyB9O1xuICAgIC8vICNDIGluaXRpYWxpemUgYSB0aW1lciBiZWZvcmUgY2xvc2luZyB0aGUgY29ubmVjdGlvblxuICAgIGlmICh0aGlzLnNpZ25hbGluZ09wdGlvbnMuZHVyYXRpb24pe1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLnN0b3BTaGFyaW5nKCk7XG4gICAgICAgIH0sIHRoaXMuc2lnbmFsaW5nT3B0aW9ucy5kdXJhdGlvbik7XG4gICAgfTtcbn07XG5cblNpZ25hbGluZy5wcm90b3R5cGUuc3RhcnRTaGFyaW5nID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5jcmVhdGVTb2NrZXQoKTtcbiAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYuc29ja2V0LmVtaXQoJ3NoYXJlJywgc2VsZi5zaWduYWxpbmdPcHRpb25zLnNlc3Npb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnNvY2tldDtcbn07XG5cblNpZ25hbGluZy5wcm90b3R5cGUuc3RvcFNoYXJpbmcgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xufTtcblxuU2lnbmFsaW5nLnByb3RvdHlwZS5zdGFydEpvaW5pbmcgPSBmdW5jdGlvbihzaWduYWxpbmdPcHRpb25zKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5jcmVhdGVTb2NrZXQoKTtcbiAgICB0aGlzLnNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYucnBzLmxhdW5jaChmdW5jdGlvbihsYXVuY2hNZXNzYWdlKXtcbiAgICAgICAgICAgIHNlbGYuc29ja2V0LmVtaXQoJ2xhdW5jaCcsIHNpZ25hbGluZ09wdGlvbnMuc2Vzc2lvbiwgbGF1bmNoTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnNvY2tldDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYWxpbmc7XG4iLCJcbmZ1bmN0aW9uIENsb3NlQnV0dG9uKGNvbnRhaW5lcil7XG4gICAgdGhpcy5idXR0b24gPSAgalF1ZXJ5KCc8YnV0dG9uPicpLmFwcGVuZFRvKGNvbnRhaW5lcilcbiAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgLmFkZENsYXNzKCdjbG9zZScpXG4gICAgICAgIC5jc3MoJ2NvbG9yJywgJ3doaXRlJylcbiAgICAgICAgLmFwcGVuZChqUXVlcnkoJzxzcGFuPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxuICAgICAgICAgICAgICAgIC5odG1sKCcmbmJzcDsmbmJzcDsmdGltZXMnKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb3NlQnV0dG9uO1xuIiwiXG5mdW5jdGlvbiBFZGl0b3IoY29udGFpbmVyLCBpZCl7XG4gICAgdGhpcy5kaXYgPSBqUXVlcnkoJzxkaXY+JykuYXBwZW5kVG8oY29udGFpbmVyKVxuICAgICAgICAuYXR0cignaWQnLCdjcmF0ZS0nK2lkKVxuICAgICAgICAuY3NzKCdtaW4taGVpZ2h0JywgJzQwMHB4Jyk7XG4gICAgdGhpcy5lZGl0b3IgPSBhY2UuZWRpdCgnY3JhdGUtJytpZCk7XG5cbiAgICB0aGlzLmVkaXRvci4kYmxvY2tTY3JvbGxpbmcgPSBJbmZpbml0eTtcbiAgICB0aGlzLmVkaXRvci5zZXRUaGVtZShcImFjZS90aGVtZS9jaHJvbWVcIik7XG4gICAgdGhpcy5lZGl0b3IuZ2V0U2Vzc2lvbigpLnNldFVzZVdyYXBNb2RlKHRydWUpOyAvLyB3b3JkIHdyYXBwaW5nXG4gICAgdGhpcy5lZGl0b3Iuc2V0SGlnaGxpZ2h0QWN0aXZlTGluZShmYWxzZSk7IC8vIG5vdCBoaWdobGlnaHRpbmcgY3VycmVudCBsaW5lXG4gICAgdGhpcy5lZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKGZhbHNlKTsgLy8gbm8gODAgY29sdW1uIG1hcmdpblxuICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNldFNob3dHdXR0ZXIoZmFsc2UpOyAvLyBubyBsaW5lIG51bWJlcnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRWRpdG9yO1xuIiwiXG5mdW5jdGlvbiBMaW5rVmlldyhjb250YWluZXIsIGlkKXtcblxuICAgIHRoaXMubGlua0NvbnRhaW5lciA9IGpRdWVyeSgnPGRpdj4nKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICAgIC5hZGRDbGFzcygnY29udGFpbmVyJylcbiAgICAgICAgLmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKVxuICAgICAgICAuY3NzKCd0b3AnLCAnLTEwMHB4JylcbiAgICAgICAgLmNzcygnd2lkdGgnLCAnaW5oZXJpdCcpXG4gICAgICAgIC5jc3MoJ3otaW5kZXgnLCAnMTAnKVxuICAgICAgICAuY3NzKCdvcGFjaXR5JywgJzAuOScpXG4gICAgICAgIC5oaWRlKCk7XG4gICAgXG4gICAgLy8gIzAgcXIgY29kZSBtb2RhbFxuICAgIHZhciBxckNvZGVNb2RhbCA9IGpRdWVyeSgnPGRpdj4nKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICAgIC5hdHRyKCdpZCcsICdtb2RhbFFSQ29kZScraWQpXG4gICAgICAgIC5hdHRyKCd0YWJpbmRleCcsJy0xJylcbiAgICAgICAgLmF0dHIoJ3JvbGUnLCdkaWFsb2cnKVxuICAgICAgICAuYXR0cignYXJpYS1sYWJlbGxlZGJ5JywnbW9kYWxRUkNvZGVMYWJlbCcpXG4gICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJylcbiAgICAgICAgLmFkZENsYXNzKCdtb2RhbCcpO1xuICAgIFxuICAgIHZhciBxckNvZGVNb2RhbERpYWxvZyA9IGpRdWVyeSgnPGRpdj4nKS5hcHBlbmRUbyhxckNvZGVNb2RhbClcbiAgICAgICAgLmFkZENsYXNzKCdtb2RhbC1kaWFsb2cnKTtcbiAgICB2YXIgcXJDb2RlTW9kYWxDb250ZW50ID0galF1ZXJ5KCc8ZGl2PicpLmFwcGVuZFRvKHFyQ29kZU1vZGFsRGlhbG9nKVxuICAgICAgICAuYWRkQ2xhc3MoJ21vZGFsLWNvbnRlbnQgdGV4dC1jZW50ZXInKTtcbiAgICB0aGlzLnFyY29kZUNhbnZhcyA9IGpRdWVyeSgnPGRpdj4nKTtcbiAgICBxckNvZGVNb2RhbENvbnRlbnQuYXBwZW5kKGpRdWVyeSgnPGJyPicpKVxuICAgICAgICAuYXBwZW5kKHRoaXMucXJjb2RlQ2FudmFzKVxuICAgICAgICAuYXBwZW5kKGpRdWVyeSgnPGJyPicpKTtcbiAgICBcbiAgICAvLyAjMSBvdmVyYWxsIGRpdmlzaW9uXG4gICAgdGhpcy5hbGVydCA9IGpRdWVyeSgnPGRpdj4nKS5hcHBlbmRUbyh0aGlzLmxpbmtDb250YWluZXIpXG4gICAgICAgIC5hdHRyKCdyb2xlJywgJ2FsZXJ0JylcbiAgICAgICAgLmFkZENsYXNzKCdhbGVydCBhbGVydC13YXJuaW5nIGFsZXJ0LWRpc21pc3NpYmxlJyk7XG4gICAgLy8gIzIgY3Jvc3MgdG8gY2xvc2UgdGhlIGRpdmlzaW9uXG4gICAgdGhpcy5kaXNtaXNzID0galF1ZXJ5KCc8YnV0dG9uPicpLmFwcGVuZFRvKHRoaXMuYWxlcnQpXG4gICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgIC5hZGRDbGFzcygnY2xvc2UnKVxuICAgICAgICAuaHRtbCgnPHNwYW4gIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+PHNwYW4gY2xhc3M9XCJzci1vbmx5XCI+ICcrXG4gICAgICAgICAgICAgICdDbG9zZSA8L3NwYW4+Jyk7XG4gICAgdmFyIHJvd0NvbnRhaW5lciA9IGpRdWVyeSgnPGRpdj4nKS5hcHBlbmRUbyh0aGlzLmFsZXJ0KVxuICAgICAgICAuYWRkQ2xhc3MoJ2NvbnRhaW5lcicpO1xuICAgIHZhciBpbnB1dEdyb3VwID0galF1ZXJ5KCc8ZGl2PicpLmFwcGVuZFRvKHJvd0NvbnRhaW5lcilcbiAgICAgICAgLmFkZENsYXNzKCdpbnB1dC1ncm91cCcpO1xuICAgIHRoaXMuaW5wdXQgPSBqUXVlcnkoJzxpbnB1dD4nKS5hcHBlbmRUbyhpbnB1dEdyb3VwKVxuICAgICAgICAuYXR0cigndHlwZScsICd0ZXh0JylcbiAgICAgICAgLmF0dHIoJ3BsYWNlaG9sZGVyJywgJ05vdGhpbmcgdG8gc2VlIGhlcmUsIG1vdmUgYWxvbmcuJylcbiAgICAgICAgLmFkZENsYXNzKCdmb3JtLWNvbnRyb2wnKTtcbiAgICBcbiAgICB2YXIgaW5wdXRHcm91cDIgPSBqUXVlcnkoJzxzcGFuPicpLmFwcGVuZFRvKGlucHV0R3JvdXApXG4gICAgICAgIC5hZGRDbGFzcygnaW5wdXQtZ3JvdXAtYnRuJyk7XG5cbiAgICB0aGlzLnFyY29kZSA9IGpRdWVyeSgnPGJ1dHRvbj4nKS5hcHBlbmRUbyhpbnB1dEdyb3VwMilcbiAgICAgICAgLmF0dHIoJ2FyaWEtbGFiZWwnLCAnUVItY29kZScpXG4gICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgIC5hdHRyKCdkYXRhLXRhcmdldCcsICcjbW9kYWxRUkNvZGUnK2lkKVxuICAgICAgICAuYXR0cignZGF0YS10b2dnbGUnLCAnbW9kYWwnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2J0biBidG4tZGVmYXVsdCcpXG4gICAgICAgIC5odG1sKCc8aSBjbGFzcz1cImZhIGZhLXFyY29kZVwiPjwvaT4gUVItQ29kZScpO1xuXG4gICAgdGhpcy5hY3Rpb24gPSBqUXVlcnkoJzxidXR0b24+JykuYXBwZW5kVG8oaW5wdXRHcm91cDIpXG4gICAgICAgIC5hdHRyKCdhcmlhLWxhYmVsJywgJ0dvIScpXG4gICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgIC5hZGRDbGFzcygnYnRuIGJ0bi1kZWZhdWx0JylcbiAgICAgICAgLmh0bWwoJ0dvIScpXG4gICAgICAgIC5jc3MoJ3otaW5kZXgnLCAnMTUnKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRpc21pc3MudW5iaW5kKFwiY2xpY2tcIikuY2xpY2soZnVuY3Rpb24oKXtzZWxmLmxpbmtDb250YWluZXIuaGlkZSgpO30pO1xufTtcblxuTGlua1ZpZXcucHJvdG90eXBlLnByaW50TGluayA9IGZ1bmN0aW9uKGxpbmspe1xuICAgIHRoaXMubGlua0NvbnRhaW5lci5zaG93KCk7XG4gICAgdGhpcy5hbGVydC5yZW1vdmVDbGFzcyhcImFsZXJ0LWluZm9cIikuYWRkQ2xhc3MoXCJhbGVydC13YXJuaW5nXCIpO1xuICAgIHRoaXMuYWN0aW9uLmh0bWwoJzxpIGNsYXNzPVwiZmEgZmEtY2xpcGJvYXJkXCI+PC9pPiBDb3B5Jyk7XG4gICAgdGhpcy5hY3Rpb24uYXR0cihcImFyaWEtbGFiZWxcIiwgXCJDb3B5IHRvIGNsaXBib2FyZFwiKTtcbiAgICB0aGlzLmlucHV0LmF0dHIoXCJyZWFkb25seVwiLFwicmVhZG9ubHlcIik7XG4gICAgdGhpcy5pbnB1dC52YWwobGluayk7XG4gICAgdGhpcy5xcmNvZGUuc2hvdygpO1xufTtcblxuTGlua1ZpZXcucHJvdG90eXBlLnByaW50TGF1bmNoTGluayA9IGZ1bmN0aW9uKGxpbmspe1xuICAgIHRoaXMucHJpbnRMaW5rKGxpbmspO1xuICAgIHRoaXMuaW5wdXQuYXR0cihcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQSBsaW5rIHdpbGwgYXBwZWFyIGluIHRoaXMgZmllbGQsIGdpdmUgaXQgdG8geW91ciBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJmcmllbmQhXCIpO1xuICAgIHRoaXMuYWN0aW9uLnVuYmluZChcImNsaWNrXCIpO1xuICAgIHRoaXMucXJjb2RlLmhpZGUoKTtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb247XG59O1xuXG5MaW5rVmlldy5wcm90b3R5cGUucHJpbnRBbnN3ZXJMaW5rID0gZnVuY3Rpb24obGluayl7XG4gICAgdGhpcy5wcmludExpbmsobGluayk7XG4gICAgdGhpcy5pbnB1dC5hdHRyKFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJBIGxpbmsgd2lsbCBhcHBlYXIgaW4gdGhpcyBmaWVsZC4gUGxlYXNlIGdpdmUgaXQgXCIrXG4gICAgICAgICAgICAgICAgICAgIFwiYmFjayB0byB5b3VyIGZyaWVuZC5cIik7XG4gICAgdGhpcy5hY3Rpb24udW5iaW5kKFwiY2xpY2tcIik7XG4gICAgdGhpcy5xcmNvZGUuaGlkZSgpO1xuICAgIHJldHVybiB0aGlzLmFjdGlvbjtcbn07XG5cbkxpbmtWaWV3LnByb3RvdHlwZS5hc2tMaW5rID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmxpbmtDb250YWluZXIuc2hvdygpO1xuICAgIHRoaXMuYWxlcnQucmVtb3ZlQ2xhc3MoXCJhbGVydC13YXJuaW5nXCIpLmFkZENsYXNzKFwiYWxlcnQtaW5mb1wiKTtcbiAgICB0aGlzLmFjdGlvbi5odG1sKCdHbyEnKTtcbiAgICB0aGlzLmFjdGlvbi5hdHRyKFwiYXJpYS1sYWJlbFwiLCBcIlN0YW1wIHRoZSB0aWNrZXRcIik7XG4gICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyKFwicmVhZG9ubHlcIik7XG4gICAgdGhpcy5pbnB1dC52YWwoXCJcIik7XG4gICAgdGhpcy5hY3Rpb24udW5iaW5kKFwiY2xpY2tcIik7XG4gICAgdGhpcy5xcmNvZGUuaGlkZSgpO1xufTtcblxuTGlua1ZpZXcucHJvdG90eXBlLmFza0xhdW5jaExpbmsgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXNrTGluaygpO1xuICAgIHRoaXMuaW5wdXQuYXR0cihcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlLCBjb3B5IHRoZSB0aWNrZXQgb2YgeW91ciBmcmllbmQgaGVyZSB0byBzdGFtcCBcIitcbiAgICAgICAgICAgICAgICAgICAgXCJpdCFcIik7XG4gICAgdGhpcy5xcmNvZGUuaGlkZSgpO1xuICAgIHJldHVybiB0aGlzLmFjdGlvbjtcbn07XG5cbkxpbmtWaWV3LnByb3RvdHlwZS5hc2tBbnN3ZXJMaW5rID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFza0xpbmsoKTtcbiAgICB0aGlzLmlucHV0LmF0dHIoXCJwbGFjZWhvbGRlclwiLCBcIkNvcHkgdGhlIHN0YW1wZWQgdGlja2V0IHRvIGNvbmZpcm0gXCIrXG4gICAgICAgICAgICAgICAgICAgIFwieW91ciBhcnJpdmFsIGluIHRoZSBuZXR3b3JrXCIpO1xuICAgIHRoaXMucXJjb2RlLmhpZGUoKTtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb247XG59O1xuXG5MaW5rVmlldy5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5saW5rQ29udGFpbmVyLmhpZGUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua1ZpZXc7XG4iLCJ2YXIgYW5pbWFscyA9IHJlcXVpcmUoJ2FuaW1hbHMnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnc3RyaW5nLWhhc2gnKTtcblxuZnVuY3Rpb24gTWFya2VyKHNlc3Npb24sIG9yaWdpbiwgcmFuZ2Upe1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgdGhpcy5jdXJzb3JzID0gW3JhbmdlXTtcbiAgICB0aGlzLmNvbG9yID0gZ2V0Q29sb3IodGhpcy5vcmlnaW4pO1xuICAgIHRoaXMuY29sb3JSR0IgPSAncmdiKCcrdGhpcy5jb2xvcisnKSc7XG4gICAgdGhpcy5jb2xvclJHQkxpZ2h0ID0gJ3JnYmEoJyt0aGlzLmNvbG9yKycsIDAuNSknO1xuICAgIHRoaXMuYW5pbWFsID0gJ0Fub255bW91cyAnICtcbiAgICAgICAgY2FwaXRhbGl6ZShhbmltYWxzLndvcmRzW2hhc2godGhpcy5vcmlnaW4pJWFuaW1hbHMud29yZHMubGVuZ3RoXSk7XG59O1xuXG4vLyAoVE9ETykgcmVmYWN0b3IgdXNpbmcganF1ZXJ5XG5NYXJrZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGh0bWwsIG1hcmtlckxheWVyLCBzZXNzaW9uLCBjb25maWcpe1xuICAgIHZhciBzdGFydCA9IGNvbmZpZy5maXJzdFJvdywgZW5kID0gY29uZmlnLmxhc3RSb3c7XG4gICAgdmFyIGN1cnNvcnMgPSB0aGlzLmN1cnNvcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJzb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBybmcgPSB7XG4gICAgICAgICAgICBzdGFydDogc2Vzc2lvbi5nZXREb2N1bWVudCgpLmluZGV4VG9Qb3NpdGlvbihjdXJzb3JzW2ldLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc2Vzc2lvbi5nZXREb2N1bWVudCgpLmluZGV4VG9Qb3NpdGlvbihjdXJzb3JzW2ldLmVuZClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YXJ0U2NyZWVuUG9zID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24ocm5nLnN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZFNjcmVlblBvcyA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHJuZy5lbmQpO1xuICAgICAgICBpZiAoc3RhcnRTY3JlZW5Qb3Mucm93ID09PSBlbmRTY3JlZW5Qb3Mucm93KXsvLyFyYW5nZS5pc011bHRpTGluZSgpKXtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIGxpbmVcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGNvbmZpZy5jaGFyYWN0ZXJXaWR0aCAqXG4gICAgICAgICAgICAgICAgKGVuZFNjcmVlblBvcy5jb2x1bW4gLSBzdGFydFNjcmVlblBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgdmFyIHRvcCA9IG1hcmtlckxheWVyLiRnZXRUb3Aoc3RhcnRTY3JlZW5Qb3Mucm93LCBjb25maWcpO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBtYXJrZXJMYXllci4kcGFkZGluZyArIHN0YXJ0U2NyZWVuUG9zLmNvbHVtblxuICAgICAgICAgICAgICAgICogY29uZmlnLmNoYXJhY3RlcldpZHRoO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5jb2xvclJHQkxpZ2h0O1xuICAgICAgICAgICAgaWYod2lkdGggPT09IDApe1xuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5jb2xvclJHQjtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29kZSA9ICc8ZGl2IGNsYXNzPVwicmVtb3RlQ2FyZXRcIiBzdHlsZT1cIicgK1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOicgK3JhbmdlICsnOycgK1xuICAgICAgICAgICAgICAgICdoZWlnaHQ6JyArIGhlaWdodCArICdweDsnICtcbiAgICAgICAgICAgICAgICAndG9wOicgKyB0b3AgKyAncHg7JyArXG4gICAgICAgICAgICAgICAgJ2xlZnQ6JyArIGxlZnQgKyAncHg7JyArXG4gICAgICAgICAgICAgICAgJ3dpZHRoOicgKyB3aWR0aCArICdweFwiPic7XG4gICAgICAgICAgICBjb2RlICs9ICc8ZGl2IGNsYXNzPVwic3F1YXJlQ2FyZXRcIiBzdHlsZT1cImJhY2tncm91bmQ6JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvclJHQiArICc7XCI+JztcbiAgICAgICAgICAgIGNvZGUgKz0gJzxkaXYgY2xhc3M9XCJpbmZvQ2FyZXRcIiBzdHlsZT1cImJhY2tncm91bmQ6JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvclJHQkxpZ2h0ICsgJztcIj4nICsgdGhpcy5hbmltYWwgKyAnPC9kaXY+PC9kaXY+PC9kaXY+JztcbiAgICAgICAgICAgIGh0bWwucHVzaChjb2RlKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvLyBtdWx0aS1saW5lXG4gICAgICAgICAgICAvLyBmaXJzdCBsaW5lXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgdG9wID0gbWFya2VyTGF5ZXIuJGdldFRvcChzdGFydFNjcmVlblBvcy5yb3csIGNvbmZpZyk7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IG1hcmtlckxheWVyLiRwYWRkaW5nICsgc3RhcnRTY3JlZW5Qb3MuY29sdW1uICpcbiAgICAgICAgICAgICAgICBjb25maWcuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiPGRpdiBjbGFzcz0ncmVtb3RlQ2FyZXQgc2VsZWN0aW9uJyBzdHlsZT0nXCIgK1xuICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvcjpcIiArIHRoaXMuY29sb3JSR0JMaWdodCArIFwiO1wiICtcbiAgICAgICAgICAgICAgICBcImhlaWdodDpcIiArIGhlaWdodCArIFwicHg7XCIgK1xuICAgICAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICAgICAgXCJsZWZ0OlwiICsgbGVmdCArIFwicHg7XCIgK1xuICAgICAgICAgICAgICAgIFwicmlnaHQ6IDA7Jz5cIjtcbiAgICAgICAgICAgIGNvZGUgKz0gJzxkaXYgY2xhc3M9XCJzcXVhcmVDYXJldFwiIHN0eWxlPVwiYmFja2dyb3VuZDonICtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yUkdCICsgJztcIj4nO1xuICAgICAgICAgICAgY29kZSArPSAnPGRpdiBjbGFzcz1cImluZm9DYXJldFwiIHN0eWxlPVwiYmFja2dyb3VuZDonICtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yUkdCTGlnaHQgKyAnO1wiPicgKyB0aGlzLmFuaW1hbCArICc8L2Rpdj48L2Rpdj48L2Rpdj4nO1xuICAgICAgICAgICAgLy8gbGFzdCBsaW5lXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgICAgIHRvcCA9IG1hcmtlckxheWVyLiRnZXRUb3AoZW5kU2NyZWVuUG9zLnJvdywgY29uZmlnKTtcbiAgICAgICAgICAgIGxlZnQgPSBtYXJrZXJMYXllci4kcGFkZGluZztcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmNoYXJhY3RlcldpZHRoICogZW5kU2NyZWVuUG9zLmNvbHVtbjtcbiAgICAgICAgICAgIGNvZGUgKz0gXCI8ZGl2IGNsYXNzPSdyZW1vdGVDYXJldCcgc3R5bGU9J1wiICtcbiAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6XCIgKyB0aGlzLmNvbG9yUkdCTGlnaHQgKyBcIjtcIiArXG4gICAgICAgICAgICAgICAgXCJoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcInRvcDpcIiArIHRvcCArIFwicHg7XCIgK1xuICAgICAgICAgICAgICAgIFwibGVmdDpcIiArIGxlZnQgKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICBcIndpZHRoOlwiICsgd2lkdGggKyBcInB4Oyc+PC9kaXY+XCI7XG4gICAgICAgICAgICAvLyBtaWRkbGUgbGluZXNcbiAgICAgICAgICAgIGlmIChlbmRTY3JlZW5Qb3Mucm93IC0gc3RhcnRTY3JlZW5Qb3Mucm93ID4gMSl7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQgKlxuICAgICAgICAgICAgICAgICAgICAoZW5kU2NyZWVuUG9zLnJvdyAtIHN0YXJ0U2NyZWVuUG9zLnJvdyAtIDEpO1xuICAgICAgICAgICAgICAgIHRvcCA9IG1hcmtlckxheWVyLiRnZXRUb3Aoc3RhcnRTY3JlZW5Qb3Mucm93ICsgMSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWFya2VyTGF5ZXIuJHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgY29kZSArPSBcIjxkaXYgY2xhc3M9J3JlbW90ZUNhcmV0JyBzdHlsZT0nXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6XCIgKyB0aGlzLmNvbG9yUkdCTGlnaHQgKyBcIjtcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0OlwiICsgaGVpZ2h0ICsgXCJweDtcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidG9wOlwiICsgdG9wICsgXCJweDtcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibGVmdDpcIiArIGxlZnQgKyBcInB4O1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCJyaWdodDowOyc+PC9kaXY+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodG1sLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NYXJrZXIucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zZXNzaW9uLl9zaWduYWwoXCJjaGFuZ2VGcm9udE1hcmtlclwiKTtcbn07XG5cbk1hcmtlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9O1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5zZXNzaW9uLnJlbW92ZU1hcmtlcihzZWxmLmlkKTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc2Vzc2lvbi5yZW1vdGVDYXJldHNbc2VsZi5vcmlnaW5dO1xuICAgIH0sMTAwMDApO1xufTtcblxuTWFya2VyLnByb3RvdHlwZS5hZGRDdXJzb3IgPSBmdW5jdGlvbigpe1xuICAgIC8vIGFkZCB0byB0aGlzIGN1cnNvcnNcbiAgICAvLyB0cmlnZ2VyIHJlZHJhd1xuICAgIHRoaXMucmVkcmF3KClcbn1cblxuXG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29sb3Ioc3RyKXtcbiAgICB2YXIgaDEgPSBoYXNoKHN0ciklMjA2O1xuICAgIHZhciBoMiA9IChoMSo3KSUyMDY7XG4gICAgdmFyIGgzID0gKGgxKjExKSUyMDY7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaDErNTApKyBcIiwgXCIrTWF0aC5mbG9vcihoMis1MCkrIFwiLCBcIitNYXRoLmZsb29yKGgzKzUwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZXI7XG4iLCJcblxudmFyIGltZGF0YSA9IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQVlBQUFCemVucjBBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1QybERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk5uVkZQcEZqMzMzdlJDUzRpQWxFdHZVaFVJSUZKQ2k0QVVrU1lxSVFrUVNvZ2hvZGtWVWNFUlJVVUVHOGlnaUFPT2pvQ01GVkVzRElvSzJBZmtJYUtPZzZPSWlzcjc0WHVqYTlhODkrYk4vclhYUHVlczg1Mnp6d2ZBQ0F5V1NETlJOWUFNcVVJZUVlQ0R4OFRHNGVRdVFJRUtKSEFBRUFpelpDRnovU01CQVBoK1BEd3JJc0FIdmdBQmVOTUxDQURBVFp2QU1CeUgvdy9xUXBsY0FZQ0VBY0Iwa1RoTENJQVVBRUI2amtLbUFFQkdBWUNkbUNaVEFLQUVBR0RMWTJMakFGQXRBR0FuZitiVEFJQ2QrSmw3QVFCYmxDRVZBYUNSQUNBVFpZaEVBR2c3QUt6UFZvcEZBRmd3QUJSbVM4UTVBTmd0QURCSlYyWklBTEMzQU1ET0VBdXlBQWdNQURCUmlJVXBBQVI3QUdESUl5TjRBSVNaQUJSRzhsYzg4U3V1RU9jcUFBQjRtYkk4dVNRNVJZRmJDQzF4QjFkWExoNG96a2tYS3hRMllRSmhta0F1d25tWkdUS0JOQS9nODh3QUFLQ1JGUkhnZy9QOWVNNE9yczdPTm82MkRsOHQ2cjhHL3lKaVl1UCs1YytyY0VBQUFPRjBmdEgrTEMrekdvQTdCb0J0L3FJbDdnUm9YZ3VnZGZlTFpySVBRTFVBb09uYVYvTncrSDQ4UEVXaGtMbloyZVhrNU5oS3hFSmJZY3BYZmY1bndsL0FWLzFzK1g0OC9QZjE0TDdpSklFeVhZRkhCUGpnd3N6MFRLVWN6NUlKaEdMYzVvOUgvTGNMLy93ZDB5TEVTV0s1V0NvVTQxRVNjWTVFbW96ek1xVWlpVUtTS2NVbDB2OWs0dDhzK3dNKzN6VUFzR28rQVh1UkxhaGRZd1AyU3ljUVdIVEE0dmNBQVBLN2I4SFVLQWdEZ0dpRDRjOTMvKzgvL1VlZ0pRQ0Faa21TY1FBQVhrUWtMbFRLc3ovSENBQUFSS0NCS3JCQkcvVEJHQ3pBQmh6QkJkekJDL3hnTm9SQ0pNVENRaEJDQ21TQUhISmdLYXlDUWlpR3piQWRLbUF2MUVBZE5NQlJhSWFUY0E0dXdsVzREajF3RC9waENKN0JLTHlCQ1FSQnlBZ1RZU0hhaUFGaWlsZ2pqZ2dYbVlYNEljRklCQktMSkNESmlCUlJJa3VSTlVneFVvcFVJRlZJSGZJOWNnSTVoMXhHdXBFN3lBQXlndnlHdkVjeGxJR3lVVDNVRExWRHVhZzNHb1JHb2d2UVpIUXhtbzhXb0p2UWNyUWFQWXcyb2VmUXEyZ1AybzgrUThjd3dPZ1lCelBFYkRBdXhzTkNzVGdzQ1pOank3RWlyQXlyeGhxd1Zxd0R1NG4xWTgreGR3UVNnVVhBQ1RZRWQwSWdZUjVCU0ZoTVdFN1lTS2dnSENRMEVkb0pOd2tEaEZIQ0p5S1RxRXUwSnJvUitjUVlZakl4aDFoSUxDUFdFbzhUTHhCN2lFUEVOeVFTaVVNeUo3bVFBa214cEZUU0V0SkcwbTVTSStrc3FaczBTQm9qazhuYVpHdXlCem1VTENBcnlJWGtuZVRENURQa0crUWg4bHNLbldKQWNhVDRVK0lvVXNwcVNobmxFT1UwNVFabG1ESkJWYU9hVXQyb29WUVJOWTlhUXEyaHRsS3ZVWWVvRXpSMW1qbk5neFpKUzZXdG9wWFRHbWdYYVBkcHIraDB1aEhkbFI1T2w5Qlgwc3ZwUitpWDZBUDBkd3dOaGhXRHg0aG5LQm1iR0FjWVp4bDNHSytZVEtZWjA0c1p4MVF3TnpIcm1PZVpENWx2VlZncXRpcDhGWkhLQ3BWS2xTYVZHeW92VkttcXBxcmVxZ3RWODFYTFZJK3BYbE45cmtaVk0xUGpxUW5VbHF0VnFwMVE2MU1iVTJlcE82aUhxbWVvYjFRL3BINVovWWtHV2NOTXcwOURwRkdnc1YvanZNWWdDMk1aczNnc0lXc05xNFoxZ1RYRUpySE4yWHgyS3J1WS9SMjdpejJxcWFFNVF6TktNMWV6VXZPVVpqOEg0NWh4K0p4MFRnbm5LS2VYODM2SzNoVHZLZUlwRzZZMFRMa3haVnhycXBhWGxsaXJTS3RScTBmcnZUYXU3YWVkcHIxRnUxbjdnUTVCeDBvblhDZEhaNC9PQlozblU5bFQzYWNLcHhaTlBUcjFyaTZxYTZVYm9idEVkNzl1cCs2WW5yNWVnSjVNYjZmZWViM24raHg5TC8xVS9XMzZwL1ZIREZnR3N3d2tCdHNNemhnOHhUVnhiendkTDhmYjhWRkRYY05BUTZWaGxXR1g0WVNSdWRFOG85VkdqVVlQakduR1hPTWs0MjNHYmNhakpnWW1JU1pMVGVwTjdwcFNUYm1tS2FZN1REdE14ODNNemFMTjFwazFtejB4MXpMbm0rZWIxNXZmdDJCYWVGb3N0cWkydUdWSnN1UmFwbG51dHJ4dWhWbzVXYVZZVlZwZHMwYXRuYTBsMXJ1dHU2Y1JwN2xPazA2cm50Wm53N0R4dHNtMnFiY1pzT1hZQnR1dXRtMjJmV0ZuWWhkbnQ4V3V3KzZUdlpOOXVuMk4vVDBIRFlmWkRxc2RXaDErYzdSeUZEcFdPdDZhenB6dVAzM0Y5SmJwTDJkWXp4RFAyRFBqdGhQTEtjUnBuVk9iMDBkbkYyZTVjNFB6aUl1SlM0TExMcGMrTHBzYnh0M0l2ZVJLZFBWeFhlRjYwdldkbTdPYnd1Mm8yNi91TnU1cDdvZmNuOHcwbnltZVdUTnowTVBJUStCUjVkRS9DNStWTUd2ZnJINVBRMCtCWjdYbkl5OWpMNUZYcmRld3Q2VjNxdmRoN3hjKzlqNXluK00rNHp3MzNqTGVXVi9NTjhDM3lMZkxUOE52bmwrRjMwTi9JLzlrLzNyLzBRQ25nQ1VCWndPSmdVR0JXd0w3K0hwOEliK09QenJiWmZheTJlMUJqS0M1UVJWQmo0S3RndVhCclNGb3lPeVFyU0gzNTVqT2tjNXBEb1ZRZnVqVzBBZGg1bUdMdzM0TUo0V0hoVmVHUDQ1d2lGZ2EwVEdYTlhmUjNFTnozMFQ2UkpaRTNwdG5NVTg1cnkxS05TbytxaTVxUE5vM3VqUzZQOFl1WmxuTTFWaWRXRWxzU3h3NUxpcXVObTVzdnQvODdmT0g0cDNpQytON0Y1Z3Z5RjF3ZWFIT3d2U0ZweGFwTGhJc09wWkFUSWhPT0pUd1FSQXFxQmFNSmZJVGR5V09Dbm5DSGNKbklpL1JOdEdJMkVOY0toNU84a2dxVFhxUzdKRzhOWGtreFRPbExPVzVoQ2Vwa0x4TURVemRtenFlRnBwMklHMHlQVHE5TVlPU2taQnhRcW9oVFpPMlorcG41bVoyeTZ4bGhiTCt4VzZMdHk4ZWxRZkphN09RckFWWkxRcTJRcWJvVkZvbzF5b0hzbWRsVjJhL3pZbktPWmFybml2TjdjeXp5dHVRTjV6dm4vL3RFc0lTNFpLMnBZWkxWeTBkV09hOXJHbzVzanh4ZWRzSzR4VUZLNFpXQnF3OHVJcTJLbTNWVDZ2dFY1ZXVmcjBtZWsxcmdWN0J5b0xCdFFGcjZ3dFZDdVdGZmV2YzErMWRUMWd2V2QrMVlmcUduUnMrRlltS3JoVGJGNWNWZjlnbzNIamxHNGR2eXIrWjNKUzBxYXZFdVdUUFp0Sm02ZWJlTFo1YkRwYXFsK2FYRG00TjJkcTBEZDlXdE8zMTlrWGJMNWZOS051N2c3WkR1YU8vUExpOFphZkp6czA3UDFTa1ZQUlUrbFEyN3RMZHRXSFgrRzdSN2h0N3ZQWTA3TlhiVzd6My9UN0p2dHRWQVZWTjFXYlZaZnRKKzdQM1A2NkpxdW40bHZ0dFhhMU9iWEh0eHdQU0EvMEhJdzYyMTduVTFSM1NQVlJTajlZcjYwY094eCsrL3AzdmR5ME5OZzFWalp6RzRpTndSSG5rNmZjSjMvY2VEVHJhZG94N3JPRUgweDkySFdjZEwycENtdkthUnB0VG12dGJZbHU2VDh3KzBkYnEzbnI4UjlzZkQ1dzBQRmw1U3ZOVXlXbmE2WUxUazJmeXo0eWRsWjE5Zmk3NTNHRGJvclo3NTJQTzMyb1BiKys2RUhUaDBrWC9pK2M3dkR2T1hQSzRkUEt5MitVVFY3aFhtcTg2WDIzcWRPbzgvcFBUVDhlN25MdWFycmxjYTdudWVyMjFlMmIzNlJ1ZU44N2Q5TDE1OFJiLzF0V2VPVDNkdmZONmIvZkY5L1hmRnQxK2NpZjl6c3U3MlhjbjdxMjhUN3hmOUVEdFFkbEQzWWZWUDF2KzNOanYzSDlxd0hlZzg5SGNSL2NHaFlQUC9wSDFqdzlEQlkrWmo4dUdEWWJybmpnK09UbmlQM0w5NmZ5blE4OWt6eWFlRi82aS9zdXVGeFl2ZnZqVjY5Zk8wWmpSb1pmeWw1Ty9iWHlsL2VyQTZ4bXYyOGJDeGg2K3lYZ3pNVjcwVnZ2dHdYZmNkeDN2bzk4UFQrUjhJSDhvLzJqNXNmVlQwS2Y3a3htVGsvOEVBNWp6L0dNekxkc0FBQUFnWTBoU1RRQUFlaVVBQUlDREFBRDUvd0FBZ09rQUFIVXdBQURxWUFBQU9wZ0FBQmR2a2wvRlJnQUFBV05KUkVGVWVOcnNseTkyZzBBUWgyZjcwR2dNSjZpSVdFd2RodGRiUkNBU21WcE1SVTB0bFVUa0lwZzlRRmJrRERGb0xrQkYzbTZudzA1Z0NXbEVHY08vdDN3Znc0L0hydWk2RGg1WlQvRGdXZ1FDZlBDUkM5L3hPRUJlZzk4UFhWL0FGNXFsMHA2c2xaNGtFOXdDeFRWVkpyZ0Z5cFdQVE1DQmZhR2VNb0lUNk9ZQ2ozaWxvaWVRcFJLZVh5c0FBQ2lMWkpZdTFFcmIvWHhYd2ZtMC8zV096Y0RiNTlIdSs4cTRvUEZxWTdlZ3RuNWZ3UmdaQ3NXRjRlZlRuZzloclRURXE4dU53a2l5TW0yaklZd2tsRVhDUW5GeGNHY0dETGh0ZnA2SXlvU1JoTGJSVnVaYUdlaW9EbENJS1Nwak9zREJNWVMyZjFJR1hESlVna0x2bGdIYUFYTkRDdjJURElTUmhCZzJTd2FXREN3Wm1EY0RBQmM3ODF1ZU13T0hyMjN2bXNBckl6SXJ0cE1UbDh6UWF6Q0ZvVmtxTGVCbGZSd1VZR1dHNE9SSmhSbUxmOWxtV2o1VzRLcU1DM3JQZFlHb2xZWjhWMEZaSkpNWEpzNE0vTXUxNGZjQURzaG5sWm5xcjF3QUFBQUFTVVZPUks1Q1lJST1cIjtcblxuZnVuY3Rpb24gTWV0YWRhdGEobW9kZWwsIGNvbnRhaW5lcil7XG4gICAgdmFyIG1ldGFkYXRhU3RyaW5nID1cbiAgICAgICAgJzx1bCBzdHlsZT1cInBhZGRpbmc6IDVweDtcIj48bGk+PGI+U2Vzc2lvbjo8L2I+ICcrXG4gICAgICAgIG1vZGVsLnNpZ25hbGluZ09wdGlvbnMuc2Vzc2lvbisnPC9saT4nK1xuICAgICAgICAnPGxpPjxiPk5hbWU6PC9iPiAnKyBtb2RlbC5uYW1lKyc8L2xpPicrXG4gICAgICAgICc8bGk+PGI+RGF0ZTo8L2I+ICcrIG1vZGVsLmRhdGUudG9TdHJpbmcoKSsnPC9saT4nO1xuICAgIFxuICAgIHZhciBidXR0b25GaWxlID0galF1ZXJ5KCc8YT4nKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICAgIC5hdHRyKCdocmVmJywnIycpXG4gICAgICAgIC5hdHRyKCdkYXRhLXRyaWdnZXInLCAnaG92ZXInKS5hdHRyKCdkYXRhLXRvZ2dsZScsICdwb3BvdmVyJylcbiAgICAgICAgLmF0dHIoJ2RhdGEtcGxhY2VtZW50JywgJ2JvdHRvbScpLmF0dHIoJ2RhdGEtaHRtbCcsICd0cnVlJylcbiAgICAgICAgLmF0dHIoJ3RpdGxlJywnRG9jdW1lbnQnKS5hdHRyKCdkYXRhLWNvbnRlbnQnLCBtZXRhZGF0YVN0cmluZylcbiAgICAgICAgLmNzcygnY29sb3InLCAnYmxhY2snKVxuICAgICAgICAuY3NzKCdkaXNwbGF5JywgJ2lubGluZS1ibG9jaycpXG4gICAgICAgIC5jc3MoJ2hlaWdodCcsICczMnB4JylcbiAgICAgICAgLmNzcygnd2lkdGgnLCAnMzJweCcpXG4gICAgICAgIC5jc3MoJ21hcmdpbi1sZWZ0JywgJzEwcHgnKVxuICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kJywgJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnICsgaW1kYXRhICtcbiAgICAgICAgICAgICAnbm8tcmVwZWF0IGNlbnRlciBjZW50ZXInKVxuICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kLXNpemUnLCAnMzJweCAzMnB4JylcbiAgICAgICAgLmFkZENsYXNzKCdjcmF0ZS1pY29uJylcbiAgICAgICAgLmNzcygnaGVpZ2h0JywnMzRweCcpLnBvcG92ZXIoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWV0YWRhdGE7XG4iLCJcblxuZnVuY3Rpb24gUHJldmlldyhjb250YWluZXIpe1xuICAgIHRoaXMuZGl2ID0galF1ZXJ5KCc8ZGl2PicpLmFwcGVuZFRvKGNvbnRhaW5lcilcbiAgICAgICAgLmNzcygnbWluLWhlaWdodCcsICc0MDBweCcpXG4gICAgICAgIC5oaWRlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByZXZpZXc7XG4iLCJcbmZ1bmN0aW9uIFJvdW5kQnV0dG9uKGNvbnRhaW5lciwgdGV4dCwgdG9vbHRpcCwgc2l6ZSl7XG4gICAgdmFyIHMgPSAzMDtcbiAgICB2YXIgcCA9IDY7XG4gICAgdmFyIGIgPSAyO1xuICAgIHN3aXRjaCAoc2l6ZSl7XG4gICAgY2FzZSBcImxhcmdlXCI6IHMgPSA2MDsgcCA9IDExOyBicmVhaztcbiAgICBjYXNlIFwic21hbGxcIjogcyA9IDEyOyBwID0gMjsgYiA9IDE7ICBicmVhaztcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuYnV0dG9uID0galF1ZXJ5KCc8YT4nKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICAgIC5hZGRDbGFzcygnYnRuIGJ0bi1kZWZhdWx0JylcbiAgICAgICAgLmNzcygnd2lkdGgnLHMgKyAncHgnKVxuICAgICAgICAuY3NzKCdoZWlnaHQnLCBzICsgJ3B4JylcbiAgICAgICAgLmNzcygnbWFyZ2luLXJpZ2h0JywgJzEwcHgnKVxuICAgICAgICAuY3NzKCdib3JkZXItcmFkaXVzJywgJzUwJScpXG4gICAgICAgIC5jc3MoJ2JvcmRlci13aWR0aCcsIGIgKyAncHgnKVxuICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kJywgJ2luaGVyaXQnKVxuICAgICAgICAuY3NzKCdwYWRkaW5nJywgcCsncHggMCcpXG4gICAgICAgIC5jc3MoJ2NvbG9yJywgJyNlY2VjZWMnKVxuICAgICAgICAuY3NzKCd2ZXJ0aWNhbC1hbGlnbicsICdtaWRkbGUnKVxuICAgICAgICAuYXR0cignZGF0YS10b2dnbGUnLCAndG9vbHRpcCcpXG4gICAgICAgIC5hdHRyKCdkYXRhLXBsYWNlbWVudCcsICdib3R0b20nKVxuICAgICAgICAuYXR0cigndGl0bGUnLCB0b29sdGlwKVxuICAgICAgICAuaHRtbCh0ZXh0KVxuICAgICAgICAucHJvcCgnZGlzYWJsZScsIHRydWUpXG4gICAgICAgIC5ob3ZlcihmdW5jdGlvbigpe1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCAnI2VjZWNlYycpO1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ2NvbG9yJywgJ2JsYWNrJyk7XG4gICAgICAgIH0sICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCAnaW5oZXJpdCcpO1xuICAgICAgICAgICAgJCh0aGlzKS5jc3MoJ2NvbG9yJywgJyNlY2VjZWMnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRvb2x0aXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm91bmRCdXR0b247XG4iLCJcbmZ1bmN0aW9uIFN0YXRlc0hlYWRlcihtb2RlbCwgY29udGFpbmVyKXtcbiAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgXG4gICAgdGhpcy5yZWQgPSBcIiNjZDI2MjZcIjtcbiAgICB0aGlzLnllbGxvdyA9IFwiI2VlYWQwZVwiO1xuICAgIHRoaXMuZ3JlZW4gPSBcIiMyMjhiMjJcIjtcbiAgICB0aGlzLmJsdWUgPSBcIiMwMEJGRkZcIjtcbiAgICBcbiAgICB0aGlzLnNpZ25hbGluZ1N0YXRlID0galF1ZXJ5KCc8aT4nKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICAgIC5hZGRDbGFzcygnZmEgZmEtY2lyY2xlLW8tbm90Y2ggZmEtMngnKVxuICAgICAgICAuYXR0cignZGF0YS10cmlnZ2VyJywgJ2hvdmVyJykuYXR0cignZGF0YS10b2dnbGUnLCAncG9wb3ZlcicpXG4gICAgICAgIC5hdHRyKCd0aXRsZScsICdTaWduYWxpbmcgc2VydmVyIHN0YXR1cycpXG4gICAgICAgIC5hdHRyKCdkYXRhLWh0bWwnLCAndHJ1ZScpLmF0dHIoJ2RhdGEtY29udGVudCcsICcnKVxuICAgICAgICAuYXR0cignZGF0YS1wbGFjZW1lbnQnLCAnYm90dG9tJylcbiAgICAgICAgLmNzcygnbWFyZ2luLXJpZ2h0JywgJzEwcHgnKVxuICAgICAgICAucG9wb3ZlcigpXG4gICAgICAgIC5oaWRlKCk7XG5cbiAgICB0aGlzLm5ldHdvcmtTdGF0ZSA9IGpRdWVyeSgnPGk+JykuYXBwZW5kVG8oY29udGFpbmVyKVxuICAgICAgICAuYWRkQ2xhc3MoJ2ZhIGZhLWdsb2JlIGZhLTJ4JylcbiAgICAgICAgLmF0dHIoJ2RhdGEtdHJpZ2dlcicsICdob3ZlcicpLmF0dHIoJ2RhdGEtdG9nZ2xlJywgJ3BvcG92ZXInKVxuICAgICAgICAuYXR0cigndGl0bGUnLCAnTmV0d29yayBzdGF0dXMnKVxuICAgICAgICAuYXR0cignZGF0YS1odG1sJywgJ3RydWUnKVxuICAgICAgICAuYXR0cignZGF0YS1jb250ZW50JywgJ0Rpc2Nvbm5lY3RlZDogeW91IGFyZSBjdXJyZW50bHknK1xuICAgICAgICAgICAgICAnIGVkaXRpbmcgPHNwYW4gY2xhc3M9XCJhbGVydC1pbmZvXCI+b24geW91ciBvd248L3NwYW4+LicpXG4gICAgICAgIC5hdHRyKCdkYXRhLXBsYWNlbWVudCcsICdib3R0b20nKVxuICAgICAgICAuY3NzKCdtYXJnaW4tcmlnaHQnLCAnMTBweCcpXG4gICAgICAgIC5jc3MoJ21hcmdpbi10b3AnLCAnMnB4JylcbiAgICAgICAgLnBvcG92ZXIoKTtcbn07XG5cblN0YXRlc0hlYWRlci5wcm90b3R5cGUuc2V0TmV0d29ya1N0YXRlID0gZnVuY3Rpb24oc3RhdGUpe1xuICAgIHN3aXRjaCAoc3RhdGUpe1xuICAgIGNhc2UgXCJjb25uZWN0ZWRcIjpcbiAgICAgICAgdmFyIGNvbm5lY3RlZFN0cmluZyA9XG4gICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdhbGVydC1zdWNjZXNzJz5Db25ncmF0dWxhdGlvbnM8L3NwYW4+XCIrXG4gICAgICAgICAgICBcIiEgWW91IGFyZSBjb25uZWN0ZWQgdG8gcGVvcGxlLCBhbmQgcGVvcGxlIGFyZSBcIitcbiAgICAgICAgICAgIFwiY29ubmVjdGVkIHRvIHlvdS4gPHNwYW4gY2xhc3M9J2FsZXJ0LWluZm8nPllvdSBjYW4gc3RhcnQgZWRpdGluZyBcIitcbiAgICAgICAgICAgIFwidG9nZXRoZXI8L3NwYW4+LlwiO1xuICAgICAgICB0aGlzLm5ldHdvcmtTdGF0ZS5jc3MoXCJjb2xvclwiLCB0aGlzLmdyZWVuKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrU3RhdGUuYXR0cihcImRhdGEtY29udGVudFwiLCBjb25uZWN0ZWRTdHJpbmcpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwicGFydGlhbGx5Y29ubmVjdGVkXCI6XG4gICAgICAgIHZhciBwYXJ0aWFsbHlDb25uZWN0ZWRTdHJpbmcgPVxuICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0nYWxlcnQtd2FybmluZyc+UGFydGlhbGx5XCIrXG4gICAgICAgICAgICBcIiBjb25uZWN0ZWQ8L3NwYW4+OiBlaXRoZXIgeW91IGFyZSBjb25uZWN0ZWQgdG8gcGVvcGxlLCBvciBwZW9wbGUgXCIrXG4gICAgICAgICAgICBcImFyZSBjb25uZWN0ZWQgdG8geW91LiBcIitcbiAgICAgICAgICAgIFwiPGk+VGhpcyBpcyBhbiB1bmRlc2lyZWQgaW50ZXJtZWRpYXJ5IHN0YXRlLiBJZiBpdCBwZXJzaXN0cywgXCIrXG4gICAgICAgICAgICBcInBsZWFzZSBjb25zaWRlciByZWpvaW5pbmcgdGhlIG5ldHdvcmsuPC9pPlwiO1xuICAgICAgICB0aGlzLm5ldHdvcmtTdGF0ZS5jc3MoXCJjb2xvclwiLCB0aGlzLnllbGxvdyk7XG4gICAgICAgIHRoaXMubmV0d29ya1N0YXRlLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgcGFydGlhbGx5Q29ubmVjdGVkU3RyaW5nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICB2YXIgZGlzY29ubmVjdGVkU3RyaW5nID1cbiAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J2FsZXJ0LWRhbmdlcic+RGlzY29ubmVjdGVkPC9zcGFuPjpcIitcbiAgICAgICAgICAgIFwiIHlvdSBhcmUgY3VycmVudGx5IGVkaXRpbmcgPHNwYW4gY2xhc3M9J2FsZXJ0LWluZm8nPm9uXCIrXG4gICAgICAgICAgICBcIiB5b3VyIG93bjwvc3Bhbj4uXCI7XG4gICAgICAgIHRoaXMubmV0d29ya1N0YXRlLmNzcyhcImNvbG9yXCIsIHRoaXMucmVkKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrU3RhdGUuYXR0cihcImRhdGEtY29udGVudFwiLCBkaXNjb25uZWN0ZWRTdHJpbmcpO1xuICAgICAgICBicmVhaztcbiAgICB9O1xufTtcblxuU3RhdGVzSGVhZGVyLnByb3RvdHlwZS5zZXRTaWduYWxpbmdTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gYmxpbmsoKXtcbiAgICAgICAgc2VsZi5zaWduYWxpbmdTdGF0ZS5zaG93KCk7XG4gICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2RlbC5zaWduYWxpbmcuc3RhcnRlZFNvY2tldCl7XG4gICAgICAgICAgICAgICAgYmxpbmsoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTaWduYWxpbmdTdGF0ZShcImRvbmVcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCAxMDAwKTtcbiAgICB9O1xuICAgIFxuICAgIHN3aXRjaCAoc3RhdGUpe1xuICAgIGNhc2UgXCJ3YWl0U2lnbmFsaW5nXCI6XG4gICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUuc2hvdygpO1xuICAgICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlLnJlbW92ZUNsYXNzKFwiZmEtc3BpblwiKTtcbiAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZS5jc3MoXCJjb2xvclwiLCB0aGlzLnllbGxvdyk7XG4gICAgICAgIHZhciB3YWl0U2lnbmFsaW5nU3RyaW5nID0gXCI8c3BhbiBjbGFzcz0nYWxlcnQtd2FybmluZyc+Q29ubmVjdGluZ1wiK1xuICAgICAgICAgICAgXCI8L3NwYW4+OiBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHdpdGggdGhlIHNpZ25hbGluZyBzZXJ2ZXIuIFwiK1xuICAgICAgICAgICAgXCJUaGUgbGF0dGVyIGFsbG93cyBwZW9wbGUgdG8gam9pbiB0aGUgZWRpdGluZyBzZXNzaW9uIGJ5IHVzaW5nIFwiK1xuICAgICAgICAgICAgXCJ0aGUgcHJvdmlkZWQgbGluay4gXCIrXG4gICAgICAgICAgICBcIjxpPklmIHRoaXMgc3RhdGUgcGVyc2lzdHMsIGNvbnNpZGVyIHJlbG9hZGluZyB0aGUgcGFnZS48L2k+XCI7XG4gICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUuYXR0cihcImRhdGEtY29udGVudFwiLCB3YWl0U2lnbmFsaW5nU3RyaW5nKTtcbiAgICAgICAgYmxpbmsoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIndhaXRTaGFyZXJcIjpcbiAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZS5zaG93KCk7XG4gICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUuYWRkQ2xhc3MoXCJmYS1zcGluXCIpO1xuICAgICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlLmNzcyhcImNvbG9yXCIsIHRoaXMuYmx1ZSk7XG4gICAgICAgIHZhciB3YWl0U2hhcmVyU3RyaW5nID0gXCJUaGUgY29ubmVjdGlvbiB0byB0aGUgc2lnbmFsaW5nIHNlcnZlciBoYXMgXCIrXG4gICAgICAgICAgICBcImJlZW4gc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkISA8c3BhbiBjbGFzcz0nYWxlcnQtaW5mbyc+V2FpdGluZyBcIitcbiAgICAgICAgICAgIFwiZm9yIHRoZSBzaGFyZXIgbm93PC9zcGFuPi5cIjtcbiAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZS5hdHRyKFwiZGF0YS1jb250ZW50XCIsIHdhaXRTaGFyZXJTdHJpbmcpO1xuICAgICAgICBibGluaygpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwid2FpdEpvaW5lcnNcIjpcbiAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZS5jc3MoXCJjb2xvclwiLCB0aGlzLmJsdWUpO1xuICAgICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlLmFkZENsYXNzKFwiZmEtc3BpblwiKTtcbiAgICAgICAgdmFyIHdhaXRKb2luZXJzU3RyaW5nID0gXCJUaGUgY29ubmVjdGlvbiB0byB0aGUgc2lnbmFsaW5nIHNlcnZlciBoYXMgXCIrXG4gICAgICAgICAgICBcImJlZW4gPHNwYW4gY2xhc3M9J2FsZXJ0LXN1Y2Nlc3MnPnN1Y2Nlc3NmdWxseTwvc3Bhbj4gXCIrXG4gICAgICAgICAgICBcImVzdGFibGlzaGVkISBcIitcbiAgICAgICAgICAgIFwiVGhlIHNlcnZlciBhbGxvd3MgcGVvcGxlIHRvIGpvaW4gdGhlIGVkaXRpbmcgc2Vzc2lvbiBieSB1c2luZyBcIitcbiAgICAgICAgICAgIFwidGhlIHByb3ZpZGVkIGxpbmsuIFwiK1xuICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0nYWxlcnQtaW5mbyc+V2FpdGluZyBmb3IgdGhlIGNvbGxhYm9yYXRvcnM8L3NwYW4+LlwiXG4gICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUuYXR0cihcImRhdGEtY29udGVudFwiLCB3YWl0Sm9pbmVyc1N0cmluZyk7XG4gICAgICAgIGJsaW5rKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkb25lXCI6XG4gICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUuc2hvdygpO1xuICAgICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlLnJlbW92ZUNsYXNzKFwiZmEtc3BpblwiKTtcbiAgICAgICAgdmFyIGRvbmVTdHJpbmcgPSBcIlRoZSBjb25uZWN0aW9uIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyIGhhcyBiZWVuIFwiK1xuICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0nYWxlcnQtaW5mbyc+dGVybWluYXRlZDwvc3Bhbj4uXCI7XG4gICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUuYXR0cihcImRhdGEtY29udGVudFwiLCBkb25lU3RyaW5nKTtcbiAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZS5jc3MoXCJjb2xvclwiLCB0aGlzLmdyZWVuKTtcbiAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZS5mYWRlT3V0KDYwMDAsIFwibGluZWFyXCIpO1xuICAgICAgICBicmVhaztcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZXNIZWFkZXI7XG4iLCJcbmZ1bmN0aW9uIFN0cnVjdHVyZShjb250YWluZXIpe1xuICAgIC8vICNBIGNyZWF0ZSB0aGUgZ2xvYmFsIGhlYWRlclxuICAgIHZhciBoZWFkZXIgPSBqUXVlcnkoJzxkaXY+JykuYXBwZW5kVG8oY29udGFpbmVyKVxuICAgICAgICAuY3NzKCd3aWR0aCcsICcxMDAlJylcbiAgICAgICAgLmNzcygnYm94LXNoYWRvdycsICcwcHggMXB4IDVweCAjYWJhYmFiJylcbiAgICAgICAgLmNzcygnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycsICc0cHgnKVxuICAgICAgICAuY3NzKCdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cycsICc0cHgnKVxuICAgICAgICAuY3NzKCdjb2xvcicsICcjZWNlY2VjJylcbiAgICAgICAgLmNzcygnYmFja2dyb3VuZC1jb2xvcicsICcjMjQyYjMyJyk7XG5cbiAgICB2YXIgaGVhZGVyQ29udGFpbmVyID0galF1ZXJ5KCc8ZGl2PicpLmFwcGVuZFRvKGhlYWRlcilcbiAgICAgICAgLmFkZENsYXNzKCdjb250YWluZXInKVxuICAgICAgICAuY3NzKCd3aWR0aCcsJ2luaGVyaXQnKTtcblxuICAgIC8vICNCIERpdmlkZSB0aGUgaGVhZGVyIGluIGZvdXIgcGFydHMgd2l0aCBkaWZmZXJlbnQgcHVycG9zZXNcbiAgICB0aGlzLmhlYWRlckxlZnQgPSBqUXVlcnkoJzxkaXY+JykuYXBwZW5kVG8oaGVhZGVyQ29udGFpbmVyKVxuICAgICAgICAuYWRkQ2xhc3MoJ3B1bGwtbGVmdCcpXG4gICAgICAgIC5jc3MoJ3BhZGRpbmctdG9wJywnMTBweCcpXG4gICAgICAgIC5jc3MoJ3BhZGRpbmctYm90dG9tJywnMTBweCcpO1xuXG4gICAgdGhpcy5oZWFkZXJSaWdodFJpZ2h0UmlnaHQgPSBqUXVlcnkoJzxkaXY+JykuYXBwZW5kVG8oaGVhZGVyQ29udGFpbmVyKVxuICAgICAgICAuYWRkQ2xhc3MoJ3B1bGwtcmlnaHQnKVxuICAgICAgICAuY3NzKCdwYWRkaW5nLXRvcCcsICcxMHB4JylcbiAgICAgICAgLmNzcygncGFkZGluZy1ib3R0b20nLCAnMTBweCcpXG4gICAgICAgIC5jc3MoJ2hlaWdodCcsICczNHB4Jyk7XG5cbiAgICB0aGlzLmhlYWRlclJpZ2h0UmlnaHQgPSBqUXVlcnkoJzxkaXY+JykuYXBwZW5kVG8oaGVhZGVyQ29udGFpbmVyKVxuICAgICAgICAuYWRkQ2xhc3MoJ3B1bGwtcmlnaHQnKVxuICAgICAgICAuY3NzKCdwYWRkaW5nLXRvcCcsJzEwcHgnKVxuICAgICAgICAuY3NzKCdwYWRkaW5nLWJvdHRvbScsJzEwcHgnKVxuICAgICAgICAuY3NzKCdoZWlnaHQnLCczNHB4JylcbiAgICAgICAgLmNzcygnbWFyZ2luLXRvcCcsICcycHgnKTtcblxuICAgIHRoaXMuaGVhZGVyUmlnaHQgPSBqUXVlcnkoJzxkaXY+JykuYXBwZW5kVG8oaGVhZGVyQ29udGFpbmVyKVxuICAgICAgICAuYWRkQ2xhc3MoJ3B1bGwtcmlnaHQnKVxuICAgICAgICAuY3NzKCdwYWRkaW5nLXRvcCcsJzEwcHgnKVxuICAgICAgICAuY3NzKCdwYWRkaW5nLWJvdHRvbScsJzEwcHgnKVxuICAgICAgICAuY3NzKCdoZWlnaHQnLCczNHB4JylcbiAgICAgICAgLmNzcygnbWFyZ2luLXJpZ2h0JywgJzIwcHgnKTtcblxuICAgIHRoaXMuYm9keSA9IGpRdWVyeSgnPGRpdj4nKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICAgIC5jc3MoJ2JveC1zaGFkb3cnLCAnMHB4IDFweCA1cHggI2FiYWJhYicpXG4gICAgICAgIC5jc3MoJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnLCAnNHB4JylcbiAgICAgICAgLmNzcygnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnLCAnNHB4JylcbiAgICAgICAgLmNzcygnbWFyZ2luLWJvdHRvbScsICcyMHB4JylcbiAgICAgICAgLmNzcygncGFkZGluZycsICczMHB4IDE1cHgnKVxuICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgJyNmZmZmZmYnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RydWN0dXJlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd29yZHMgPSByZXF1aXJlKCcuL3dvcmRzLmpzb24nKTtcbnZhciB1bmlxdWVSYW5kb20gPSByZXF1aXJlKCd1bmlxdWUtcmFuZG9tJykoMCwgd29yZHMubGVuZ3RoIC0gMSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gd29yZHNbdW5pcXVlUmFuZG9tKCldO1xufTtcblxubW9kdWxlLmV4cG9ydHMud29yZHMgPSB3b3JkcztcbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgXCJhYXJkdmFya1wiLFxuICBcImFsYmF0cm9zc1wiLFxuICBcImFsbGlnYXRvclwiLFxuICBcImFscGFjYVwiLFxuICBcImFudFwiLFxuICBcImFudGVhdGVyXCIsXG4gIFwiYW50ZWxvcGVcIixcbiAgXCJhcGVcIixcbiAgXCJhcm1hZGlsbG9cIixcbiAgXCJkb25rZXlcIixcbiAgXCJiYWJvb25cIixcbiAgXCJiYWRnZXJcIixcbiAgXCJiYXJyYWN1ZGFcIixcbiAgXCJiYXRcIixcbiAgXCJiZWFyXCIsXG4gIFwiYmVhdmVyXCIsXG4gIFwiYmVlXCIsXG4gIFwiYmlzb25cIixcbiAgXCJib2FyXCIsXG4gIFwiYnVmZmFsb1wiLFxuICBcImJ1dHRlcmZseVwiLFxuICBcImNhbWVsXCIsXG4gIFwiY2FweWJhcmFcIixcbiAgXCJjYXJpYm91XCIsXG4gIFwiY2Fzc293YXJ5XCIsXG4gIFwiY2F0XCIsXG4gIFwiY2F0ZXJwaWxsYXJcIixcbiAgXCJjYXR0bGVcIixcbiAgXCJjaGFtb2lzXCIsXG4gIFwiY2hlZXRhaFwiLFxuICBcImNoaWNrZW5cIixcbiAgXCJjaGltcGFuemVlXCIsXG4gIFwiY2hpbmNoaWxsYVwiLFxuICBcImNob3VnaFwiLFxuICBcImNsYW1cIixcbiAgXCJjb2JyYVwiLFxuICBcImNvY2tyb2FjaFwiLFxuICBcImNvZFwiLFxuICBcImNvcm1vcmFudFwiLFxuICBcImNveW90ZVwiLFxuICBcImNyYWJcIixcbiAgXCJjcmFuZVwiLFxuICBcImNyb2NvZGlsZVwiLFxuICBcImNyb3dcIixcbiAgXCJjdXJsZXdcIixcbiAgXCJkZWVyXCIsXG4gIFwiZGlub3NhdXJcIixcbiAgXCJkb2dcIixcbiAgXCJkb2dmaXNoXCIsXG4gIFwiZG9scGhpblwiLFxuICBcImRvbmtleVwiLFxuICBcImRvdHRlcmVsXCIsXG4gIFwiZG92ZVwiLFxuICBcImRyYWdvbmZseVwiLFxuICBcImR1Y2tcIixcbiAgXCJkdWdvbmdcIixcbiAgXCJkdW5saW5cIixcbiAgXCJlYWdsZVwiLFxuICBcImVjaGlkbmFcIixcbiAgXCJlZWxcIixcbiAgXCJlbGFuZFwiLFxuICBcImVsZXBoYW50XCIsXG4gIFwiZWxlcGhhbnQtc2VhbFwiLFxuICBcImVsa1wiLFxuICBcImVtdVwiLFxuICBcImZhbGNvblwiLFxuICBcImZlcnJldFwiLFxuICBcImZpbmNoXCIsXG4gIFwiZmlzaFwiLFxuICBcImZsYW1pbmdvXCIsXG4gIFwiZmx5XCIsXG4gIFwiZm94XCIsXG4gIFwiZnJvZ1wiLFxuICBcImdhdXJcIixcbiAgXCJnYXplbGxlXCIsXG4gIFwiZ2VyYmlsXCIsXG4gIFwiZ2lhbnQtcGFuZGFcIixcbiAgXCJnaXJhZmZlXCIsXG4gIFwiZ25hdFwiLFxuICBcImdudVwiLFxuICBcImdvYXRcIixcbiAgXCJnb29zZVwiLFxuICBcImdvbGRmaW5jaFwiLFxuICBcImdvbGRmaXNoXCIsXG4gIFwiZ29yaWxsYVwiLFxuICBcImdvc2hhd2tcIixcbiAgXCJncmFzc2hvcHBlclwiLFxuICBcImdyb3VzZVwiLFxuICBcImd1YW5hY29cIixcbiAgXCJndWluZWEtZm93bFwiLFxuICBcImd1aW5lYS1waWdcIixcbiAgXCJndWxsXCIsXG4gIFwiaGFtc3RlclwiLFxuICBcImhhcmVcIixcbiAgXCJoYXdrXCIsXG4gIFwiaGVkZ2Vob2dcIixcbiAgXCJoZXJvblwiLFxuICBcImhlcnJpbmdcIixcbiAgXCJoaXBwb3BvdGFtdXNcIixcbiAgXCJob3JuZXRcIixcbiAgXCJob3JzZVwiLFxuICBcImh1bWFuXCIsXG4gIFwiaHVtbWluZ2JpcmRcIixcbiAgXCJoeWVuYVwiLFxuICBcImliZXhcIixcbiAgXCJpYmlzXCIsXG4gIFwiamFja2FsXCIsXG4gIFwiamFndWFyXCIsXG4gIFwiamF5XCIsXG4gIFwiamVsbHlmaXNoXCIsXG4gIFwia2FuZ2Fyb29cIixcbiAgXCJraW5nZmlzaGVyXCIsXG4gIFwia29hbGFcIixcbiAgXCJrb21vZG8tZHJhZ29uXCIsXG4gIFwia29va2FidXJhXCIsXG4gIFwia291cHJleVwiLFxuICBcImt1ZHVcIixcbiAgXCJsYXB3aW5nXCIsXG4gIFwibGFya1wiLFxuICBcImxlbXVyXCIsXG4gIFwibGVvcGFyZFwiLFxuICBcImxpb25cIixcbiAgXCJsbGFtYVwiLFxuICBcImxvYnN0ZXJcIixcbiAgXCJsb2N1c3RcIixcbiAgXCJsb3Jpc1wiLFxuICBcImxvdXNlXCIsXG4gIFwibHlyZWJpcmRcIixcbiAgXCJtYWdwaWVcIixcbiAgXCJtYWxsYXJkXCIsXG4gIFwibWFuYXRlZVwiLFxuICBcIm1hbmRyaWxsXCIsXG4gIFwibWFudGlzXCIsXG4gIFwibWFydGVuXCIsXG4gIFwibWVlcmthdFwiLFxuICBcIm1pbmtcIixcbiAgXCJtb2xlXCIsXG4gIFwibW9uZ29vc2VcIixcbiAgXCJtb25rZXlcIixcbiAgXCJtb29zZVwiLFxuICBcIm1vdXNlXCIsXG4gIFwibW9zcXVpdG9cIixcbiAgXCJtdWxlXCIsXG4gIFwibmFyd2hhbFwiLFxuICBcIm5ld3RcIixcbiAgXCJuaWdodGluZ2FsZVwiLFxuICBcIm9jdG9wdXNcIixcbiAgXCJva2FwaVwiLFxuICBcIm9wb3NzdW1cIixcbiAgXCJvcnl4XCIsXG4gIFwib3N0cmljaFwiLFxuICBcIm90dGVyXCIsXG4gIFwib3dsXCIsXG4gIFwib3hcIixcbiAgXCJveXN0ZXJcIixcbiAgXCJwYW50aGVyXCIsXG4gIFwicGFycm90XCIsXG4gIFwicGFydHJpZGdlXCIsXG4gIFwicGVhZm93bFwiLFxuICBcInBlbGljYW5cIixcbiAgXCJwZW5ndWluXCIsXG4gIFwicGhlYXNhbnRcIixcbiAgXCJwaWdcIixcbiAgXCJwaWdlb25cIixcbiAgXCJwb2xhci1iZWFyXCIsXG4gIFwicG9ueVwiLFxuICBcInBvcmN1cGluZVwiLFxuICBcInBvcnBvaXNlXCIsXG4gIFwicHJhaXJpZS1kb2dcIixcbiAgXCJxdWFpbFwiLFxuICBcInF1ZWxlYVwiLFxuICBcInF1ZXR6YWxcIixcbiAgXCJyYWJiaXRcIixcbiAgXCJyYWNjb29uXCIsXG4gIFwicmFpbFwiLFxuICBcInJhbVwiLFxuICBcInJhdFwiLFxuICBcInJhdmVuXCIsXG4gIFwicmVkLWRlZXJcIixcbiAgXCJyZWQtcGFuZGFcIixcbiAgXCJyZWluZGVlclwiLFxuICBcInJoaW5vY2Vyb3NcIixcbiAgXCJyb29rXCIsXG4gIFwic2FsYW1hbmRlclwiLFxuICBcInNhbG1vblwiLFxuICBcInNhbmQtZG9sbGFyXCIsXG4gIFwic2FuZHBpcGVyXCIsXG4gIFwic2FyZGluZVwiLFxuICBcInNjb3JwaW9uXCIsXG4gIFwic2VhLWxpb25cIixcbiAgXCJzZWEtdXJjaGluXCIsXG4gIFwic2VhaG9yc2VcIixcbiAgXCJzZWFsXCIsXG4gIFwic2hhcmtcIixcbiAgXCJzaGVlcFwiLFxuICBcInNocmV3XCIsXG4gIFwic2t1bmtcIixcbiAgXCJzbmFpbFwiLFxuICBcInNuYWtlXCIsXG4gIFwic3BhcnJvd1wiLFxuICBcInNwaWRlclwiLFxuICBcInNwb29uYmlsbFwiLFxuICBcInNxdWlkXCIsXG4gIFwic3F1aXJyZWxcIixcbiAgXCJzdGFybGluZ1wiLFxuICBcInN0aW5ncmF5XCIsXG4gIFwic3RpbmtidWdcIixcbiAgXCJzdG9ya1wiLFxuICBcInN3YWxsb3dcIixcbiAgXCJzd2FuXCIsXG4gIFwidGFwaXJcIixcbiAgXCJ0YXJzaWVyXCIsXG4gIFwidGVybWl0ZVwiLFxuICBcInRpZ2VyXCIsXG4gIFwidG9hZFwiLFxuICBcInRyb3V0XCIsXG4gIFwidHVya2V5XCIsXG4gIFwidHVydGxlXCIsXG4gIFwidmljdcOxYVwiLFxuICBcInZpcGVyXCIsXG4gIFwidnVsdHVyZVwiLFxuICBcIndhbGxhYnlcIixcbiAgXCJ3YWxydXNcIixcbiAgXCJ3YXNwXCIsXG4gIFwid2F0ZXItYnVmZmFsb1wiLFxuICBcIndlYXNlbFwiLFxuICBcIndoYWxlXCIsXG4gIFwid29sZlwiLFxuICBcIndvbHZlcmluZVwiLFxuICBcIndvbWJhdFwiLFxuICBcIndvb2Rjb2NrXCIsXG4gIFwid29vZHBlY2tlclwiLFxuICBcIndvcm1cIixcbiAgXCJ3cmVuXCIsXG4gIFwieWFrXCIsXG4gIFwiemVicmFcIlxuXVxuIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKGNoYXJzKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuICAgICAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcbiAgICAgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG4gICAgICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWJHOWlMMmx1WkdWNExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHlvcVhHNGdLaUJEY21WaGRHVWdZU0JpYkc5aUlHSjFhV3hrWlhJZ1pYWmxiaUIzYUdWdUlIWmxibVJ2Y2lCd2NtVm1hWGhsY3lCbGVHbHpkRnh1SUNvdlhHNWNiblpoY2lCQ2JHOWlRblZwYkdSbGNpQTlJR2RzYjJKaGJDNUNiRzlpUW5WcGJHUmxjbHh1SUNCOGZDQm5iRzlpWVd3dVYyVmlTMmwwUW14dllrSjFhV3hrWlhKY2JpQWdmSHdnWjJ4dlltRnNMazFUUW14dllrSjFhV3hrWlhKY2JpQWdmSHdnWjJ4dlltRnNMazF2ZWtKc2IySkNkV2xzWkdWeU8xeHVYRzR2S2lwY2JpQXFJRU5vWldOcklHbG1JRUpzYjJJZ1kyOXVjM1J5ZFdOMGIzSWdhWE1nYzNWd2NHOXlkR1ZrWEc0Z0tpOWNibHh1ZG1GeUlHSnNiMkpUZFhCd2IzSjBaV1FnUFNBb1puVnVZM1JwYjI0b0tTQjdYRzRnSUhSeWVTQjdYRzRnSUNBZ2RtRnlJR0VnUFNCdVpYY2dRbXh2WWloYkoyaHBKMTBwTzF4dUlDQWdJSEpsZEhWeWJpQmhMbk5wZW1VZ1BUMDlJREk3WEc0Z0lIMGdZMkYwWTJnb1pTa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ2ZWeHVmU2tvS1R0Y2JseHVMeW9xWEc0Z0tpQkRhR1ZqYXlCcFppQkNiRzlpSUdOdmJuTjBjblZqZEc5eUlITjFjSEJ2Y25SeklFRnljbUY1UW5WbVptVnlWbWxsZDNOY2JpQXFJRVpoYVd4eklHbHVJRk5oWm1GeWFTQTJMQ0J6YnlCM1pTQnVaV1ZrSUhSdklHMWhjQ0IwYnlCQmNuSmhlVUoxWm1abGNuTWdkR2hsY21VdVhHNGdLaTljYmx4dWRtRnlJR0pzYjJKVGRYQndiM0owYzBGeWNtRjVRblZtWm1WeVZtbGxkeUE5SUdKc2IySlRkWEJ3YjNKMFpXUWdKaVlnS0daMWJtTjBhVzl1S0NrZ2UxeHVJQ0IwY25rZ2UxeHVJQ0FnSUhaaGNpQmlJRDBnYm1WM0lFSnNiMklvVzI1bGR5QlZhVzUwT0VGeWNtRjVLRnN4TERKZEtWMHBPMXh1SUNBZ0lISmxkSFZ5YmlCaUxuTnBlbVVnUFQwOUlESTdYRzRnSUgwZ1kyRjBZMmdvWlNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnZlZ4dWZTa29LVHRjYmx4dUx5b3FYRzRnS2lCRGFHVmpheUJwWmlCQ2JHOWlRblZwYkdSbGNpQnBjeUJ6ZFhCd2IzSjBaV1JjYmlBcUwxeHVYRzUyWVhJZ1lteHZZa0oxYVd4a1pYSlRkWEJ3YjNKMFpXUWdQU0JDYkc5aVFuVnBiR1JsY2x4dUlDQW1KaUJDYkc5aVFuVnBiR1JsY2k1d2NtOTBiM1I1Y0dVdVlYQndaVzVrWEc0Z0lDWW1JRUpzYjJKQ2RXbHNaR1Z5TG5CeWIzUnZkSGx3WlM1blpYUkNiRzlpTzF4dVhHNHZLaXBjYmlBcUlFaGxiSEJsY2lCbWRXNWpkR2x2YmlCMGFHRjBJRzFoY0hNZ1FYSnlZWGxDZFdabVpYSldhV1YzY3lCMGJ5QkJjbkpoZVVKMVptWmxjbk5jYmlBcUlGVnpaV1FnWW5rZ1FteHZZa0oxYVd4a1pYSWdZMjl1YzNSeWRXTjBiM0lnWVc1a0lHOXNaQ0JpY205M2MyVnljeUIwYUdGMElHUnBaRzRuZEZ4dUlDb2djM1Z3Y0c5eWRDQnBkQ0JwYmlCMGFHVWdRbXh2WWlCamIyNXpkSEoxWTNSdmNpNWNiaUFxTDF4dVhHNW1kVzVqZEdsdmJpQnRZWEJCY25KaGVVSjFabVpsY2xacFpYZHpLR0Z5ZVNrZ2UxeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWVTNXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJSFpoY2lCamFIVnVheUE5SUdGeWVWdHBYVHRjYmlBZ0lDQnBaaUFvWTJoMWJtc3VZblZtWm1WeUlHbHVjM1JoYm1ObGIyWWdRWEp5WVhsQ2RXWm1aWElwSUh0Y2JpQWdJQ0FnSUhaaGNpQmlkV1lnUFNCamFIVnVheTVpZFdabVpYSTdYRzVjYmlBZ0lDQWdJQzh2SUdsbUlIUm9hWE1nYVhNZ1lTQnpkV0poY25KaGVTd2diV0ZyWlNCaElHTnZjSGtnYzI4Z2QyVWdiMjVzZVZ4dUlDQWdJQ0FnTHk4Z2FXNWpiSFZrWlNCMGFHVWdjM1ZpWVhKeVlYa2djbVZuYVc5dUlHWnliMjBnZEdobElIVnVaR1Z5YkhscGJtY2dZblZtWm1WeVhHNGdJQ0FnSUNCcFppQW9ZMmgxYm1zdVlubDBaVXhsYm1kMGFDQWhQVDBnWW5WbUxtSjVkR1ZNWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHTnZjSGtnUFNCdVpYY2dWV2x1ZERoQmNuSmhlU2hqYUhWdWF5NWllWFJsVEdWdVozUm9LVHRjYmlBZ0lDQWdJQ0FnWTI5d2VTNXpaWFFvYm1WM0lGVnBiblE0UVhKeVlYa29ZblZtTENCamFIVnVheTVpZVhSbFQyWm1jMlYwTENCamFIVnVheTVpZVhSbFRHVnVaM1JvS1NrN1hHNGdJQ0FnSUNBZ0lHSjFaaUE5SUdOdmNIa3VZblZtWm1WeU8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQmhjbmxiYVYwZ1BTQmlkV1k3WEc0Z0lDQWdmVnh1SUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUVKc2IySkNkV2xzWkdWeVEyOXVjM1J5ZFdOMGIzSW9ZWEo1TENCdmNIUnBiMjV6S1NCN1hHNGdJRzl3ZEdsdmJuTWdQU0J2Y0hScGIyNXpJSHg4SUh0OU8xeHVYRzRnSUhaaGNpQmlZaUE5SUc1bGR5QkNiRzlpUW5WcGJHUmxjaWdwTzF4dUlDQnRZWEJCY25KaGVVSjFabVpsY2xacFpYZHpLR0Z5ZVNrN1hHNWNiaUFnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCaGNua3ViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0JpWWk1aGNIQmxibVFvWVhKNVcybGRLVHRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUFvYjNCMGFXOXVjeTUwZVhCbEtTQS9JR0ppTG1kbGRFSnNiMklvYjNCMGFXOXVjeTUwZVhCbEtTQTZJR0ppTG1kbGRFSnNiMklvS1R0Y2JuMDdYRzVjYm1aMWJtTjBhVzl1SUVKc2IySkRiMjV6ZEhKMVkzUnZjaWhoY25rc0lHOXdkR2x2Ym5NcElIdGNiaUFnYldGd1FYSnlZWGxDZFdabVpYSldhV1YzY3loaGNua3BPMXh1SUNCeVpYUjFjbTRnYm1WM0lFSnNiMklvWVhKNUxDQnZjSFJwYjI1eklIeDhJSHQ5S1R0Y2JuMDdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnS0daMWJtTjBhVzl1S0NrZ2UxeHVJQ0JwWmlBb1lteHZZbE4xY0hCdmNuUmxaQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQmliRzlpVTNWd2NHOXlkSE5CY25KaGVVSjFabVpsY2xacFpYY2dQeUJuYkc5aVlXd3VRbXh2WWlBNklFSnNiMkpEYjI1emRISjFZM1J2Y2p0Y2JpQWdmU0JsYkhObElHbG1JQ2hpYkc5aVFuVnBiR1JsY2xOMWNIQnZjblJsWkNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJDYkc5aVFuVnBiR1JsY2tOdmJuTjBjblZqZEc5eU8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lISmxkSFZ5YmlCMWJtUmxabWx1WldRN1hHNGdJSDFjYm4wcEtDazdYRzRpWFgwPSIsIi8qICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAsIEFqYXgub3JnIEIuVi5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgQWpheC5vcmcgQi5WLiBub3IgdGhlXG4gKiAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICogICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgQUpBWC5PUkcgQi5WLiBCRSBMSUFCTEUgRk9SIEFOWVxuICogRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAqIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAqIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICogT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKiAqL1xuXG4vKipcbiAqIERlZmluZSBhIG1vZHVsZSBhbG9uZyB3aXRoIGEgcGF5bG9hZFxuICogQHBhcmFtIG1vZHVsZSBhIG5hbWUgZm9yIHRoZSBwYXlsb2FkXG4gKiBAcGFyYW0gcGF5bG9hZCBhIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCAoYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkgcGFyYW1zXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXG52YXIgQUNFX05BTUVTUEFDRSA9IFwiYWNlXCI7XG5cbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuaWYgKCFnbG9iYWwgJiYgdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKSBnbG9iYWwgPSB3aW5kb3c7IC8vIHN0cmljdCBtb2RlXG5cblxuaWYgKCFBQ0VfTkFNRVNQQUNFICYmIHR5cGVvZiBhY2VxdWlyZWpzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcblxuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24obW9kdWxlLCBkZXBzLCBwYXlsb2FkKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGRlZmluZS5vcmlnaW5hbClcbiAgICAgICAgICAgIGRlZmluZS5vcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkcm9wcGluZyBtb2R1bGUgYmVjYXVzZSBkZWZpbmUgd2FzblxcJ3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcbiAgICAgICAgcGF5bG9hZCA9IGRlcHM7XG4gICAgaWYgKCFkZWZpbmUubW9kdWxlc1ttb2R1bGVdKSB7XG4gICAgICAgIGRlZmluZS5wYXlsb2Fkc1ttb2R1bGVdID0gcGF5bG9hZDtcbiAgICAgICAgZGVmaW5lLm1vZHVsZXNbbW9kdWxlXSA9IG51bGw7XG4gICAgfVxufTtcblxuZGVmaW5lLm1vZHVsZXMgPSB7fTtcbmRlZmluZS5wYXlsb2FkcyA9IHt9O1xuXG4vKipcbiAqIEdldCBhdCBmdW5jdGlvbmFsaXR5IGFjZS5kZWZpbmUoKWVkIHVzaW5nIHRoZSBmdW5jdGlvbiBhYm92ZVxuICovXG52YXIgX2FjZXF1aXJlID0gZnVuY3Rpb24ocGFyZW50SWQsIG1vZHVsZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IGxvb2t1cChwYXJlbnRJZCwgbW9kdWxlKTtcbiAgICAgICAgaWYgKHBheWxvYWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtb2R1bGUpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1vZHVsZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBkZXAgPSBsb29rdXAocGFyZW50SWQsIG1vZHVsZVtpXSk7XG4gICAgICAgICAgICBpZiAoZGVwID09IHVuZGVmaW5lZCAmJiBhY2VxdWlyZS5vcmlnaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwYXJhbXMucHVzaChkZXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjay5hcHBseShudWxsLCBwYXJhbXMpIHx8IHRydWU7XG4gICAgfVxufTtcblxudmFyIGFjZXF1aXJlID0gZnVuY3Rpb24obW9kdWxlLCBjYWxsYmFjaykge1xuICAgIHZhciBwYWNrYWdlZE1vZHVsZSA9IF9hY2VxdWlyZShcIlwiLCBtb2R1bGUsIGNhbGxiYWNrKTtcbiAgICBpZiAocGFja2FnZWRNb2R1bGUgPT0gdW5kZWZpbmVkICYmIGFjZXF1aXJlLm9yaWdpbmFsKVxuICAgICAgICByZXR1cm4gYWNlcXVpcmUub3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcGFja2FnZWRNb2R1bGU7XG59O1xuXG52YXIgbm9ybWFsaXplTW9kdWxlID0gZnVuY3Rpb24ocGFyZW50SWQsIG1vZHVsZU5hbWUpIHtcbiAgICAvLyBub3JtYWxpemUgcGx1Z2luIGFjZXF1aXJlc1xuICAgIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoXCIhXCIpICE9PSAtMSkge1xuICAgICAgICB2YXIgY2h1bmtzID0gbW9kdWxlTmFtZS5zcGxpdChcIiFcIik7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVNb2R1bGUocGFyZW50SWQsIGNodW5rc1swXSkgKyBcIiFcIiArIG5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCwgY2h1bmtzWzFdKTtcbiAgICB9XG4gICAgLy8gbm9ybWFsaXplIHJlbGF0aXZlIGFjZXF1aXJlc1xuICAgIGlmIChtb2R1bGVOYW1lLmNoYXJBdCgwKSA9PSBcIi5cIikge1xuICAgICAgICB2YXIgYmFzZSA9IHBhcmVudElkLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAtMSkuam9pbihcIi9cIik7XG4gICAgICAgIG1vZHVsZU5hbWUgPSBiYXNlICsgXCIvXCIgKyBtb2R1bGVOYW1lO1xuXG4gICAgICAgIHdoaWxlKG1vZHVsZU5hbWUuaW5kZXhPZihcIi5cIikgIT09IC0xICYmIHByZXZpb3VzICE9IG1vZHVsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IG1vZHVsZU5hbWU7XG4gICAgICAgICAgICBtb2R1bGVOYW1lID0gbW9kdWxlTmFtZS5yZXBsYWNlKC9cXC9cXC5cXC8vLCBcIi9cIikucmVwbGFjZSgvW15cXC9dK1xcL1xcLlxcLlxcLy8sIFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2R1bGVOYW1lO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBsb29rdXAgbW9kdWxlTmFtZXMgYW5kIHJlc29sdmUgdGhlbSBieSBjYWxsaW5nIHRoZVxuICogZGVmaW5pdGlvbiBmdW5jdGlvbiBpZiBuZWVkZWQuXG4gKi9cbnZhciBsb29rdXAgPSBmdW5jdGlvbihwYXJlbnRJZCwgbW9kdWxlTmFtZSkge1xuICAgIG1vZHVsZU5hbWUgPSBub3JtYWxpemVNb2R1bGUocGFyZW50SWQsIG1vZHVsZU5hbWUpO1xuXG4gICAgdmFyIG1vZHVsZSA9IGRlZmluZS5tb2R1bGVzW21vZHVsZU5hbWVdO1xuICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZSA9IGRlZmluZS5wYXlsb2Fkc1ttb2R1bGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBleHBvcnRzID0ge307XG4gICAgICAgICAgICB2YXIgbW9kID0ge1xuICAgICAgICAgICAgICAgIGlkOiBtb2R1bGVOYW1lLFxuICAgICAgICAgICAgICAgIHVyaTogJycsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0cyxcbiAgICAgICAgICAgICAgICBwYWNrYWdlZDogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJlcSA9IGZ1bmN0aW9uKG1vZHVsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2FjZXF1aXJlKG1vZHVsZU5hbWUsIG1vZHVsZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gbW9kdWxlKHJlcSwgZXhwb3J0cywgbW9kKTtcbiAgICAgICAgICAgIGV4cG9ydHMgPSByZXR1cm5WYWx1ZSB8fCBtb2QuZXhwb3J0cztcbiAgICAgICAgICAgIGRlZmluZS5tb2R1bGVzW21vZHVsZU5hbWVdID0gZXhwb3J0cztcbiAgICAgICAgICAgIGRlbGV0ZSBkZWZpbmUucGF5bG9hZHNbbW9kdWxlTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlID0gZGVmaW5lLm1vZHVsZXNbbW9kdWxlTmFtZV0gPSBleHBvcnRzIHx8IG1vZHVsZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZHVsZTtcbn07XG5cbmZ1bmN0aW9uIGV4cG9ydEFjZShucykge1xuICAgIHZhciByb290ID0gZ2xvYmFsO1xuICAgIGlmIChucykge1xuICAgICAgICBpZiAoIWdsb2JhbFtuc10pXG4gICAgICAgICAgICBnbG9iYWxbbnNdID0ge307XG4gICAgICAgIHJvb3QgPSBnbG9iYWxbbnNdO1xuICAgIH1cblxuICAgIGlmICghcm9vdC5kZWZpbmUgfHwgIXJvb3QuZGVmaW5lLnBhY2thZ2VkKSB7XG4gICAgICAgIGRlZmluZS5vcmlnaW5hbCA9IHJvb3QuZGVmaW5lO1xuICAgICAgICByb290LmRlZmluZSA9IGRlZmluZTtcbiAgICAgICAgcm9vdC5kZWZpbmUucGFja2FnZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghcm9vdC5hY2VxdWlyZSB8fCAhcm9vdC5hY2VxdWlyZS5wYWNrYWdlZCkge1xuICAgICAgICBhY2VxdWlyZS5vcmlnaW5hbCA9IHJvb3QuYWNlcXVpcmU7XG4gICAgICAgIHJvb3QuYWNlcXVpcmUgPSBhY2VxdWlyZTtcbiAgICAgICAgcm9vdC5hY2VxdWlyZS5wYWNrYWdlZCA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnRBY2UoQUNFX05BTUVTUEFDRSk7XG5cbn0pKCk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL3JlZ2V4cFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcmVhbCA9IHtcbiAgICAgICAgICAgIGV4ZWM6IFJlZ0V4cC5wcm90b3R5cGUuZXhlYyxcbiAgICAgICAgICAgIHRlc3Q6IFJlZ0V4cC5wcm90b3R5cGUudGVzdCxcbiAgICAgICAgICAgIG1hdGNoOiBTdHJpbmcucHJvdG90eXBlLm1hdGNoLFxuICAgICAgICAgICAgcmVwbGFjZTogU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLFxuICAgICAgICAgICAgc3BsaXQ6IFN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxpYW50RXhlY05wY2cgPSByZWFsLmV4ZWMuY2FsbCgvKCk/Py8sIFwiXCIpWzFdID09PSB1bmRlZmluZWQsIC8vIGNoZWNrIGBleGVjYCBoYW5kbGluZyBvZiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgY29tcGxpYW50TGFzdEluZGV4SW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHggPSAvXi9nO1xuICAgICAgICAgICAgcmVhbC50ZXN0LmNhbGwoeCwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gIXgubGFzdEluZGV4O1xuICAgICAgICB9KCk7XG5cbiAgICBpZiAoY29tcGxpYW50TGFzdEluZGV4SW5jcmVtZW50ICYmIGNvbXBsaWFudEV4ZWNOcGNnKVxuICAgICAgICByZXR1cm47XG4gICAgUmVnRXhwLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZWFsLmV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIG5hbWUsIHIyO1xuICAgICAgICBpZiAoIHR5cGVvZihzdHIpID09ICdzdHJpbmcnICYmIG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgaW5kZXhPZihtYXRjaCwgXCJcIikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHIyID0gUmVnRXhwKHRoaXMuc291cmNlLCByZWFsLnJlcGxhY2UuY2FsbChnZXROYXRpdmVGbGFncyh0aGlzKSwgXCJnXCIsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICByZWFsLnJlcGxhY2UuY2FsbChzdHIuc2xpY2UobWF0Y2guaW5kZXgpLCByMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3hyZWdleHAgJiYgdGhpcy5feHJlZ2V4cC5jYXB0dXJlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLl94cmVnZXhwLmNhcHR1cmVOYW1lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtuYW1lXSA9IG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29tcGxpYW50TGFzdEluZGV4SW5jcmVtZW50ICYmIHRoaXMuZ2xvYmFsICYmICFtYXRjaFswXS5sZW5ndGggJiYgKHRoaXMubGFzdEluZGV4ID4gbWF0Y2guaW5kZXgpKVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdEluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH07XG4gICAgaWYgKCFjb21wbGlhbnRMYXN0SW5kZXhJbmNyZW1lbnQpIHtcbiAgICAgICAgUmVnRXhwLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcmVhbC5leGVjLmNhbGwodGhpcywgc3RyKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLmdsb2JhbCAmJiAhbWF0Y2hbMF0ubGVuZ3RoICYmICh0aGlzLmxhc3RJbmRleCA+IG1hdGNoLmluZGV4KSlcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleC0tO1xuICAgICAgICAgICAgcmV0dXJuICEhbWF0Y2g7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlRmxhZ3MgKHJlZ2V4KSB7XG4gICAgICAgIHJldHVybiAocmVnZXguZ2xvYmFsICAgICA/IFwiZ1wiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgKHJlZ2V4Lmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICtcbiAgICAgICAgICAgICAgIChyZWdleC5tdWx0aWxpbmUgID8gXCJtXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAgICAocmVnZXguZXh0ZW5kZWQgICA/IFwieFwiIDogXCJcIikgKyAvLyBQcm9wb3NlZCBmb3IgRVM0OyBpbmNsdWRlZCBpbiBBUzNcbiAgICAgICAgICAgICAgIChyZWdleC5zdGlja3kgICAgID8gXCJ5XCIgOiBcIlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmRleE9mIChhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIC8vIFVzZSB0aGUgbmF0aXZlIGFycmF5IG1ldGhvZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0sIGZyb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbSB8fCAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZXM1LXNoaW1cIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlIFwiICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgICAgICBpZih0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9O1xufVxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciBwcm90b3R5cGVPZkFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZU9mT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBzbGljZSA9IHByb3RvdHlwZU9mQXJyYXkuc2xpY2U7XG52YXIgX3RvU3RyaW5nID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0LnRvU3RyaW5nKTtcbnZhciBvd25zID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Lmhhc093blByb3BlcnR5KTtcbnZhciBkZWZpbmVHZXR0ZXI7XG52YXIgZGVmaW5lU2V0dGVyO1xudmFyIGxvb2t1cEdldHRlcjtcbnZhciBsb29rdXBTZXR0ZXI7XG52YXIgc3VwcG9ydHNBY2Nlc3NvcnM7XG5pZiAoKHN1cHBvcnRzQWNjZXNzb3JzID0gb3ducyhwcm90b3R5cGVPZk9iamVjdCwgXCJfX2RlZmluZUdldHRlcl9fXCIpKSkge1xuICAgIGRlZmluZUdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fKTtcbiAgICBkZWZpbmVTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVTZXR0ZXJfXyk7XG4gICAgbG9va3VwR2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwR2V0dGVyX18pO1xuICAgIGxvb2t1cFNldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fKTtcbn1cbmlmIChbMSwyXS5zcGxpY2UoMCkubGVuZ3RoICE9IDIpIHtcbiAgICBpZihmdW5jdGlvbigpIHsgLy8gdGVzdCBJRSA8IDkgdG8gc3BsaWNlIGJ1ZyAtIHNlZSBpc3N1ZSAjMTM4XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcnJheShsKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBBcnJheShsKzIpO1xuICAgICAgICAgICAgYVswXSA9IGFbMV0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFycmF5ID0gW10sIGxlbmd0aEJlZm9yZTtcbiAgICAgICAgXG4gICAgICAgIGFycmF5LnNwbGljZS5hcHBseShhcnJheSwgbWFrZUFycmF5KDIwKSk7XG4gICAgICAgIGFycmF5LnNwbGljZS5hcHBseShhcnJheSwgbWFrZUFycmF5KDI2KSk7XG5cbiAgICAgICAgbGVuZ3RoQmVmb3JlID0gYXJyYXkubGVuZ3RoOyAvLzQ2XG4gICAgICAgIGFycmF5LnNwbGljZSg1LCAwLCBcIlhYWFwiKTsgLy8gYWRkIG9uZSBlbGVtZW50XG5cbiAgICAgICAgbGVuZ3RoQmVmb3JlICsgMSA9PSBhcnJheS5sZW5ndGhcblxuICAgICAgICBpZiAobGVuZ3RoQmVmb3JlICsgMSA9PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOy8vIGhhcyByaWdodCBzcGxpY2UgaW1wbGVtZW50YXRpb24gd2l0aG91dCBidWdzXG4gICAgICAgIH1cbiAgICB9KCkpIHsvL0lFIDYvN1xuICAgICAgICB2YXIgYXJyYXlfc3BsaWNlID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIFtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPT09IHZvaWQgMCA/IDAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPT09IHZvaWQgMCA/ICh0aGlzLmxlbmd0aCAtIHN0YXJ0KSA6IGRlbGV0ZUNvdW50XG4gICAgICAgICAgICAgICAgXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Ugey8vSUU4XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbihwb3MsIHJlbW92ZUNvdW50KXtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MgPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWF4KGxlbmd0aCArIHBvcywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHBvcytyZW1vdmVDb3VudCA8IGxlbmd0aCkpXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ291bnQgPSBsZW5ndGggLSBwb3M7XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5zbGljZShwb3MsIHBvcytyZW1vdmVDb3VudCk7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgdmFyIGFkZCA9IGluc2VydC5sZW5ndGg7ICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocG9zID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaC5hcHBseSh0aGlzLCBpbnNlcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZSA9IE1hdGgubWluKHJlbW92ZUNvdW50LCBsZW5ndGggLSBwb3MpO1xuICAgICAgICAgICAgICAgIHZhciB0YWlsT2xkUG9zID0gcG9zICsgcmVtb3ZlO1xuICAgICAgICAgICAgICAgIHZhciB0YWlsTmV3UG9zID0gdGFpbE9sZFBvcyArIGFkZCAtIHJlbW92ZTtcbiAgICAgICAgICAgICAgICB2YXIgdGFpbENvdW50ID0gbGVuZ3RoIC0gdGFpbE9sZFBvcztcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoQWZ0ZXJSZW1vdmUgPSBsZW5ndGggLSByZW1vdmU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbE5ld1BvcyA8IHRhaWxPbGRQb3MpIHsgLy8gY2FzZSBBXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFpbENvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbdGFpbE5ld1BvcytpXSA9IHRoaXNbdGFpbE9sZFBvcytpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFpbE5ld1BvcyA+IHRhaWxPbGRQb3MpIHsgLy8gY2FzZSBCXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHRhaWxDb3VudDsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbdGFpbE5ld1BvcytpXSA9IHRoaXNbdGFpbE9sZFBvcytpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSwgYWRkID09IHJlbW92ZSAobm90aGluZyB0byBkbylcblxuICAgICAgICAgICAgICAgIGlmIChhZGQgJiYgcG9zID09PSBsZW5ndGhBZnRlclJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aEFmdGVyUmVtb3ZlOyAvLyB0cnVuY2F0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2guYXBwbHkodGhpcywgaW5zZXJ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aEFmdGVyUmVtb3ZlICsgYWRkOyAvLyByZXNlcnZlcyBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWRkOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcG9zK2ldID0gaW5zZXJ0W2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgIH07XG4gICAgfVxufVxuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcob2JqKSA9PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfTtcbn1cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdChcImFcIiksXG4gICAgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPSBcImFcIiB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFwiW29iamVjdCBTdHJpbmddXCIgP1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXQoXCJcIikgOlxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG4gICAgICAgIGlmIChfdG9TdHJpbmcoZnVuKSAhPSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUubWFwKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcChmdW4gLyosIHRoaXNwKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIF90b1N0cmluZyh0aGlzKSA9PSBcIltvYmplY3QgU3RyaW5nXVwiID9cbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KFwiXCIpIDpcbiAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2VsZltpXTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuLmNhbGwodGhpc3AsIHZhbHVlLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUuZXZlcnkpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZXZlcnkgPSBmdW5jdGlvbiBldmVyeShmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgIWZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5pZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiBzb21lKGZ1biAvKiwgdGhpc3AgKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIF90b1N0cmluZyh0aGlzKSA9PSBcIltvYmplY3QgU3RyaW5nXVwiID9cbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KFwiXCIpIDpcbiAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShmdW4gLyosIGluaXRpYWwqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFwiW29iamVjdCBTdHJpbmddXCIgP1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXQoXCJcIikgOlxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGZbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK2kgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bi5jYWxsKHZvaWQgMCwgcmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQpIHtcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiByZWR1Y2VSaWdodChmdW4gLyosIGluaXRpYWwqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFwiW29iamVjdCBTdHJpbmddXCIgP1xuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXQoXCJcIikgOlxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGVuZ3RoICYmIGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQsIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2ktLV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGkgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bi5jYWxsKHZvaWQgMCwgcmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgKFswLCAxXS5pbmRleE9mKDEsIDIpICE9IC0xKSkge1xuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuaWYgKCFBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgfHwgKFswLCAxXS5sYXN0SW5kZXhPZigwLCAtMykgIT0gLTEpKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcIlwiKSA6XG4gICAgICAgICAgICAgICAgdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gTWF0aC5taW4oaSwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogbGVuZ3RoIC0gTWF0aC5hYnMoaSk7XG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzb3VnaHQgPT09IHNlbGZbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cbmlmICghT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgT2JqZWN0LmdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QuX19wcm90b19fIHx8IChcbiAgICAgICAgICAgIG9iamVjdC5jb25zdHJ1Y3RvciA/XG4gICAgICAgICAgICBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlIDpcbiAgICAgICAgICAgIHByb3RvdHlwZU9mT2JqZWN0XG4gICAgICAgICk7XG4gICAgfTtcbn1cbmlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgIHZhciBFUlJfTk9OX09CSkVDVCA9IFwiT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciBjYWxsZWQgb24gYSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJub24tb2JqZWN0OiBcIjtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ICE9IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iamVjdCAhPSBcImZ1bmN0aW9uXCIpIHx8IG9iamVjdCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1QgKyBvYmplY3QpO1xuICAgICAgICBpZiAoIW93bnMob2JqZWN0LCBwcm9wZXJ0eSkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3IsIGdldHRlciwgc2V0dGVyO1xuICAgICAgICBkZXNjcmlwdG9yID0gIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH07XG4gICAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycykge1xuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XG5cbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB2YXIgc2V0dGVyID0gbG9va3VwU2V0dGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblxuICAgICAgICAgICAgaWYgKGdldHRlciB8fCBzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyKSBkZXNjcmlwdG9yLmdldCA9IGdldHRlcjtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSBkZXNjcmlwdG9yLnNldCA9IHNldHRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfTtcbn1cbmlmICghT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIH07XG59XG5pZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICB2YXIgY3JlYXRlRW1wdHk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fID09PSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgXCJfX3Byb3RvX19cIjogbnVsbCB9O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVtcHR5ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGVtcHR5KVxuICAgICAgICAgICAgICAgIGVtcHR5W2ldID0gbnVsbDtcbiAgICAgICAgICAgIGVtcHR5LmNvbnN0cnVjdG9yID1cbiAgICAgICAgICAgIGVtcHR5Lmhhc093blByb3BlcnR5ID1cbiAgICAgICAgICAgIGVtcHR5LnByb3BlcnR5SXNFbnVtZXJhYmxlID1cbiAgICAgICAgICAgIGVtcHR5LmlzUHJvdG90eXBlT2YgPVxuICAgICAgICAgICAgZW1wdHkudG9Mb2NhbGVTdHJpbmcgPVxuICAgICAgICAgICAgZW1wdHkudG9TdHJpbmcgPVxuICAgICAgICAgICAgZW1wdHkudmFsdWVPZiA9XG4gICAgICAgICAgICBlbXB0eS5fX3Byb3RvX18gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIG9iamVjdDtcbiAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gY3JlYXRlRW1wdHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInR5cGVvZiBwcm90b3R5cGVbXCIrKHR5cGVvZiBwcm90b3R5cGUpK1wiXSAhPSAnb2JqZWN0J1wiKTtcbiAgICAgICAgICAgIHZhciBUeXBlID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzICE9PSB2b2lkIDApXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsob2JqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgXCJzZW50aW5lbFwiLCB7fSk7XG4gICAgICAgIHJldHVybiBcInNlbnRpbmVsXCIgaW4gb2JqZWN0O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgIH1cbn1cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0ID0gZG9lc0RlZmluZVByb3BlcnR5V29yayh7fSk7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbkRvbSA9IHR5cGVvZiBkb2N1bWVudCA9PSBcInVuZGVmaW5lZFwiIHx8XG4gICAgICAgIGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgaWYgKCFkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgfHwgIWRlZmluZVByb3BlcnR5V29ya3NPbkRvbSkge1xuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHlGYWxsYmFjayA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgICB9XG59XG5cbmlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICB2YXIgRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiA9IFwiUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhbiBvYmplY3Q6IFwiO1xuICAgIHZhciBFUlJfTk9OX09CSkVDVF9UQVJHRVQgPSBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxsZWQgb24gbm9uLW9iamVjdDogXCJcbiAgICB2YXIgRVJSX0FDQ0VTU09SU19OT1RfU1VQUE9SVEVEID0gXCJnZXR0ZXJzICYgc2V0dGVycyBjYW4gbm90IGJlIGRlZmluZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9uIHRoaXMgamF2YXNjcmlwdCBlbmdpbmVcIjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ICE9IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iamVjdCAhPSBcImZ1bmN0aW9uXCIpIHx8IG9iamVjdCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfVEFSR0VUICsgb2JqZWN0KTtcbiAgICAgICAgaWYgKCh0eXBlb2YgZGVzY3JpcHRvciAhPSBcIm9iamVjdFwiICYmIHR5cGVvZiBkZXNjcmlwdG9yICE9IFwiZnVuY3Rpb25cIikgfHwgZGVzY3JpcHRvciA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiArIGRlc2NyaXB0b3IpO1xuICAgICAgICBpZiAoZGVmaW5lUHJvcGVydHlGYWxsYmFjaykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHlGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0FjY2Vzc29ycyAmJiAobG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcGVydHkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0FjY2Vzc29ycylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCk7XG4gICAgICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCBcImdldFwiKSlcbiAgICAgICAgICAgICAgICBkZWZpbmVHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgICAgICAgaWYgKG93bnMoZGVzY3JpcHRvciwgXCJzZXRcIikpXG4gICAgICAgICAgICAgICAgZGVmaW5lU2V0dGVyKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cbmlmICghT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChvd25zKHByb3BlcnRpZXMsIHByb3BlcnR5KSlcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgcHJvcGVydGllc1twcm9wZXJ0eV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cbmlmICghT2JqZWN0LnNlYWwpIHtcbiAgICBPYmplY3Quc2VhbCA9IGZ1bmN0aW9uIHNlYWwob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cbmlmICghT2JqZWN0LmZyZWV6ZSkge1xuICAgIE9iamVjdC5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cbnRyeSB7XG4gICAgT2JqZWN0LmZyZWV6ZShmdW5jdGlvbiAoKSB7fSk7XG59IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICBPYmplY3QuZnJlZXplID0gKGZ1bmN0aW9uIGZyZWV6ZShmcmVlemVPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmVlemVPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KShPYmplY3QuZnJlZXplKTtcbn1cbmlmICghT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID0gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cbmlmICghT2JqZWN0LmlzU2VhbGVkKSB7XG4gICAgT2JqZWN0LmlzU2VhbGVkID0gZnVuY3Rpb24gaXNTZWFsZWQob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcbiAgICBPYmplY3QuaXNGcm96ZW4gPSBmdW5jdGlvbiBpc0Zyb3plbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5pZiAoIU9iamVjdC5pc0V4dGVuc2libGUpIHtcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlID0gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKG9iamVjdCkge1xuICAgICAgICBpZiAoT2JqZWN0KG9iamVjdCkgPT09IG9iamVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgICB3aGlsZSAob3ducyhvYmplY3QsIG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lICs9ICc/JztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSB0cnVlO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvd25zKG9iamVjdCwgbmFtZSk7XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbmFtZV07XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9O1xufVxuaWYgKCFPYmplY3Qua2V5cykge1xuICAgIHZhciBoYXNEb250RW51bUJ1ZyA9IHRydWUsXG4gICAgICAgIGRvbnRFbnVtcyA9IFtcbiAgICAgICAgICAgIFwidG9TdHJpbmdcIixcbiAgICAgICAgICAgIFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICAgICAgICAgIFwidmFsdWVPZlwiLFxuICAgICAgICAgICAgXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICAgICAgXCJpc1Byb3RvdHlwZU9mXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXG4gICAgICAgICAgICBcImNvbnN0cnVjdG9yXCJcbiAgICAgICAgXSxcbiAgICAgICAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGtleSBpbiB7XCJ0b1N0cmluZ1wiOiBudWxsfSkge1xuICAgICAgICBoYXNEb250RW51bUJ1ZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAodHlwZW9mIG9iamVjdCAhPSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmplY3QgIT0gXCJmdW5jdGlvblwiKSB8fFxuICAgICAgICAgICAgb2JqZWN0ID09PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZG9udEVudW1zTGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkb250RW51bSA9IGRvbnRFbnVtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhvYmplY3QsIGRvbnRFbnVtKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goZG9udEVudW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG59XG5pZiAoIURhdGUubm93KSB7XG4gICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xufVxudmFyIHdzID0gXCJcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1wiICtcbiAgICBcIlxcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XCIgK1xuICAgIFwiXFx1MjAyOVxcdUZFRkZcIjtcbmlmICghU3RyaW5nLnByb3RvdHlwZS50cmltIHx8IHdzLnRyaW0oKSkge1xuICAgIHdzID0gXCJbXCIgKyB3cyArIFwiXVwiO1xuICAgIHZhciB0cmltQmVnaW5SZWdleHAgPSBuZXcgUmVnRXhwKFwiXlwiICsgd3MgKyB3cyArIFwiKlwiKSxcbiAgICAgICAgdHJpbUVuZFJlZ2V4cCA9IG5ldyBSZWdFeHAod3MgKyB3cyArIFwiKiRcIik7XG4gICAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgXCJcIikucmVwbGFjZSh0cmltRW5kUmVnZXhwLCBcIlwiKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0b0ludGVnZXIobikge1xuICAgIG4gPSArbjtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEvMCkgJiYgbiAhPT0gLSgxLzApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShpbnB1dCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIHJldHVybiAoXG4gICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgIHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICB0eXBlID09PSBcInN0cmluZ1wiXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gdG9QcmltaXRpdmUoaW5wdXQpIHtcbiAgICB2YXIgdmFsLCB2YWx1ZU9mLCB0b1N0cmluZztcbiAgICBpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgdmFsdWVPZiA9IGlucHV0LnZhbHVlT2Y7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZU9mID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFsID0gdmFsdWVPZi5jYWxsKGlucHV0KTtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcgPSBpbnB1dC50b1N0cmluZztcbiAgICBpZiAodHlwZW9mIHRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFsID0gdG9TdHJpbmcuY2FsbChpbnB1dCk7XG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbn1cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIrbytcIiB0byBvYmplY3RcIik7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvZml4b2xkYnJvd3NlcnNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvcmVnZXhwXCIsXCJhY2UvbGliL2VzNS1zaGltXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuYWNlcXVpcmUoXCIuL3JlZ2V4cFwiKTtcbmFjZXF1aXJlKFwiLi9lczUtc2hpbVwiKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2RvbVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBYSFRNTF9OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG5leHBvcnRzLmdldERvY3VtZW50SGVhZCA9IGZ1bmN0aW9uKGRvYykge1xuICAgIGlmICghZG9jKVxuICAgICAgICBkb2MgPSBkb2N1bWVudDtcbiAgICByZXR1cm4gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xufVxuXG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0YWcsIG5zKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyA/XG4gICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucyB8fCBYSFRNTF9OUywgdGFnKSA6XG4gICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbn07XG5cbmV4cG9ydHMuaGFzQ3NzQ2xhc3MgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gKGVsLmNsYXNzTmFtZSB8fCBcIlwiKS5zcGxpdCgvXFxzKy9nKTtcbiAgICByZXR1cm4gY2xhc3Nlcy5pbmRleE9mKG5hbWUpICE9PSAtMTtcbn07XG5leHBvcnRzLmFkZENzc0NsYXNzID0gZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICBpZiAoIWV4cG9ydHMuaGFzQ3NzQ2xhc3MoZWwsIG5hbWUpKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIiArIG5hbWU7XG4gICAgfVxufTtcbmV4cG9ydHMucmVtb3ZlQ3NzQ2xhc3MgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcIiBcIik7XG59O1xuXG5leHBvcnRzLnRvZ2dsZUNzc0NsYXNzID0gZnVuY3Rpb24oZWwsIG5hbWUpIHtcbiAgICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKSwgYWRkID0gdHJ1ZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYWRkID0gZmFsc2U7XG4gICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgaWYoYWRkKVxuICAgICAgICBjbGFzc2VzLnB1c2gobmFtZSk7XG5cbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgIHJldHVybiBhZGQ7XG59O1xuZXhwb3J0cy5zZXRDc3NDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGNsYXNzTmFtZSwgaW5jbHVkZSkge1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgIGV4cG9ydHMuYWRkQ3NzQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBleHBvcnRzLnJlbW92ZUNzc0NsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5oYXNDc3NTdHJpbmcgPSBmdW5jdGlvbihpZCwgZG9jKSB7XG4gICAgdmFyIGluZGV4ID0gMCwgc2hlZXRzO1xuICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuICAgIGlmIChkb2MuY3JlYXRlU3R5bGVTaGVldCAmJiAoc2hlZXRzID0gZG9jLnN0eWxlU2hlZXRzKSkge1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBzaGVldHMubGVuZ3RoKVxuICAgICAgICAgICAgaWYgKHNoZWV0c1tpbmRleCsrXS5vd25pbmdFbGVtZW50LmlkID09PSBpZCkgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgoc2hlZXRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3R5bGVcIikpKSB7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHNoZWV0cy5sZW5ndGgpXG4gICAgICAgICAgICBpZiAoc2hlZXRzW2luZGV4KytdLmlkID09PSBpZCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0cy5pbXBvcnRDc3NTdHJpbmcgPSBmdW5jdGlvbiBpbXBvcnRDc3NTdHJpbmcoY3NzVGV4dCwgaWQsIGRvYykge1xuICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICBpZiAoaWQgJiYgZXhwb3J0cy5oYXNDc3NTdHJpbmcoaWQsIGRvYykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIFxuICAgIHZhciBzdHlsZTtcbiAgICBcbiAgICBpZiAoZG9jLmNyZWF0ZVN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUgPSBkb2MuY3JlYXRlU3R5bGVTaGVldCgpO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgc3R5bGUub3duaW5nRWxlbWVudC5pZCA9IGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnROU1xuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKFhIVE1MX05TLCBcInN0eWxlXCIpXG4gICAgICAgICAgICA6IGRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKGNzc1RleHQpKTtcbiAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgc3R5bGUuaWQgPSBpZDtcblxuICAgICAgICBleHBvcnRzLmdldERvY3VtZW50SGVhZChkb2MpLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLmltcG9ydENzc1N0eWxzaGVldCA9IGZ1bmN0aW9uKHVyaSwgZG9jKSB7XG4gICAgaWYgKGRvYy5jcmVhdGVTdHlsZVNoZWV0KSB7XG4gICAgICAgIGRvYy5jcmVhdGVTdHlsZVNoZWV0KHVyaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxpbmsgPSBleHBvcnRzLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgICAgIGxpbmsuaHJlZiA9IHVyaTtcblxuICAgICAgICBleHBvcnRzLmdldERvY3VtZW50SGVhZChkb2MpLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZ2V0SW5uZXJXaWR0aCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBwYXJzZUludChleHBvcnRzLmNvbXB1dGVkU3R5bGUoZWxlbWVudCwgXCJwYWRkaW5nTGVmdFwiKSwgMTApICtcbiAgICAgICAgcGFyc2VJbnQoZXhwb3J0cy5jb21wdXRlZFN0eWxlKGVsZW1lbnQsIFwicGFkZGluZ1JpZ2h0XCIpLCAxMCkgKyBcbiAgICAgICAgZWxlbWVudC5jbGllbnRXaWR0aFxuICAgICk7XG59O1xuXG5leHBvcnRzLmdldElubmVySGVpZ2h0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHBhcnNlSW50KGV4cG9ydHMuY29tcHV0ZWRTdHlsZShlbGVtZW50LCBcInBhZGRpbmdUb3BcIiksIDEwKSArXG4gICAgICAgIHBhcnNlSW50KGV4cG9ydHMuY29tcHV0ZWRTdHlsZShlbGVtZW50LCBcInBhZGRpbmdCb3R0b21cIiksIDEwKSArXG4gICAgICAgIGVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgKTtcbn07XG5cblxuaWYgKHR5cGVvZiBkb2N1bWVudCA9PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcblxuaWYgKHdpbmRvdy5wYWdlWU9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwb3J0cy5nZXRQYWdlU2Nyb2xsVG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuZ2V0UGFnZVNjcm9sbExlZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICB9O1xufVxuZWxzZSB7XG4gICAgZXhwb3J0cy5nZXRQYWdlU2Nyb2xsVG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5nZXRQYWdlU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xuICAgIH07XG59XG5cbmlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSlcbiAgICBleHBvcnRzLmNvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZSkge1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICByZXR1cm4gKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIFwiXCIpIHx8IHt9KVtzdHlsZV0gfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIFwiXCIpIHx8IHt9O1xuICAgIH07XG5lbHNlXG4gICAgZXhwb3J0cy5jb21wdXRlZFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGUpIHtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY3VycmVudFN0eWxlW3N0eWxlXTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY3VycmVudFN0eWxlO1xuICAgIH07XG5cbmV4cG9ydHMuc2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgIHZhciBpbm5lciA9IGV4cG9ydHMuY3JlYXRlRWxlbWVudChcImFjZV9pbm5lclwiKTtcbiAgICBpbm5lci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIGlubmVyLnN0eWxlLm1pbldpZHRoID0gXCIwcHhcIjtcbiAgICBpbm5lci5zdHlsZS5oZWlnaHQgPSBcIjIwMHB4XCI7XG4gICAgaW5uZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICAgIHZhciBvdXRlciA9IGV4cG9ydHMuY3JlYXRlRWxlbWVudChcImFjZV9vdXRlclwiKTtcbiAgICB2YXIgc3R5bGUgPSBvdXRlci5zdHlsZTtcblxuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHN0eWxlLmxlZnQgPSBcIi0xMDAwMHB4XCI7XG4gICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHN0eWxlLndpZHRoID0gXCIyMDBweFwiO1xuICAgIHN0eWxlLm1pbldpZHRoID0gXCIwcHhcIjtcbiAgICBzdHlsZS5oZWlnaHQgPSBcIjE1MHB4XCI7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXG4gICAgdmFyIG5vU2Nyb2xsYmFyID0gaW5uZXIub2Zmc2V0V2lkdGg7XG5cbiAgICBzdHlsZS5vdmVyZmxvdyA9IFwic2Nyb2xsXCI7XG4gICAgdmFyIHdpdGhTY3JvbGxiYXIgPSBpbm5lci5vZmZzZXRXaWR0aDtcblxuICAgIGlmIChub1Njcm9sbGJhciA9PSB3aXRoU2Nyb2xsYmFyKSB7XG4gICAgICAgIHdpdGhTY3JvbGxiYXIgPSBvdXRlci5jbGllbnRXaWR0aDtcbiAgICB9XG5cbiAgICBib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcblxuICAgIHJldHVybiBub1Njcm9sbGJhci13aXRoU2Nyb2xsYmFyO1xufTtcbmV4cG9ydHMuc2V0SW5uZXJIdG1sID0gZnVuY3Rpb24oZWwsIGlubmVySHRtbCkge1xuICAgIHZhciBlbGVtZW50ID0gZWwuY2xvbmVOb2RlKGZhbHNlKTsvL2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBpbm5lckh0bWw7XG4gICAgZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWxlbWVudCwgZWwpO1xuICAgIHJldHVybiBlbGVtZW50O1xufTtcblxuaWYgKFwidGV4dENvbnRlbnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBleHBvcnRzLnNldElubmVyVGV4dCA9IGZ1bmN0aW9uKGVsLCBpbm5lclRleHQpIHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSBpbm5lclRleHQ7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuZ2V0SW5uZXJUZXh0ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnRleHRDb250ZW50O1xuICAgIH07XG59XG5lbHNlIHtcbiAgICBleHBvcnRzLnNldElubmVyVGV4dCA9IGZ1bmN0aW9uKGVsLCBpbm5lclRleHQpIHtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gaW5uZXJUZXh0O1xuICAgIH07XG5cbiAgICBleHBvcnRzLmdldElubmVyVGV4dCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5pbm5lclRleHQ7XG4gICAgfTtcbn1cblxuZXhwb3J0cy5nZXRQYXJlbnRXaW5kb3cgPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kZWZhdWx0VmlldyB8fCBkb2N1bWVudC5wYXJlbnRXaW5kb3c7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvb29wXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0cy5taXhpbiA9IGZ1bmN0aW9uKG9iaiwgbWl4aW4pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWl4aW4pIHtcbiAgICAgICAgb2JqW2tleV0gPSBtaXhpbltrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5pbXBsZW1lbnQgPSBmdW5jdGlvbihwcm90bywgbWl4aW4pIHtcbiAgICBleHBvcnRzLm1peGluKHByb3RvLCBtaXhpbik7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIva2V5c1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9maXhvbGRicm93c2Vyc1wiLFwiYWNlL2xpYi9vb3BcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG5hY2VxdWlyZShcIi4vZml4b2xkYnJvd3NlcnNcIik7XG5cbnZhciBvb3AgPSBhY2VxdWlyZShcIi4vb29wXCIpO1xudmFyIEtleXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgICAgTU9ESUZJRVJfS0VZUzoge1xuICAgICAgICAgICAgMTY6ICdTaGlmdCcsIDE3OiAnQ3RybCcsIDE4OiAnQWx0JywgMjI0OiAnTWV0YSdcbiAgICAgICAgfSxcblxuICAgICAgICBLRVlfTU9EUzoge1xuICAgICAgICAgICAgXCJjdHJsXCI6IDEsIFwiYWx0XCI6IDIsIFwib3B0aW9uXCIgOiAyLCBcInNoaWZ0XCI6IDQsXG4gICAgICAgICAgICBcInN1cGVyXCI6IDgsIFwibWV0YVwiOiA4LCBcImNvbW1hbmRcIjogOCwgXCJjbWRcIjogOFxuICAgICAgICB9LFxuXG4gICAgICAgIEZVTkNUSU9OX0tFWVMgOiB7XG4gICAgICAgICAgICA4ICA6IFwiQmFja3NwYWNlXCIsXG4gICAgICAgICAgICA5ICA6IFwiVGFiXCIsXG4gICAgICAgICAgICAxMyA6IFwiUmV0dXJuXCIsXG4gICAgICAgICAgICAxOSA6IFwiUGF1c2VcIixcbiAgICAgICAgICAgIDI3IDogXCJFc2NcIixcbiAgICAgICAgICAgIDMyIDogXCJTcGFjZVwiLFxuICAgICAgICAgICAgMzMgOiBcIlBhZ2VVcFwiLFxuICAgICAgICAgICAgMzQgOiBcIlBhZ2VEb3duXCIsXG4gICAgICAgICAgICAzNSA6IFwiRW5kXCIsXG4gICAgICAgICAgICAzNiA6IFwiSG9tZVwiLFxuICAgICAgICAgICAgMzcgOiBcIkxlZnRcIixcbiAgICAgICAgICAgIDM4IDogXCJVcFwiLFxuICAgICAgICAgICAgMzkgOiBcIlJpZ2h0XCIsXG4gICAgICAgICAgICA0MCA6IFwiRG93blwiLFxuICAgICAgICAgICAgNDQgOiBcIlByaW50XCIsXG4gICAgICAgICAgICA0NSA6IFwiSW5zZXJ0XCIsXG4gICAgICAgICAgICA0NiA6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICA5NiA6IFwiTnVtcGFkMFwiLFxuICAgICAgICAgICAgOTcgOiBcIk51bXBhZDFcIixcbiAgICAgICAgICAgIDk4IDogXCJOdW1wYWQyXCIsXG4gICAgICAgICAgICA5OSA6IFwiTnVtcGFkM1wiLFxuICAgICAgICAgICAgMTAwOiBcIk51bXBhZDRcIixcbiAgICAgICAgICAgIDEwMTogXCJOdW1wYWQ1XCIsXG4gICAgICAgICAgICAxMDI6IFwiTnVtcGFkNlwiLFxuICAgICAgICAgICAgMTAzOiBcIk51bXBhZDdcIixcbiAgICAgICAgICAgIDEwNDogXCJOdW1wYWQ4XCIsXG4gICAgICAgICAgICAxMDU6IFwiTnVtcGFkOVwiLFxuICAgICAgICAgICAgJy0xMyc6IFwiTnVtcGFkRW50ZXJcIixcbiAgICAgICAgICAgIDExMjogXCJGMVwiLFxuICAgICAgICAgICAgMTEzOiBcIkYyXCIsXG4gICAgICAgICAgICAxMTQ6IFwiRjNcIixcbiAgICAgICAgICAgIDExNTogXCJGNFwiLFxuICAgICAgICAgICAgMTE2OiBcIkY1XCIsXG4gICAgICAgICAgICAxMTc6IFwiRjZcIixcbiAgICAgICAgICAgIDExODogXCJGN1wiLFxuICAgICAgICAgICAgMTE5OiBcIkY4XCIsXG4gICAgICAgICAgICAxMjA6IFwiRjlcIixcbiAgICAgICAgICAgIDEyMTogXCJGMTBcIixcbiAgICAgICAgICAgIDEyMjogXCJGMTFcIixcbiAgICAgICAgICAgIDEyMzogXCJGMTJcIixcbiAgICAgICAgICAgIDE0NDogXCJOdW1sb2NrXCIsXG4gICAgICAgICAgICAxNDU6IFwiU2Nyb2xsbG9ja1wiXG4gICAgICAgIH0sXG5cbiAgICAgICAgUFJJTlRBQkxFX0tFWVM6IHtcbiAgICAgICAgICAgMzI6ICcgJywgIDQ4OiAnMCcsICA0OTogJzEnLCAgNTA6ICcyJywgIDUxOiAnMycsICA1MjogJzQnLCA1MzogICc1JyxcbiAgICAgICAgICAgNTQ6ICc2JywgIDU1OiAnNycsICA1NjogJzgnLCAgNTc6ICc5JywgIDU5OiAnOycsICA2MTogJz0nLCA2NTogICdhJyxcbiAgICAgICAgICAgNjY6ICdiJywgIDY3OiAnYycsICA2ODogJ2QnLCAgNjk6ICdlJywgIDcwOiAnZicsICA3MTogJ2cnLCA3MjogICdoJyxcbiAgICAgICAgICAgNzM6ICdpJywgIDc0OiAnaicsICA3NTogJ2snLCAgNzY6ICdsJywgIDc3OiAnbScsICA3ODogJ24nLCA3OTogICdvJyxcbiAgICAgICAgICAgODA6ICdwJywgIDgxOiAncScsICA4MjogJ3InLCAgODM6ICdzJywgIDg0OiAndCcsICA4NTogJ3UnLCA4NjogICd2JyxcbiAgICAgICAgICAgODc6ICd3JywgIDg4OiAneCcsICA4OTogJ3knLCAgOTA6ICd6JywgMTA3OiAnKycsIDEwOTogJy0nLCAxMTA6ICcuJyxcbiAgICAgICAgICAxODY6ICc7JywgMTg3OiAnPScsIDE4ODogJywnLCAxODk6ICctJywgMTkwOiAnLicsIDE5MTogJy8nLCAxOTI6ICdgJyxcbiAgICAgICAgICAyMTk6ICdbJywgMjIwOiAnXFxcXCcsMjIxOiAnXScsIDIyMjogJ1xcJydcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG5hbWUsIGk7XG4gICAgZm9yIChpIGluIHJldC5GVU5DVElPTl9LRVlTKSB7XG4gICAgICAgIG5hbWUgPSByZXQuRlVOQ1RJT05fS0VZU1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRbbmFtZV0gPSBwYXJzZUludChpLCAxMCk7XG4gICAgfVxuICAgIGZvciAoaSBpbiByZXQuUFJJTlRBQkxFX0tFWVMpIHtcbiAgICAgICAgbmFtZSA9IHJldC5QUklOVEFCTEVfS0VZU1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRbbmFtZV0gPSBwYXJzZUludChpLCAxMCk7XG4gICAgfVxuICAgIG9vcC5taXhpbihyZXQsIHJldC5NT0RJRklFUl9LRVlTKTtcbiAgICBvb3AubWl4aW4ocmV0LCByZXQuUFJJTlRBQkxFX0tFWVMpO1xuICAgIG9vcC5taXhpbihyZXQsIHJldC5GVU5DVElPTl9LRVlTKTtcbiAgICByZXQuZW50ZXIgPSByZXRbXCJyZXR1cm5cIl07XG4gICAgcmV0LmVzY2FwZSA9IHJldC5lc2M7XG4gICAgcmV0LmRlbCA9IHJldFtcImRlbGV0ZVwiXTtcbiAgICByZXRbMTczXSA9ICctJztcbiAgICBcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtb2RzID0gW1wiY21kXCIsIFwiY3RybFwiLCBcImFsdFwiLCBcInNoaWZ0XCJdO1xuICAgICAgICBmb3IgKHZhciBpID0gTWF0aC5wb3coMiwgbW9kcy5sZW5ndGgpOyBpLS07KSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXQuS0VZX01PRFNbaV0gPSBtb2RzLmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgJiByZXQuS0VZX01PRFNbeF07XG4gICAgICAgICAgICB9KS5qb2luKFwiLVwiKSArIFwiLVwiO1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIHJldC5LRVlfTU9EU1swXSA9IFwiXCI7XG4gICAgcmV0LktFWV9NT0RTWy0xXSA9IFwiaW5wdXQtXCI7XG5cbiAgICByZXR1cm4gcmV0O1xufSkoKTtcbm9vcC5taXhpbihleHBvcnRzLCBLZXlzKTtcblxuZXhwb3J0cy5rZXlDb2RlVG9TdHJpbmcgPSBmdW5jdGlvbihrZXlDb2RlKSB7XG4gICAgdmFyIGtleVN0cmluZyA9IEtleXNba2V5Q29kZV07XG4gICAgaWYgKHR5cGVvZiBrZXlTdHJpbmcgIT0gXCJzdHJpbmdcIilcbiAgICAgICAga2V5U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcbiAgICByZXR1cm4ga2V5U3RyaW5nLnRvTG93ZXJDYXNlKCk7XG59O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvdXNlcmFnZW50XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuT1MgPSB7XG4gICAgTElOVVg6IFwiTElOVVhcIixcbiAgICBNQUM6IFwiTUFDXCIsXG4gICAgV0lORE9XUzogXCJXSU5ET1dTXCJcbn07XG5leHBvcnRzLmdldE9TID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGV4cG9ydHMuaXNNYWMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuT1MuTUFDO1xuICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc0xpbnV4KSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9TLkxJTlVYO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk9TLldJTkRPV1M7XG4gICAgfVxufTtcbmlmICh0eXBlb2YgbmF2aWdhdG9yICE9IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuO1xuXG52YXIgb3MgPSAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKC9tYWN8d2lufGxpbnV4L2kpIHx8IFtcIm90aGVyXCJdKVswXS50b0xvd2VyQ2FzZSgpO1xudmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbmV4cG9ydHMuaXNXaW4gPSAob3MgPT0gXCJ3aW5cIik7XG5leHBvcnRzLmlzTWFjID0gKG9zID09IFwibWFjXCIpO1xuZXhwb3J0cy5pc0xpbnV4ID0gKG9zID09IFwibGludXhcIik7XG5leHBvcnRzLmlzSUUgPSBcbiAgICAobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIiB8fCBuYXZpZ2F0b3IuYXBwTmFtZS5pbmRleE9mKFwiTVNBcHBIb3N0XCIpID49IDApXG4gICAgPyBwYXJzZUZsb2F0KCh1YS5tYXRjaCgvKD86TVNJRSB8VHJpZGVudFxcL1swLTldK1tcXC4wLTldKzsuKnJ2OikoWzAtOV0rW1xcLjAtOV0rKS8pfHxbXSlbMV0pXG4gICAgOiBwYXJzZUZsb2F0KCh1YS5tYXRjaCgvKD86VHJpZGVudFxcL1swLTldK1tcXC4wLTldKzsuKnJ2OikoWzAtOV0rW1xcLjAtOV0rKS8pfHxbXSlbMV0pOyAvLyBmb3IgaWVcbiAgICBcbmV4cG9ydHMuaXNPbGRJRSA9IGV4cG9ydHMuaXNJRSAmJiBleHBvcnRzLmlzSUUgPCA5O1xuZXhwb3J0cy5pc0dlY2tvID0gZXhwb3J0cy5pc01vemlsbGEgPSAod2luZG93LkNvbnRyb2xsZXJzIHx8IHdpbmRvdy5jb250cm9sbGVycykgJiYgd2luZG93Lm5hdmlnYXRvci5wcm9kdWN0ID09PSBcIkdlY2tvXCI7XG5leHBvcnRzLmlzT2xkR2Vja28gPSBleHBvcnRzLmlzR2Vja28gJiYgcGFyc2VJbnQoKHVhLm1hdGNoKC9ydlxcOihcXGQrKS8pfHxbXSlbMV0sIDEwKSA8IDQ7XG5leHBvcnRzLmlzT3BlcmEgPSB3aW5kb3cub3BlcmEgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5vcGVyYSkgPT0gXCJbb2JqZWN0IE9wZXJhXVwiO1xuZXhwb3J0cy5pc1dlYktpdCA9IHBhcnNlRmxvYXQodWEuc3BsaXQoXCJXZWJLaXQvXCIpWzFdKSB8fCB1bmRlZmluZWQ7XG5cbmV4cG9ydHMuaXNDaHJvbWUgPSBwYXJzZUZsb2F0KHVhLnNwbGl0KFwiIENocm9tZS9cIilbMV0pIHx8IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5pc0FJUiA9IHVhLmluZGV4T2YoXCJBZG9iZUFJUlwiKSA+PSAwO1xuXG5leHBvcnRzLmlzSVBhZCA9IHVhLmluZGV4T2YoXCJpUGFkXCIpID49IDA7XG5cbmV4cG9ydHMuaXNUb3VjaFBhZCA9IHVhLmluZGV4T2YoXCJUb3VjaFBhZFwiKSA+PSAwO1xuXG5leHBvcnRzLmlzQ2hyb21lT1MgPSB1YS5pbmRleE9mKFwiIENyT1MgXCIpID49IDA7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9ldmVudFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9rZXlzXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlzID0gYWNlcXVpcmUoXCIuL2tleXNcIik7XG52YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXCIuL3VzZXJhZ2VudFwiKTtcblxuZXhwb3J0cy5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW0sIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGVsZW0sIHdpbmRvdy5ldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNhbGxiYWNrLl93cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgZWxlbS5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgZWxlbS5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBjYWxsYmFjay5fd3JhcHBlciB8fCBjYWxsYmFjayk7XG4gICAgfVxufTtcbmV4cG9ydHMuc3RvcEV2ZW50ID0gZnVuY3Rpb24oZSkge1xuICAgIGV4cG9ydHMuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIGV4cG9ydHMucHJldmVudERlZmF1bHQoZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0cy5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGVsc2VcbiAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xufTtcblxuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVsc2VcbiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xufTtcbmV4cG9ydHMuZ2V0QnV0dG9uID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnR5cGUgPT0gXCJkYmxjbGlja1wiKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAoZS50eXBlID09IFwiY29udGV4dG1lbnVcIiB8fCAodXNlcmFnZW50LmlzTWFjICYmIChlLmN0cmxLZXkgJiYgIWUuYWx0S2V5ICYmICFlLnNoaWZ0S2V5KSkpXG4gICAgICAgIHJldHVybiAyO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBlLmJ1dHRvbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7MTowLCAyOjIsIDQ6MX1bZS5idXR0b25dO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuY2FwdHVyZSA9IGZ1bmN0aW9uKGVsLCBldmVudEhhbmRsZXIsIHJlbGVhc2VDYXB0dXJlSGFuZGxlcikge1xuICAgIGZ1bmN0aW9uIG9uTW91c2VVcChlKSB7XG4gICAgICAgIGV2ZW50SGFuZGxlciAmJiBldmVudEhhbmRsZXIoZSk7XG4gICAgICAgIHJlbGVhc2VDYXB0dXJlSGFuZGxlciAmJiByZWxlYXNlQ2FwdHVyZUhhbmRsZXIoZSk7XG5cbiAgICAgICAgZXhwb3J0cy5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgZXZlbnRIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgZXhwb3J0cy5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIG9uTW91c2VVcCwgdHJ1ZSk7XG4gICAgICAgIGV4cG9ydHMucmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIFwiZHJhZ3N0YXJ0XCIsIG9uTW91c2VVcCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5hZGRMaXN0ZW5lcihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgZXZlbnRIYW5kbGVyLCB0cnVlKTtcbiAgICBleHBvcnRzLmFkZExpc3RlbmVyKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCB0cnVlKTtcbiAgICBleHBvcnRzLmFkZExpc3RlbmVyKGRvY3VtZW50LCBcImRyYWdzdGFydFwiLCBvbk1vdXNlVXAsIHRydWUpO1xuICAgIFxuICAgIHJldHVybiBvbk1vdXNlVXA7XG59O1xuXG5leHBvcnRzLmFkZE1vdXNlV2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsLCBjYWxsYmFjaykge1xuICAgIGlmIChcIm9ubW91c2V3aGVlbFwiIGluIGVsKSB7XG4gICAgICAgIGV4cG9ydHMuYWRkTGlzdGVuZXIoZWwsIFwibW91c2V3aGVlbFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gODtcbiAgICAgICAgICAgIGlmIChlLndoZWVsRGVsdGFYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlLndoZWVsWCA9IC1lLndoZWVsRGVsdGFYIC8gZmFjdG9yO1xuICAgICAgICAgICAgICAgIGUud2hlZWxZID0gLWUud2hlZWxEZWx0YVkgLyBmYWN0b3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUud2hlZWxYID0gMDtcbiAgICAgICAgICAgICAgICBlLndoZWVsWSA9IC1lLndoZWVsRGVsdGEgLyBmYWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChcIm9ud2hlZWxcIiBpbiBlbCkge1xuICAgICAgICBleHBvcnRzLmFkZExpc3RlbmVyKGVsLCBcIndoZWVsXCIsICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gMC4zNTtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5kZWx0YU1vZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGUuRE9NX0RFTFRBX1BJWEVMOlxuICAgICAgICAgICAgICAgICAgICBlLndoZWVsWCA9IGUuZGVsdGFYICogZmFjdG9yIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGUud2hlZWxZID0gZS5kZWx0YVkgKiBmYWN0b3IgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBlLkRPTV9ERUxUQV9MSU5FOlxuICAgICAgICAgICAgICAgIGNhc2UgZS5ET01fREVMVEFfUEFHRTpcbiAgICAgICAgICAgICAgICAgICAgZS53aGVlbFggPSAoZS5kZWx0YVggfHwgMCkgKiA1O1xuICAgICAgICAgICAgICAgICAgICBlLndoZWVsWSA9IChlLmRlbHRhWSB8fCAwKSAqIDU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXhwb3J0cy5hZGRMaXN0ZW5lcihlbCwgXCJET01Nb3VzZVNjcm9sbFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5heGlzICYmIGUuYXhpcyA9PSBlLkhPUklaT05UQUxfQVhJUykge1xuICAgICAgICAgICAgICAgIGUud2hlZWxYID0gKGUuZGV0YWlsIHx8IDApICogNTtcbiAgICAgICAgICAgICAgICBlLndoZWVsWSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUud2hlZWxYID0gMDtcbiAgICAgICAgICAgICAgICBlLndoZWVsWSA9IChlLmRldGFpbCB8fCAwKSAqIDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5hZGRNdWx0aU1vdXNlRG93bkxpc3RlbmVyID0gZnVuY3Rpb24oZWwsIHRpbWVvdXRzLCBldmVudEhhbmRsZXIsIGNhbGxiYWNrTmFtZSkge1xuICAgIHZhciBjbGlja3MgPSAwO1xuICAgIHZhciBzdGFydFgsIHN0YXJ0WSwgdGltZXI7IFxuICAgIHZhciBldmVudE5hbWVzID0ge1xuICAgICAgICAyOiBcImRibGNsaWNrXCIsXG4gICAgICAgIDM6IFwidHJpcGxlY2xpY2tcIixcbiAgICAgICAgNDogXCJxdWFkY2xpY2tcIlxuICAgIH07XG5cbiAgICBleHBvcnRzLmFkZExpc3RlbmVyKGVsLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChleHBvcnRzLmdldEJ1dHRvbihlKSAhPT0gMCkge1xuICAgICAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRldGFpbCA+IDEpIHtcbiAgICAgICAgICAgIGNsaWNrcysrO1xuICAgICAgICAgICAgaWYgKGNsaWNrcyA+IDQpXG4gICAgICAgICAgICAgICAgY2xpY2tzID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsaWNrcyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0lFKSB7XG4gICAgICAgICAgICB2YXIgaXNOZXdDbGljayA9IE1hdGguYWJzKGUuY2xpZW50WCAtIHN0YXJ0WCkgPiA1IHx8IE1hdGguYWJzKGUuY2xpZW50WSAtIHN0YXJ0WSkgPiA1O1xuICAgICAgICAgICAgaWYgKCF0aW1lciB8fCBpc05ld0NsaWNrKVxuICAgICAgICAgICAgICAgIGNsaWNrcyA9IDE7XG4gICAgICAgICAgICBpZiAodGltZXIpXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHt0aW1lciA9IG51bGx9LCB0aW1lb3V0c1tjbGlja3MgLSAxXSB8fCA2MDApO1xuXG4gICAgICAgICAgICBpZiAoY2xpY2tzID09IDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydFggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBlLl9jbGlja3MgPSBjbGlja3M7XG5cbiAgICAgICAgZXZlbnRIYW5kbGVyW2NhbGxiYWNrTmFtZV0oXCJtb3VzZWRvd25cIiwgZSk7XG5cbiAgICAgICAgaWYgKGNsaWNrcyA+IDQpXG4gICAgICAgICAgICBjbGlja3MgPSAwO1xuICAgICAgICBlbHNlIGlmIChjbGlja3MgPiAxKVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlcltjYWxsYmFja05hbWVdKGV2ZW50TmFtZXNbY2xpY2tzXSwgZSk7XG4gICAgfSk7XG5cbiAgICBpZiAodXNlcmFnZW50LmlzT2xkSUUpIHtcbiAgICAgICAgZXhwb3J0cy5hZGRMaXN0ZW5lcihlbCwgXCJkYmxjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjbGlja3MgPSAyO1xuICAgICAgICAgICAgaWYgKHRpbWVyKVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7dGltZXIgPSBudWxsfSwgdGltZW91dHNbY2xpY2tzIC0gMV0gfHwgNjAwKTtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcltjYWxsYmFja05hbWVdKFwibW91c2Vkb3duXCIsIGUpO1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVyW2NhbGxiYWNrTmFtZV0oZXZlbnROYW1lc1tjbGlja3NdLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxudmFyIGdldE1vZGlmaWVySGFzaCA9IHVzZXJhZ2VudC5pc01hYyAmJiB1c2VyYWdlbnQuaXNPcGVyYSAmJiAhKFwiS2V5Ym9hcmRFdmVudFwiIGluIHdpbmRvdylcbiAgICA/IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIDAgfCAoZS5tZXRhS2V5ID8gMSA6IDApIHwgKGUuYWx0S2V5ID8gMiA6IDApIHwgKGUuc2hpZnRLZXkgPyA0IDogMCkgfCAoZS5jdHJsS2V5ID8gOCA6IDApO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIDAgfCAoZS5jdHJsS2V5ID8gMSA6IDApIHwgKGUuYWx0S2V5ID8gMiA6IDApIHwgKGUuc2hpZnRLZXkgPyA0IDogMCkgfCAoZS5tZXRhS2V5ID8gOCA6IDApO1xuICAgIH07XG5cbmV4cG9ydHMuZ2V0TW9kaWZpZXJTdHJpbmcgPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGtleXMuS0VZX01PRFNbZ2V0TW9kaWZpZXJIYXNoKGUpXTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbW1hbmRLZXlzKGNhbGxiYWNrLCBlLCBrZXlDb2RlKSB7XG4gICAgdmFyIGhhc2hJZCA9IGdldE1vZGlmaWVySGFzaChlKTtcblxuICAgIGlmICghdXNlcmFnZW50LmlzTWFjICYmIHByZXNzZWRLZXlzKSB7XG4gICAgICAgIGlmIChwcmVzc2VkS2V5c1s5MV0gfHwgcHJlc3NlZEtleXNbOTJdKVxuICAgICAgICAgICAgaGFzaElkIHw9IDg7XG4gICAgICAgIGlmIChwcmVzc2VkS2V5cy5hbHRHcikge1xuICAgICAgICAgICAgaWYgKCgzICYgaGFzaElkKSAhPSAzKVxuICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmFsdEdyID0gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IDE4IHx8IGtleUNvZGUgPT09IDE3KSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBcImxvY2F0aW9uXCIgaW4gZSA/IGUubG9jYXRpb24gOiBlLmtleUxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IDE3ICYmIGxvY2F0aW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXNzZWRLZXlzW2tleUNvZGVdID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHRzID0gZS50aW1lU3RhbXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IDE4ICYmIGhhc2hJZCA9PT0gMyAmJiBsb2NhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGUudGltZXN0YW1wIC0gdHM7XG4gICAgICAgICAgICAgICAgaWYgKGR0IDwgNTApXG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmFsdEdyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoa2V5Q29kZSBpbiBrZXlzLk1PRElGSUVSX0tFWVMpIHtcbiAgICAgICAga2V5Q29kZSA9IC0xO1xuICAgIH1cblxuICAgIGlmIChoYXNoSWQgJiA4ICYmIChrZXlDb2RlID09PSA5MSB8fCBrZXlDb2RlID09PSA5MykpIHtcbiAgICAgICAga2V5Q29kZSA9IC0xO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWhhc2hJZCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBcImxvY2F0aW9uXCIgaW4gZSA/IGUubG9jYXRpb24gOiBlLmtleUxvY2F0aW9uO1xuICAgICAgICBpZiAobG9jYXRpb24gPT09IDMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGUsIGhhc2hJZCwgLWtleUNvZGUpO1xuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHVzZXJhZ2VudC5pc0Nocm9tZU9TICYmIGhhc2hJZCAmIDgpIHtcbiAgICAgICAgY2FsbGJhY2soZSwgaGFzaElkLCBrZXlDb2RlKTtcbiAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGFzaElkICY9IH44O1xuICAgIH1cbiAgICBpZiAoIWhhc2hJZCAmJiAhKGtleUNvZGUgaW4ga2V5cy5GVU5DVElPTl9LRVlTKSAmJiAhKGtleUNvZGUgaW4ga2V5cy5QUklOVEFCTEVfS0VZUykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY2FsbGJhY2soZSwgaGFzaElkLCBrZXlDb2RlKTtcbn1cblxudmFyIHByZXNzZWRLZXlzID0gbnVsbDtcbnZhciB0cyA9IDA7XG5leHBvcnRzLmFkZENvbW1hbmRLZXlMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsLCBjYWxsYmFjaykge1xuICAgIHZhciBhZGRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkTGlzdGVuZXI7XG4gICAgaWYgKHVzZXJhZ2VudC5pc09sZEdlY2tvIHx8ICh1c2VyYWdlbnQuaXNPcGVyYSAmJiAhKFwiS2V5Ym9hcmRFdmVudFwiIGluIHdpbmRvdykpKSB7XG4gICAgICAgIHZhciBsYXN0S2V5RG93bktleUNvZGUgPSBudWxsO1xuICAgICAgICBhZGRMaXN0ZW5lcihlbCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGxhc3RLZXlEb3duS2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsLCBcImtleXByZXNzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVDb21tYW5kS2V5cyhjYWxsYmFjaywgZSwgbGFzdEtleURvd25LZXlDb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxhc3REZWZhdWx0UHJldmVudGVkID0gbnVsbDtcblxuICAgICAgICBhZGRMaXN0ZW5lcihlbCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHByZXNzZWRLZXlzW2Uua2V5Q29kZV0gPSAocHJlc3NlZEtleXNbZS5rZXlDb2RlXSB8fCAwKSArIDE7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbm9ybWFsaXplQ29tbWFuZEtleXMoY2FsbGJhY2ssIGUsIGUua2V5Q29kZSk7XG4gICAgICAgICAgICBsYXN0RGVmYXVsdFByZXZlbnRlZCA9IGUuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFkZExpc3RlbmVyKGVsLCBcImtleXByZXNzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0RGVmYXVsdFByZXZlbnRlZCAmJiAoZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuc3RvcEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0UHJldmVudGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZWwsIFwia2V5dXBcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcHJlc3NlZEtleXNbZS5rZXlDb2RlXSA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcHJlc3NlZEtleXMpIHtcbiAgICAgICAgICAgIHByZXNzZWRLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKHdpbmRvdywgXCJmb2N1c1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5pZiAod2luZG93LnBvc3RNZXNzYWdlICYmICF1c2VyYWdlbnQuaXNPbGRJRSkge1xuICAgIHZhciBwb3N0TWVzc2FnZUlkID0gMTtcbiAgICBleHBvcnRzLm5leHRUaWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIHdpbikge1xuICAgICAgICB3aW4gPSB3aW4gfHwgd2luZG93O1xuICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSBcInplcm8tdGltZW91dC1tZXNzYWdlLVwiICsgcG9zdE1lc3NhZ2VJZDtcbiAgICAgICAgZXhwb3J0cy5hZGRMaXN0ZW5lcih3aW4sIFwibWVzc2FnZVwiLCBmdW5jdGlvbiBsaXN0ZW5lcihlKSB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhID09IG1lc3NhZ2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5zdG9wUHJvcGFnYXRpb24oZSk7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5yZW1vdmVMaXN0ZW5lcih3aW4sIFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbi5wb3N0TWVzc2FnZShtZXNzYWdlTmFtZSwgXCIqXCIpO1xuICAgIH07XG59XG5cblxuZXhwb3J0cy5uZXh0RnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuaWYgKGV4cG9ydHMubmV4dEZyYW1lKVxuICAgIGV4cG9ydHMubmV4dEZyYW1lID0gZXhwb3J0cy5uZXh0RnJhbWUuYmluZCh3aW5kb3cpO1xuZWxzZVxuICAgIGV4cG9ydHMubmV4dEZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTcpO1xuICAgIH07XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvbGFuZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYVthLmxlbmd0aCAtIDFdO1xufTtcblxuZXhwb3J0cy5zdHJpbmdSZXZlcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbn07XG5cbmV4cG9ydHMuc3RyaW5nUmVwZWF0ID0gZnVuY3Rpb24gKHN0cmluZywgY291bnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICBpZiAoY291bnQgJiAxKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcblxuICAgICAgICBpZiAoY291bnQgPj49IDEpXG4gICAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHRyaW1CZWdpblJlZ2V4cCA9IC9eXFxzXFxzKi87XG52YXIgdHJpbUVuZFJlZ2V4cCA9IC9cXHNcXHMqJC87XG5cbmV4cG9ydHMuc3RyaW5nVHJpbUxlZnQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgJycpO1xufTtcblxuZXhwb3J0cy5zdHJpbmdUcmltUmlnaHQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbn07XG5cbmV4cG9ydHMuY29weU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG5leHBvcnRzLmNvcHlBcnJheSA9IGZ1bmN0aW9uKGFycmF5KXtcbiAgICB2YXIgY29weSA9IFtdO1xuICAgIGZvciAodmFyIGk9MCwgbD1hcnJheS5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSAmJiB0eXBlb2YgYXJyYXlbaV0gPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIGNvcHlbaV0gPSB0aGlzLmNvcHlPYmplY3QoIGFycmF5W2ldICk7XG4gICAgICAgIGVsc2UgXG4gICAgICAgICAgICBjb3B5W2ldID0gYXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufTtcblxuZXhwb3J0cy5kZWVwQ29weSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIHZhciBjb25zID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIGlmIChjb25zID09PSBSZWdFeHApXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgXG4gICAgdmFyIGNvcHkgPSBjb25zKCk7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBleHBvcnRzLmRlZXBDb3B5KG9ialtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufTtcblxuZXhwb3J0cy5hcnJheVRvTWFwID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwW2FycltpXV0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuXG59O1xuXG5leHBvcnRzLmNyZWF0ZU1hcCA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yICh2YXIgaSBpbiBwcm9wcykge1xuICAgICAgICBtYXBbaV0gPSBwcm9wc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn07XG5leHBvcnRzLmFycmF5UmVtb3ZlID0gZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHZhbHVlID09PSBhcnJheVtpXSkge1xuICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5lc2NhcGVSZWdFeHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLiorP14ke30oKXxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKTtcbn07XG5cbmV4cG9ydHMuZXNjYXBlSFRNTCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCBcIiYjMzg7XCIpLnJlcGxhY2UoL1wiL2csIFwiJiMzNDtcIikucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpLnJlcGxhY2UoLzwvZywgXCImIzYwO1wiKTtcbn07XG5cbmV4cG9ydHMuZ2V0TWF0Y2hPZmZzZXRzID0gZnVuY3Rpb24oc3RyaW5nLCByZWdFeHApIHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgc3RyaW5nLnJlcGxhY2UocmVnRXhwLCBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIG9mZnNldDogYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMl0sXG4gICAgICAgICAgICBsZW5ndGg6IHN0ci5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbn07XG5leHBvcnRzLmRlZmVycmVkQ2FsbCA9IGZ1bmN0aW9uKGZjbikge1xuICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgZmNuKCk7XG4gICAgfTtcblxuICAgIHZhciBkZWZlcnJlZCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgICAgICAgZGVmZXJyZWQuY2FuY2VsKCk7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCB8fCAwKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5zY2hlZHVsZSA9IGRlZmVycmVkO1xuXG4gICAgZGVmZXJyZWQuY2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICBmY24oKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgfTtcbiAgICBcbiAgICBkZWZlcnJlZC5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59O1xuXG5cbmV4cG9ydHMuZGVsYXllZENhbGwgPSBmdW5jdGlvbihmY24sIGRlZmF1bHRUaW1lb3V0KSB7XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBmY24oKTtcbiAgICB9O1xuXG4gICAgdmFyIF9zZWxmID0gZnVuY3Rpb24odGltZW91dCkge1xuICAgICAgICBpZiAodGltZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgdGltZW91dCB8fCBkZWZhdWx0VGltZW91dCk7XG4gICAgfTtcblxuICAgIF9zZWxmLmRlbGF5ID0gZnVuY3Rpb24odGltZW91dCkge1xuICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQgfHwgZGVmYXVsdFRpbWVvdXQpO1xuICAgIH07XG4gICAgX3NlbGYuc2NoZWR1bGUgPSBfc2VsZjtcblxuICAgIF9zZWxmLmNhbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgZmNuKCk7XG4gICAgfTtcblxuICAgIF9zZWxmLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgfTtcblxuICAgIF9zZWxmLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgfTtcblxuICAgIHJldHVybiBfc2VsZjtcbn07XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9rZXlib2FyZC90ZXh0aW5wdXRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9sYW5nXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGV2ZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvZXZlbnRcIik7XG52YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIGRvbSA9IGFjZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBsYW5nID0gYWNlcXVpcmUoXCIuLi9saWIvbGFuZ1wiKTtcbnZhciBCUk9LRU5fU0VUREFUQSA9IHVzZXJhZ2VudC5pc0Nocm9tZSA8IDE4O1xudmFyIFVTRV9JRV9NSU1FX1RZUEUgPSAgdXNlcmFnZW50LmlzSUU7XG5cbnZhciBUZXh0SW5wdXQgPSBmdW5jdGlvbihwYXJlbnROb2RlLCBob3N0KSB7XG4gICAgdmFyIHRleHQgPSBkb20uY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgIHRleHQuY2xhc3NOYW1lID0gXCJhY2VfdGV4dC1pbnB1dFwiO1xuXG4gICAgaWYgKHVzZXJhZ2VudC5pc1RvdWNoUGFkKVxuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZShcIngtcGFsbS1kaXNhYmxlLWF1dG8tY2FwXCIsIHRydWUpO1xuXG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsIFwib2ZmXCIpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIiwgXCJvZmZcIik7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLCBcIm9mZlwiKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIiwgZmFsc2UpO1xuXG4gICAgdGV4dC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgaWYgKHVzZXJhZ2VudC5pc09sZElFKSB0ZXh0LnN0eWxlLnRvcCA9IFwiLTEwMDBweFwiO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHQsIHBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG5cbiAgICB2YXIgUExBQ0VIT0xERVIgPSBcIlxceDAxXFx4MDFcIjtcblxuICAgIHZhciBjb3BpZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFzdGVkID0gZmFsc2U7XG4gICAgdmFyIGluQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICB2YXIgdGVtcFN0eWxlID0gJyc7XG4gICAgdmFyIGlzU2VsZWN0aW9uRW1wdHkgPSB0cnVlO1xuICAgIHRyeSB7IHZhciBpc0ZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0ZXh0OyB9IGNhdGNoKGUpIHt9XG4gICAgXG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJibHVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaG9zdC5vbkJsdXIoZSk7XG4gICAgICAgIGlzRm9jdXNlZCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiZm9jdXNcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBob3N0Lm9uRm9jdXMoZSk7XG4gICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgfSk7XG4gICAgdGhpcy5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGVtcFN0eWxlKSByZXR1cm4gdGV4dC5mb2N1cygpO1xuICAgICAgICB0ZXh0LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgICB0ZXh0LnN0eWxlLnRvcCA9IFwiLTEwMDBweFwiO1xuICAgICAgICB0ZXh0LmZvY3VzKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0ZXh0LnN0eWxlLnBvc2l0aW9uID0gXCJcIjtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLmJsdXIgPSBmdW5jdGlvbigpIHsgdGV4dC5ibHVyKCk7IH07XG4gICAgdGhpcy5pc0ZvY3VzZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzRm9jdXNlZDtcbiAgICB9O1xuICAgIHZhciBzeW5jU2VsZWN0aW9uID0gbGFuZy5kZWxheWVkQ2FsbChmdW5jdGlvbigpIHtcbiAgICAgICAgaXNGb2N1c2VkICYmIHJlc2V0U2VsZWN0aW9uKGlzU2VsZWN0aW9uRW1wdHkpO1xuICAgIH0pO1xuICAgIHZhciBzeW5jVmFsdWUgPSBsYW5nLmRlbGF5ZWRDYWxsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgaWYgKCFpbkNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0ZXh0LnZhbHVlID0gUExBQ0VIT0xERVI7XG4gICAgICAgICAgICBpc0ZvY3VzZWQgJiYgcmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlc2V0U2VsZWN0aW9uKGlzRW1wdHkpIHtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluQ29tcG9zaXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGlmIChpbnB1dEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHNlbGVjdGlvbkVuZCA9IGlzRW1wdHkgPyAwIDogdGV4dC52YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gaXNFbXB0eSA/IDIgOiAxO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRleHQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgIH0gY2F0Y2goZSl7fVxuXG4gICAgICAgIGluQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFZhbHVlKCkge1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGV4dC52YWx1ZSA9IFBMQUNFSE9MREVSO1xuICAgICAgICBpZiAodXNlcmFnZW50LmlzV2ViS2l0KVxuICAgICAgICAgICAgc3luY1ZhbHVlLnNjaGVkdWxlKCk7XG4gICAgfVxuXG4gICAgdXNlcmFnZW50LmlzV2ViS2l0IHx8IGhvc3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlU2VsZWN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChob3N0LnNlbGVjdGlvbi5pc0VtcHR5KCkgIT0gaXNTZWxlY3Rpb25FbXB0eSkge1xuICAgICAgICAgICAgaXNTZWxlY3Rpb25FbXB0eSA9ICFpc1NlbGVjdGlvbkVtcHR5O1xuICAgICAgICAgICAgc3luY1NlbGVjdGlvbi5zY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXNldFZhbHVlKCk7XG4gICAgaWYgKGlzRm9jdXNlZClcbiAgICAgICAgaG9zdC5vbkZvY3VzKCk7XG5cblxuICAgIHZhciBpc0FsbFNlbGVjdGVkID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0ZXh0LnNlbGVjdGlvbkVuZCA9PT0gdGV4dC52YWx1ZS5sZW5ndGg7XG4gICAgfTtcbiAgICBpZiAoIXRleHQuc2V0U2VsZWN0aW9uUmFuZ2UgJiYgdGV4dC5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgdGV4dC5zZXRTZWxlY3Rpb25SYW5nZSA9IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICBpc0FsbFNlbGVjdGVkID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0ZXh0Lm93bmVyRG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICB9Y2F0Y2goZSkge31cbiAgICAgICAgICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UucGFyZW50RWxlbWVudCgpICE9IHRleHQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UudGV4dCA9PSB0ZXh0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VyYWdlbnQuaXNPbGRJRSkge1xuICAgICAgICB2YXIgaW5Qcm9wZXJ0eUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB2YXIgb25Qcm9wZXJ0eUNoYW5nZSA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgaWYgKGluUHJvcGVydHlDaGFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0ZXh0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKGluQ29tcG9zaXRpb24gfHwgIWRhdGEgfHwgZGF0YSA9PSBQTEFDRUhPTERFUilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoZSAmJiBkYXRhID09IFBMQUNFSE9MREVSWzBdKVxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUHJvcGVydHkuc2NoZWR1bGUoKTtcblxuICAgICAgICAgICAgc2VuZFRleHQoZGF0YSk7XG4gICAgICAgICAgICBpblByb3BlcnR5Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGluUHJvcGVydHlDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN5bmNQcm9wZXJ0eSA9IGxhbmcuZGVsYXllZENhbGwob25Qcm9wZXJ0eUNoYW5nZSk7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwicHJvcGVydHljaGFuZ2VcIiwgb25Qcm9wZXJ0eUNoYW5nZSk7XG5cbiAgICAgICAgdmFyIGtleXRhYmxlID0geyAxMzoxLCAyNzoxIH07XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwia2V5dXBcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uICYmICghdGV4dC52YWx1ZSB8fCBrZXl0YWJsZVtlLmtleUNvZGVdKSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG9uQ29tcG9zaXRpb25FbmQsIDApO1xuICAgICAgICAgICAgaWYgKCh0ZXh0LnZhbHVlLmNoYXJDb2RlQXQoMCl8fDApIDwgMTI5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQcm9wZXJ0eS5jYWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbkNvbXBvc2l0aW9uID8gb25Db21wb3NpdGlvblVwZGF0ZSgpIDogb25Db21wb3NpdGlvblN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHN5bmNQcm9wZXJ0eS5zY2hlZHVsZSg1MCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBvblNlbGVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGNvcGllZCkge1xuICAgICAgICAgICAgY29waWVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbGxTZWxlY3RlZCh0ZXh0KSkge1xuICAgICAgICAgICAgaG9zdC5zZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXNldFNlbGVjdGlvbihob3N0LnNlbGVjdGlvbi5pc0VtcHR5KCkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpbnB1dEhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMuc2V0SW5wdXRIYW5kbGVyID0gZnVuY3Rpb24oY2IpIHtpbnB1dEhhbmRsZXIgPSBjYn07XG4gICAgdGhpcy5nZXRJbnB1dEhhbmRsZXIgPSBmdW5jdGlvbigpIHtyZXR1cm4gaW5wdXRIYW5kbGVyfTtcbiAgICB2YXIgYWZ0ZXJDb250ZXh0TWVudSA9IGZhbHNlO1xuICAgIFxuICAgIHZhciBzZW5kVGV4dCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGlucHV0SGFuZGxlcikge1xuICAgICAgICAgICAgZGF0YSA9IGlucHV0SGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIGlucHV0SGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhc3RlZCkge1xuICAgICAgICAgICAgcmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIGhvc3Qub25QYXN0ZShkYXRhKTtcbiAgICAgICAgICAgIHBhc3RlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gUExBQ0VIT0xERVIuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJDb250ZXh0TWVudSlcbiAgICAgICAgICAgICAgICBob3N0LmV4ZWNDb21tYW5kKFwiZGVsXCIsIHtzb3VyY2U6IFwiYWNlXCJ9KTtcbiAgICAgICAgICAgIGVsc2UgLy8gc29tZSB2ZXJzaW9ucyBvZiBhbmRyb2lkIGRvIG5vdCBmaXJlIGtleWRvd24gd2hlbiBwcmVzc2luZyBiYWNrc3BhY2VcbiAgICAgICAgICAgICAgICBob3N0LmV4ZWNDb21tYW5kKFwiYmFja3NwYWNlXCIsIHtzb3VyY2U6IFwiYWNlXCJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnN1YnN0cmluZygwLCAyKSA9PSBQTEFDRUhPTERFUilcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zdWJzdHIoMik7XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLmNoYXJBdCgwKSA9PSBQTEFDRUhPTERFUi5jaGFyQXQoMCkpXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3Vic3RyKDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5jaGFyQXQoZGF0YS5sZW5ndGggLSAxKSA9PSBQTEFDRUhPTERFUi5jaGFyQXQoMCkpXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgaWYgKGRhdGEuY2hhckF0KGRhdGEubGVuZ3RoIC0gMSkgPT0gUExBQ0VIT0xERVIuY2hhckF0KDApKVxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgaG9zdC5vblRleHRJbnB1dChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXJDb250ZXh0TWVudSlcbiAgICAgICAgICAgIGFmdGVyQ29udGV4dE1lbnUgPSBmYWxzZTtcbiAgICB9O1xuICAgIHZhciBvbklucHV0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGRhdGEgPSB0ZXh0LnZhbHVlO1xuICAgICAgICBzZW5kVGV4dChkYXRhKTtcbiAgICAgICAgcmVzZXRWYWx1ZSgpO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGhhbmRsZUNsaXBib2FyZERhdGEgPSBmdW5jdGlvbihlLCBkYXRhKSB7XG4gICAgICAgIHZhciBjbGlwYm9hcmREYXRhID0gZS5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgICAgICBpZiAoIWNsaXBib2FyZERhdGEgfHwgQlJPS0VOX1NFVERBVEEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBtaW1lID0gVVNFX0lFX01JTUVfVFlQRSA/IFwiVGV4dFwiIDogXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpcGJvYXJkRGF0YS5zZXREYXRhKG1pbWUsIGRhdGEpICE9PSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGlwYm9hcmREYXRhLmdldERhdGEobWltZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRvQ29weSA9IGZ1bmN0aW9uKGUsIGlzQ3V0KSB7XG4gICAgICAgIHZhciBkYXRhID0gaG9zdC5nZXRDb3B5VGV4dCgpO1xuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgICAgaWYgKGhhbmRsZUNsaXBib2FyZERhdGEoZSwgZGF0YSkpIHtcbiAgICAgICAgICAgIGlzQ3V0ID8gaG9zdC5vbkN1dCgpIDogaG9zdC5vbkNvcHkoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29waWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRleHQudmFsdWUgPSBkYXRhO1xuICAgICAgICAgICAgdGV4dC5zZWxlY3QoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb3BpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXNldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgcmVzZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpc0N1dCA/IGhvc3Qub25DdXQoKSA6IGhvc3Qub25Db3B5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIG9uQ3V0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBkb0NvcHkoZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgb25Db3B5ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBkb0NvcHkoZSwgZmFsc2UpO1xuICAgIH07XG4gICAgXG4gICAgdmFyIG9uUGFzdGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gaGFuZGxlQ2xpcGJvYXJkRGF0YShlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIGhvc3Qub25QYXN0ZShkYXRhKTtcbiAgICAgICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc2V0U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBwYXN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50LmFkZENvbW1hbmRLZXlMaXN0ZW5lcih0ZXh0LCBob3N0Lm9uQ29tbWFuZEtleS5iaW5kKGhvc3QpKTtcblxuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwic2VsZWN0XCIsIG9uU2VsZWN0KTtcblxuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiaW5wdXRcIiwgb25JbnB1dCk7XG5cbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImN1dFwiLCBvbkN1dCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJjb3B5XCIsIG9uQ29weSk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXCJwYXN0ZVwiLCBvblBhc3RlKTtcbiAgICBpZiAoISgnb25jdXQnIGluIHRleHQpIHx8ICEoJ29uY29weScgaW4gdGV4dCkgfHwgISgnb25wYXN0ZScgaW4gdGV4dCkpe1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihwYXJlbnROb2RlLCBcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCh1c2VyYWdlbnQuaXNNYWMgJiYgIWUubWV0YUtleSkgfHwgIWUuY3RybEtleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgICAgICAgICAgb25Db3B5KGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg2OlxuICAgICAgICAgICAgICAgICAgICBvblBhc3RlKGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgICAgICBvbkN1dChlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgb25Db21wb3NpdGlvblN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbiB8fCAhaG9zdC5vbkNvbXBvc2l0aW9uU3RhcnQgfHwgaG9zdC4kcmVhZE9ubHkpIFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpbkNvbXBvc2l0aW9uID0ge307XG4gICAgICAgIGhvc3Qub25Db21wb3NpdGlvblN0YXJ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob25Db21wb3NpdGlvblVwZGF0ZSwgMCk7XG4gICAgICAgIGhvc3Qub24oXCJtb3VzZWRvd25cIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmICghaG9zdC5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBob3N0Lmluc2VydChcIlwiKTtcbiAgICAgICAgICAgIGhvc3Quc2Vzc2lvbi5tYXJrVW5kb0dyb3VwKCk7XG4gICAgICAgICAgICBob3N0LnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3Quc2Vzc2lvbi5tYXJrVW5kb0dyb3VwKCk7XG4gICAgfTtcblxuICAgIHZhciBvbkNvbXBvc2l0aW9uVXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghaW5Db21wb3NpdGlvbiB8fCAhaG9zdC5vbkNvbXBvc2l0aW9uVXBkYXRlIHx8IGhvc3QuJHJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdmFsID0gdGV4dC52YWx1ZS5yZXBsYWNlKC9cXHgwMS9nLCBcIlwiKTtcbiAgICAgICAgaWYgKGluQ29tcG9zaXRpb24ubGFzdFZhbHVlID09PSB2YWwpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGhvc3Qub25Db21wb3NpdGlvblVwZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoaW5Db21wb3NpdGlvbi5sYXN0VmFsdWUpXG4gICAgICAgICAgICBob3N0LnVuZG8oKTtcbiAgICAgICAgaW5Db21wb3NpdGlvbi5sYXN0VmFsdWUgPSB2YWw7XG4gICAgICAgIGlmIChpbkNvbXBvc2l0aW9uLmxhc3RWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBob3N0LnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgaG9zdC5pbnNlcnQoaW5Db21wb3NpdGlvbi5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgaG9zdC5zZXNzaW9uLm1hcmtVbmRvR3JvdXAoKTtcbiAgICAgICAgICAgIGluQ29tcG9zaXRpb24ucmFuZ2UgPSBob3N0LnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgaG9zdC5zZWxlY3Rpb24uc2V0UmFuZ2Uocik7XG4gICAgICAgICAgICBob3N0LnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbkNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWhvc3Qub25Db21wb3NpdGlvbkVuZCB8fCBob3N0LiRyZWFkT25seSkgcmV0dXJuO1xuICAgICAgICB2YXIgYyA9IGluQ29tcG9zaXRpb247XG4gICAgICAgIGluQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBzdHIgPSB0ZXh0LnZhbHVlLnJlcGxhY2UoL1xceDAxL2csIFwiXCIpO1xuICAgICAgICAgICAgaWYgKGluQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyID09IGMubGFzdFZhbHVlKVxuICAgICAgICAgICAgICAgIHJlc2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjLmxhc3RWYWx1ZSAmJiBzdHIpIHtcbiAgICAgICAgICAgICAgICByZXNldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgc2VuZFRleHQoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIGNvbXBvc2l0aW9uSW5wdXRIYW5kbGVyKHN0cikge1xuICAgICAgICAgICAgaWYgKHRpbWVyKVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx4MDEvZywgXCJcIik7XG4gICAgICAgICAgICBpZiAoc3RyID09IGMubGFzdFZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgaWYgKGMubGFzdFZhbHVlICYmIHRpbWVyKVxuICAgICAgICAgICAgICAgIGhvc3QudW5kbygpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfTtcbiAgICAgICAgaG9zdC5vbkNvbXBvc2l0aW9uRW5kKCk7XG4gICAgICAgIGhvc3QucmVtb3ZlTGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjb21wb3NpdGlvbmVuZFwiICYmIGMucmFuZ2UpIHtcbiAgICAgICAgICAgIGhvc3Quc2VsZWN0aW9uLnNldFJhbmdlKGMucmFuZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBcblxuICAgIHZhciBzeW5jQ29tcG9zaXRpb24gPSBsYW5nLmRlbGF5ZWRDYWxsKG9uQ29tcG9zaXRpb25VcGRhdGUsIDUwKTtcblxuICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgIGlmICh1c2VyYWdlbnQuaXNHZWNrbykge1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcInRleHRcIiwgZnVuY3Rpb24oKXtzeW5jQ29tcG9zaXRpb24uc2NoZWR1bGUoKX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFwia2V5dXBcIiwgZnVuY3Rpb24oKXtzeW5jQ29tcG9zaXRpb24uc2NoZWR1bGUoKX0pO1xuICAgICAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImtleWRvd25cIiwgZnVuY3Rpb24oKXtzeW5jQ29tcG9zaXRpb24uc2NoZWR1bGUoKX0pO1xuICAgIH1cbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImNvbXBvc2l0aW9uZW5kXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICB0aGlzLnNldFJlYWRPbmx5ID0gZnVuY3Rpb24ocmVhZE9ubHkpIHtcbiAgICAgICB0ZXh0LnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgfTtcblxuICAgIHRoaXMub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgYWZ0ZXJDb250ZXh0TWVudSA9IHRydWU7XG4gICAgICAgIHJlc2V0U2VsZWN0aW9uKGhvc3Quc2VsZWN0aW9uLmlzRW1wdHkoKSk7XG4gICAgICAgIGhvc3QuX2VtaXQoXCJuYXRpdmVjb250ZXh0bWVudVwiLCB7dGFyZ2V0OiBob3N0LCBkb21FdmVudDogZX0pO1xuICAgICAgICB0aGlzLm1vdmVUb01vdXNlKGUsIHRydWUpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5tb3ZlVG9Nb3VzZSA9IGZ1bmN0aW9uKGUsIGJyaW5nVG9Gcm9udCkge1xuICAgICAgICBpZiAoIWJyaW5nVG9Gcm9udCAmJiB1c2VyYWdlbnQuaXNPbGRJRSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0ZW1wU3R5bGUpXG4gICAgICAgICAgICB0ZW1wU3R5bGUgPSB0ZXh0LnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIHRleHQuc3R5bGUuY3NzVGV4dCA9IChicmluZ1RvRnJvbnQgPyBcInotaW5kZXg6MTAwMDAwO1wiIDogXCJcIilcbiAgICAgICAgICAgICsgXCJoZWlnaHQ6XCIgKyB0ZXh0LnN0eWxlLmhlaWdodCArIFwiO1wiXG4gICAgICAgICAgICArICh1c2VyYWdlbnQuaXNJRSA/IFwib3BhY2l0eTowLjE7XCIgOiBcIlwiKTtcblxuICAgICAgICB2YXIgcmVjdCA9IGhvc3QuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgc3R5bGUgPSBkb20uY29tcHV0ZWRTdHlsZShob3N0LmNvbnRhaW5lcik7XG4gICAgICAgIHZhciB0b3AgPSByZWN0LnRvcCArIChwYXJzZUludChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMCk7XG4gICAgICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0ICsgKHBhcnNlSW50KHJlY3QuYm9yZGVyTGVmdFdpZHRoKSB8fCAwKTtcbiAgICAgICAgdmFyIG1heFRvcCA9IHJlY3QuYm90dG9tIC0gdG9wIC0gdGV4dC5jbGllbnRIZWlnaHQgLTI7XG4gICAgICAgIHZhciBtb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGV4dC5zdHlsZS5sZWZ0ID0gZS5jbGllbnRYIC0gbGVmdCAtIDIgKyBcInB4XCI7XG4gICAgICAgICAgICB0ZXh0LnN0eWxlLnRvcCA9IE1hdGgubWluKGUuY2xpZW50WSAtIHRvcCAtIDIsIG1heFRvcCkgKyBcInB4XCI7XG4gICAgICAgIH07IFxuICAgICAgICBtb3ZlKGUpO1xuXG4gICAgICAgIGlmIChlLnR5cGUgIT0gXCJtb3VzZWRvd25cIilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAoaG9zdC5yZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IpXG4gICAgICAgICAgICBob3N0LnJlbmRlcmVyLiRrZWVwVGV4dEFyZWFBdEN1cnNvciA9IG51bGw7XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNXaW4gJiYgIXVzZXJhZ2VudC5pc09sZElFKVxuICAgICAgICAgICAgZXZlbnQuY2FwdHVyZShob3N0LmNvbnRhaW5lciwgbW92ZSwgb25Db250ZXh0TWVudUNsb3NlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNvbnRleHRNZW51Q2xvc2UgPSBvbkNvbnRleHRNZW51Q2xvc2U7XG4gICAgdmFyIGNsb3NlVGltZW91dDtcbiAgICBmdW5jdGlvbiBvbkNvbnRleHRNZW51Q2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXQpXG4gICAgICAgIGNsb3NlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRlbXBTdHlsZSkge1xuICAgICAgICAgICAgICAgIHRleHQuc3R5bGUuY3NzVGV4dCA9IHRlbXBTdHlsZTtcbiAgICAgICAgICAgICAgICB0ZW1wU3R5bGUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob3N0LnJlbmRlcmVyLiRrZWVwVGV4dEFyZWFBdEN1cnNvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9zdC5yZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhvc3QucmVuZGVyZXIuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHVzZXJhZ2VudC5pc09sZElFID8gMjAwIDogMCk7XG4gICAgfVxuXG4gICAgdmFyIG9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGhvc3QudGV4dElucHV0Lm9uQ29udGV4dE1lbnUoZSk7XG4gICAgICAgIG9uQ29udGV4dE1lbnVDbG9zZSgpO1xuICAgIH07XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoaG9zdC5yZW5kZXJlci5zY3JvbGxlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xufTtcblxuZXhwb3J0cy5UZXh0SW5wdXQgPSBUZXh0SW5wdXQ7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9kZWZhdWx0X2hhbmRsZXJzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgZG9tID0gYWNlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIGV2ZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvZXZlbnRcIik7XG52YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xuXG52YXIgRFJBR19PRkZTRVQgPSAwOyAvLyBwaXhlbHNcblxuZnVuY3Rpb24gRGVmYXVsdEhhbmRsZXJzKG1vdXNlSGFuZGxlcikge1xuICAgIG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24gPSBudWxsO1xuXG4gICAgdmFyIGVkaXRvciA9IG1vdXNlSGFuZGxlci5lZGl0b3I7XG4gICAgZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZURvd24uYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICBlZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXCJkYmxjbGlja1wiLCB0aGlzLm9uRG91YmxlQ2xpY2suYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICBlZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXCJ0cmlwbGVjbGlja1wiLCB0aGlzLm9uVHJpcGxlQ2xpY2suYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICBlZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXCJxdWFkY2xpY2tcIiwgdGhpcy5vblF1YWRDbGljay5iaW5kKG1vdXNlSGFuZGxlcikpO1xuICAgIGVkaXRvci5zZXREZWZhdWx0SGFuZGxlcihcIm1vdXNld2hlZWxcIiwgdGhpcy5vbk1vdXNlV2hlZWwuYmluZChtb3VzZUhhbmRsZXIpKTtcblxuICAgIHZhciBleHBvcnRzID0gW1wic2VsZWN0XCIsIFwic3RhcnRTZWxlY3RcIiwgXCJzZWxlY3RFbmRcIiwgXCJzZWxlY3RBbGxFbmRcIiwgXCJzZWxlY3RCeVdvcmRzRW5kXCIsXG4gICAgICAgIFwic2VsZWN0QnlMaW5lc0VuZFwiLCBcImRyYWdXYWl0XCIsIFwiZHJhZ1dhaXRFbmRcIiwgXCJmb2N1c1dhaXRcIl07XG5cbiAgICBleHBvcnRzLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICBtb3VzZUhhbmRsZXJbeF0gPSB0aGlzW3hdO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgbW91c2VIYW5kbGVyLnNlbGVjdEJ5TGluZXMgPSB0aGlzLmV4dGVuZFNlbGVjdGlvbkJ5LmJpbmQobW91c2VIYW5kbGVyLCBcImdldExpbmVSYW5nZVwiKTtcbiAgICBtb3VzZUhhbmRsZXIuc2VsZWN0QnlXb3JkcyA9IHRoaXMuZXh0ZW5kU2VsZWN0aW9uQnkuYmluZChtb3VzZUhhbmRsZXIsIFwiZ2V0V29yZFJhbmdlXCIpO1xufVxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIGluU2VsZWN0aW9uID0gZXYuaW5TZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd25FdmVudCA9IGV2O1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG5cbiAgICAgICAgdmFyIGJ1dHRvbiA9IGV2LmdldEJ1dHRvbigpO1xuICAgICAgICBpZiAoYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbXB0eSA9IHNlbGVjdGlvblJhbmdlLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmcrKztcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25FbXB0eSlcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHBvcyk7XG4gICAgICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nLS07XG4gICAgICAgICAgICBlZGl0b3IudGV4dElucHV0Lm9uQ29udGV4dE1lbnUoZXYuZG9tRXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBzdG9wcGluZyBldmVudCBoZXJlIGJyZWFrcyBjb250ZXh0bWVudSBvbiBmZiBtYWNcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChpblNlbGVjdGlvbiAmJiAhZWRpdG9yLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRmb2N1c1RpbW91dCAmJiAhdGhpcy4kY2xpY2tTZWxlY3Rpb24gJiYgIWVkaXRvci5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXCJmb2N1c1dhaXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlTW91c2UoZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FwdHVyZU1vdXNlKGV2KTtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdChwb3MsIGV2LmRvbUV2ZW50Ll9jbGlja3MgPiAxKTtcbiAgICAgICAgcmV0dXJuIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnRTZWxlY3QgPSBmdW5jdGlvbihwb3MsIHdhaXRGb3JDbGlja1NlbGVjdGlvbikge1xuICAgICAgICBwb3MgPSBwb3MgfHwgdGhpcy5lZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmcrKztcbiAgICAgICAgaWYgKHRoaXMubW91c2Vkb3duRXZlbnQuZ2V0U2hpZnRLZXkoKSlcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0VG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICBlbHNlIGlmICghd2FpdEZvckNsaWNrU2VsZWN0aW9uKVxuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICBpZiAoIXdhaXRGb3JDbGlja1NlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgICAgIGlmIChlZGl0b3IucmVuZGVyZXIuc2Nyb2xsZXIuc2V0Q2FwdHVyZSkge1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLnNldENhcHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2V0U3R5bGUoXCJhY2Vfc2VsZWN0aW5nXCIpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwic2VsZWN0XCIpO1xuICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nLS07XG4gICAgfTtcblxuICAgIHRoaXMuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbmNob3IsIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLnJlbmRlcmVyLnNjcmVlblRvVGV4dENvb3JkaW5hdGVzKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZysrO1xuICAgICAgICBpZiAodGhpcy4kY2xpY2tTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjbXAgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5jb21wYXJlUG9pbnQoY3Vyc29yKTtcblxuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRoaXMuJGNsaWNrU2VsZWN0aW9uLmVuZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09IDEpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudGVkUmFuZ2UgPSBjYWxjUmFuZ2VPcmllbnRhdGlvbih0aGlzLiRjbGlja1NlbGVjdGlvbiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBvcmllbnRlZFJhbmdlLmN1cnNvcjtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBvcmllbnRlZFJhbmdlLmFuY2hvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uQW5jaG9yKGFuY2hvci5yb3csIGFuY2hvci5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0VG9Qb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nLS07XG4gICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgIH07XG5cbiAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbkJ5ID0gZnVuY3Rpb24odW5pdE5hbWUpIHtcbiAgICAgICAgdmFyIGFuY2hvciwgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uW3VuaXROYW1lXShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZysrO1xuICAgICAgICBpZiAodGhpcy4kY2xpY2tTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjbXBTdGFydCA9IHRoaXMuJGNsaWNrU2VsZWN0aW9uLmNvbXBhcmVQb2ludChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgY21wRW5kID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uY29tcGFyZVBvaW50KHJhbmdlLmVuZCk7XG5cbiAgICAgICAgICAgIGlmIChjbXBTdGFydCA9PSAtMSAmJiBjbXBFbmQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRoaXMuJGNsaWNrU2VsZWN0aW9uLmVuZDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kLnJvdyAhPSBjdXJzb3Iucm93IHx8IHJhbmdlLmVuZC5jb2x1bW4gIT0gY3Vyc29yLmNvbHVtbilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcEVuZCA9PSAxICYmIGNtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ICE9IGN1cnNvci5yb3cgfHwgcmFuZ2Uuc3RhcnQuY29sdW1uICE9IGN1cnNvci5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wU3RhcnQgPT0gLTEgJiYgY21wRW5kID09IDEpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvcmllbnRlZFJhbmdlID0gY2FsY1JhbmdlT3JpZW50YXRpb24odGhpcy4kY2xpY2tTZWxlY3Rpb24sIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gb3JpZW50ZWRSYW5nZS5jdXJzb3I7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gb3JpZW50ZWRSYW5nZS5hbmNob3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldFNlbGVjdGlvbkFuY2hvcihhbmNob3Iucm93LCBhbmNob3IuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFRvUG9zaXRpb24oY3Vyc29yKTtcbiAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZy0tO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZWxlY3RFbmQgPVxuICAgIHRoaXMuc2VsZWN0QWxsRW5kID1cbiAgICB0aGlzLnNlbGVjdEJ5V29yZHNFbmQgPVxuICAgIHRoaXMuc2VsZWN0QnlMaW5lc0VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRjbGlja1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZWRpdG9yLnVuc2V0U3R5bGUoXCJhY2Vfc2VsZWN0aW5nXCIpO1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IucmVuZGVyZXIuc2Nyb2xsZXIucmVsZWFzZUNhcHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLnJlbGVhc2VDYXB0dXJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5mb2N1c1dhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKHRoaXMubW91c2Vkb3duRXZlbnQueCwgdGhpcy5tb3VzZWRvd25FdmVudC55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAoZGlzdGFuY2UgPiBEUkFHX09GRlNFVCB8fCB0aW1lIC0gdGhpcy5tb3VzZWRvd25FdmVudC50aW1lID4gdGhpcy4kZm9jdXNUaW1vdXQpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0KHRoaXMubW91c2Vkb3duRXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuXG4gICAgICAgIHZhciByYW5nZSA9IHNlc3Npb24uZ2V0QnJhY2tldFJhbmdlKHBvcyk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbi0tO1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXCJzZWxlY3RcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0V29yZFJhbmdlKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShcInNlbGVjdEJ5V29yZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSByYW5nZTtcbiAgICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblRyaXBsZUNsaWNrID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJzZWxlY3RCeUxpbmVzXCIpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgcmFuZ2UuY29udGFpbnMocG9zLnJvdywgcG9zLmNvbHVtbikpIHtcbiAgICAgICAgICAgIHRoaXMuJGNsaWNrU2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRMaW5lUmFuZ2UocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgIHRoaXMuJGNsaWNrU2VsZWN0aW9uLmVuZCA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0TGluZVJhbmdlKHJhbmdlLmVuZC5yb3cpLmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGNsaWNrU2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRMaW5lUmFuZ2UocG9zLnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblF1YWRDbGljayA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcblxuICAgICAgICBlZGl0b3Iuc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuJGNsaWNrU2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJzZWxlY3RBbGxcIik7XG4gICAgfTtcblxuICAgIHRoaXMub25Nb3VzZVdoZWVsID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGV2LmdldEFjY2VsS2V5KCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChldi5nZXRTaGlmdEtleSgpICYmIGV2LndoZWVsWSAmJiAhZXYud2hlZWxYKSB7XG4gICAgICAgICAgICBldi53aGVlbFggPSBldi53aGVlbFk7XG4gICAgICAgICAgICBldi53aGVlbFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBldi5kb21FdmVudC50aW1lU3RhbXA7XG4gICAgICAgIHZhciBkdCA9IHQgLSAodGhpcy4kbGFzdFNjcm9sbFRpbWV8fDApO1xuICAgICAgICBcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgaXNTY3JvbGFibGUgPSBlZGl0b3IucmVuZGVyZXIuaXNTY3JvbGxhYmxlQnkoZXYud2hlZWxYICogZXYuc3BlZWQsIGV2LndoZWVsWSAqIGV2LnNwZWVkKTtcbiAgICAgICAgaWYgKGlzU2Nyb2xhYmxlIHx8IGR0IDwgMjAwKSB7XG4gICAgICAgICAgICB0aGlzLiRsYXN0U2Nyb2xsVGltZSA9IHQ7XG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQnkoZXYud2hlZWxYICogZXYuc3BlZWQsIGV2LndoZWVsWSAqIGV2LnNwZWVkKTtcbiAgICAgICAgICAgIHJldHVybiBldi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KS5jYWxsKERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUpO1xuXG5leHBvcnRzLkRlZmF1bHRIYW5kbGVycyA9IERlZmF1bHRIYW5kbGVycztcblxuZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKGF4LCBheSwgYngsIGJ5KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhieCAtIGF4LCAyKSArIE1hdGgucG93KGJ5IC0gYXksIDIpKTtcbn1cblxuZnVuY3Rpb24gY2FsY1JhbmdlT3JpZW50YXRpb24ocmFuZ2UsIGN1cnNvcikge1xuICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdylcbiAgICAgICAgdmFyIGNtcCA9IDIgKiBjdXJzb3IuY29sdW1uIC0gcmFuZ2Uuc3RhcnQuY29sdW1uIC0gcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICBlbHNlIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdyAtIDEgJiYgIXJhbmdlLnN0YXJ0LmNvbHVtbiAmJiAhcmFuZ2UuZW5kLmNvbHVtbilcbiAgICAgICAgdmFyIGNtcCA9IGN1cnNvci5jb2x1bW4gLSA0O1xuICAgIGVsc2VcbiAgICAgICAgdmFyIGNtcCA9IDIgKiBjdXJzb3Iucm93IC0gcmFuZ2Uuc3RhcnQucm93IC0gcmFuZ2UuZW5kLnJvdztcblxuICAgIGlmIChjbXAgPCAwKVxuICAgICAgICByZXR1cm4ge2N1cnNvcjogcmFuZ2Uuc3RhcnQsIGFuY2hvcjogcmFuZ2UuZW5kfTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB7Y3Vyc29yOiByYW5nZS5lbmQsIGFuY2hvcjogcmFuZ2Uuc3RhcnR9O1xufVxuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS90b29sdGlwXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9kb21cIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gYWNlcXVpcmUoXCIuL2xpYi9kb21cIik7XG5mdW5jdGlvbiBUb29sdGlwIChwYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICB0aGlzLiRlbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLiRwYXJlbnROb2RlID0gcGFyZW50Tm9kZTtcbn1cblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJGluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX3Rvb2x0aXBcIjtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuJHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy4kZWxlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50O1xuICAgIH07XG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50IHx8IHRoaXMuJGluaXQoKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgZG9tLnNldElubmVyVGV4dCh0aGlzLmdldEVsZW1lbnQoKSwgdGV4dCk7XG4gICAgfTtcbiAgICB0aGlzLnNldEh0bWwgPSBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfTtcbiAgICB0aGlzLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICB9O1xuICAgIHRoaXMuc2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmdldEVsZW1lbnQoKSwgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKHRleHQsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRleHQgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcbiAgICAgICAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHgsIHkpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoKS5vZmZzZXRIZWlnaHQ7XG4gICAgfTtcbiAgICB0aGlzLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoKS5vZmZzZXRXaWR0aDtcbiAgICB9O1xuXG59KS5jYWxsKFRvb2x0aXAucHJvdG90eXBlKTtcblxuZXhwb3J0cy5Ub29sdGlwID0gVG9vbHRpcDtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vdXNlL2RlZmF1bHRfZ3V0dGVyX2hhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL3Rvb2x0aXBcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xudmFyIGRvbSA9IGFjZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBvb3AgPSBhY2VxdWlyZShcIi4uL2xpYi9vb3BcIik7XG52YXIgZXZlbnQgPSBhY2VxdWlyZShcIi4uL2xpYi9ldmVudFwiKTtcbnZhciBUb29sdGlwID0gYWNlcXVpcmUoXCIuLi90b29sdGlwXCIpLlRvb2x0aXA7XG5cbmZ1bmN0aW9uIEd1dHRlckhhbmRsZXIobW91c2VIYW5kbGVyKSB7XG4gICAgdmFyIGVkaXRvciA9IG1vdXNlSGFuZGxlci5lZGl0b3I7XG4gICAgdmFyIGd1dHRlciA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXI7XG4gICAgdmFyIHRvb2x0aXAgPSBuZXcgR3V0dGVyVG9vbHRpcChlZGl0b3IuY29udGFpbmVyKTtcblxuICAgIG1vdXNlSGFuZGxlci5lZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXCJndXR0ZXJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWVkaXRvci5pc0ZvY3VzZWQoKSB8fCBlLmdldEJ1dHRvbigpICE9IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBndXR0ZXJSZWdpb24gPSBndXR0ZXIuZ2V0UmVnaW9uKGUpO1xuXG4gICAgICAgIGlmIChndXR0ZXJSZWdpb24gPT0gXCJmb2xkV2lkZ2V0c1wiKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciByb3cgPSBlLmdldERvY3VtZW50UG9zaXRpb24oKS5yb3c7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2Vzc2lvbi5zZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKGUuZ2V0U2hpZnRLZXkoKSlcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3RUbyhyb3csIDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlLmRvbUV2ZW50LmRldGFpbCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3VzZUhhbmRsZXIuJGNsaWNrU2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRMaW5lUmFuZ2Uocm93KTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZUhhbmRsZXIuc2V0U3RhdGUoXCJzZWxlY3RCeUxpbmVzXCIpO1xuICAgICAgICBtb3VzZUhhbmRsZXIuY2FwdHVyZU1vdXNlKGUpO1xuICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG5cbiAgICB2YXIgdG9vbHRpcFRpbWVvdXQsIG1vdXNlRXZlbnQsIHRvb2x0aXBBbm5vdGF0aW9uO1xuXG4gICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXAoKSB7XG4gICAgICAgIHZhciByb3cgPSBtb3VzZUV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKS5yb3c7XG4gICAgICAgIHZhciBhbm5vdGF0aW9uID0gZ3V0dGVyLiRhbm5vdGF0aW9uc1tyb3ddO1xuICAgICAgICBpZiAoIWFubm90YXRpb24pXG4gICAgICAgICAgICByZXR1cm4gaGlkZVRvb2x0aXAoKTtcblxuICAgICAgICB2YXIgbWF4Um93ID0gZWRpdG9yLnNlc3Npb24uZ2V0TGVuZ3RoKCk7XG4gICAgICAgIGlmIChyb3cgPT0gbWF4Um93KSB7XG4gICAgICAgICAgICB2YXIgc2NyZWVuUm93ID0gZWRpdG9yLnJlbmRlcmVyLnBpeGVsVG9TY3JlZW5Db29yZGluYXRlcygwLCBtb3VzZUV2ZW50LnkpLnJvdztcbiAgICAgICAgICAgIHZhciBwb3MgPSBtb3VzZUV2ZW50LiRwb3M7XG4gICAgICAgICAgICBpZiAoc2NyZWVuUm93ID4gZWRpdG9yLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhwb3Mucm93LCBwb3MuY29sdW1uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b29sdGlwQW5ub3RhdGlvbiA9PSBhbm5vdGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b29sdGlwQW5ub3RhdGlvbiA9IGFubm90YXRpb24udGV4dC5qb2luKFwiPGJyLz5cIik7XG5cbiAgICAgICAgdG9vbHRpcC5zZXRIdG1sKHRvb2x0aXBBbm5vdGF0aW9uKTtcbiAgICAgICAgdG9vbHRpcC5zaG93KCk7XG4gICAgICAgIGVkaXRvci5vbihcIm1vdXNld2hlZWxcIiwgaGlkZVRvb2x0aXApO1xuXG4gICAgICAgIGlmIChtb3VzZUhhbmRsZXIuJHRvb2x0aXBGb2xsb3dzTW91c2UpIHtcbiAgICAgICAgICAgIG1vdmVUb29sdGlwKG1vdXNlRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGd1dHRlckVsZW1lbnQgPSBndXR0ZXIuJGNlbGxzW2VkaXRvci5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Sb3cocm93LCAwKV0uZWxlbWVudDtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZ3V0dGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRvb2x0aXAuZ2V0RWxlbWVudCgpLnN0eWxlO1xuICAgICAgICAgICAgc3R5bGUubGVmdCA9IHJlY3QucmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICBzdHlsZS50b3AgPSByZWN0LmJvdHRvbSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwKCkge1xuICAgICAgICBpZiAodG9vbHRpcFRpbWVvdXQpXG4gICAgICAgICAgICB0b29sdGlwVGltZW91dCA9IGNsZWFyVGltZW91dCh0b29sdGlwVGltZW91dCk7XG4gICAgICAgIGlmICh0b29sdGlwQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgdG9vbHRpcC5oaWRlKCk7XG4gICAgICAgICAgICB0b29sdGlwQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBlZGl0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNld2hlZWxcIiwgaGlkZVRvb2x0aXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZVRvb2x0aXAoZSkge1xuICAgICAgICB0b29sdGlwLnNldFBvc2l0aW9uKGUueCwgZS55KTtcbiAgICB9XG5cbiAgICBtb3VzZUhhbmRsZXIuZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFwiZ3V0dGVybW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUuZG9tRXZlbnQudGFyZ2V0IHx8IGUuZG9tRXZlbnQuc3JjRWxlbWVudDtcbiAgICAgICAgaWYgKGRvbS5oYXNDc3NDbGFzcyh0YXJnZXQsIFwiYWNlX2ZvbGQtd2lkZ2V0XCIpKVxuICAgICAgICAgICAgcmV0dXJuIGhpZGVUb29sdGlwKCk7XG5cbiAgICAgICAgaWYgKHRvb2x0aXBBbm5vdGF0aW9uICYmIG1vdXNlSGFuZGxlci4kdG9vbHRpcEZvbGxvd3NNb3VzZSlcbiAgICAgICAgICAgIG1vdmVUb29sdGlwKGUpO1xuXG4gICAgICAgIG1vdXNlRXZlbnQgPSBlO1xuICAgICAgICBpZiAodG9vbHRpcFRpbWVvdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtb3VzZUV2ZW50ICYmICFtb3VzZUhhbmRsZXIuaXNNb3VzZVByZXNzZWQpXG4gICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcCgpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfSk7XG5cbiAgICBldmVudC5hZGRMaXN0ZW5lcihlZGl0b3IucmVuZGVyZXIuJGd1dHRlciwgXCJtb3VzZW91dFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIG1vdXNlRXZlbnQgPSBudWxsO1xuICAgICAgICBpZiAoIXRvb2x0aXBBbm5vdGF0aW9uIHx8IHRvb2x0aXBUaW1lb3V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9KTtcbiAgICBcbiAgICBlZGl0b3Iub24oXCJjaGFuZ2VTZXNzaW9uXCIsIGhpZGVUb29sdGlwKTtcbn1cblxuZnVuY3Rpb24gR3V0dGVyVG9vbHRpcChwYXJlbnROb2RlKSB7XG4gICAgVG9vbHRpcC5jYWxsKHRoaXMsIHBhcmVudE5vZGUpO1xufVxuXG5vb3AuaW5oZXJpdHMoR3V0dGVyVG9vbHRpcCwgVG9vbHRpcCk7XG5cbihmdW5jdGlvbigpe1xuICAgIHRoaXMuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICB4ICs9IDE1O1xuICAgICAgICB5ICs9IDE1O1xuICAgICAgICBpZiAoeCArIHdpZHRoID4gd2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgIHggLT0gKHggKyB3aWR0aCkgLSB3aW5kb3dXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSArIGhlaWdodCA+IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgeSAtPSAyMCArIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRQb3NpdGlvbi5jYWxsKHRoaXMsIHgsIHkpO1xuICAgIH07XG5cbn0pLmNhbGwoR3V0dGVyVG9vbHRpcC5wcm90b3R5cGUpO1xuXG5cblxuZXhwb3J0cy5HdXR0ZXJIYW5kbGVyID0gR3V0dGVySGFuZGxlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvbW91c2VfZXZlbnRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGV2ZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvZXZlbnRcIik7XG52YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIE1vdXNlRXZlbnQgPSBleHBvcnRzLk1vdXNlRXZlbnQgPSBmdW5jdGlvbihkb21FdmVudCwgZWRpdG9yKSB7XG4gICAgdGhpcy5kb21FdmVudCA9IGRvbUV2ZW50O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIFxuICAgIHRoaXMueCA9IHRoaXMuY2xpZW50WCA9IGRvbUV2ZW50LmNsaWVudFg7XG4gICAgdGhpcy55ID0gdGhpcy5jbGllbnRZID0gZG9tRXZlbnQuY2xpZW50WTtcblxuICAgIHRoaXMuJHBvcyA9IG51bGw7XG4gICAgdGhpcy4kaW5TZWxlY3Rpb24gPSBudWxsO1xuICAgIFxuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG59O1xuXG4oZnVuY3Rpb24oKSB7ICBcbiAgICBcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24odGhpcy5kb21FdmVudCk7XG4gICAgICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQodGhpcy5kb21FdmVudCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgdGhpcy5nZXREb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLiRwb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcG9zO1xuICAgICAgICBcbiAgICAgICAgdGhpcy4kcG9zID0gdGhpcy5lZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy5jbGllbnRYLCB0aGlzLmNsaWVudFkpO1xuICAgICAgICByZXR1cm4gdGhpcy4kcG9zO1xuICAgIH07XG4gICAgdGhpcy5pblNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy4kaW5TZWxlY3Rpb24gIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5TZWxlY3Rpb247XG4gICAgICAgICAgICBcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBcblxuICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvblJhbmdlLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHRoaXMuJGluU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy4kaW5TZWxlY3Rpb24gPSBzZWxlY3Rpb25SYW5nZS5jb250YWlucyhwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiRpblNlbGVjdGlvbjtcbiAgICB9O1xuICAgIHRoaXMuZ2V0QnV0dG9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBldmVudC5nZXRCdXR0b24odGhpcy5kb21FdmVudCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNoaWZ0S2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbUV2ZW50LnNoaWZ0S2V5O1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRBY2NlbEtleSA9IHVzZXJhZ2VudC5pc01hY1xuICAgICAgICA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FdmVudC5tZXRhS2V5OyB9XG4gICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRvbUV2ZW50LmN0cmxLZXk7IH07XG4gICAgXG59KS5jYWxsKE1vdXNlRXZlbnQucHJvdG90eXBlKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvZHJhZ2Ryb3BfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvdXNlcmFnZW50XCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGRvbSA9IGFjZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBldmVudCA9IGFjZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcblxudmFyIEFVVE9TQ1JPTExfREVMQVkgPSAyMDA7XG52YXIgU0NST0xMX0NVUlNPUl9ERUxBWSA9IDIwMDtcbnZhciBTQ1JPTExfQ1VSU09SX0hZU1RFUkVTSVMgPSA1O1xuXG5mdW5jdGlvbiBEcmFnZHJvcEhhbmRsZXIobW91c2VIYW5kbGVyKSB7XG5cbiAgICB2YXIgZWRpdG9yID0gbW91c2VIYW5kbGVyLmVkaXRvcjtcblxuICAgIHZhciBibGFua0ltYWdlID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgYmxhbmtJbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7XG4gICAgaWYgKHVzZXJhZ2VudC5pc09wZXJhKVxuICAgICAgICBibGFua0ltYWdlLnN0eWxlLmNzc1RleHQgPSBcIndpZHRoOjFweDtoZWlnaHQ6MXB4O3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDt6LWluZGV4OjIxNDc0ODM2NDc7b3BhY2l0eTowO1wiO1xuXG4gICAgdmFyIGV4cG9ydHMgPSBbXCJkcmFnV2FpdFwiLCBcImRyYWdXYWl0RW5kXCIsIFwic3RhcnREcmFnXCIsIFwiZHJhZ1JlYWR5RW5kXCIsIFwib25Nb3VzZURyYWdcIl07XG5cbiAgICAgZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgIG1vdXNlSGFuZGxlclt4XSA9IHRoaXNbeF07XG4gICAgfSwgdGhpcyk7XG4gICAgZWRpdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRG93bi5iaW5kKG1vdXNlSGFuZGxlcikpO1xuXG5cbiAgICB2YXIgbW91c2VUYXJnZXQgPSBlZGl0b3IuY29udGFpbmVyO1xuICAgIHZhciBkcmFnU2VsZWN0aW9uTWFya2VyLCB4LCB5O1xuICAgIHZhciB0aW1lcklkLCByYW5nZTtcbiAgICB2YXIgZHJhZ0N1cnNvciwgY291bnRlciA9IDA7XG4gICAgdmFyIGRyYWdPcGVyYXRpb247XG4gICAgdmFyIGlzSW50ZXJuYWw7XG4gICAgdmFyIGF1dG9TY3JvbGxTdGFydFRpbWU7XG4gICAgdmFyIGN1cnNvck1vdmVkVGltZTtcbiAgICB2YXIgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQ7XG5cbiAgICB0aGlzLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxEcmFnIHx8ICFtb3VzZVRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBzZWxmLnN0YXJ0U2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jYXB0dXJlTW91c2UoZSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcblxuICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gZWRpdG9yLmdldFJlYWRPbmx5KCkgPyBcImNvcHlcIiA6IFwiY29weU1vdmVcIjtcbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc09wZXJhKSB7XG4gICAgICAgICAgICBlZGl0b3IuY29udGFpbmVyLmFwcGVuZENoaWxkKGJsYW5rSW1hZ2UpO1xuICAgICAgICAgICAgYmxhbmtJbWFnZS5zY3JvbGxUb3AgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShibGFua0ltYWdlLCAwLCAwKTtcbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc09wZXJhKSB7XG4gICAgICAgICAgICBlZGl0b3IuY29udGFpbmVyLnJlbW92ZUNoaWxkKGJsYW5rSW1hZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIGVkaXRvci5zZXNzaW9uLmdldFRleHRSYW5nZSgpKTtcblxuICAgICAgICBpc0ludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcImRyYWdcIik7XG4gICAgfTtcblxuICAgIHRoaXMub25EcmFnRW5kID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBtb3VzZVRhcmdldC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgaXNJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKG51bGwpO1xuICAgICAgICBpZiAoIWVkaXRvci5nZXRSZWFkT25seSgpKSB7XG4gICAgICAgICAgICB2YXIgZHJvcEVmZmVjdCA9IGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3Q7XG4gICAgICAgICAgICBpZiAoIWRyYWdPcGVyYXRpb24gJiYgZHJvcEVmZmVjdCA9PSBcIm1vdmVcIilcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdmUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllci5zZXRCbGlua2luZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRvci51bnNldFN0eWxlKFwiYWNlX2RyYWdnaW5nXCIpO1xuICAgICAgICB0aGlzLmVkaXRvci5yZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcIlwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkRyYWdFbnRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGVkaXRvci5nZXRSZWFkT25seSgpIHx8ICFjYW5BY2NlcHQoZS5kYXRhVHJhbnNmZXIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB4ID0gZS5jbGllbnRYO1xuICAgICAgICB5ID0gZS5jbGllbnRZO1xuICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb25NYXJrZXIpXG4gICAgICAgICAgICBhZGREcmFnTWFya2VyKCk7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGRyYWdPcGVyYXRpb24gPSBnZXREcm9wRWZmZWN0KGUpO1xuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgfTtcblxuICAgIHRoaXMub25EcmFnT3ZlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGVkaXRvci5nZXRSZWFkT25seSgpIHx8ICFjYW5BY2NlcHQoZS5kYXRhVHJhbnNmZXIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB4ID0gZS5jbGllbnRYO1xuICAgICAgICB5ID0gZS5jbGllbnRZO1xuICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb25NYXJrZXIpIHtcbiAgICAgICAgICAgIGFkZERyYWdNYXJrZXIoKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU1vdmVUaW1lciAhPT0gbnVsbClcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlVGltZXIgPSBudWxsO1xuXG4gICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBkcmFnT3BlcmF0aW9uID0gZ2V0RHJvcEVmZmVjdChlKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uRHJhZ0xlYXZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIGlmIChjb3VudGVyIDw9IDAgJiYgZHJhZ1NlbGVjdGlvbk1hcmtlcikge1xuICAgICAgICAgICAgY2xlYXJEcmFnTWFya2VyKCk7XG4gICAgICAgICAgICBkcmFnT3BlcmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uRHJvcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFkcmFnQ3Vyc29yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZS5kYXRhVHJhbnNmZXI7XG4gICAgICAgIGlmIChpc0ludGVybmFsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRyYWdPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29udGFpbnMoZHJhZ0N1cnNvci5yb3csIGRyYWdDdXJzb3IuY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRyYWdDdXJzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBkcmFnQ3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBlZGl0b3IubW92ZVRleHQocmFuZ2UsIGRyYWdDdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb3B5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZWRpdG9yLm1vdmVUZXh0KHJhbmdlLCBkcmFnQ3Vyc29yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZHJvcERhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgnVGV4dCcpO1xuICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRyYWdDdXJzb3IsXG4gICAgICAgICAgICAgICAgZW5kOiBlZGl0b3Iuc2Vzc2lvbi5pbnNlcnQoZHJhZ0N1cnNvciwgZHJvcERhdGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICBkcmFnT3BlcmF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckRyYWdNYXJrZXIoKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgIH07XG5cbiAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJkcmFnc3RhcnRcIiwgdGhpcy5vbkRyYWdTdGFydC5iaW5kKG1vdXNlSGFuZGxlcikpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcImRyYWdlbmRcIiwgdGhpcy5vbkRyYWdFbmQuYmluZChtb3VzZUhhbmRsZXIpKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJkcmFnZW50ZXJcIiwgdGhpcy5vbkRyYWdFbnRlci5iaW5kKG1vdXNlSGFuZGxlcikpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcImRyYWdvdmVyXCIsIHRoaXMub25EcmFnT3Zlci5iaW5kKG1vdXNlSGFuZGxlcikpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcImRyYWdsZWF2ZVwiLCB0aGlzLm9uRHJhZ0xlYXZlLmJpbmQobW91c2VIYW5kbGVyKSk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFwiZHJvcFwiLCB0aGlzLm9uRHJvcC5iaW5kKG1vdXNlSGFuZGxlcikpO1xuXG4gICAgZnVuY3Rpb24gc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoY3Vyc29yLCBwcmV2Q3Vyc29yKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgdk1vdmVtZW50ID0gIXByZXZDdXJzb3IgfHwgY3Vyc29yLnJvdyAhPSBwcmV2Q3Vyc29yLnJvdztcbiAgICAgICAgdmFyIGhNb3ZlbWVudCA9ICFwcmV2Q3Vyc29yIHx8IGN1cnNvci5jb2x1bW4gIT0gcHJldkN1cnNvci5jb2x1bW47XG4gICAgICAgIGlmICghY3Vyc29yTW92ZWRUaW1lIHx8IHZNb3ZlbWVudCB8fCBoTW92ZW1lbnQpIHtcbiAgICAgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmcgKz0gMTtcbiAgICAgICAgICAgIGVkaXRvci5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZyAtPSAxO1xuICAgICAgICAgICAgY3Vyc29yTW92ZWRUaW1lID0gbm93O1xuICAgICAgICAgICAgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQgPSB7eDogeCwgeTogeX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQueCwgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQueSwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBTQ1JPTExfQ1VSU09SX0hZU1RFUkVTSVMpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3JNb3ZlZFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub3cgLSBjdXJzb3JNb3ZlZFRpbWUgPj0gU0NST0xMX0NVUlNPUl9ERUxBWSkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIGN1cnNvck1vdmVkVGltZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdXRvU2Nyb2xsKGN1cnNvciwgcHJldkN1cnNvcikge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBlZGl0b3IucmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGNoYXJhY3RlcldpZHRoID0gZWRpdG9yLnJlbmRlcmVyLmxheWVyQ29uZmlnLmNoYXJhY3RlcldpZHRoO1xuICAgICAgICB2YXIgZWRpdG9yUmVjdCA9IGVkaXRvci5yZW5kZXJlci5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSB7XG4gICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgIGxlZnQ6IHggLSBlZGl0b3JSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICByaWdodDogZWRpdG9yUmVjdC5yaWdodCAtIHhcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgdG9wOiB5IC0gZWRpdG9yUmVjdC50b3AsXG4gICAgICAgICAgICAgICBib3R0b206IGVkaXRvclJlY3QuYm90dG9tIC0geVxuICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBuZWFyZXN0WE9mZnNldCA9IE1hdGgubWluKG9mZnNldHMueC5sZWZ0LCBvZmZzZXRzLngucmlnaHQpO1xuICAgICAgICB2YXIgbmVhcmVzdFlPZmZzZXQgPSBNYXRoLm1pbihvZmZzZXRzLnkudG9wLCBvZmZzZXRzLnkuYm90dG9tKTtcbiAgICAgICAgdmFyIHNjcm9sbEN1cnNvciA9IHtyb3c6IGN1cnNvci5yb3csIGNvbHVtbjogY3Vyc29yLmNvbHVtbn07XG4gICAgICAgIGlmIChuZWFyZXN0WE9mZnNldCAvIGNoYXJhY3RlcldpZHRoIDw9IDIpIHtcbiAgICAgICAgICAgIHNjcm9sbEN1cnNvci5jb2x1bW4gKz0gKG9mZnNldHMueC5sZWZ0IDwgb2Zmc2V0cy54LnJpZ2h0ID8gLTMgOiArMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lYXJlc3RZT2Zmc2V0IC8gbGluZUhlaWdodCA8PSAxKSB7XG4gICAgICAgICAgICBzY3JvbGxDdXJzb3Iucm93ICs9IChvZmZzZXRzLnkudG9wIDwgb2Zmc2V0cy55LmJvdHRvbSA/IC0xIDogKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2U2Nyb2xsID0gY3Vyc29yLnJvdyAhPSBzY3JvbGxDdXJzb3Iucm93O1xuICAgICAgICB2YXIgaFNjcm9sbCA9IGN1cnNvci5jb2x1bW4gIT0gc2Nyb2xsQ3Vyc29yLmNvbHVtbjtcbiAgICAgICAgdmFyIHZNb3ZlbWVudCA9ICFwcmV2Q3Vyc29yIHx8IGN1cnNvci5yb3cgIT0gcHJldkN1cnNvci5yb3c7XG4gICAgICAgIGlmICh2U2Nyb2xsIHx8IChoU2Nyb2xsICYmICF2TW92ZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoIWF1dG9TY3JvbGxTdGFydFRpbWUpXG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbFN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vdyAtIGF1dG9TY3JvbGxTdGFydFRpbWUgPj0gQVVUT1NDUk9MTF9ERUxBWSlcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoc2Nyb2xsQ3Vyc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1dG9TY3JvbGxTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnSW50ZXJ2YWwoKSB7XG4gICAgICAgIHZhciBwcmV2Q3Vyc29yID0gZHJhZ0N1cnNvcjtcbiAgICAgICAgZHJhZ0N1cnNvciA9IGVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyh4LCB5KTtcbiAgICAgICAgc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoZHJhZ0N1cnNvciwgcHJldkN1cnNvcik7XG4gICAgICAgIGF1dG9TY3JvbGwoZHJhZ0N1cnNvciwgcHJldkN1cnNvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRHJhZ01hcmtlcigpIHtcbiAgICAgICAgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICBkcmFnU2VsZWN0aW9uTWFya2VyID0gZWRpdG9yLnNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcImFjZV9zZWxlY3Rpb25cIiwgZWRpdG9yLmdldFNlbGVjdGlvblN0eWxlKCkpO1xuICAgICAgICBlZGl0b3IuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc0ZvY3VzZWQoKSlcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci4kY3Vyc29yTGF5ZXIuc2V0QmxpbmtpbmcoZmFsc2UpO1xuICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgICAgICBvbkRyYWdJbnRlcnZhbCgpO1xuICAgICAgICB0aW1lcklkID0gc2V0SW50ZXJ2YWwob25EcmFnSW50ZXJ2YWwsIDIwKTtcbiAgICAgICAgY291bnRlciA9IDA7XG4gICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJEcmFnTWFya2VyKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdmVNYXJrZXIoZHJhZ1NlbGVjdGlvbk1hcmtlcik7XG4gICAgICAgIGRyYWdTZWxlY3Rpb25NYXJrZXIgPSBudWxsO1xuICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nICs9IDE7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nIC09IDE7XG4gICAgICAgIGlmIChlZGl0b3IuaXNGb2N1c2VkKCkgJiYgIWlzSW50ZXJuYWwpXG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuJGN1cnNvckxheWVyLnNldEJsaW5raW5nKCFlZGl0b3IuZ2V0UmVhZE9ubHkoKSk7XG4gICAgICAgIHJhbmdlID0gbnVsbDtcbiAgICAgICAgZHJhZ0N1cnNvciA9IG51bGw7XG4gICAgICAgIGNvdW50ZXIgPSAwO1xuICAgICAgICBhdXRvU2Nyb2xsU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgY3Vyc29yTW92ZWRUaW1lID0gbnVsbDtcbiAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG4gICAgdmFyIG9uTW91c2VNb3ZlVGltZXIgPSBudWxsO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge1xuICAgICAgICBpZiAob25Nb3VzZU1vdmVUaW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICBvbk1vdXNlTW92ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Nb3VzZU1vdmVUaW1lciAhPSBudWxsICYmIGRyYWdTZWxlY3Rpb25NYXJrZXIpXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyRHJhZ01hcmtlcigpO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuQWNjZXB0KGRhdGFUcmFuc2Zlcikge1xuICAgICAgICB2YXIgdHlwZXMgPSBkYXRhVHJhbnNmZXIudHlwZXM7XG4gICAgICAgIHJldHVybiAhdHlwZXMgfHwgQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbCh0eXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT0gJ3RleHQvcGxhaW4nIHx8IHR5cGUgPT0gJ1RleHQnO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREcm9wRWZmZWN0KGUpIHtcbiAgICAgICAgdmFyIGNvcHlBbGxvd2VkID0gWydjb3B5JywgJ2NvcHltb3ZlJywgJ2FsbCcsICd1bmluaXRpYWxpemVkJ107XG4gICAgICAgIHZhciBtb3ZlQWxsb3dlZCA9IFsnbW92ZScsICdjb3B5bW92ZScsICdsaW5rbW92ZScsICdhbGwnLCAndW5pbml0aWFsaXplZCddO1xuXG4gICAgICAgIHZhciBjb3B5TW9kaWZpZXJTdGF0ZSA9IHVzZXJhZ2VudC5pc01hYyA/IGUuYWx0S2V5IDogZS5jdHJsS2V5O1xuICAgICAgICB2YXIgZWZmZWN0QWxsb3dlZCA9IFwidW5pbml0aWFsaXplZFwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWZmZWN0QWxsb3dlZCA9IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdmFyIGRyb3BFZmZlY3QgPSBcIm5vbmVcIjtcblxuICAgICAgICBpZiAoY29weU1vZGlmaWVyU3RhdGUgJiYgY29weUFsbG93ZWQuaW5kZXhPZihlZmZlY3RBbGxvd2VkKSA+PSAwKVxuICAgICAgICAgICAgZHJvcEVmZmVjdCA9IFwiY29weVwiO1xuICAgICAgICBlbHNlIGlmIChtb3ZlQWxsb3dlZC5pbmRleE9mKGVmZmVjdEFsbG93ZWQpID49IDApXG4gICAgICAgICAgICBkcm9wRWZmZWN0ID0gXCJtb3ZlXCI7XG4gICAgICAgIGVsc2UgaWYgKGNvcHlBbGxvd2VkLmluZGV4T2YoZWZmZWN0QWxsb3dlZCkgPj0gMClcbiAgICAgICAgICAgIGRyb3BFZmZlY3QgPSBcImNvcHlcIjtcblxuICAgICAgICByZXR1cm4gZHJvcEVmZmVjdDtcbiAgICB9XG59XG5cbihmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuZHJhZ1dhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gRGF0ZS5ub3coKSAtIHRoaXMubW91c2Vkb3duRXZlbnQudGltZTtcbiAgICAgICAgaWYgKGludGVydmFsID4gdGhpcy5lZGl0b3IuZ2V0RHJhZ0RlbGF5KCkpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZygpO1xuICAgIH07XG5cbiAgICB0aGlzLmRyYWdXYWl0RW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmVkaXRvci5jb250YWluZXI7XG4gICAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdCh0aGlzLm1vdXNlZG93bkV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0RW5kKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZHJhZ1JlYWR5RW5kID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5yZW5kZXJlci4kY3Vyc29yTGF5ZXIuc2V0QmxpbmtpbmcoIXRoaXMuZWRpdG9yLmdldFJlYWRPbmx5KCkpO1xuICAgICAgICB0aGlzLmVkaXRvci51bnNldFN0eWxlKFwiYWNlX2RyYWdnaW5nXCIpO1xuICAgICAgICB0aGlzLmVkaXRvci5yZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcIlwiKTtcbiAgICAgICAgdGhpcy5kcmFnV2FpdEVuZCgpO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuY2FuY2VsRHJhZyA9IGZhbHNlO1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlZGl0b3IuY29udGFpbmVyO1xuICAgICAgICB0YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllci5zZXRCbGlua2luZyhmYWxzZSk7XG4gICAgICAgIGVkaXRvci5zZXRTdHlsZShcImFjZV9kcmFnZ2luZ1wiKTtcbiAgICAgICAgdmFyIGN1cnNvclN0eWxlID0gdXNlcmFnZW50LmlzV2luID8gXCJkZWZhdWx0XCIgOiBcIm1vdmVcIjtcbiAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNldEN1cnNvclN0eWxlKGN1cnNvclN0eWxlKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcImRyYWdSZWFkeVwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbk1vdXNlRHJhZyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZWRpdG9yLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0lFICYmIHRoaXMuc3RhdGUgPT0gXCJkcmFnUmVhZHlcIikge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKHRoaXMubW91c2Vkb3duRXZlbnQueCwgdGhpcy5tb3VzZWRvd25FdmVudC55LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAzKVxuICAgICAgICAgICAgICAgIHRhcmdldC5kcmFnRHJvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImRyYWdXYWl0XCIpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZSh0aGlzLm1vdXNlZG93bkV2ZW50LngsIHRoaXMubW91c2Vkb3duRXZlbnQueSwgdGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0KHRoaXMubW91c2Vkb3duRXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uTW91c2VEb3duID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuJGRyYWdFbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm1vdXNlZG93bkV2ZW50ID0gZTtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuXG4gICAgICAgIHZhciBpblNlbGVjdGlvbiA9IGUuaW5TZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGUuZ2V0QnV0dG9uKCk7XG4gICAgICAgIHZhciBjbGlja0NvdW50ID0gZS5kb21FdmVudC5kZXRhaWwgfHwgMTtcbiAgICAgICAgaWYgKGNsaWNrQ291bnQgPT09IDEgJiYgYnV0dG9uID09PSAwICYmIGluU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZS5lZGl0b3IuaW5NdWx0aVNlbGVjdE1vZGUgJiYgKGUuZ2V0QWNjZWxLZXkoKSB8fCBlLmdldFNoaWZ0S2V5KCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLmRvbUV2ZW50LnRhcmdldCB8fCBlLmRvbUV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoXCJ1bnNlbGVjdGFibGVcIiBpbiBldmVudFRhcmdldClcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC51bnNlbGVjdGFibGUgPSBcIm9uXCI7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLmdldERyYWdEZWxheSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJhZ2VudC5pc1dlYktpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VUYXJnZXQgPSBlZGl0b3IuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKFwiZHJhZ1dhaXRcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVNb3VzZShlLCB0aGlzLm9uTW91c2VEcmFnLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgZS5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pLmNhbGwoRHJhZ2Ryb3BIYW5kbGVyLnByb3RvdHlwZSk7XG5cblxuZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKGF4LCBheSwgYngsIGJ5KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhieCAtIGF4LCAyKSArIE1hdGgucG93KGJ5IC0gYXksIDIpKTtcbn1cblxuZXhwb3J0cy5EcmFnZHJvcEhhbmRsZXIgPSBEcmFnZHJvcEhhbmRsZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xpYi9uZXRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZG9tXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBkb20gPSBhY2VxdWlyZShcIi4vZG9tXCIpO1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKG51bGwpO1xufTtcblxuZXhwb3J0cy5sb2FkU2NyaXB0ID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaGVhZCA9IGRvbS5nZXREb2N1bWVudEhlYWQoKTtcbiAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgcy5zcmMgPSBwYXRoO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQocyk7XG5cbiAgICBzLm9ubG9hZCA9IHMub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oXywgaXNBYm9ydCkge1xuICAgICAgICBpZiAoaXNBYm9ydCB8fCAhcy5yZWFkeVN0YXRlIHx8IHMucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHMucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIHMgPSBzLm9ubG9hZCA9IHMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaXNBYm9ydClcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLnF1YWxpZnlVUkwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGEuaHJlZjtcbn1cblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRFbWl0dGVyID0ge307XG52YXIgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7IHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTsgfTtcbnZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlOyB9O1xuXG5FdmVudEVtaXR0ZXIuX2VtaXQgPVxuRXZlbnRFbWl0dGVyLl9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnROYW1lLCBlKSB7XG4gICAgdGhpcy5fZXZlbnRSZWdpc3RyeSB8fCAodGhpcy5fZXZlbnRSZWdpc3RyeSA9IHt9KTtcbiAgICB0aGlzLl9kZWZhdWx0SGFuZGxlcnMgfHwgKHRoaXMuX2RlZmF1bHRIYW5kbGVycyA9IHt9KTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gfHwgW107XG4gICAgdmFyIGRlZmF1bHRIYW5kbGVyID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMubGVuZ3RoICYmICFkZWZhdWx0SGFuZGxlcilcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIgfHwgIWUpXG4gICAgICAgIGUgPSB7fTtcblxuICAgIGlmICghZS50eXBlKVxuICAgICAgICBlLnR5cGUgPSBldmVudE5hbWU7XG4gICAgaWYgKCFlLnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG4gICAgaWYgKCFlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG5cbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8bGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXShlLCB0aGlzKTtcbiAgICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIGlmIChkZWZhdWx0SGFuZGxlciAmJiAhZS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZGVmYXVsdEhhbmRsZXIoZSwgdGhpcyk7XG59O1xuXG5cbkV2ZW50RW1pdHRlci5fc2lnbmFsID0gZnVuY3Rpb24oZXZlbnROYW1lLCBlKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9ICh0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8IHt9KVtldmVudE5hbWVdO1xuICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgICByZXR1cm47XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGxpc3RlbmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgbGlzdGVuZXJzW2ldKGUsIHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLm9uY2UgPSBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICBjYWxsYmFjayAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiBuZXdDYWxsYmFjaygpIHtcbiAgICAgICAgX3NlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG5ld0NhbGxiYWNrKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcbn07XG5cblxuRXZlbnRFbWl0dGVyLnNldERlZmF1bHRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2RlZmF1bHRIYW5kbGVyc1xuICAgIGlmICghaGFuZGxlcnMpXG4gICAgICAgIGhhbmRsZXJzID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzID0ge19kaXNhYmxlZF86IHt9fTtcbiAgICBcbiAgICBpZiAoaGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgb2xkID0gaGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgdmFyIGRpc2FibGVkID0gaGFuZGxlcnMuX2Rpc2FibGVkX1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoIWRpc2FibGVkKVxuICAgICAgICAgICAgaGFuZGxlcnMuX2Rpc2FibGVkX1tldmVudE5hbWVdID0gZGlzYWJsZWQgPSBbXTtcbiAgICAgICAgZGlzYWJsZWQucHVzaChvbGQpO1xuICAgICAgICB2YXIgaSA9IGRpc2FibGVkLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaSAhPSAtMSkgXG4gICAgICAgICAgICBkaXNhYmxlZC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBjYWxsYmFjaztcbn07XG5FdmVudEVtaXR0ZXIucmVtb3ZlRGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzXG4gICAgaWYgKCFoYW5kbGVycylcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBkaXNhYmxlZCA9IGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXTtcbiAgICBcbiAgICBpZiAoaGFuZGxlcnNbZXZlbnROYW1lXSA9PSBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb2xkID0gaGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0SGFuZGxlcihldmVudE5hbWUsIGRpc2FibGVkLnBvcCgpKTtcbiAgICB9IGVsc2UgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHZhciBpID0gZGlzYWJsZWQuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgZGlzYWJsZWQuc3BsaWNlKGksIDEpO1xuICAgIH1cbn07XG5cbkV2ZW50RW1pdHRlci5vbiA9XG5FdmVudEVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGNhcHR1cmluZykge1xuICAgIHRoaXMuX2V2ZW50UmVnaXN0cnkgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8IHt9O1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXTtcbiAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgICAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRSZWdpc3RyeVtldmVudE5hbWVdID0gW107XG5cbiAgICBpZiAobGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spID09IC0xKVxuICAgICAgICBsaXN0ZW5lcnNbY2FwdHVyaW5nID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIl0oY2FsbGJhY2spO1xuICAgIHJldHVybiBjYWxsYmFjaztcbn07XG5cbkV2ZW50RW1pdHRlci5vZmYgPVxuRXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyID1cbkV2ZW50RW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2V2ZW50UmVnaXN0cnkgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5IHx8IHt9O1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXTtcbiAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xufTtcblxuRXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLl9ldmVudFJlZ2lzdHJ5KSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gPSBbXTtcbn07XG5cbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saWIvYXBwX2NvbmZpZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJubyB1c2Ugc3RyaWN0XCI7XG5cbnZhciBvb3AgPSBhY2VxdWlyZShcIi4vb29wXCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFwiLi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcblxudmFyIG9wdGlvbnNQcm92aWRlciA9IHtcbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRMaXN0KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdExpc3QpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbihrZXksIG9wdExpc3Rba2V5XSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9uTmFtZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAoIW9wdGlvbk5hbWVzKSB7XG4gICAgICAgICAgICBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuJG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbk5hbWVzKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gb3B0aW9uTmFtZXM7XG4gICAgICAgICAgICBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uTmFtZXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5nZXRPcHRpb24oa2V5KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzW1wiJFwiICsgbmFtZV0gPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb3B0ID0gdGhpcy4kb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKCFvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiB3YXJuKCdtaXNzcGVsbGVkIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdC5mb3J3YXJkVG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tvcHQuZm9yd2FyZFRvXSAmJiB0aGlzW29wdC5mb3J3YXJkVG9dLnNldE9wdGlvbihuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKCFvcHQuaGFuZGxlc1NldClcbiAgICAgICAgICAgIHRoaXNbXCIkXCIgKyBuYW1lXSA9IHZhbHVlO1xuICAgICAgICBpZiAob3B0ICYmIG9wdC5zZXQpXG4gICAgICAgICAgICBvcHQuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBvcHQgPSB0aGlzLiRvcHRpb25zW25hbWVdO1xuICAgICAgICBpZiAoIW9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIHdhcm4oJ21pc3NwZWxsZWQgb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LmZvcndhcmRUbylcbiAgICAgICAgICAgIHJldHVybiB0aGlzW29wdC5mb3J3YXJkVG9dICYmIHRoaXNbb3B0LmZvcndhcmRUb10uZ2V0T3B0aW9uKG5hbWUpO1xuICAgICAgICByZXR1cm4gb3B0ICYmIG9wdC5nZXQgPyBvcHQuZ2V0LmNhbGwodGhpcykgOiB0aGlzW1wiJFwiICsgbmFtZV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKVxuICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcmVwb3J0RXJyb3IobXNnLCBkYXRhKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobXNnKTtcbiAgICBlLmRhdGEgPSBkYXRhO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSA9PSBcIm9iamVjdFwiICYmIGNvbnNvbGUuZXJyb3IpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZTsgfSk7XG59XG5cbnZhciBBcHBDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiRkZWZhdWx0T3B0aW9ucyA9IHt9O1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcbiAgICB0aGlzLmRlZmluZU9wdGlvbnMgPSBmdW5jdGlvbihvYmosIHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvYmouJG9wdGlvbnMpXG4gICAgICAgICAgICB0aGlzLiRkZWZhdWx0T3B0aW9uc1twYXRoXSA9IG9iai4kb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBvcHQgPSB7Zm9yd2FyZFRvOiBvcHR9O1xuXG4gICAgICAgICAgICBvcHQubmFtZSB8fCAob3B0Lm5hbWUgPSBrZXkpO1xuICAgICAgICAgICAgb2JqLiRvcHRpb25zW29wdC5uYW1lXSA9IG9wdDtcbiAgICAgICAgICAgIGlmIChcImluaXRpYWxWYWx1ZVwiIGluIG9wdClcbiAgICAgICAgICAgICAgICBvYmpbXCIkXCIgKyBvcHQubmFtZV0gPSBvcHQuaW5pdGlhbFZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgb29wLmltcGxlbWVudChvYmosIG9wdGlvbnNQcm92aWRlcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iai4kb3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSBvYmouJG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIGlmIChcInZhbHVlXCIgaW4gb3B0KVxuICAgICAgICAgICAgICAgIG9iai5zZXRPcHRpb24oa2V5LCBvcHQudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbihwYXRoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMuJGRlZmF1bHRPcHRpb25zW3BhdGhdIHx8ICh0aGlzLiRkZWZhdWx0T3B0aW9uc1twYXRoXSA9IHt9KTtcbiAgICAgICAgaWYgKG9wdHNbbmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmZvcndhcmRUbylcbiAgICAgICAgICAgICAgICB0aGlzLnNldERlZmF1bHRWYWx1ZShvcHRzLmZvcndhcmRUbywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9wdHNbbmFtZV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnNldERlZmF1bHRWYWx1ZXMgPSBmdW5jdGlvbihwYXRoLCBvcHRpb25IYXNoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbkhhc2gpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldERlZmF1bHRWYWx1ZShwYXRoLCBrZXksIG9wdGlvbkhhc2hba2V5XSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICB0aGlzLndhcm4gPSB3YXJuO1xuICAgIHRoaXMucmVwb3J0RXJyb3IgPSByZXBvcnRFcnJvcjtcblxufSkuY2FsbChBcHBDb25maWcucHJvdG90eXBlKTtcblxuZXhwb3J0cy5BcHBDb25maWcgPSBBcHBDb25maWc7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2NvbmZpZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9uZXRcIixcImFjZS9saWIvYXBwX2NvbmZpZ1wiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJubyB1c2Ugc3RyaWN0XCI7XG5cbnZhciBsYW5nID0gYWNlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIG5ldCA9IGFjZXF1aXJlKFwiLi9saWIvbmV0XCIpO1xudmFyIEFwcENvbmZpZyA9IGFjZXF1aXJlKFwiLi9saWIvYXBwX2NvbmZpZ1wiKS5BcHBDb25maWc7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBBcHBDb25maWcoKTtcblxudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbn0pKCk7XG5cbnZhciBvcHRpb25zID0ge1xuICAgIHBhY2thZ2VkOiBmYWxzZSxcbiAgICB3b3JrZXJQYXRoOiBudWxsLFxuICAgIG1vZGVQYXRoOiBudWxsLFxuICAgIHRoZW1lUGF0aDogbnVsbCxcbiAgICBiYXNlUGF0aDogXCJcIixcbiAgICBzdWZmaXg6IFwiLmpzXCIsXG4gICAgJG1vZHVsZVVybHM6IHt9XG59O1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbmZpZyBrZXk6IFwiICsga2V5KTtcblxuICAgIHJldHVybiBvcHRpb25zW2tleV07XG59O1xuXG5leHBvcnRzLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb25maWcga2V5OiBcIiArIGtleSk7XG5cbiAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcbn07XG5cbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhbmcuY29weU9iamVjdChvcHRpb25zKTtcbn07XG5leHBvcnRzLm1vZHVsZVVybCA9IGZ1bmN0aW9uKG5hbWUsIGNvbXBvbmVudCkge1xuICAgIGlmIChvcHRpb25zLiRtb2R1bGVVcmxzW25hbWVdKVxuICAgICAgICByZXR1cm4gb3B0aW9ucy4kbW9kdWxlVXJsc1tuYW1lXTtcblxuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudCB8fCBwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXSB8fCBcIlwiO1xuICAgIHZhciBzZXAgPSBjb21wb25lbnQgPT0gXCJzbmlwcGV0c1wiID8gXCIvXCIgOiBcIi1cIjtcbiAgICB2YXIgYmFzZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjb21wb25lbnQgPT0gXCJ3b3JrZXJcIiAmJiBzZXAgPT0gXCItXCIpIHtcbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIl5cIiArIGNvbXBvbmVudCArIFwiW1xcXFwtX118W1xcXFwtX11cIiArIGNvbXBvbmVudCArIFwiJFwiLCBcImdcIik7XG4gICAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UocmUsIFwiXCIpO1xuICAgIH1cblxuICAgIGlmICgoIWJhc2UgfHwgYmFzZSA9PSBjb21wb25lbnQpICYmIHBhcnRzLmxlbmd0aCA+IDEpXG4gICAgICAgIGJhc2UgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXTtcbiAgICB2YXIgcGF0aCA9IG9wdGlvbnNbY29tcG9uZW50ICsgXCJQYXRoXCJdO1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgcGF0aCA9IG9wdGlvbnMuYmFzZVBhdGg7XG4gICAgfSBlbHNlIGlmIChzZXAgPT0gXCIvXCIpIHtcbiAgICAgICAgY29tcG9uZW50ID0gc2VwID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKHBhdGggJiYgcGF0aC5zbGljZSgtMSkgIT0gXCIvXCIpXG4gICAgICAgIHBhdGggKz0gXCIvXCI7XG4gICAgcmV0dXJuIHBhdGggKyBjb21wb25lbnQgKyBzZXAgKyBiYXNlICsgdGhpcy5nZXQoXCJzdWZmaXhcIik7XG59O1xuXG5leHBvcnRzLnNldE1vZHVsZVVybCA9IGZ1bmN0aW9uKG5hbWUsIHN1YnN0KSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuJG1vZHVsZVVybHNbbmFtZV0gPSBzdWJzdDtcbn07XG5cbmV4cG9ydHMuJGxvYWRpbmcgPSB7fTtcbmV4cG9ydHMubG9hZE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZU5hbWUsIG9uTG9hZCkge1xuICAgIHZhciBtb2R1bGUsIG1vZHVsZVR5cGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobW9kdWxlTmFtZSkpIHtcbiAgICAgICAgbW9kdWxlVHlwZSA9IG1vZHVsZU5hbWVbMF07XG4gICAgICAgIG1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lWzFdO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIG1vZHVsZSA9IGFjZXF1aXJlKG1vZHVsZU5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKG1vZHVsZSAmJiAhZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSlcbiAgICAgICAgcmV0dXJuIG9uTG9hZCAmJiBvbkxvYWQobW9kdWxlKTtcblxuICAgIGlmICghZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSlcbiAgICAgICAgZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSA9IFtdO1xuXG4gICAgZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXS5wdXNoKG9uTG9hZCk7XG5cbiAgICBpZiAoZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXS5sZW5ndGggPiAxKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgYWZ0ZXJMb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFjZXF1aXJlKFttb2R1bGVOYW1lXSwgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICBleHBvcnRzLl9lbWl0KFwibG9hZC5tb2R1bGVcIiwge25hbWU6IG1vZHVsZU5hbWUsIG1vZHVsZTogbW9kdWxlfSk7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXTtcbiAgICAgICAgICAgIGV4cG9ydHMuJGxvYWRpbmdbbW9kdWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24ob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChtb2R1bGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoIWV4cG9ydHMuZ2V0KFwicGFja2FnZWRcIikpXG4gICAgICAgIHJldHVybiBhZnRlckxvYWQoKTtcbiAgICBuZXQubG9hZFNjcmlwdChleHBvcnRzLm1vZHVsZVVybChtb2R1bGVOYW1lLCBtb2R1bGVUeXBlKSwgYWZ0ZXJMb2FkKTtcbn07XG5pbml0KHRydWUpO2Z1bmN0aW9uIGluaXQocGFja2FnZWQpIHtcblxuICAgIG9wdGlvbnMucGFja2FnZWQgPSBwYWNrYWdlZCB8fCBhY2VxdWlyZS5wYWNrYWdlZCB8fCBtb2R1bGUucGFja2FnZWQgfHwgKGdsb2JhbC5kZWZpbmUgJiYgZGVmaW5lLnBhY2thZ2VkKTtcblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KVxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgIHZhciBzY3JpcHRPcHRpb25zID0ge307XG4gICAgdmFyIHNjcmlwdFVybCA9IFwiXCI7XG4gICAgdmFyIGN1cnJlbnRTY3JpcHQgPSAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCB8fCBkb2N1bWVudC5fY3VycmVudFNjcmlwdCApOyAvLyBuYXRpdmUgb3IgcG9seWZpbGxcbiAgICB2YXIgY3VycmVudERvY3VtZW50ID0gY3VycmVudFNjcmlwdCAmJiBjdXJyZW50U2NyaXB0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgXG4gICAgdmFyIHNjcmlwdHMgPSBjdXJyZW50RG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG4gICAgZm9yICh2YXIgaT0wOyBpPHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbaV07XG5cbiAgICAgICAgdmFyIHNyYyA9IHNjcmlwdC5zcmMgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgICAgaWYgKCFzcmMpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHNjcmlwdC5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKHZhciBqPTAsIGw9YXR0cmlidXRlcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuaW5kZXhPZihcImRhdGEtYWNlLVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdE9wdGlvbnNbZGVIeXBoZW5hdGUoYXR0ci5uYW1lLnJlcGxhY2UoL15kYXRhLWFjZS0vLCBcIlwiKSldID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0gc3JjLm1hdGNoKC9eKC4qKVxcL2FjZShcXC1cXHcrKT9cXC5qcyhcXD98JCkvKTtcbiAgICAgICAgaWYgKG0pXG4gICAgICAgICAgICBzY3JpcHRVcmwgPSBtWzFdO1xuICAgIH1cblxuICAgIGlmIChzY3JpcHRVcmwpIHtcbiAgICAgICAgc2NyaXB0T3B0aW9ucy5iYXNlID0gc2NyaXB0T3B0aW9ucy5iYXNlIHx8IHNjcmlwdFVybDtcbiAgICAgICAgc2NyaXB0T3B0aW9ucy5wYWNrYWdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2NyaXB0T3B0aW9ucy5iYXNlUGF0aCA9IHNjcmlwdE9wdGlvbnMuYmFzZTtcbiAgICBzY3JpcHRPcHRpb25zLndvcmtlclBhdGggPSBzY3JpcHRPcHRpb25zLndvcmtlclBhdGggfHwgc2NyaXB0T3B0aW9ucy5iYXNlO1xuICAgIHNjcmlwdE9wdGlvbnMubW9kZVBhdGggPSBzY3JpcHRPcHRpb25zLm1vZGVQYXRoIHx8IHNjcmlwdE9wdGlvbnMuYmFzZTtcbiAgICBzY3JpcHRPcHRpb25zLnRoZW1lUGF0aCA9IHNjcmlwdE9wdGlvbnMudGhlbWVQYXRoIHx8IHNjcmlwdE9wdGlvbnMuYmFzZTtcbiAgICBkZWxldGUgc2NyaXB0T3B0aW9ucy5iYXNlO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNjcmlwdE9wdGlvbnMpXG4gICAgICAgIGlmICh0eXBlb2Ygc2NyaXB0T3B0aW9uc1trZXldICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgZXhwb3J0cy5zZXQoa2V5LCBzY3JpcHRPcHRpb25zW2tleV0pO1xufTtcblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcblxuZnVuY3Rpb24gZGVIeXBoZW5hdGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKG0sIG0xKSB7IHJldHVybiBtMS50b1VwcGVyQ2FzZSgpOyB9KTtcbn1cblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW91c2UvbW91c2VfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIixcImFjZS9tb3VzZS9kZWZhdWx0X2hhbmRsZXJzXCIsXCJhY2UvbW91c2UvZGVmYXVsdF9ndXR0ZXJfaGFuZGxlclwiLFwiYWNlL21vdXNlL21vdXNlX2V2ZW50XCIsXCJhY2UvbW91c2UvZHJhZ2Ryb3BfaGFuZGxlclwiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBldmVudCA9IGFjZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xudmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBEZWZhdWx0SGFuZGxlcnMgPSBhY2VxdWlyZShcIi4vZGVmYXVsdF9oYW5kbGVyc1wiKS5EZWZhdWx0SGFuZGxlcnM7XG52YXIgRGVmYXVsdEd1dHRlckhhbmRsZXIgPSBhY2VxdWlyZShcIi4vZGVmYXVsdF9ndXR0ZXJfaGFuZGxlclwiKS5HdXR0ZXJIYW5kbGVyO1xudmFyIE1vdXNlRXZlbnQgPSBhY2VxdWlyZShcIi4vbW91c2VfZXZlbnRcIikuTW91c2VFdmVudDtcbnZhciBEcmFnZHJvcEhhbmRsZXIgPSBhY2VxdWlyZShcIi4vZHJhZ2Ryb3BfaGFuZGxlclwiKS5EcmFnZHJvcEhhbmRsZXI7XG52YXIgY29uZmlnID0gYWNlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBNb3VzZUhhbmRsZXIgPSBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuXG4gICAgbmV3IERlZmF1bHRIYW5kbGVycyh0aGlzKTtcbiAgICBuZXcgRGVmYXVsdEd1dHRlckhhbmRsZXIodGhpcyk7XG4gICAgbmV3IERyYWdkcm9wSGFuZGxlcih0aGlzKTtcblxuICAgIHZhciBmb2N1c0VkaXRvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCAhZG9jdW1lbnQuaGFzRm9jdXMoKSlcbiAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgdmFyIG1vdXNlVGFyZ2V0ID0gZWRpdG9yLnJlbmRlcmVyLmdldE1vdXNlRXZlbnRUYXJnZXQoKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXCJjbGlja1wiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFwiY2xpY2tcIikpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcywgXCJtb3VzZW1vdmVcIikpO1xuICAgIGV2ZW50LmFkZE11bHRpTW91c2VEb3duTGlzdGVuZXIobW91c2VUYXJnZXQsIFs0MDAsIDMwMCwgMjUwXSwgdGhpcywgXCJvbk1vdXNlRXZlbnRcIik7XG4gICAgaWYgKGVkaXRvci5yZW5kZXJlci5zY3JvbGxCYXJWKSB7XG4gICAgICAgIGV2ZW50LmFkZE11bHRpTW91c2VEb3duTGlzdGVuZXIoZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhclYuaW5uZXIsIFs0MDAsIDMwMCwgMjUwXSwgdGhpcywgXCJvbk1vdXNlRXZlbnRcIik7XG4gICAgICAgIGV2ZW50LmFkZE11bHRpTW91c2VEb3duTGlzdGVuZXIoZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhckguaW5uZXIsIFs0MDAsIDMwMCwgMjUwXSwgdGhpcywgXCJvbk1vdXNlRXZlbnRcIik7XG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSkge1xuICAgICAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhclYuZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZm9jdXNFZGl0b3IpO1xuICAgICAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhckguZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZm9jdXNFZGl0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV2ZW50LmFkZE1vdXNlV2hlZWxMaXN0ZW5lcihlZGl0b3IuY29udGFpbmVyLCB0aGlzLm9uTW91c2VXaGVlbC5iaW5kKHRoaXMsIFwibW91c2V3aGVlbFwiKSk7XG5cbiAgICB2YXIgZ3V0dGVyRWwgPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlcjtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcImd1dHRlcm1vdXNlZG93blwiKSk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZ3V0dGVyRWwsIFwiY2xpY2tcIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcImd1dHRlcmNsaWNrXCIpKTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXCJkYmxjbGlja1wiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFwiZ3V0dGVyZGJsY2xpY2tcIikpO1xuICAgIGV2ZW50LmFkZExpc3RlbmVyKGd1dHRlckVsLCBcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFwiZ3V0dGVybW91c2Vtb3ZlXCIpKTtcblxuICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcIm1vdXNlZG93blwiLCBmb2N1c0VkaXRvcik7XG5cbiAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgIH0pO1xuXG4gICAgZWRpdG9yLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZiAoX3NlbGYuc3RhdGUgfHwgX3NlbGYuJGRyYWdEZWxheSB8fCAhX3NlbGYuJGRyYWdFbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBjaGFyYWN0ZXIgPSBlZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXMoZS54LCBlLnkpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3Iuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZWRpdG9yLnJlbmRlcmVyO1xuXG4gICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpICYmIHJhbmdlLmluc2lkZVN0YXJ0KGNoYXJhY3Rlci5yb3csIGNoYXJhY3Rlci5jb2x1bW4pKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcImRlZmF1bHRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcIlwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub25Nb3VzZUV2ZW50ID0gZnVuY3Rpb24obmFtZSwgZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5fZW1pdChuYW1lLCBuZXcgTW91c2VFdmVudChlLCB0aGlzLmVkaXRvcikpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24obmFtZSwgZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5lZGl0b3IuX2V2ZW50UmVnaXN0cnkgJiYgdGhpcy5lZGl0b3IuX2V2ZW50UmVnaXN0cnkubW91c2Vtb3ZlO1xuICAgICAgICBpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLmVkaXRvci5fZW1pdChuYW1lLCBuZXcgTW91c2VFdmVudChlLCB0aGlzLmVkaXRvcikpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uTW91c2VXaGVlbCA9IGZ1bmN0aW9uKG5hbWUsIGUpIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudChlLCB0aGlzLmVkaXRvcik7XG4gICAgICAgIG1vdXNlRXZlbnQuc3BlZWQgPSB0aGlzLiRzY3JvbGxTcGVlZCAqIDI7XG4gICAgICAgIG1vdXNlRXZlbnQud2hlZWxYID0gZS53aGVlbFg7XG4gICAgICAgIG1vdXNlRXZlbnQud2hlZWxZID0gZS53aGVlbFk7XG5cbiAgICAgICAgdGhpcy5lZGl0b3IuX2VtaXQobmFtZSwgbW91c2VFdmVudCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfTtcblxuICAgIHRoaXMuY2FwdHVyZU1vdXNlID0gZnVuY3Rpb24oZXYsIG1vdXNlTW92ZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy54ID0gZXYueDtcbiAgICAgICAgdGhpcy55ID0gZXYueTtcblxuICAgICAgICB0aGlzLmlzTW91c2VQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5lZGl0b3IucmVuZGVyZXI7XG4gICAgICAgIGlmIChyZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IpXG4gICAgICAgICAgICByZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSBudWxsO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCFlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodXNlcmFnZW50LmlzV2ViS2l0ICYmICFlLndoaWNoICYmIHNlbGYucmVsZWFzZU1vdXNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJlbGVhc2VNb3VzZSgpO1xuXG4gICAgICAgICAgICBzZWxmLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBzZWxmLnkgPSBlLmNsaWVudFk7XG4gICAgICAgICAgICBtb3VzZU1vdmVIYW5kbGVyICYmIG1vdXNlTW92ZUhhbmRsZXIoZSk7XG4gICAgICAgICAgICBzZWxmLm1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudChlLCBzZWxmLmVkaXRvcik7XG4gICAgICAgICAgICBzZWxmLiRtb3VzZU1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb25DYXB0dXJlRW5kID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICAgICAgICAgIG9uQ2FwdHVyZUludGVydmFsKCk7XG4gICAgICAgICAgICBzZWxmW3NlbGYuc3RhdGUgKyBcIkVuZFwiXSAmJiBzZWxmW3NlbGYuc3RhdGUgKyBcIkVuZFwiXShlKTtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLiRrZWVwVGV4dEFyZWFBdEN1cnNvciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaXNNb3VzZVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuJG9uQ2FwdHVyZU1vdXNlTW92ZSA9IHNlbGYucmVsZWFzZU1vdXNlID0gbnVsbDtcbiAgICAgICAgICAgIGUgJiYgc2VsZi5vbk1vdXNlRXZlbnQoXCJtb3VzZXVwXCIsIGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvbkNhcHR1cmVJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZltzZWxmLnN0YXRlXSAmJiBzZWxmW3NlbGYuc3RhdGVdKCk7XG4gICAgICAgICAgICBzZWxmLiRtb3VzZU1vdmVkID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZXJhZ2VudC5pc09sZElFICYmIGV2LmRvbUV2ZW50LnR5cGUgPT0gXCJkYmxjbGlja1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtvbkNhcHR1cmVFbmQoZXYpO30pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kb25DYXB0dXJlTW91c2VNb3ZlID0gb25Nb3VzZU1vdmU7XG4gICAgICAgIHNlbGYucmVsZWFzZU1vdXNlID0gZXZlbnQuY2FwdHVyZSh0aGlzLmVkaXRvci5jb250YWluZXIsIG9uTW91c2VNb3ZlLCBvbkNhcHR1cmVFbmQpO1xuICAgICAgICB2YXIgdGltZXJJZCA9IHNldEludGVydmFsKG9uQ2FwdHVyZUludGVydmFsLCAyMCk7XG4gICAgfTtcbiAgICB0aGlzLnJlbGVhc2VNb3VzZSA9IG51bGw7XG4gICAgdGhpcy5jYW5jZWxDb250ZXh0TWVudSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlICYmIGUuZG9tRXZlbnQgJiYgZS5kb21FdmVudC50eXBlICE9IFwiY29udGV4dG1lbnVcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vZmYoXCJuYXRpdmVjb250ZXh0bWVudVwiLCBzdG9wKTtcbiAgICAgICAgICAgIGlmIChlICYmIGUuZG9tRXZlbnQpXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEV2ZW50KGUuZG9tRXZlbnQpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHNldFRpbWVvdXQoc3RvcCwgMTApO1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcIm5hdGl2ZWNvbnRleHRtZW51XCIsIHN0b3ApO1xuICAgIH07XG59KS5jYWxsKE1vdXNlSGFuZGxlci5wcm90b3R5cGUpO1xuXG5jb25maWcuZGVmaW5lT3B0aW9ucyhNb3VzZUhhbmRsZXIucHJvdG90eXBlLCBcIm1vdXNlSGFuZGxlclwiLCB7XG4gICAgc2Nyb2xsU3BlZWQ6IHtpbml0aWFsVmFsdWU6IDJ9LFxuICAgIGRyYWdEZWxheToge2luaXRpYWxWYWx1ZTogKHVzZXJhZ2VudC5pc01hYyA/IDE1MCA6IDApfSxcbiAgICBkcmFnRW5hYmxlZDoge2luaXRpYWxWYWx1ZTogdHJ1ZX0sXG4gICAgZm9jdXNUaW1vdXQ6IHtpbml0aWFsVmFsdWU6IDB9LFxuICAgIHRvb2x0aXBGb2xsb3dzTW91c2U6IHtpbml0aWFsVmFsdWU6IHRydWV9XG59KTtcblxuXG5leHBvcnRzLk1vdXNlSGFuZGxlciA9IE1vdXNlSGFuZGxlcjtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vdXNlL2ZvbGRfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEZvbGRIYW5kbGVyKGVkaXRvcikge1xuXG4gICAgZWRpdG9yLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBlLmdldERvY3VtZW50UG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcbiAgICAgICAgdmFyIGZvbGQgPSBzZXNzaW9uLmdldEZvbGRBdChwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbiwgMSk7XG4gICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICBpZiAoZS5nZXRBY2NlbEtleSgpKVxuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlRm9sZChmb2xkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmV4cGFuZEZvbGQoZm9sZCk7XG5cbiAgICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBlZGl0b3Iub24oXCJndXR0ZXJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBndXR0ZXJSZWdpb24gPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLmdldFJlZ2lvbihlKTtcblxuICAgICAgICBpZiAoZ3V0dGVyUmVnaW9uID09IFwiZm9sZFdpZGdldHNcIikge1xuICAgICAgICAgICAgdmFyIHJvdyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcbiAgICAgICAgICAgIHZhciBzZXNzaW9uID0gZWRpdG9yLnNlc3Npb247XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi5mb2xkV2lkZ2V0cyAmJiBzZXNzaW9uLmZvbGRXaWRnZXRzW3Jvd10pXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ub25Gb2xkV2lkZ2V0Q2xpY2socm93LCBlKTtcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmlzRm9jdXNlZCgpKVxuICAgICAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGVkaXRvci5vbihcImd1dHRlcmRibGNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGd1dHRlclJlZ2lvbiA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuZ2V0UmVnaW9uKGUpO1xuXG4gICAgICAgIGlmIChndXR0ZXJSZWdpb24gPT0gXCJmb2xkV2lkZ2V0c1wiKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xuICAgICAgICAgICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2Vzc2lvbi5nZXRQYXJlbnRGb2xkUmFuZ2VEYXRhKHJvdywgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBkYXRhLnJhbmdlIHx8IGRhdGEuZmlyc3RSYW5nZTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIHZhciBmb2xkID0gc2Vzc2lvbi5nZXRGb2xkQXQocm93LCBzZXNzaW9uLmdldExpbmUocm93KS5sZW5ndGgsIDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24uYWRkRm9sZChcIi4uLlwiLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyh7cm93OiByYW5nZS5zdGFydC5yb3csIGNvbHVtbjogMH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuRm9sZEhhbmRsZXIgPSBGb2xkSGFuZGxlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uva2V5Ym9hcmQva2V5YmluZGluZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9rZXlzXCIsXCJhY2UvbGliL2V2ZW50XCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleVV0aWwgID0gYWNlcXVpcmUoXCIuLi9saWIva2V5c1wiKTtcbnZhciBldmVudCA9IGFjZXF1aXJlKFwiLi4vbGliL2V2ZW50XCIpO1xuXG52YXIgS2V5QmluZGluZyA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHRoaXMuJGVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiRkYXRhID0ge2VkaXRvcjogZWRpdG9yfTtcbiAgICB0aGlzLiRoYW5kbGVycyA9IFtdO1xuICAgIHRoaXMuc2V0RGVmYXVsdEhhbmRsZXIoZWRpdG9yLmNvbW1hbmRzKTtcbn07XG5cbihmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldERlZmF1bHRIYW5kbGVyID0gZnVuY3Rpb24oa2IpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVLZXlib2FyZEhhbmRsZXIodGhpcy4kZGVmYXVsdEhhbmRsZXIpO1xuICAgICAgICB0aGlzLiRkZWZhdWx0SGFuZGxlciA9IGtiO1xuICAgICAgICB0aGlzLmFkZEtleWJvYXJkSGFuZGxlcihrYiwgMCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0S2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24oa2IpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLiRoYW5kbGVycztcbiAgICAgICAgaWYgKGhbaC5sZW5ndGggLSAxXSA9PSBrYilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB3aGlsZSAoaFtoLmxlbmd0aCAtIDFdICYmIGhbaC5sZW5ndGggLSAxXSAhPSB0aGlzLiRkZWZhdWx0SGFuZGxlcilcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKGhbaC5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgdGhpcy5hZGRLZXlib2FyZEhhbmRsZXIoa2IsIDEpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZEtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uKGtiLCBwb3MpIHtcbiAgICAgICAgaWYgKCFrYilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBrYiA9PSBcImZ1bmN0aW9uXCIgJiYgIWtiLmhhbmRsZUtleWJvYXJkKVxuICAgICAgICAgICAga2IuaGFuZGxlS2V5Ym9hcmQgPSBrYjtcbiAgICAgICAgdmFyIGkgPSB0aGlzLiRoYW5kbGVycy5pbmRleE9mKGtiKTtcbiAgICAgICAgaWYgKGkgIT0gLTEpXG4gICAgICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgaWYgKHBvcyA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLiRoYW5kbGVycy5wdXNoKGtiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kaGFuZGxlcnMuc3BsaWNlKHBvcywgMCwga2IpO1xuXG4gICAgICAgIGlmIChpID09IC0xICYmIGtiLmF0dGFjaClcbiAgICAgICAgICAgIGtiLmF0dGFjaCh0aGlzLiRlZGl0b3IpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uKGtiKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy4kaGFuZGxlcnMuaW5kZXhPZihrYik7XG4gICAgICAgIGlmIChpID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGtiLmRldGFjaCAmJiBrYi5kZXRhY2godGhpcy4kZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0S2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRoYW5kbGVyc1t0aGlzLiRoYW5kbGVycy5sZW5ndGggLSAxXTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRTdGF0dXNUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy4kZGF0YTtcbiAgICAgICAgdmFyIGVkaXRvciA9IGRhdGEuZWRpdG9yO1xuICAgICAgICByZXR1cm4gdGhpcy4kaGFuZGxlcnMubWFwKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoLmdldFN0YXR1c1RleHQgJiYgaC5nZXRTdGF0dXNUZXh0KGVkaXRvciwgZGF0YSkgfHwgXCJcIjtcbiAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLiRjYWxsS2V5Ym9hcmRIYW5kbGVycyA9IGZ1bmN0aW9uKGhhc2hJZCwga2V5U3RyaW5nLCBrZXlDb2RlLCBlKSB7XG4gICAgICAgIHZhciB0b0V4ZWN1dGU7XG4gICAgICAgIHZhciBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIHZhciBjb21tYW5kcyA9IHRoaXMuJGVkaXRvci5jb21tYW5kcztcblxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy4kaGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB0b0V4ZWN1dGUgPSB0aGlzLiRoYW5kbGVyc1tpXS5oYW5kbGVLZXlib2FyZChcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRhLCBoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSwgZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdG9FeGVjdXRlIHx8ICF0b0V4ZWN1dGUuY29tbWFuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0b0V4ZWN1dGUuY29tbWFuZCA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gY29tbWFuZHMuZXhlYyh0b0V4ZWN1dGUuY29tbWFuZCwgdGhpcy4kZWRpdG9yLCB0b0V4ZWN1dGUuYXJncywgZSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgZSAmJiBoYXNoSWQgIT0gLTEgJiYgXG4gICAgICAgICAgICAgICAgdG9FeGVjdXRlLnBhc3NFdmVudCAhPSB0cnVlICYmIHRvRXhlY3V0ZS5jb21tYW5kLnBhc3NFdmVudCAhPSB0cnVlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wRXZlbnQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VjY2VzcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNvbW1hbmRLZXkgPSBmdW5jdGlvbihlLCBoYXNoSWQsIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIGtleVN0cmluZyA9IGtleVV0aWwua2V5Q29kZVRvU3RyaW5nKGtleUNvZGUpO1xuICAgICAgICB0aGlzLiRjYWxsS2V5Ym9hcmRIYW5kbGVycyhoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSwgZSk7XG4gICAgfTtcblxuICAgIHRoaXMub25UZXh0SW5wdXQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHZhciBzdWNjZXNzID0gdGhpcy4kY2FsbEtleWJvYXJkSGFuZGxlcnMoLTEsIHRleHQpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLiRlZGl0b3IuY29tbWFuZHMuZXhlYyhcImluc2VydHN0cmluZ1wiLCB0aGlzLiRlZGl0b3IsIHRleHQpO1xuICAgIH07XG5cbn0pLmNhbGwoS2V5QmluZGluZy5wcm90b3R5cGUpO1xuXG5leHBvcnRzLktleUJpbmRpbmcgPSBLZXlCaW5kaW5nO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvcmFuZ2VcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xudmFyIGNvbXBhcmVQb2ludHMgPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEucm93IC0gcDIucm93IHx8IHAxLmNvbHVtbiAtIHAyLmNvbHVtbjtcbn07XG52YXIgUmFuZ2UgPSBmdW5jdGlvbihzdGFydFJvdywgc3RhcnRDb2x1bW4sIGVuZFJvdywgZW5kQ29sdW1uKSB7XG4gICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgcm93OiBzdGFydFJvdyxcbiAgICAgICAgY29sdW1uOiBzdGFydENvbHVtblxuICAgIH07XG5cbiAgICB0aGlzLmVuZCA9IHtcbiAgICAgICAgcm93OiBlbmRSb3csXG4gICAgICAgIGNvbHVtbjogZW5kQ29sdW1uXG4gICAgfTtcbn07XG5cbihmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzRXF1YWwgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJlxuICAgICAgICAgICAgdGhpcy5lbmQucm93ID09PSByYW5nZS5lbmQucm93ICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9PT0gcmFuZ2Uuc3RhcnQuY29sdW1uICYmXG4gICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPT09IHJhbmdlLmVuZC5jb2x1bW47XG4gICAgfTtcbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXCJSYW5nZTogW1wiICsgdGhpcy5zdGFydC5yb3cgKyBcIi9cIiArIHRoaXMuc3RhcnQuY29sdW1uICtcbiAgICAgICAgICAgIFwiXSAtPiBbXCIgKyB0aGlzLmVuZC5yb3cgKyBcIi9cIiArIHRoaXMuZW5kLmNvbHVtbiArIFwiXVwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jb250YWlucyA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pID09IDA7XG4gICAgfTtcbiAgICB0aGlzLmNvbXBhcmVSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBjbXAsXG4gICAgICAgICAgICBlbmQgPSByYW5nZS5lbmQsXG4gICAgICAgICAgICBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuXG4gICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShlbmQucm93LCBlbmQuY29sdW1uKTtcbiAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLmNvbXBhcmUoc3RhcnQucm93LCBzdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJlKHN0YXJ0LnJvdywgc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jb21wYXJlUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocC5yb3csIHAuY29sdW1uKTtcbiAgICB9O1xuICAgIHRoaXMuY29udGFpbnNSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQb2ludChyYW5nZS5zdGFydCkgPT0gMCAmJiB0aGlzLmNvbXBhcmVQb2ludChyYW5nZS5lbmQpID09IDA7XG4gICAgfTtcbiAgICB0aGlzLmludGVyc2VjdHMgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgY21wID0gdGhpcy5jb21wYXJlUmFuZ2UocmFuZ2UpO1xuICAgICAgICByZXR1cm4gKGNtcCA9PSAtMSB8fCBjbXAgPT0gMCB8fCBjbXAgPT0gMSk7XG4gICAgfTtcbiAgICB0aGlzLmlzRW5kID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnJvdyA9PSByb3cgJiYgdGhpcy5lbmQuY29sdW1uID09IGNvbHVtbjtcbiAgICB9O1xuICAgIHRoaXMuaXNTdGFydCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvdyA9PSByb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT0gY29sdW1uO1xuICAgIH07XG4gICAgdGhpcy5zZXRTdGFydCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygcm93ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID0gcm93LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gcm93LnJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gcm93O1xuICAgICAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2V0RW5kID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByb3cgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gcm93LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kLnJvdyA9IHJvdy5yb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuZC5yb3cgPSByb3c7XG4gICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaW5zaWRlID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQocm93LCBjb2x1bW4pIHx8IHRoaXMuaXNTdGFydChyb3csIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuaW5zaWRlU3RhcnQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5jb21wYXJlKHJvdywgY29sdW1uKSA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuZChyb3csIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuaW5zaWRlRW5kID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFydChyb3csIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuY29tcGFyZSA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICghdGhpcy5pc011bHRpTGluZSgpKSB7XG4gICAgICAgICAgICBpZiAocm93ID09PSB0aGlzLnN0YXJ0LnJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4gPCB0aGlzLnN0YXJ0LmNvbHVtbiA/IC0xIDogKGNvbHVtbiA+IHRoaXMuZW5kLmNvbHVtbiA/IDEgOiAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93IDwgdGhpcy5zdGFydC5yb3cpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG5cbiAgICAgICAgaWYgKHJvdyA+IHRoaXMuZW5kLnJvdylcbiAgICAgICAgICAgIHJldHVybiAxO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0LnJvdyA9PT0gcm93KVxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbiA+PSB0aGlzLnN0YXJ0LmNvbHVtbiA/IDAgOiAtMTtcblxuICAgICAgICBpZiAodGhpcy5lbmQucm93ID09PSByb3cpXG4gICAgICAgICAgICByZXR1cm4gY29sdW1uIDw9IHRoaXMuZW5kLmNvbHVtbiA/IDAgOiAxO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgdGhpcy5jb21wYXJlU3RhcnQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5zdGFydC5yb3cgPT0gcm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09IGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShyb3csIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY29tcGFyZUVuZCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZC5yb3cgPT0gcm93ICYmIHRoaXMuZW5kLmNvbHVtbiA9PSBjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShyb3csIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY29tcGFyZUluc2lkZSA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZC5yb3cgPT0gcm93ICYmIHRoaXMuZW5kLmNvbHVtbiA9PSBjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhcnQucm93ID09IHJvdyAmJiB0aGlzLnN0YXJ0LmNvbHVtbiA9PSBjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNsaXBSb3dzID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kLnJvdyA+IGxhc3RSb3cpXG4gICAgICAgICAgICB2YXIgZW5kID0ge3JvdzogbGFzdFJvdyArIDEsIGNvbHVtbjogMH07XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5kLnJvdyA8IGZpcnN0Um93KVxuICAgICAgICAgICAgdmFyIGVuZCA9IHtyb3c6IGZpcnN0Um93LCBjb2x1bW46IDB9O1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0LnJvdyA+IGxhc3RSb3cpXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB7cm93OiBsYXN0Um93ICsgMSwgY29sdW1uOiAwfTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFydC5yb3cgPCBmaXJzdFJvdylcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHtyb3c6IGZpcnN0Um93LCBjb2x1bW46IDB9O1xuXG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0IHx8IHRoaXMuc3RhcnQsIGVuZCB8fCB0aGlzLmVuZCk7XG4gICAgfTtcbiAgICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBjbXAgPSB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIGlmIChjbXAgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBlbHNlIGlmIChjbXAgPT0gLTEpXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB7cm93OiByb3csIGNvbHVtbjogY29sdW1ufTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIGVuZCA9IHtyb3c6IHJvdywgY29sdW1uOiBjb2x1bW59O1xuXG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0IHx8IHRoaXMuc3RhcnQsIGVuZCB8fCB0aGlzLmVuZCk7XG4gICAgfTtcblxuICAgIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnQucm93ID09PSB0aGlzLmVuZC5yb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT09IHRoaXMuZW5kLmNvbHVtbik7XG4gICAgfTtcbiAgICB0aGlzLmlzTXVsdGlMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zdGFydC5yb3cgIT09IHRoaXMuZW5kLnJvdyk7XG4gICAgfTtcbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICB9O1xuICAgIHRoaXMuY29sbGFwc2VSb3dzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZC5jb2x1bW4gPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydC5yb3csIDAsIE1hdGgubWF4KHRoaXMuc3RhcnQucm93LCB0aGlzLmVuZC5yb3ctMSksIDApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydC5yb3csIDAsIHRoaXMuZW5kLnJvdywgMClcbiAgICB9O1xuICAgIHRoaXMudG9TY3JlZW5SYW5nZSA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgICAgICAgdmFyIHNjcmVlblBvc1N0YXJ0ID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5zdGFydCk7XG4gICAgICAgIHZhciBzY3JlZW5Qb3NFbmQgPSBzZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbih0aGlzLmVuZCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgICAgICAgIHNjcmVlblBvc1N0YXJ0LnJvdywgc2NyZWVuUG9zU3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgc2NyZWVuUG9zRW5kLnJvdywgc2NyZWVuUG9zRW5kLmNvbHVtblxuICAgICAgICApO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlQnkgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICB0aGlzLnN0YXJ0LnJvdyArPSByb3c7XG4gICAgICAgIHRoaXMuc3RhcnQuY29sdW1uICs9IGNvbHVtbjtcbiAgICAgICAgdGhpcy5lbmQucm93ICs9IHJvdztcbiAgICAgICAgdGhpcy5lbmQuY29sdW1uICs9IGNvbHVtbjtcbiAgICB9O1xuXG59KS5jYWxsKFJhbmdlLnByb3RvdHlwZSk7XG5SYW5nZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQucm93LCBzdGFydC5jb2x1bW4sIGVuZC5yb3csIGVuZC5jb2x1bW4pO1xufTtcblJhbmdlLmNvbXBhcmVQb2ludHMgPSBjb21wYXJlUG9pbnRzO1xuXG5SYW5nZS5jb21wYXJlUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyAtIHAyLnJvdyB8fCBwMS5jb2x1bW4gLSBwMi5jb2x1bW47XG59O1xuXG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3NlbGVjdGlvblwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgbGFuZyA9IGFjZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuZG9jID0gc2Vzc2lvbi5nZXREb2N1bWVudCgpO1xuXG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIHRoaXMubGVhZCA9IHRoaXMuc2VsZWN0aW9uTGVhZCA9IHRoaXMuZG9jLmNyZWF0ZUFuY2hvcigwLCAwKTtcbiAgICB0aGlzLmFuY2hvciA9IHRoaXMuc2VsZWN0aW9uQW5jaG9yID0gdGhpcy5kb2MuY3JlYXRlQW5jaG9yKDAsIDApO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubGVhZC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoXCJjaGFuZ2VDdXJzb3JcIik7XG4gICAgICAgIGlmICghc2VsZi4kaXNFbXB0eSlcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoXCJjaGFuZ2VTZWxlY3Rpb25cIik7XG4gICAgICAgIGlmICghc2VsZi4ka2VlcERlc2lyZWRDb2x1bW5PbkNoYW5nZSAmJiBlLm9sZC5jb2x1bW4gIT0gZS52YWx1ZS5jb2x1bW4pXG4gICAgICAgICAgICBzZWxmLiRkZXNpcmVkQ29sdW1uID0gbnVsbDtcbiAgICB9KTtcblxuICAgIHRoaXMuc2VsZWN0aW9uQW5jaG9yLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuJGlzRW1wdHkpXG4gICAgICAgICAgICBzZWxmLl9lbWl0KFwiY2hhbmdlU2VsZWN0aW9uXCIpO1xuICAgIH0pO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuICAgIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuJGlzRW1wdHkgfHwgKFxuICAgICAgICAgICAgdGhpcy5hbmNob3Iucm93ID09IHRoaXMubGVhZC5yb3cgJiZcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yLmNvbHVtbiA9PSB0aGlzLmxlYWQuY29sdW1uXG4gICAgICAgICkpO1xuICAgIH07XG4gICAgdGhpcy5pc011bHRpTGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlKCkuaXNNdWx0aUxpbmUoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q3Vyc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYWQuZ2V0UG9zaXRpb24oKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uQW5jaG9yID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5hbmNob3Iuc2V0UG9zaXRpb24ocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIGlmICh0aGlzLiRpc0VtcHR5KSB7XG4gICAgICAgICAgICB0aGlzLiRpc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlU2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldFNlbGVjdGlvbkFuY2hvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy4kaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbkxlYWQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNlbGVjdGlvbkxlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZC5nZXRQb3NpdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5zaGlmdFNlbGVjdGlvbiA9IGZ1bmN0aW9uKGNvbHVtbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHRoaXMubGVhZC5yb3csIHRoaXMubGVhZC5jb2x1bW4gKyBjb2x1bW5zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmdldFNlbGVjdGlvbkFuY2hvcigpO1xuICAgICAgICB2YXIgbGVhZCA9IHRoaXMuZ2V0U2VsZWN0aW9uTGVhZCgpO1xuXG4gICAgICAgIHZhciBpc0JhY2t3YXJkcyA9IHRoaXMuaXNCYWNrd2FyZHMoKTtcblxuICAgICAgICBpZiAoIWlzQmFja3dhcmRzIHx8IGFuY2hvci5jb2x1bW4gIT09IDApXG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbkFuY2hvcihhbmNob3Iucm93LCBhbmNob3IuY29sdW1uICsgY29sdW1ucyk7XG5cbiAgICAgICAgaWYgKGlzQmFja3dhcmRzIHx8IGxlYWQuY29sdW1uICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGxlYWQucm93LCBsZWFkLmNvbHVtbiArIGNvbHVtbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaXNCYWNrd2FyZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgICB2YXIgbGVhZCA9IHRoaXMubGVhZDtcbiAgICAgICAgcmV0dXJuIChhbmNob3Iucm93ID4gbGVhZC5yb3cgfHwgKGFuY2hvci5yb3cgPT0gbGVhZC5yb3cgJiYgYW5jaG9yLmNvbHVtbiA+IGxlYWQuY29sdW1uKSk7XG4gICAgfTtcbiAgICB0aGlzLmdldFJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLmxlYWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKVxuICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMobGVhZCwgbGVhZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNCYWNrd2FyZHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMobGVhZCwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKGFuY2hvciwgbGVhZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRpc0VtcHR5KSB7XG4gICAgICAgICAgICB0aGlzLiRpc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJjaGFuZ2VTZWxlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0QWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXN0Um93ID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbkFuY2hvcigwLCAwKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8obGFzdFJvdywgdGhpcy5kb2MuZ2V0TGluZShsYXN0Um93KS5sZW5ndGgpO1xuICAgIH07XG4gICAgdGhpcy5zZXRSYW5nZSA9XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSA9IGZ1bmN0aW9uKHJhbmdlLCByZXZlcnNlKSB7XG4gICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbkFuY2hvcihyYW5nZS5lbmQucm93LCByYW5nZS5lbmQuY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0VG8ocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25BbmNob3IocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RUbyhyYW5nZS5lbmQucm93LCByYW5nZS5lbmQuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRSYW5nZSgpLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHRoaXMuJGlzRW1wdHkgPSB0cnVlO1xuICAgICAgICB0aGlzLiRkZXNpcmVkQ29sdW1uID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy4kbW92ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKG1vdmVyKSB7XG4gICAgICAgIHZhciBsZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICBpZiAodGhpcy4kaXNFbXB0eSlcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uQW5jaG9yKGxlYWQucm93LCBsZWFkLmNvbHVtbik7XG5cbiAgICAgICAgbW92ZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0VG8gPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMubW92ZVRvID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICB0aGlzLm1vdmVUb1Bvc2l0aW9uID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihwb3MpO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RVcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvclVwKTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0RG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckRvd24pO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RSaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvclJpZ2h0KTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0TGVmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckxlZnQpO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RMaW5lU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JMaW5lU3RhcnQpO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RMaW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yTGluZUVuZCk7XG4gICAgfTtcbiAgICB0aGlzLnNlbGVjdEZpbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JGaWxlRW5kKTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0RmlsZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yRmlsZVN0YXJ0KTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0V29yZFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yV29yZFJpZ2h0KTtcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0V29yZExlZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JXb3JkTGVmdCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFdvcmRSYW5nZSA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSByb3cgfHwgdGhpcy5sZWFkO1xuICAgICAgICAgICAgcm93ID0gY3Vyc29yLnJvdztcbiAgICAgICAgICAgIGNvbHVtbiA9IGN1cnNvci5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRXb3JkUmFuZ2Uocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RXb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5nZXRXb3JkUmFuZ2UoKSk7XG4gICAgfTtcbiAgICB0aGlzLnNlbGVjdEFXb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlc3Npb24uZ2V0QVdvcmRSYW5nZShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0TGluZVJhbmdlID0gZnVuY3Rpb24ocm93LCBleGNsdWRlTGFzdENoYXIpIHtcbiAgICAgICAgdmFyIHJvd1N0YXJ0ID0gdHlwZW9mIHJvdyA9PSBcIm51bWJlclwiID8gcm93IDogdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIHJvd0VuZDtcblxuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZExpbmUocm93U3RhcnQpO1xuICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgIHJvd1N0YXJ0ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICAgICAgcm93RW5kID0gZm9sZExpbmUuZW5kLnJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvd0VuZCA9IHJvd1N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleGNsdWRlTGFzdENoYXIgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJvd1N0YXJ0LCAwLCByb3dFbmQsIHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvd0VuZCkubGVuZ3RoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyb3dTdGFydCwgMCwgcm93RW5kICsgMSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLnNlbGVjdExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmdldExpbmVSYW5nZSgpKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvclVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KC0xLCAwKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvckRvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yQnkoMSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLm1vdmVDdXJzb3JMZWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmxlYWQuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICAgIGZvbGQ7XG5cbiAgICAgICAgaWYgKGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4sIC0xKSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJzb3IuY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhjdXJzb3Iucm93IC0gMSwgdGhpcy5kb2MuZ2V0TGluZShjdXJzb3Iucm93IC0gMSkubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5zZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24uaXNUYWJTdG9wKGN1cnNvcikgJiYgdGhpcy5kb2MuZ2V0TGluZShjdXJzb3Iucm93KS5zbGljZShjdXJzb3IuY29sdW1uLXRhYlNpemUsIGN1cnNvci5jb2x1bW4pLnNwbGl0KFwiIFwiKS5sZW5ndGgtMSA9PSB0YWJTaXplKVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIC10YWJTaXplKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JCeSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvclJpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmxlYWQuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgICAgIGZvbGQ7XG4gICAgICAgIGlmIChmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uLCAxKSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVhZC5jb2x1bW4gPT0gdGhpcy5kb2MuZ2V0TGluZSh0aGlzLmxlYWQucm93KS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYWQucm93IDwgdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8odGhpcy5sZWFkLnJvdyArIDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhYlNpemUgPSB0aGlzLnNlc3Npb24uZ2V0VGFiU2l6ZSgpO1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMubGVhZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24uaXNUYWJTdG9wKGN1cnNvcikgJiYgdGhpcy5kb2MuZ2V0TGluZShjdXJzb3Iucm93KS5zbGljZShjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uK3RhYlNpemUpLnNwbGl0KFwiIFwiKS5sZW5ndGgtMSA9PSB0YWJTaXplKVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIHRhYlNpemUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1vdmVDdXJzb3JMaW5lU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMubGVhZC5yb3c7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxlYWQuY29sdW1uO1xuICAgICAgICB2YXIgc2NyZWVuUm93ID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Sb3cocm93LCBjb2x1bW4pO1xuICAgICAgICB2YXIgZmlyc3RDb2x1bW5Qb3NpdGlvbiA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUm93LCAwKTtcbiAgICAgICAgdmFyIGJlZm9yZUN1cnNvciA9IHRoaXMuc2Vzc2lvbi5nZXREaXNwbGF5TGluZShcbiAgICAgICAgICAgIHJvdywgbnVsbCwgZmlyc3RDb2x1bW5Qb3NpdGlvbi5yb3csXG4gICAgICAgICAgICBmaXJzdENvbHVtblBvc2l0aW9uLmNvbHVtblxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBsZWFkaW5nU3BhY2UgPSBiZWZvcmVDdXJzb3IubWF0Y2goL15cXHMqLyk7XG4gICAgICAgIGlmIChsZWFkaW5nU3BhY2VbMF0ubGVuZ3RoICE9IGNvbHVtbiAmJiAhdGhpcy5zZXNzaW9uLiR1c2VFbWFjc1N0eWxlTGluZVN0YXJ0KVxuICAgICAgICAgICAgZmlyc3RDb2x1bW5Qb3NpdGlvbi5jb2x1bW4gKz0gbGVhZGluZ1NwYWNlWzBdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihmaXJzdENvbHVtblBvc2l0aW9uKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvckxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIHZhciBsaW5lRW5kID0gdGhpcy5zZXNzaW9uLmdldERvY3VtZW50TGFzdFJvd0NvbHVtblBvc2l0aW9uKGxlYWQucm93LCBsZWFkLmNvbHVtbik7XG4gICAgICAgIGlmICh0aGlzLmxlYWQuY29sdW1uID09IGxpbmVFbmQuY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGxpbmVFbmQucm93KTtcbiAgICAgICAgICAgIGlmIChsaW5lRW5kLmNvbHVtbiA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0RW5kID0gbGluZS5zZWFyY2goL1xccyskLyk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRFbmQgPiAwKVxuICAgICAgICAgICAgICAgICAgICBsaW5lRW5kLmNvbHVtbiA9IHRleHRFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhsaW5lRW5kLnJvdywgbGluZUVuZC5jb2x1bW4pO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlQ3Vyc29yRmlsZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpLmxlbmd0aDtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlQ3Vyc29yRmlsZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKDAsIDApO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlQ3Vyc29yTG9uZ1dvcmRSaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICB2YXIgcmlnaHRPZkN1cnNvciA9IGxpbmUuc3Vic3RyaW5nKGNvbHVtbik7XG5cbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICB0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQocm93LCBjb2x1bW4sIDEpO1xuICAgICAgICBpZiAoZm9sZCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmV4ZWMocmlnaHRPZkN1cnNvcikpIHtcbiAgICAgICAgICAgIGNvbHVtbiArPSB0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgcmlnaHRPZkN1cnNvciA9IGxpbmUuc3Vic3RyaW5nKGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbiA+PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBsaW5lLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JSaWdodCgpO1xuICAgICAgICAgICAgaWYgKHJvdyA8IHRoaXMuZG9jLmdldExlbmd0aCgpIC0gMSlcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JXb3JkUmlnaHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLnNlc3Npb24udG9rZW5SZS5leGVjKHJpZ2h0T2ZDdXJzb3IpKSB7XG4gICAgICAgICAgICBjb2x1bW4gKz0gdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgY29sdW1uKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvckxvbmdXb3JkTGVmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XG4gICAgICAgIHZhciBmb2xkO1xuICAgICAgICBpZiAoZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQocm93LCBjb2x1bW4sIC0xKSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZFN0cmluZ0F0KHJvdywgY29sdW1uLCAtMSk7XG4gICAgICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpLnN1YnN0cmluZygwLCBjb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnRPZkN1cnNvciA9IGxhbmcuc3RyaW5nUmV2ZXJzZShzdHIpO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmIChtYXRjaCA9IHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmV4ZWMobGVmdE9mQ3Vyc29yKSkge1xuICAgICAgICAgICAgY29sdW1uIC09IHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIGxlZnRPZkN1cnNvciA9IGxlZnRPZkN1cnNvci5zbGljZSh0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgMCk7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JMZWZ0KCk7XG4gICAgICAgICAgICBpZiAocm93ID4gMClcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JXb3JkTGVmdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IHRoaXMuc2Vzc2lvbi50b2tlblJlLmV4ZWMobGVmdE9mQ3Vyc29yKSkge1xuICAgICAgICAgICAgY29sdW1uIC09IHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XG4gICAgfTtcblxuICAgIHRoaXMuJHNob3J0V29yZEVuZEluZGV4ID0gZnVuY3Rpb24ocmlnaHRPZkN1cnNvcikge1xuICAgICAgICB2YXIgbWF0Y2gsIGluZGV4ID0gMCwgY2g7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlUmUgPSAvXFxzLztcbiAgICAgICAgdmFyIHRva2VuUmUgPSB0aGlzLnNlc3Npb24udG9rZW5SZTtcblxuICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmIChtYXRjaCA9IHRoaXMuc2Vzc2lvbi50b2tlblJlLmV4ZWMocmlnaHRPZkN1cnNvcikpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKChjaCA9IHJpZ2h0T2ZDdXJzb3JbaW5kZXhdKSAmJiB3aGl0ZXNwYWNlUmUudGVzdChjaCkpXG4gICAgICAgICAgICAgICAgaW5kZXggKys7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgIHdoaWxlICgoY2ggPSByaWdodE9mQ3Vyc29yW2luZGV4XSkgJiYgIXRva2VuUmUudGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoaXRlc3BhY2VSZS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2ggPSByaWdodE9mQ3Vyc29yW2luZGV4XSkgJiYgd2hpdGVzcGFjZVJlLnRlc3QoY2gpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICB0aGlzLm1vdmVDdXJzb3JTaG9ydFdvcmRSaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5sZWFkLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICB2YXIgcmlnaHRPZkN1cnNvciA9IGxpbmUuc3Vic3RyaW5nKGNvbHVtbik7XG5cbiAgICAgICAgdmFyIGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAxKTtcbiAgICAgICAgaWYgKGZvbGQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pO1xuXG4gICAgICAgIGlmIChjb2x1bW4gPT0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgICAgcmlnaHRPZkN1cnNvciA9IHRoaXMuZG9jLmdldExpbmUocm93KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHJvdyA8IGwgJiYgL15cXHMqJC8udGVzdChyaWdodE9mQ3Vyc29yKSk7XG5cbiAgICAgICAgICAgIGlmICghL15cXHMrLy50ZXN0KHJpZ2h0T2ZDdXJzb3IpKVxuICAgICAgICAgICAgICAgIHJpZ2h0T2ZDdXJzb3IgPSBcIlwiO1xuICAgICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuJHNob3J0V29yZEVuZEluZGV4KHJpZ2h0T2ZDdXJzb3IpO1xuXG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHJvdywgY29sdW1uICsgaW5kZXgpO1xuICAgIH07XG5cbiAgICB0aGlzLm1vdmVDdXJzb3JTaG9ydFdvcmRMZWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmxlYWQucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sZWFkLmNvbHVtbjtcblxuICAgICAgICB2YXIgZm9sZDtcbiAgICAgICAgaWYgKGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAtMSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKTtcblxuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvdykuc3Vic3RyaW5nKDAsIGNvbHVtbik7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByb3ctLTtcbiAgICAgICAgICAgICAgICBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICAgICAgfSB3aGlsZSAocm93ID4gMCAmJiAvXlxccyokLy50ZXN0KGxpbmUpKTtcblxuICAgICAgICAgICAgY29sdW1uID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIS9cXHMrJC8udGVzdChsaW5lKSlcbiAgICAgICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0T2ZDdXJzb3IgPSBsYW5nLnN0cmluZ1JldmVyc2UobGluZSk7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuJHNob3J0V29yZEVuZEluZGV4KGxlZnRPZkN1cnNvcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvKHJvdywgY29sdW1uIC0gaW5kZXgpO1xuICAgIH07XG5cbiAgICB0aGlzLm1vdmVDdXJzb3JXb3JkUmlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kc2VsZWN0TG9uZ1dvcmRzKVxuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yTG9uZ1dvcmRSaWdodCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JTaG9ydFdvcmRSaWdodCgpO1xuICAgIH07XG5cbiAgICB0aGlzLm1vdmVDdXJzb3JXb3JkTGVmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRzZWxlY3RMb25nV29yZHMpXG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JMb25nV29yZExlZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yU2hvcnRXb3JkTGVmdCgpO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlQ3Vyc29yQnkgPSBmdW5jdGlvbihyb3dzLCBjaGFycykge1xuICAgICAgICB2YXIgc2NyZWVuUG9zID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihcbiAgICAgICAgICAgIHRoaXMubGVhZC5yb3csXG4gICAgICAgICAgICB0aGlzLmxlYWQuY29sdW1uXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGNoYXJzID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kZGVzaXJlZENvbHVtbilcbiAgICAgICAgICAgICAgICBzY3JlZW5Qb3MuY29sdW1uID0gdGhpcy4kZGVzaXJlZENvbHVtbjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiRkZXNpcmVkQ29sdW1uID0gc2NyZWVuUG9zLmNvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2NQb3MgPSB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblBvcy5yb3cgKyByb3dzLCBzY3JlZW5Qb3MuY29sdW1uKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyb3dzICE9PSAwICYmIGNoYXJzID09PSAwICYmIGRvY1Bvcy5yb3cgPT09IHRoaXMubGVhZC5yb3cgJiYgZG9jUG9zLmNvbHVtbiA9PT0gdGhpcy5sZWFkLmNvbHVtbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cyAmJiB0aGlzLnNlc3Npb24ubGluZVdpZGdldHNbZG9jUG9zLnJvd10pXG4gICAgICAgICAgICAgICAgZG9jUG9zLnJvdysrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGRvY1Bvcy5yb3csIGRvY1Bvcy5jb2x1bW4gKyBjaGFycywgY2hhcnMgPT09IDApO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHBvc2l0aW9uLnJvdywgcG9zaXRpb24uY29sdW1uKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvclRvID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIGtlZXBEZXNpcmVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChyb3csIGNvbHVtbiwgMSk7XG4gICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICByb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGNvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4ka2VlcERlc2lyZWRDb2x1bW5PbkNoYW5nZSA9IHRydWU7XG4gICAgICAgIHRoaXMubGVhZC5zZXRQb3NpdGlvbihyb3csIGNvbHVtbik7XG4gICAgICAgIHRoaXMuJGtlZXBEZXNpcmVkQ29sdW1uT25DaGFuZ2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWtlZXBEZXNpcmVkQ29sdW1uKVxuICAgICAgICAgICAgdGhpcy4kZGVzaXJlZENvbHVtbiA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLm1vdmVDdXJzb3JUb1NjcmVlbiA9IGZ1bmN0aW9uKHJvdywgY29sdW1uLCBrZWVwRGVzaXJlZENvbHVtbikge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihyb3csIGNvbHVtbik7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHBvcy5yb3csIHBvcy5jb2x1bW4sIGtlZXBEZXNpcmVkQ29sdW1uKTtcbiAgICB9O1xuICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVhZC5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5hbmNob3IuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHRoaXMuZG9jID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5mcm9tT3JpZW50ZWRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UsIHJhbmdlLmN1cnNvciA9PSByYW5nZS5zdGFydCk7XG4gICAgICAgIHRoaXMuJGRlc2lyZWRDb2x1bW4gPSByYW5nZS5kZXNpcmVkQ29sdW1uIHx8IHRoaXMuJGRlc2lyZWRDb2x1bW47XG4gICAgfTtcblxuICAgIHRoaXMudG9PcmllbnRlZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gci5zdGFydC5jb2x1bW47XG4gICAgICAgICAgICByYW5nZS5zdGFydC5yb3cgPSByLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSByLmVuZC5jb2x1bW47XG4gICAgICAgICAgICByYW5nZS5lbmQucm93ID0gci5lbmQucm93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UgPSByO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2UuY3Vyc29yID0gdGhpcy5pc0JhY2t3YXJkcygpID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7XG4gICAgICAgIHJhbmdlLmRlc2lyZWRDb2x1bW4gPSB0aGlzLiRkZXNpcmVkQ29sdW1uO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLmdldFJhbmdlT2ZNb3ZlbWVudHMgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jLmNhbGwobnVsbCwgdGhpcyk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0LGVuZCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQsc3RhcnQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzdGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnJhbmdlcy5tYXAoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHZhciByMSA9IHIuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICByMS5pc0JhY2t3YXJkcyA9IHIuY3Vyc29yID09IHIuc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgICAgICAgIGRhdGEuaXNCYWNrd2FyZHMgPSB0aGlzLmlzQmFja3dhcmRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMuZnJvbUpTT04gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b1NpbmdsZVJhbmdlKGRhdGFbMF0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBSYW5nZS5mcm9tUG9pbnRzKGRhdGFbaV0uc3RhcnQsIGRhdGFbaV0uZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaXNCYWNrd2FyZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICByLmN1cnNvciA9IHIuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUmFuZ2UociwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJhbmdlTGlzdClcbiAgICAgICAgICAgIHRoaXMudG9TaW5nbGVSYW5nZShkYXRhKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShkYXRhLCBkYXRhLmlzQmFja3dhcmRzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5pc0VxdWFsID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoKGRhdGEubGVuZ3RoIHx8IHRoaXMucmFuZ2VDb3VudCkgJiYgZGF0YS5sZW5ndGggIT0gdGhpcy5yYW5nZUNvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoIHx8ICF0aGlzLnJhbmdlcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlKCkuaXNFcXVhbChkYXRhKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5yYW5nZXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5pc0VxdWFsKGRhdGFbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG59KS5jYWxsKFNlbGVjdGlvbi5wcm90b3R5cGUpO1xuXG5leHBvcnRzLlNlbGVjdGlvbiA9IFNlbGVjdGlvbjtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3Rva2VuaXplclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb25maWcgPSBhY2VxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIE1BWF9UT0tFTl9DT1VOVCA9IDIwMDA7XG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24ocnVsZXMpIHtcbiAgICB0aGlzLnN0YXRlcyA9IHJ1bGVzO1xuXG4gICAgdGhpcy5yZWdFeHBzID0ge307XG4gICAgdGhpcy5tYXRjaE1hcHBpbmdzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGVzW2tleV07XG4gICAgICAgIHZhciBydWxlUmVnRXhwcyA9IFtdO1xuICAgICAgICB2YXIgbWF0Y2hUb3RhbCA9IDA7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5tYXRjaE1hcHBpbmdzW2tleV0gPSB7ZGVmYXVsdFRva2VuOiBcInRleHRcIn07XG4gICAgICAgIHZhciBmbGFnID0gXCJnXCI7XG5cbiAgICAgICAgdmFyIHNwbGl0dGVyUnVybGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gc3RhdGVbaV07XG4gICAgICAgICAgICBpZiAocnVsZS5kZWZhdWx0VG9rZW4pXG4gICAgICAgICAgICAgICAgbWFwcGluZy5kZWZhdWx0VG9rZW4gPSBydWxlLmRlZmF1bHRUb2tlbjtcbiAgICAgICAgICAgIGlmIChydWxlLmNhc2VJbnNlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICBmbGFnID0gXCJnaVwiO1xuICAgICAgICAgICAgaWYgKHJ1bGUucmVnZXggPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKHJ1bGUucmVnZXggaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgICAgICAgICAgcnVsZS5yZWdleCA9IHJ1bGUucmVnZXgudG9TdHJpbmcoKS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB2YXIgYWRqdXN0ZWRyZWdleCA9IHJ1bGUucmVnZXg7XG4gICAgICAgICAgICB2YXIgbWF0Y2hjb3VudCA9IG5ldyBSZWdFeHAoXCIoPzooXCIgKyBhZGp1c3RlZHJlZ2V4ICsgXCIpfCguKSlcIikuZXhlYyhcImFcIikubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUudG9rZW4ubGVuZ3RoID09IDEgfHwgbWF0Y2hjb3VudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW4gPSBydWxlLnRva2VuWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hjb3VudCAtIDEgIT0gcnVsZS50b2tlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcIm51bWJlciBvZiBjbGFzc2VzIGFuZCByZWdleHAgZ3JvdXBzIGRvZXNuJ3QgbWF0Y2hcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ291bnQ6IG1hdGNoY291bnQgLSAxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuID0gcnVsZS50b2tlblswXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuQXJyYXkgPSBydWxlLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gdGhpcy4kYXJyYXlUb2tlbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZS50b2tlbiA9PSBcImZ1bmN0aW9uXCIgJiYgIXJ1bGUub25NYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGNvdW50ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gdGhpcy4kYXBwbHlUb2tlbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUub25NYXRjaCA9IHJ1bGUudG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIGlmICgvXFxcXFxcZC8udGVzdChydWxlLnJlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZHJlZ2V4ID0gcnVsZS5yZWdleC5yZXBsYWNlKC9cXFxcKFswLTldKykvZywgZnVuY3Rpb24obWF0Y2gsIGRpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyAocGFyc2VJbnQoZGlnaXQsIDEwKSArIG1hdGNoVG90YWwgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdGVkcmVnZXggPSB0aGlzLnJlbW92ZUNhcHR1cmluZ0dyb3VwcyhydWxlLnJlZ2V4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlLnNwbGl0UmVnZXggJiYgdHlwZW9mIHJ1bGUudG9rZW4gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgc3BsaXR0ZXJSdXJsZXMucHVzaChydWxlKTsgLy8gZmxhZyB3aWxsIGJlIGtub3duIG9ubHkgYXQgdGhlIHZlcnkgZW5kXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcHBpbmdbbWF0Y2hUb3RhbF0gPSBpO1xuICAgICAgICAgICAgbWF0Y2hUb3RhbCArPSBtYXRjaGNvdW50O1xuXG4gICAgICAgICAgICBydWxlUmVnRXhwcy5wdXNoKGFkanVzdGVkcmVnZXgpO1xuICAgICAgICAgICAgaWYgKCFydWxlLm9uTWF0Y2gpXG4gICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFydWxlUmVnRXhwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1hcHBpbmdbMF0gPSAwO1xuICAgICAgICAgICAgcnVsZVJlZ0V4cHMucHVzaChcIiRcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNwbGl0dGVyUnVybGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgcnVsZS5zcGxpdFJlZ2V4ID0gdGhpcy5jcmVhdGVTcGxpdHRlclJlZ2V4cChydWxlLnJlZ2V4LCBmbGFnKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5yZWdFeHBzW2tleV0gPSBuZXcgUmVnRXhwKFwiKFwiICsgcnVsZVJlZ0V4cHMuam9pbihcIil8KFwiKSArIFwiKXwoJClcIiwgZmxhZyk7XG4gICAgfVxufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuJHNldE1heFRva2VuQ291bnQgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIE1BWF9UT0tFTl9DT1VOVCA9IG0gfCAwO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy4kYXBwbHlUb2tlbiA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5zcGxpdFJlZ2V4LmV4ZWMoc3RyKS5zbGljZSgxKTtcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy50b2tlbi5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIFt7dHlwZTogdHlwZXMsIHZhbHVlOiBzdHJ9XTtcblxuICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2ldKVxuICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSxcblxuICAgIHRoaXMuJGFycmF5VG9rZW5zID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmICghc3RyKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5zcGxpdFJlZ2V4LmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCF2YWx1ZXMpXG4gICAgICAgICAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy50b2tlbkFycmF5O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHR5cGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGhdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpICsgMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlQ2FwdHVyaW5nR3JvdXBzID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgICAgIHZhciByID0gc3JjLnJlcGxhY2UoXG4gICAgICAgICAgICAvXFxbKD86XFxcXC58W15cXF1dKSo/XFxdfFxcXFwufFxcKFxcP1s6PSFdfChcXCgpL2csXG4gICAgICAgICAgICBmdW5jdGlvbih4LCB5KSB7cmV0dXJuIHkgPyBcIig/OlwiIDogeDt9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICB0aGlzLmNyZWF0ZVNwbGl0dGVyUmVnZXhwID0gZnVuY3Rpb24oc3JjLCBmbGFnKSB7XG4gICAgICAgIGlmIChzcmMuaW5kZXhPZihcIig/PVwiKSAhPSAtMSkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gMDtcbiAgICAgICAgICAgIHZhciBpbkNoQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsYXN0Q2FwdHVyZSA9IHt9O1xuICAgICAgICAgICAgc3JjLnJlcGxhY2UoLyhcXFxcLil8KFxcKCg/OlxcP1s9IV0pPyl8KFxcKSl8KFtcXFtcXF1dKS9nLCBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICBtLCBlc2MsIHBhcmVuT3BlbiwgcGFyZW5DbG9zZSwgc3F1YXJlLCBpbmRleFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluQ2hDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBpbkNoQ2xhc3MgPSBzcXVhcmUgIT0gXCJdXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcXVhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5DaENsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVuQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrID09IGxhc3RDYXB0dXJlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2FwdHVyZS5lbmQgPSBpbmRleCsxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhcHR1cmUuc3RhY2sgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFjay0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW5PcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbk9wZW4ubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDYXB0dXJlLnN0YWNrID0gc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDYXB0dXJlLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGxhc3RDYXB0dXJlLmVuZCAhPSBudWxsICYmIC9eXFwpKiQvLnRlc3Qoc3JjLnN1YnN0cihsYXN0Q2FwdHVyZS5lbmQpKSlcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKDAsIGxhc3RDYXB0dXJlLnN0YXJ0KSArIHNyYy5zdWJzdHIobGFzdENhcHR1cmUuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzcmMsIChmbGFnfHxcIlwiKS5yZXBsYWNlKFwiZ1wiLCBcIlwiKSk7XG4gICAgfTtcbiAgICB0aGlzLmdldExpbmVUb2tlbnMgPSBmdW5jdGlvbihsaW5lLCBzdGFydFN0YXRlKSB7XG4gICAgICAgIGlmIChzdGFydFN0YXRlICYmIHR5cGVvZiBzdGFydFN0YXRlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHN0YXJ0U3RhdGUuc2xpY2UoMCk7XG4gICAgICAgICAgICBzdGFydFN0YXRlID0gc3RhY2tbMF07XG4gICAgICAgICAgICBpZiAoc3RhcnRTdGF0ZSA9PT0gXCIjdG1wXCIpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpXG4gICAgICAgICAgICAgICAgc3RhcnRTdGF0ZSA9IHN0YWNrLnNoaWZ0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcblxuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gc3RhcnRTdGF0ZSB8fCBcInN0YXJ0XCI7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGVzW2N1cnJlbnRTdGF0ZV07XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZXNbY3VycmVudFN0YXRlXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMubWF0Y2hNYXBwaW5nc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICB2YXIgcmUgPSB0aGlzLnJlZ0V4cHNbY3VycmVudFN0YXRlXTtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcblxuICAgICAgICB2YXIgbWF0Y2gsIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIG1hdGNoQXR0ZW1wdHMgPSAwO1xuXG4gICAgICAgIHZhciB0b2tlbiA9IHt0eXBlOiBudWxsLCB2YWx1ZTogXCJcIn07XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhsaW5lKSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXBwaW5nLmRlZmF1bHRUb2tlbjtcbiAgICAgICAgICAgIHZhciBydWxlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggLSB2YWx1ZS5sZW5ndGggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2tpcHBlZCA9IGxpbmUuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXggLSB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgKz0gc2tpcHBlZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB7dHlwZTogdHlwZSwgdmFsdWU6IHNraXBwZWR9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGgtMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2kgKyAxXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHJ1bGUgPSBzdGF0ZVttYXBwaW5nW2ldXTtcblxuICAgICAgICAgICAgICAgIGlmIChydWxlLm9uTWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBydWxlLm9uTWF0Y2godmFsdWUsIGN1cnJlbnRTdGF0ZSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJ1bGUudG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5uZXh0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHJ1bGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHJ1bGUubmV4dChjdXJyZW50U3RhdGUsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKFwic3RhdGUgZG9lc24ndCBleGlzdFwiLCBjdXJyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLm1hdGNoTWFwcGluZ3NbY3VycmVudFN0YXRlXTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlID0gdGhpcy5yZWdFeHBzW2N1cnJlbnRTdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoIXJ1bGUgfHwgcnVsZS5tZXJnZSAhPT0gZmFsc2UpICYmIHRva2VuLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB7dHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB7dHlwZTogbnVsbCwgdmFsdWU6IFwiXCJ9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0eXBlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPT0gbGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hBdHRlbXB0cysrID4gTUFYX1RPS0VOX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoQXR0ZW1wdHMgPiAyICogbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcImluZmluaXRlIGxvb3Agd2l0aCBpbiBhY2UgdG9rZW5pemVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0U3RhdGU6IHN0YXJ0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAobGFzdEluZGV4IDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpbmUuc3Vic3RyaW5nKGxhc3RJbmRleCwgbGFzdEluZGV4ICs9IDIwMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICBzdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUpXG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHN0YWNrWzBdICE9PSBjdXJyZW50U3RhdGUpXG4gICAgICAgICAgICAgICAgc3RhY2sudW5zaGlmdChcIiN0bXBcIiwgY3VycmVudFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW5zIDogdG9rZW5zLFxuICAgICAgICAgICAgc3RhdGUgOiBzdGFjay5sZW5ndGggPyBzdGFjayA6IGN1cnJlbnRTdGF0ZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLnJlcG9ydEVycm9yID0gY29uZmlnLnJlcG9ydEVycm9yO1xuXG59KS5jYWxsKFRva2VuaXplci5wcm90b3R5cGUpO1xuXG5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL21vZGUvdGV4dF9oaWdobGlnaHRfcnVsZXNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvbGFuZ1wiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBsYW5nID0gYWNlcXVpcmUoXCIuLi9saWIvbGFuZ1wiKTtcblxudmFyIFRleHRIaWdobGlnaHRSdWxlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy4kcnVsZXMgPSB7XG4gICAgICAgIFwic3RhcnRcIiA6IFt7XG4gICAgICAgICAgICB0b2tlbiA6IFwiZW1wdHlfbGluZVwiLFxuICAgICAgICAgICAgcmVnZXggOiAnXiQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHRUb2tlbiA6IFwidGV4dFwiXG4gICAgICAgIH1dXG4gICAgfTtcbn07XG5cbihmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuYWRkUnVsZXMgPSBmdW5jdGlvbihydWxlcywgcHJlZml4KSB7XG4gICAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcnVsZXMpXG4gICAgICAgICAgICAgICAgdGhpcy4kcnVsZXNba2V5XSA9IHJ1bGVzW2tleV07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlc1trZXldO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gc3RhdGVbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dCB8fCBydWxlLm9uTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLm5leHQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dFN0YXRlICYmIHJ1bGUubmV4dFN0YXRlLmluZGV4T2YocHJlZml4KSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5leHRTdGF0ZSA9IHByZWZpeCArIHJ1bGUubmV4dFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dC5pbmRleE9mKHByZWZpeCkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0ID0gcHJlZml4ICsgcnVsZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kcnVsZXNbcHJlZml4ICsga2V5XSA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UnVsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJ1bGVzO1xuICAgIH07XG5cbiAgICB0aGlzLmVtYmVkUnVsZXMgPSBmdW5jdGlvbiAoSGlnaGxpZ2h0UnVsZXMsIHByZWZpeCwgZXNjYXBlUnVsZXMsIHN0YXRlcywgYXBwZW5kKSB7XG4gICAgICAgIHZhciBlbWJlZFJ1bGVzID0gdHlwZW9mIEhpZ2hsaWdodFJ1bGVzID09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBuZXcgSGlnaGxpZ2h0UnVsZXMoKS5nZXRSdWxlcygpXG4gICAgICAgICAgICA6IEhpZ2hsaWdodFJ1bGVzO1xuICAgICAgICBpZiAoc3RhdGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZXNbaV0gPSBwcmVmaXggKyBzdGF0ZXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlbWJlZFJ1bGVzKVxuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHByZWZpeCArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZFJ1bGVzKGVtYmVkUnVsZXMsIHByZWZpeCk7XG5cbiAgICAgICAgaWYgKGVzY2FwZVJ1bGVzKSB7XG4gICAgICAgICAgICB2YXIgYWRkUnVsZXMgPSBBcnJheS5wcm90b3R5cGVbYXBwZW5kID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBhZGRSdWxlcy5hcHBseSh0aGlzLiRydWxlc1tzdGF0ZXNbaV1dLCBsYW5nLmRlZXBDb3B5KGVzY2FwZVJ1bGVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuJGVtYmVkcylcbiAgICAgICAgICAgIHRoaXMuJGVtYmVkcyA9IFtdO1xuICAgICAgICB0aGlzLiRlbWJlZHMucHVzaChwcmVmaXgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEVtYmVkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZW1iZWRzO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaFN0YXRlID0gZnVuY3Rpb24oY3VycmVudFN0YXRlLCBzdGFjaykge1xuICAgICAgICBpZiAoY3VycmVudFN0YXRlICE9IFwic3RhcnRcIiB8fCBzdGFjay5sZW5ndGgpXG4gICAgICAgICAgICBzdGFjay51bnNoaWZ0KHRoaXMubmV4dFN0YXRlLCBjdXJyZW50U3RhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0U3RhdGU7XG4gICAgfTtcbiAgICB2YXIgcG9wU3RhdGUgPSBmdW5jdGlvbihjdXJyZW50U3RhdGUsIHN0YWNrKSB7XG4gICAgICAgIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBzdGFjay5zaGlmdCgpIHx8IFwic3RhcnRcIjtcbiAgICB9O1xuXG4gICAgdGhpcy5ub3JtYWxpemVSdWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaWQgPSAwO1xuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLiRydWxlcztcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1N0YXRlKGtleSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBzdGF0ZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUucmVnZXggJiYgcnVsZS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLnJlZ2V4ID0gcnVsZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlLm5leHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5leHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRva2VuOiBydWxlLnRva2VuXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBydWxlLnRva2VuICsgXCIuZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleDogcnVsZS5lbmQgfHwgcnVsZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IFwicG9wXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW4gPSBydWxlLnRva2VuICsgXCIuc3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5wdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBydWxlLm5leHQgfHwgcnVsZS5wdXNoO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlTmFtZSA9IHJ1bGUuc3RhdGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlTmFtZSkgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSA9IHJ1bGUudG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSA9IHN0YXRlTmFtZVswXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGVzW3N0YXRlTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lICs9IGlkKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbc3RhdGVOYW1lXSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHN0YXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1N0YXRlKHN0YXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0ID09IFwicG9wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0ID0gcG9wU3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUucHVzaCkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLm5leHRTdGF0ZSA9IHJ1bGUubmV4dCB8fCBydWxlLnB1c2g7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHB1c2hTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGUucHVzaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByIGluIHJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc1tyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc1tyXS5wdXNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlc1tyXS5wdXNoLmFwcGx5KHJ1bGVzW3JdLCBydWxlLnJ1bGVzW3JdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNbcl0gPSBydWxlLnJ1bGVzW3JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLmluY2x1ZGUgfHwgdHlwZW9mIHJ1bGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZU5hbWUgPSBydWxlLmluY2x1ZGUgfHwgcnVsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvSW5zZXJ0ID0gcnVsZXNbaW5jbHVkZU5hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShydWxlKSlcbiAgICAgICAgICAgICAgICAgICAgdG9JbnNlcnQgPSBydWxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW2ksIDFdLmNvbmNhdCh0b0luc2VydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLm5vRXNjYXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKHgpIHtyZXR1cm4gIXgubmV4dDt9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3BsaWNlLmFwcGx5KHN0YXRlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB0b0luc2VydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChydWxlLmtleXdvcmRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS50b2tlbiA9IHRoaXMuY3JlYXRlS2V5d29yZE1hcHBlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUua2V5d29yZE1hcCwgcnVsZS5kZWZhdWx0VG9rZW4gfHwgXCJ0ZXh0XCIsIHJ1bGUuY2FzZUluc2Vuc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlLmRlZmF1bHRUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMocnVsZXMpLmZvckVhY2gocHJvY2Vzc1N0YXRlLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGVLZXl3b3JkTWFwcGVyID0gZnVuY3Rpb24obWFwLCBkZWZhdWx0VG9rZW4sIGlnbm9yZUNhc2UsIHNwbGl0Q2hhcikge1xuICAgICAgICB2YXIga2V5d29yZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YXIgYSA9IG1hcFtjbGFzc05hbWVdO1xuICAgICAgICAgICAgaWYgKGlnbm9yZUNhc2UpXG4gICAgICAgICAgICAgICAgYSA9IGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gYS5zcGxpdChzcGxpdENoYXIgfHwgXCJ8XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07IClcbiAgICAgICAgICAgICAgICBrZXl3b3Jkc1tsaXN0W2ldXSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2V5d29yZHMpKSB7XG4gICAgICAgICAgICBrZXl3b3Jkcy5fX3Byb3RvX18gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGtleXdvcmRMaXN0ID0gT2JqZWN0LmtleXMoa2V5d29yZHMpO1xuICAgICAgICBtYXAgPSBudWxsO1xuICAgICAgICByZXR1cm4gaWdub3JlQ2FzZVxuICAgICAgICAgICAgPyBmdW5jdGlvbih2YWx1ZSkge3JldHVybiBrZXl3b3Jkc1t2YWx1ZS50b0xvd2VyQ2FzZSgpXSB8fCBkZWZhdWx0VG9rZW4gfVxuICAgICAgICAgICAgOiBmdW5jdGlvbih2YWx1ZSkge3JldHVybiBrZXl3b3Jkc1t2YWx1ZV0gfHwgZGVmYXVsdFRva2VuIH07XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0S2V5d29yZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGtleXdvcmRzO1xuICAgIH07XG5cbn0pLmNhbGwoVGV4dEhpZ2hsaWdodFJ1bGVzLnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuVGV4dEhpZ2hsaWdodFJ1bGVzID0gVGV4dEhpZ2hsaWdodFJ1bGVzO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS9iZWhhdmlvdXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgQmVoYXZpb3VyID0gZnVuY3Rpb24oKSB7XG4gICB0aGlzLiRiZWhhdmlvdXJzID0ge307XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbiAobmFtZSwgYWN0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBzd2l0Y2ggKHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhc2UgdGhpcy4kYmVoYXZpb3VyczpcbiAgICAgICAgICAgICAgdGhpcy4kYmVoYXZpb3VycyA9IHt9O1xuICAgICAgICAgIGNhc2UgdGhpcy4kYmVoYXZpb3Vyc1tuYW1lXTpcbiAgICAgICAgICAgICAgdGhpcy4kYmVoYXZpb3Vyc1tuYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGJlaGF2aW91cnNbbmFtZV1bYWN0aW9uXSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmFkZEJlaGF2aW91cnMgPSBmdW5jdGlvbiAoYmVoYXZpb3Vycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmVoYXZpb3Vycykge1xuICAgICAgICAgICAgZm9yICh2YXIgYWN0aW9uIGluIGJlaGF2aW91cnNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGtleSwgYWN0aW9uLCBiZWhhdmlvdXJzW2tleV1bYWN0aW9uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy4kYmVoYXZpb3VycyAmJiB0aGlzLiRiZWhhdmlvdXJzW25hbWVdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy4kYmVoYXZpb3Vyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmluaGVyaXQgPSBmdW5jdGlvbiAobW9kZSwgZmlsdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgYmVoYXZpb3VycyA9IG5ldyBtb2RlKCkuZ2V0QmVoYXZpb3VycyhmaWx0ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW91cnMgPSBtb2RlLmdldEJlaGF2aW91cnMoZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEJlaGF2aW91cnMoYmVoYXZpb3Vycyk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZ2V0QmVoYXZpb3VycyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRiZWhhdmlvdXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJldCA9IHt9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRiZWhhdmlvdXJzW2ZpbHRlcltpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ZpbHRlcltpXV0gPSB0aGlzLiRiZWhhdmlvdXJzW2ZpbHRlcltpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgIH1cblxufSkuY2FsbChCZWhhdmlvdXIucHJvdG90eXBlKTtcblxuZXhwb3J0cy5CZWhhdmlvdXIgPSBCZWhhdmlvdXI7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS91bmljb2RlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMucGFja2FnZXMgPSB7fTtcblxuYWRkVW5pY29kZVBhY2thZ2Uoe1xuICAgIEw6ICBcIjAwNDEtMDA1QTAwNjEtMDA3QTAwQUEwMEI1MDBCQTAwQzAtMDBENjAwRDgtMDBGNjAwRjgtMDJDMTAyQzYtMDJEMTAyRTAtMDJFNDAyRUMwMkVFMDM3MC0wMzc0MDM3NjAzNzcwMzdBLTAzN0QwMzg2MDM4OC0wMzhBMDM4QzAzOEUtMDNBMTAzQTMtMDNGNTAzRjctMDQ4MTA0OEEtMDUyNTA1MzEtMDU1NjA1NTkwNTYxLTA1ODcwNUQwLTA1RUEwNUYwLTA1RjIwNjIxLTA2NEEwNjZFMDY2RjA2NzEtMDZEMzA2RDUwNkU1MDZFNjA2RUUwNkVGMDZGQS0wNkZDMDZGRjA3MTAwNzEyLTA3MkYwNzRELTA3QTUwN0IxMDdDQS0wN0VBMDdGNDA3RjUwN0ZBMDgwMC0wODE1MDgxQTA4MjQwODI4MDkwNC0wOTM5MDkzRDA5NTAwOTU4LTA5NjEwOTcxMDk3MjA5NzktMDk3RjA5ODUtMDk4QzA5OEYwOTkwMDk5My0wOUE4MDlBQS0wOUIwMDlCMjA5QjYtMDlCOTA5QkQwOUNFMDlEQzA5REQwOURGLTA5RTEwOUYwMDlGMTBBMDUtMEEwQTBBMEYwQTEwMEExMy0wQTI4MEEyQS0wQTMwMEEzMjBBMzMwQTM1MEEzNjBBMzgwQTM5MEE1OS0wQTVDMEE1RTBBNzItMEE3NDBBODUtMEE4RDBBOEYtMEE5MTBBOTMtMEFBODBBQUEtMEFCMDBBQjIwQUIzMEFCNS0wQUI5MEFCRDBBRDAwQUUwMEFFMTBCMDUtMEIwQzBCMEYwQjEwMEIxMy0wQjI4MEIyQS0wQjMwMEIzMjBCMzMwQjM1LTBCMzkwQjNEMEI1QzBCNUQwQjVGLTBCNjEwQjcxMEI4MzBCODUtMEI4QTBCOEUtMEI5MDBCOTItMEI5NTBCOTkwQjlBMEI5QzBCOUUwQjlGMEJBMzBCQTQwQkE4LTBCQUEwQkFFLTBCQjkwQkQwMEMwNS0wQzBDMEMwRS0wQzEwMEMxMi0wQzI4MEMyQS0wQzMzMEMzNS0wQzM5MEMzRDBDNTgwQzU5MEM2MDBDNjEwQzg1LTBDOEMwQzhFLTBDOTAwQzkyLTBDQTgwQ0FBLTBDQjMwQ0I1LTBDQjkwQ0JEMENERTBDRTAwQ0UxMEQwNS0wRDBDMEQwRS0wRDEwMEQxMi0wRDI4MEQyQS0wRDM5MEQzRDBENjAwRDYxMEQ3QS0wRDdGMEQ4NS0wRDk2MEQ5QS0wREIxMERCMy0wREJCMERCRDBEQzAtMERDNjBFMDEtMEUzMDBFMzIwRTMzMEU0MC0wRTQ2MEU4MTBFODIwRTg0MEU4NzBFODgwRThBMEU4RDBFOTQtMEU5NzBFOTktMEU5RjBFQTEtMEVBMzBFQTUwRUE3MEVBQTBFQUIwRUFELTBFQjAwRUIyMEVCMzBFQkQwRUMwLTBFQzQwRUM2MEVEQzBFREQwRjAwMEY0MC0wRjQ3MEY0OS0wRjZDMEY4OC0wRjhCMTAwMC0xMDJBMTAzRjEwNTAtMTA1NTEwNUEtMTA1RDEwNjExMDY1MTA2NjEwNkUtMTA3MDEwNzUtMTA4MTEwOEUxMEEwLTEwQzUxMEQwLTEwRkExMEZDMTEwMC0xMjQ4MTI0QS0xMjREMTI1MC0xMjU2MTI1ODEyNUEtMTI1RDEyNjAtMTI4ODEyOEEtMTI4RDEyOTAtMTJCMDEyQjItMTJCNTEyQjgtMTJCRTEyQzAxMkMyLTEyQzUxMkM4LTEyRDYxMkQ4LTEzMTAxMzEyLTEzMTUxMzE4LTEzNUExMzgwLTEzOEYxM0EwLTEzRjQxNDAxLTE2NkMxNjZGLTE2N0YxNjgxLTE2OUExNkEwLTE2RUExNzAwLTE3MEMxNzBFLTE3MTExNzIwLTE3MzExNzQwLTE3NTExNzYwLTE3NkMxNzZFLTE3NzAxNzgwLTE3QjMxN0Q3MTdEQzE4MjAtMTg3NzE4ODAtMThBODE4QUExOEIwLTE4RjUxOTAwLTE5MUMxOTUwLTE5NkQxOTcwLTE5NzQxOTgwLTE5QUIxOUMxLTE5QzcxQTAwLTFBMTYxQTIwLTFBNTQxQUE3MUIwNS0xQjMzMUI0NS0xQjRCMUI4My0xQkEwMUJBRTFCQUYxQzAwLTFDMjMxQzRELTFDNEYxQzVBLTFDN0QxQ0U5LTFDRUMxQ0VFLTFDRjExRDAwLTFEQkYxRTAwLTFGMTUxRjE4LTFGMUQxRjIwLTFGNDUxRjQ4LTFGNEQxRjUwLTFGNTcxRjU5MUY1QjFGNUQxRjVGLTFGN0QxRjgwLTFGQjQxRkI2LTFGQkMxRkJFMUZDMi0xRkM0MUZDNi0xRkNDMUZEMC0xRkQzMUZENi0xRkRCMUZFMC0xRkVDMUZGMi0xRkY0MUZGNi0xRkZDMjA3MTIwN0YyMDkwLTIwOTQyMTAyMjEwNzIxMEEtMjExMzIxMTUyMTE5LTIxMUQyMTI0MjEyNjIxMjgyMTJBLTIxMkQyMTJGLTIxMzkyMTNDLTIxM0YyMTQ1LTIxNDkyMTRFMjE4MzIxODQyQzAwLTJDMkUyQzMwLTJDNUUyQzYwLTJDRTQyQ0VCLTJDRUUyRDAwLTJEMjUyRDMwLTJENjUyRDZGMkQ4MC0yRDk2MkRBMC0yREE2MkRBOC0yREFFMkRCMC0yREI2MkRCOC0yREJFMkRDMC0yREM2MkRDOC0yRENFMkREMC0yREQ2MkREOC0yRERFMkUyRjMwMDUzMDA2MzAzMS0zMDM1MzAzQjMwM0MzMDQxLTMwOTYzMDlELTMwOUYzMEExLTMwRkEzMEZDLTMwRkYzMTA1LTMxMkQzMTMxLTMxOEUzMUEwLTMxQjczMUYwLTMxRkYzNDAwLTREQjU0RTAwLTlGQ0JBMDAwLUE0OENBNEQwLUE0RkRBNTAwLUE2MENBNjEwLUE2MUZBNjJBQTYyQkE2NDAtQTY1RkE2NjItQTY2RUE2N0YtQTY5N0E2QTAtQTZFNUE3MTctQTcxRkE3MjItQTc4OEE3OEJBNzhDQTdGQi1BODAxQTgwMy1BODA1QTgwNy1BODBBQTgwQy1BODIyQTg0MC1BODczQTg4Mi1BOEIzQThGMi1BOEY3QThGQkE5MEEtQTkyNUE5MzAtQTk0NkE5NjAtQTk3Q0E5ODQtQTlCMkE5Q0ZBQTAwLUFBMjhBQTQwLUFBNDJBQTQ0LUFBNEJBQTYwLUFBNzZBQTdBQUE4MC1BQUFGQUFCMUFBQjVBQUI2QUFCOS1BQUJEQUFDMEFBQzJBQURCLUFBRERBQkMwLUFCRTJBQzAwLUQ3QTNEN0IwLUQ3QzZEN0NCLUQ3RkJGOTAwLUZBMkRGQTMwLUZBNkRGQTcwLUZBRDlGQjAwLUZCMDZGQjEzLUZCMTdGQjFERkIxRi1GQjI4RkIyQS1GQjM2RkIzOC1GQjNDRkIzRUZCNDBGQjQxRkI0M0ZCNDRGQjQ2LUZCQjFGQkQzLUZEM0RGRDUwLUZEOEZGRDkyLUZEQzdGREYwLUZERkJGRTcwLUZFNzRGRTc2LUZFRkNGRjIxLUZGM0FGRjQxLUZGNUFGRjY2LUZGQkVGRkMyLUZGQzdGRkNBLUZGQ0ZGRkQyLUZGRDdGRkRBLUZGRENcIixcbiAgICBMbDogXCIwMDYxLTAwN0EwMEFBMDBCNTAwQkEwMERGLTAwRjYwMEY4LTAwRkYwMTAxMDEwMzAxMDUwMTA3MDEwOTAxMEIwMTBEMDEwRjAxMTEwMTEzMDExNTAxMTcwMTE5MDExQjAxMUQwMTFGMDEyMTAxMjMwMTI1MDEyNzAxMjkwMTJCMDEyRDAxMkYwMTMxMDEzMzAxMzUwMTM3MDEzODAxM0EwMTNDMDEzRTAxNDAwMTQyMDE0NDAxNDYwMTQ4MDE0OTAxNEIwMTREMDE0RjAxNTEwMTUzMDE1NTAxNTcwMTU5MDE1QjAxNUQwMTVGMDE2MTAxNjMwMTY1MDE2NzAxNjkwMTZCMDE2RDAxNkYwMTcxMDE3MzAxNzUwMTc3MDE3QTAxN0MwMTdFLTAxODAwMTgzMDE4NTAxODgwMThDMDE4RDAxOTIwMTk1MDE5OS0wMTlCMDE5RTAxQTEwMUEzMDFBNTAxQTgwMUFBMDFBQjAxQUQwMUIwMDFCNDAxQjYwMUI5MDFCQTAxQkQtMDFCRjAxQzYwMUM5MDFDQzAxQ0UwMUQwMDFEMjAxRDQwMUQ2MDFEODAxREEwMURDMDFERDAxREYwMUUxMDFFMzAxRTUwMUU3MDFFOTAxRUIwMUVEMDFFRjAxRjAwMUYzMDFGNTAxRjkwMUZCMDFGRDAxRkYwMjAxMDIwMzAyMDUwMjA3MDIwOTAyMEIwMjBEMDIwRjAyMTEwMjEzMDIxNTAyMTcwMjE5MDIxQjAyMUQwMjFGMDIyMTAyMjMwMjI1MDIyNzAyMjkwMjJCMDIyRDAyMkYwMjMxMDIzMy0wMjM5MDIzQzAyM0YwMjQwMDI0MjAyNDcwMjQ5MDI0QjAyNEQwMjRGLTAyOTMwMjk1LTAyQUYwMzcxMDM3MzAzNzcwMzdCLTAzN0QwMzkwMDNBQy0wM0NFMDNEMDAzRDEwM0Q1LTAzRDcwM0Q5MDNEQjAzREQwM0RGMDNFMTAzRTMwM0U1MDNFNzAzRTkwM0VCMDNFRDAzRUYtMDNGMzAzRjUwM0Y4MDNGQjAzRkMwNDMwLTA0NUYwNDYxMDQ2MzA0NjUwNDY3MDQ2OTA0NkIwNDZEMDQ2RjA0NzEwNDczMDQ3NTA0NzcwNDc5MDQ3QjA0N0QwNDdGMDQ4MTA0OEIwNDhEMDQ4RjA0OTEwNDkzMDQ5NTA0OTcwNDk5MDQ5QjA0OUQwNDlGMDRBMTA0QTMwNEE1MDRBNzA0QTkwNEFCMDRBRDA0QUYwNEIxMDRCMzA0QjUwNEI3MDRCOTA0QkIwNEJEMDRCRjA0QzIwNEM0MDRDNjA0QzgwNENBMDRDQzA0Q0UwNENGMDREMTA0RDMwNEQ1MDRENzA0RDkwNERCMDRERDA0REYwNEUxMDRFMzA0RTUwNEU3MDRFOTA0RUIwNEVEMDRFRjA0RjEwNEYzMDRGNTA0RjcwNEY5MDRGQjA0RkQwNEZGMDUwMTA1MDMwNTA1MDUwNzA1MDkwNTBCMDUwRDA1MEYwNTExMDUxMzA1MTUwNTE3MDUxOTA1MUIwNTFEMDUxRjA1MjEwNTIzMDUyNTA1NjEtMDU4NzFEMDAtMUQyQjFENjItMUQ3NzFENzktMUQ5QTFFMDExRTAzMUUwNTFFMDcxRTA5MUUwQjFFMEQxRTBGMUUxMTFFMTMxRTE1MUUxNzFFMTkxRTFCMUUxRDFFMUYxRTIxMUUyMzFFMjUxRTI3MUUyOTFFMkIxRTJEMUUyRjFFMzExRTMzMUUzNTFFMzcxRTM5MUUzQjFFM0QxRTNGMUU0MTFFNDMxRTQ1MUU0NzFFNDkxRTRCMUU0RDFFNEYxRTUxMUU1MzFFNTUxRTU3MUU1OTFFNUIxRTVEMUU1RjFFNjExRTYzMUU2NTFFNjcxRTY5MUU2QjFFNkQxRTZGMUU3MTFFNzMxRTc1MUU3NzFFNzkxRTdCMUU3RDFFN0YxRTgxMUU4MzFFODUxRTg3MUU4OTFFOEIxRThEMUU4RjFFOTExRTkzMUU5NS0xRTlEMUU5RjFFQTExRUEzMUVBNTFFQTcxRUE5MUVBQjFFQUQxRUFGMUVCMTFFQjMxRUI1MUVCNzFFQjkxRUJCMUVCRDFFQkYxRUMxMUVDMzFFQzUxRUM3MUVDOTFFQ0IxRUNEMUVDRjFFRDExRUQzMUVENTFFRDcxRUQ5MUVEQjFFREQxRURGMUVFMTFFRTMxRUU1MUVFNzFFRTkxRUVCMUVFRDFFRUYxRUYxMUVGMzFFRjUxRUY3MUVGOTFFRkIxRUZEMUVGRi0xRjA3MUYxMC0xRjE1MUYyMC0xRjI3MUYzMC0xRjM3MUY0MC0xRjQ1MUY1MC0xRjU3MUY2MC0xRjY3MUY3MC0xRjdEMUY4MC0xRjg3MUY5MC0xRjk3MUZBMC0xRkE3MUZCMC0xRkI0MUZCNjFGQjcxRkJFMUZDMi0xRkM0MUZDNjFGQzcxRkQwLTFGRDMxRkQ2MUZENzFGRTAtMUZFNzFGRjItMUZGNDFGRjYxRkY3MjEwQTIxMEUyMTBGMjExMzIxMkYyMTM0MjEzOTIxM0MyMTNEMjE0Ni0yMTQ5MjE0RTIxODQyQzMwLTJDNUUyQzYxMkM2NTJDNjYyQzY4MkM2QTJDNkMyQzcxMkM3MzJDNzQyQzc2LTJDN0MyQzgxMkM4MzJDODUyQzg3MkM4OTJDOEIyQzhEMkM4RjJDOTEyQzkzMkM5NTJDOTcyQzk5MkM5QjJDOUQyQzlGMkNBMTJDQTMyQ0E1MkNBNzJDQTkyQ0FCMkNBRDJDQUYyQ0IxMkNCMzJDQjUyQ0I3MkNCOTJDQkIyQ0JEMkNCRjJDQzEyQ0MzMkNDNTJDQzcyQ0M5MkNDQjJDQ0QyQ0NGMkNEMTJDRDMyQ0Q1MkNENzJDRDkyQ0RCMkNERDJDREYyQ0UxMkNFMzJDRTQyQ0VDMkNFRTJEMDAtMkQyNUE2NDFBNjQzQTY0NUE2NDdBNjQ5QTY0QkE2NERBNjRGQTY1MUE2NTNBNjU1QTY1N0E2NTlBNjVCQTY1REE2NUZBNjYzQTY2NUE2NjdBNjY5QTY2QkE2NkRBNjgxQTY4M0E2ODVBNjg3QTY4OUE2OEJBNjhEQTY4RkE2OTFBNjkzQTY5NUE2OTdBNzIzQTcyNUE3MjdBNzI5QTcyQkE3MkRBNzJGLUE3MzFBNzMzQTczNUE3MzdBNzM5QTczQkE3M0RBNzNGQTc0MUE3NDNBNzQ1QTc0N0E3NDlBNzRCQTc0REE3NEZBNzUxQTc1M0E3NTVBNzU3QTc1OUE3NUJBNzVEQTc1RkE3NjFBNzYzQTc2NUE3NjdBNzY5QTc2QkE3NkRBNzZGQTc3MS1BNzc4QTc3QUE3N0NBNzdGQTc4MUE3ODNBNzg1QTc4N0E3OENGQjAwLUZCMDZGQjEzLUZCMTdGRjQxLUZGNUFcIixcbiAgICBMdTogXCIwMDQxLTAwNUEwMEMwLTAwRDYwMEQ4LTAwREUwMTAwMDEwMjAxMDQwMTA2MDEwODAxMEEwMTBDMDEwRTAxMTAwMTEyMDExNDAxMTYwMTE4MDExQTAxMUMwMTFFMDEyMDAxMjIwMTI0MDEyNjAxMjgwMTJBMDEyQzAxMkUwMTMwMDEzMjAxMzQwMTM2MDEzOTAxM0IwMTNEMDEzRjAxNDEwMTQzMDE0NTAxNDcwMTRBMDE0QzAxNEUwMTUwMDE1MjAxNTQwMTU2MDE1ODAxNUEwMTVDMDE1RTAxNjAwMTYyMDE2NDAxNjYwMTY4MDE2QTAxNkMwMTZFMDE3MDAxNzIwMTc0MDE3NjAxNzgwMTc5MDE3QjAxN0QwMTgxMDE4MjAxODQwMTg2MDE4NzAxODktMDE4QjAxOEUtMDE5MTAxOTMwMTk0MDE5Ni0wMTk4MDE5QzAxOUQwMTlGMDFBMDAxQTIwMUE0MDFBNjAxQTcwMUE5MDFBQzAxQUUwMUFGMDFCMS0wMUIzMDFCNTAxQjcwMUI4MDFCQzAxQzQwMUM3MDFDQTAxQ0QwMUNGMDFEMTAxRDMwMUQ1MDFENzAxRDkwMURCMDFERTAxRTAwMUUyMDFFNDAxRTYwMUU4MDFFQTAxRUMwMUVFMDFGMTAxRjQwMUY2LTAxRjgwMUZBMDFGQzAxRkUwMjAwMDIwMjAyMDQwMjA2MDIwODAyMEEwMjBDMDIwRTAyMTAwMjEyMDIxNDAyMTYwMjE4MDIxQTAyMUMwMjFFMDIyMDAyMjIwMjI0MDIyNjAyMjgwMjJBMDIyQzAyMkUwMjMwMDIzMjAyM0EwMjNCMDIzRDAyM0UwMjQxMDI0My0wMjQ2MDI0ODAyNEEwMjRDMDI0RTAzNzAwMzcyMDM3NjAzODYwMzg4LTAzOEEwMzhDMDM4RTAzOEYwMzkxLTAzQTEwM0EzLTAzQUIwM0NGMDNEMi0wM0Q0MDNEODAzREEwM0RDMDNERTAzRTAwM0UyMDNFNDAzRTYwM0U4MDNFQTAzRUMwM0VFMDNGNDAzRjcwM0Y5MDNGQTAzRkQtMDQyRjA0NjAwNDYyMDQ2NDA0NjYwNDY4MDQ2QTA0NkMwNDZFMDQ3MDA0NzIwNDc0MDQ3NjA0NzgwNDdBMDQ3QzA0N0UwNDgwMDQ4QTA0OEMwNDhFMDQ5MDA0OTIwNDk0MDQ5NjA0OTgwNDlBMDQ5QzA0OUUwNEEwMDRBMjA0QTQwNEE2MDRBODA0QUEwNEFDMDRBRTA0QjAwNEIyMDRCNDA0QjYwNEI4MDRCQTA0QkMwNEJFMDRDMDA0QzEwNEMzMDRDNTA0QzcwNEM5MDRDQjA0Q0QwNEQwMDREMjA0RDQwNEQ2MDREODA0REEwNERDMDRERTA0RTAwNEUyMDRFNDA0RTYwNEU4MDRFQTA0RUMwNEVFMDRGMDA0RjIwNEY0MDRGNjA0RjgwNEZBMDRGQzA0RkUwNTAwMDUwMjA1MDQwNTA2MDUwODA1MEEwNTBDMDUwRTA1MTAwNTEyMDUxNDA1MTYwNTE4MDUxQTA1MUMwNTFFMDUyMDA1MjIwNTI0MDUzMS0wNTU2MTBBMC0xMEM1MUUwMDFFMDIxRTA0MUUwNjFFMDgxRTBBMUUwQzFFMEUxRTEwMUUxMjFFMTQxRTE2MUUxODFFMUExRTFDMUUxRTFFMjAxRTIyMUUyNDFFMjYxRTI4MUUyQTFFMkMxRTJFMUUzMDFFMzIxRTM0MUUzNjFFMzgxRTNBMUUzQzFFM0UxRTQwMUU0MjFFNDQxRTQ2MUU0ODFFNEExRTRDMUU0RTFFNTAxRTUyMUU1NDFFNTYxRTU4MUU1QTFFNUMxRTVFMUU2MDFFNjIxRTY0MUU2NjFFNjgxRTZBMUU2QzFFNkUxRTcwMUU3MjFFNzQxRTc2MUU3ODFFN0ExRTdDMUU3RTFFODAxRTgyMUU4NDFFODYxRTg4MUU4QTFFOEMxRThFMUU5MDFFOTIxRTk0MUU5RTFFQTAxRUEyMUVBNDFFQTYxRUE4MUVBQTFFQUMxRUFFMUVCMDFFQjIxRUI0MUVCNjFFQjgxRUJBMUVCQzFFQkUxRUMwMUVDMjFFQzQxRUM2MUVDODFFQ0ExRUNDMUVDRTFFRDAxRUQyMUVENDFFRDYxRUQ4MUVEQTFFREMxRURFMUVFMDFFRTIxRUU0MUVFNjFFRTgxRUVBMUVFQzFFRUUxRUYwMUVGMjFFRjQxRUY2MUVGODFFRkExRUZDMUVGRTFGMDgtMUYwRjFGMTgtMUYxRDFGMjgtMUYyRjFGMzgtMUYzRjFGNDgtMUY0RDFGNTkxRjVCMUY1RDFGNUYxRjY4LTFGNkYxRkI4LTFGQkIxRkM4LTFGQ0IxRkQ4LTFGREIxRkU4LTFGRUMxRkY4LTFGRkIyMTAyMjEwNzIxMEItMjEwRDIxMTAtMjExMjIxMTUyMTE5LTIxMUQyMTI0MjEyNjIxMjgyMTJBLTIxMkQyMTMwLTIxMzMyMTNFMjEzRjIxNDUyMTgzMkMwMC0yQzJFMkM2MDJDNjItMkM2NDJDNjcyQzY5MkM2QjJDNkQtMkM3MDJDNzIyQzc1MkM3RS0yQzgwMkM4MjJDODQyQzg2MkM4ODJDOEEyQzhDMkM4RTJDOTAyQzkyMkM5NDJDOTYyQzk4MkM5QTJDOUMyQzlFMkNBMDJDQTIyQ0E0MkNBNjJDQTgyQ0FBMkNBQzJDQUUyQ0IwMkNCMjJDQjQyQ0I2MkNCODJDQkEyQ0JDMkNCRTJDQzAyQ0MyMkNDNDJDQzYyQ0M4MkNDQTJDQ0MyQ0NFMkNEMDJDRDIyQ0Q0MkNENjJDRDgyQ0RBMkNEQzJDREUyQ0UwMkNFMjJDRUIyQ0VEQTY0MEE2NDJBNjQ0QTY0NkE2NDhBNjRBQTY0Q0E2NEVBNjUwQTY1MkE2NTRBNjU2QTY1OEE2NUFBNjVDQTY1RUE2NjJBNjY0QTY2NkE2NjhBNjZBQTY2Q0E2ODBBNjgyQTY4NEE2ODZBNjg4QTY4QUE2OENBNjhFQTY5MEE2OTJBNjk0QTY5NkE3MjJBNzI0QTcyNkE3MjhBNzJBQTcyQ0E3MkVBNzMyQTczNEE3MzZBNzM4QTczQUE3M0NBNzNFQTc0MEE3NDJBNzQ0QTc0NkE3NDhBNzRBQTc0Q0E3NEVBNzUwQTc1MkE3NTRBNzU2QTc1OEE3NUFBNzVDQTc1RUE3NjBBNzYyQTc2NEE3NjZBNzY4QTc2QUE3NkNBNzZFQTc3OUE3N0JBNzdEQTc3RUE3ODBBNzgyQTc4NEE3ODZBNzhCRkYyMS1GRjNBXCIsXG4gICAgTHQ6IFwiMDFDNTAxQzgwMUNCMDFGMjFGODgtMUY4RjFGOTgtMUY5RjFGQTgtMUZBRjFGQkMxRkNDMUZGQ1wiLFxuICAgIExtOiBcIjAyQjAtMDJDMTAyQzYtMDJEMTAyRTAtMDJFNDAyRUMwMkVFMDM3NDAzN0EwNTU5MDY0MDA2RTUwNkU2MDdGNDA3RjUwN0ZBMDgxQTA4MjQwODI4MDk3MTBFNDYwRUM2MTBGQzE3RDcxODQzMUFBNzFDNzgtMUM3RDFEMkMtMUQ2MTFENzgxRDlCLTFEQkYyMDcxMjA3RjIwOTAtMjA5NDJDN0QyRDZGMkUyRjMwMDUzMDMxLTMwMzUzMDNCMzA5RDMwOUUzMEZDLTMwRkVBMDE1QTRGOC1BNEZEQTYwQ0E2N0ZBNzE3LUE3MUZBNzcwQTc4OEE5Q0ZBQTcwQUFEREZGNzBGRjlFRkY5RlwiLFxuICAgIExvOiBcIjAxQkIwMUMwLTAxQzMwMjk0MDVEMC0wNUVBMDVGMC0wNUYyMDYyMS0wNjNGMDY0MS0wNjRBMDY2RTA2NkYwNjcxLTA2RDMwNkQ1MDZFRTA2RUYwNkZBLTA2RkMwNkZGMDcxMDA3MTItMDcyRjA3NEQtMDdBNTA3QjEwN0NBLTA3RUEwODAwLTA4MTUwOTA0LTA5MzkwOTNEMDk1MDA5NTgtMDk2MTA5NzIwOTc5LTA5N0YwOTg1LTA5OEMwOThGMDk5MDA5OTMtMDlBODA5QUEtMDlCMDA5QjIwOUI2LTA5QjkwOUJEMDlDRTA5REMwOUREMDlERi0wOUUxMDlGMDA5RjEwQTA1LTBBMEEwQTBGMEExMDBBMTMtMEEyODBBMkEtMEEzMDBBMzIwQTMzMEEzNTBBMzYwQTM4MEEzOTBBNTktMEE1QzBBNUUwQTcyLTBBNzQwQTg1LTBBOEQwQThGLTBBOTEwQTkzLTBBQTgwQUFBLTBBQjAwQUIyMEFCMzBBQjUtMEFCOTBBQkQwQUQwMEFFMDBBRTEwQjA1LTBCMEMwQjBGMEIxMDBCMTMtMEIyODBCMkEtMEIzMDBCMzIwQjMzMEIzNS0wQjM5MEIzRDBCNUMwQjVEMEI1Ri0wQjYxMEI3MTBCODMwQjg1LTBCOEEwQjhFLTBCOTAwQjkyLTBCOTUwQjk5MEI5QTBCOUMwQjlFMEI5RjBCQTMwQkE0MEJBOC0wQkFBMEJBRS0wQkI5MEJEMDBDMDUtMEMwQzBDMEUtMEMxMDBDMTItMEMyODBDMkEtMEMzMzBDMzUtMEMzOTBDM0QwQzU4MEM1OTBDNjAwQzYxMEM4NS0wQzhDMEM4RS0wQzkwMEM5Mi0wQ0E4MENBQS0wQ0IzMENCNS0wQ0I5MENCRDBDREUwQ0UwMENFMTBEMDUtMEQwQzBEMEUtMEQxMDBEMTItMEQyODBEMkEtMEQzOTBEM0QwRDYwMEQ2MTBEN0EtMEQ3RjBEODUtMEQ5NjBEOUEtMERCMTBEQjMtMERCQjBEQkQwREMwLTBEQzYwRTAxLTBFMzAwRTMyMEUzMzBFNDAtMEU0NTBFODEwRTgyMEU4NDBFODcwRTg4MEU4QTBFOEQwRTk0LTBFOTcwRTk5LTBFOUYwRUExLTBFQTMwRUE1MEVBNzBFQUEwRUFCMEVBRC0wRUIwMEVCMjBFQjMwRUJEMEVDMC0wRUM0MEVEQzBFREQwRjAwMEY0MC0wRjQ3MEY0OS0wRjZDMEY4OC0wRjhCMTAwMC0xMDJBMTAzRjEwNTAtMTA1NTEwNUEtMTA1RDEwNjExMDY1MTA2NjEwNkUtMTA3MDEwNzUtMTA4MTEwOEUxMEQwLTEwRkExMTAwLTEyNDgxMjRBLTEyNEQxMjUwLTEyNTYxMjU4MTI1QS0xMjVEMTI2MC0xMjg4MTI4QS0xMjhEMTI5MC0xMkIwMTJCMi0xMkI1MTJCOC0xMkJFMTJDMDEyQzItMTJDNTEyQzgtMTJENjEyRDgtMTMxMDEzMTItMTMxNTEzMTgtMTM1QTEzODAtMTM4RjEzQTAtMTNGNDE0MDEtMTY2QzE2NkYtMTY3RjE2ODEtMTY5QTE2QTAtMTZFQTE3MDAtMTcwQzE3MEUtMTcxMTE3MjAtMTczMTE3NDAtMTc1MTE3NjAtMTc2QzE3NkUtMTc3MDE3ODAtMTdCMzE3REMxODIwLTE4NDIxODQ0LTE4NzcxODgwLTE4QTgxOEFBMThCMC0xOEY1MTkwMC0xOTFDMTk1MC0xOTZEMTk3MC0xOTc0MTk4MC0xOUFCMTlDMS0xOUM3MUEwMC0xQTE2MUEyMC0xQTU0MUIwNS0xQjMzMUI0NS0xQjRCMUI4My0xQkEwMUJBRTFCQUYxQzAwLTFDMjMxQzRELTFDNEYxQzVBLTFDNzcxQ0U5LTFDRUMxQ0VFLTFDRjEyMTM1LTIxMzgyRDMwLTJENjUyRDgwLTJEOTYyREEwLTJEQTYyREE4LTJEQUUyREIwLTJEQjYyREI4LTJEQkUyREMwLTJEQzYyREM4LTJEQ0UyREQwLTJERDYyREQ4LTJEREUzMDA2MzAzQzMwNDEtMzA5NjMwOUYzMEExLTMwRkEzMEZGMzEwNS0zMTJEMzEzMS0zMThFMzFBMC0zMUI3MzFGMC0zMUZGMzQwMC00REI1NEUwMC05RkNCQTAwMC1BMDE0QTAxNi1BNDhDQTREMC1BNEY3QTUwMC1BNjBCQTYxMC1BNjFGQTYyQUE2MkJBNjZFQTZBMC1BNkU1QTdGQi1BODAxQTgwMy1BODA1QTgwNy1BODBBQTgwQy1BODIyQTg0MC1BODczQTg4Mi1BOEIzQThGMi1BOEY3QThGQkE5MEEtQTkyNUE5MzAtQTk0NkE5NjAtQTk3Q0E5ODQtQTlCMkFBMDAtQUEyOEFBNDAtQUE0MkFBNDQtQUE0QkFBNjAtQUE2RkFBNzEtQUE3NkFBN0FBQTgwLUFBQUZBQUIxQUFCNUFBQjZBQUI5LUFBQkRBQUMwQUFDMkFBREJBQURDQUJDMC1BQkUyQUMwMC1EN0EzRDdCMC1EN0M2RDdDQi1EN0ZCRjkwMC1GQTJERkEzMC1GQTZERkE3MC1GQUQ5RkIxREZCMUYtRkIyOEZCMkEtRkIzNkZCMzgtRkIzQ0ZCM0VGQjQwRkI0MUZCNDNGQjQ0RkI0Ni1GQkIxRkJEMy1GRDNERkQ1MC1GRDhGRkQ5Mi1GREM3RkRGMC1GREZCRkU3MC1GRTc0RkU3Ni1GRUZDRkY2Ni1GRjZGRkY3MS1GRjlERkZBMC1GRkJFRkZDMi1GRkM3RkZDQS1GRkNGRkZEMi1GRkQ3RkZEQS1GRkRDXCIsXG4gICAgTTogIFwiMDMwMC0wMzZGMDQ4My0wNDg5MDU5MS0wNUJEMDVCRjA1QzEwNUMyMDVDNDA1QzUwNUM3MDYxMC0wNjFBMDY0Qi0wNjVFMDY3MDA2RDYtMDZEQzA2REUtMDZFNDA2RTcwNkU4MDZFQS0wNkVEMDcxMTA3MzAtMDc0QTA3QTYtMDdCMDA3RUItMDdGMzA4MTYtMDgxOTA4MUItMDgyMzA4MjUtMDgyNzA4MjktMDgyRDA5MDAtMDkwMzA5M0MwOTNFLTA5NEUwOTUxLTA5NTUwOTYyMDk2MzA5ODEtMDk4MzA5QkMwOUJFLTA5QzQwOUM3MDlDODA5Q0ItMDlDRDA5RDcwOUUyMDlFMzBBMDEtMEEwMzBBM0MwQTNFLTBBNDIwQTQ3MEE0ODBBNEItMEE0RDBBNTEwQTcwMEE3MTBBNzUwQTgxLTBBODMwQUJDMEFCRS0wQUM1MEFDNy0wQUM5MEFDQi0wQUNEMEFFMjBBRTMwQjAxLTBCMDMwQjNDMEIzRS0wQjQ0MEI0NzBCNDgwQjRCLTBCNEQwQjU2MEI1NzBCNjIwQjYzMEI4MjBCQkUtMEJDMjBCQzYtMEJDODBCQ0EtMEJDRDBCRDcwQzAxLTBDMDMwQzNFLTBDNDQwQzQ2LTBDNDgwQzRBLTBDNEQwQzU1MEM1NjBDNjIwQzYzMEM4MjBDODMwQ0JDMENCRS0wQ0M0MENDNi0wQ0M4MENDQS0wQ0NEMENENTBDRDYwQ0UyMENFMzBEMDIwRDAzMEQzRS0wRDQ0MEQ0Ni0wRDQ4MEQ0QS0wRDREMEQ1NzBENjIwRDYzMEQ4MjBEODMwRENBMERDRi0wREQ0MERENjBERDgtMERERjBERjIwREYzMEUzMTBFMzQtMEUzQTBFNDctMEU0RTBFQjEwRUI0LTBFQjkwRUJCMEVCQzBFQzgtMEVDRDBGMTgwRjE5MEYzNTBGMzcwRjM5MEYzRTBGM0YwRjcxLTBGODQwRjg2MEY4NzBGOTAtMEY5NzBGOTktMEZCQzBGQzYxMDJCLTEwM0UxMDU2LTEwNTkxMDVFLTEwNjAxMDYyLTEwNjQxMDY3LTEwNkQxMDcxLTEwNzQxMDgyLTEwOEQxMDhGMTA5QS0xMDlEMTM1RjE3MTItMTcxNDE3MzItMTczNDE3NTIxNzUzMTc3MjE3NzMxN0I2LTE3RDMxN0REMTgwQi0xODBEMThBOTE5MjAtMTkyQjE5MzAtMTkzQjE5QjAtMTlDMDE5QzgxOUM5MUExNy0xQTFCMUE1NS0xQTVFMUE2MC0xQTdDMUE3RjFCMDAtMUIwNDFCMzQtMUI0NDFCNkItMUI3MzFCODAtMUI4MjFCQTEtMUJBQTFDMjQtMUMzNzFDRDAtMUNEMjFDRDQtMUNFODFDRUQxQ0YyMURDMC0xREU2MURGRC0xREZGMjBEMC0yMEYwMkNFRi0yQ0YxMkRFMC0yREZGMzAyQS0zMDJGMzA5OTMwOUFBNjZGLUE2NzJBNjdDQTY3REE2RjBBNkYxQTgwMkE4MDZBODBCQTgyMy1BODI3QTg4MEE4ODFBOEI0LUE4QzRBOEUwLUE4RjFBOTI2LUE5MkRBOTQ3LUE5NTNBOTgwLUE5ODNBOUIzLUE5QzBBQTI5LUFBMzZBQTQzQUE0Q0FBNERBQTdCQUFCMEFBQjItQUFCNEFBQjdBQUI4QUFCRUFBQkZBQUMxQUJFMy1BQkVBQUJFQ0FCRURGQjFFRkUwMC1GRTBGRkUyMC1GRTI2XCIsXG4gICAgTW46IFwiMDMwMC0wMzZGMDQ4My0wNDg3MDU5MS0wNUJEMDVCRjA1QzEwNUMyMDVDNDA1QzUwNUM3MDYxMC0wNjFBMDY0Qi0wNjVFMDY3MDA2RDYtMDZEQzA2REYtMDZFNDA2RTcwNkU4MDZFQS0wNkVEMDcxMTA3MzAtMDc0QTA3QTYtMDdCMDA3RUItMDdGMzA4MTYtMDgxOTA4MUItMDgyMzA4MjUtMDgyNzA4MjktMDgyRDA5MDAtMDkwMjA5M0MwOTQxLTA5NDgwOTREMDk1MS0wOTU1MDk2MjA5NjMwOTgxMDlCQzA5QzEtMDlDNDA5Q0QwOUUyMDlFMzBBMDEwQTAyMEEzQzBBNDEwQTQyMEE0NzBBNDgwQTRCLTBBNEQwQTUxMEE3MDBBNzEwQTc1MEE4MTBBODIwQUJDMEFDMS0wQUM1MEFDNzBBQzgwQUNEMEFFMjBBRTMwQjAxMEIzQzBCM0YwQjQxLTBCNDQwQjREMEI1NjBCNjIwQjYzMEI4MjBCQzAwQkNEMEMzRS0wQzQwMEM0Ni0wQzQ4MEM0QS0wQzREMEM1NTBDNTYwQzYyMEM2MzBDQkMwQ0JGMENDNjBDQ0MwQ0NEMENFMjBDRTMwRDQxLTBENDQwRDREMEQ2MjBENjMwRENBMEREMi0wREQ0MERENjBFMzEwRTM0LTBFM0EwRTQ3LTBFNEUwRUIxMEVCNC0wRUI5MEVCQjBFQkMwRUM4LTBFQ0QwRjE4MEYxOTBGMzUwRjM3MEYzOTBGNzEtMEY3RTBGODAtMEY4NDBGODYwRjg3MEY5MC0wRjk3MEY5OS0wRkJDMEZDNjEwMkQtMTAzMDEwMzItMTAzNzEwMzkxMDNBMTAzRDEwM0UxMDU4MTA1OTEwNUUtMTA2MDEwNzEtMTA3NDEwODIxMDg1MTA4NjEwOEQxMDlEMTM1RjE3MTItMTcxNDE3MzItMTczNDE3NTIxNzUzMTc3MjE3NzMxN0I3LTE3QkQxN0M2MTdDOS0xN0QzMTdERDE4MEItMTgwRDE4QTkxOTIwLTE5MjIxOTI3MTkyODE5MzIxOTM5LTE5M0IxQTE3MUExODFBNTYxQTU4LTFBNUUxQTYwMUE2MjFBNjUtMUE2QzFBNzMtMUE3QzFBN0YxQjAwLTFCMDMxQjM0MUIzNi0xQjNBMUIzQzFCNDIxQjZCLTFCNzMxQjgwMUI4MTFCQTItMUJBNTFCQTgxQkE5MUMyQy0xQzMzMUMzNjFDMzcxQ0QwLTFDRDIxQ0Q0LTFDRTAxQ0UyLTFDRTgxQ0VEMURDMC0xREU2MURGRC0xREZGMjBEMC0yMERDMjBFMTIwRTUtMjBGMDJDRUYtMkNGMTJERTAtMkRGRjMwMkEtMzAyRjMwOTkzMDlBQTY2RkE2N0NBNjdEQTZGMEE2RjFBODAyQTgwNkE4MEJBODI1QTgyNkE4QzRBOEUwLUE4RjFBOTI2LUE5MkRBOTQ3LUE5NTFBOTgwLUE5ODJBOUIzQTlCNi1BOUI5QTlCQ0FBMjktQUEyRUFBMzFBQTMyQUEzNUFBMzZBQTQzQUE0Q0FBQjBBQUIyLUFBQjRBQUI3QUFCOEFBQkVBQUJGQUFDMUFCRTVBQkU4QUJFREZCMUVGRTAwLUZFMEZGRTIwLUZFMjZcIixcbiAgICBNYzogXCIwOTAzMDkzRS0wOTQwMDk0OS0wOTRDMDk0RTA5ODIwOTgzMDlCRS0wOUMwMDlDNzA5QzgwOUNCMDlDQzA5RDcwQTAzMEEzRS0wQTQwMEE4MzBBQkUtMEFDMDBBQzkwQUNCMEFDQzBCMDIwQjAzMEIzRTBCNDAwQjQ3MEI0ODBCNEIwQjRDMEI1NzBCQkUwQkJGMEJDMTBCQzIwQkM2LTBCQzgwQkNBLTBCQ0MwQkQ3MEMwMS0wQzAzMEM0MS0wQzQ0MEM4MjBDODMwQ0JFMENDMC0wQ0M0MENDNzBDQzgwQ0NBMENDQjBDRDUwQ0Q2MEQwMjBEMDMwRDNFLTBENDAwRDQ2LTBENDgwRDRBLTBENEMwRDU3MEQ4MjBEODMwRENGLTBERDEwREQ4LTBEREYwREYyMERGMzBGM0UwRjNGMEY3RjEwMkIxMDJDMTAzMTEwMzgxMDNCMTAzQzEwNTYxMDU3MTA2Mi0xMDY0MTA2Ny0xMDZEMTA4MzEwODQxMDg3LTEwOEMxMDhGMTA5QS0xMDlDMTdCNjE3QkUtMTdDNTE3QzcxN0M4MTkyMy0xOTI2MTkyOS0xOTJCMTkzMDE5MzExOTMzLTE5MzgxOUIwLTE5QzAxOUM4MTlDOTFBMTktMUExQjFBNTUxQTU3MUE2MTFBNjMxQTY0MUE2RC0xQTcyMUIwNDFCMzUxQjNCMUIzRC0xQjQxMUI0MzFCNDQxQjgyMUJBMTFCQTYxQkE3MUJBQTFDMjQtMUMyQjFDMzQxQzM1MUNFMTFDRjJBODIzQTgyNEE4MjdBODgwQTg4MUE4QjQtQThDM0E5NTJBOTUzQTk4M0E5QjRBOUI1QTlCQUE5QkJBOUJELUE5QzBBQTJGQUEzMEFBMzNBQTM0QUE0REFBN0JBQkUzQUJFNEFCRTZBQkU3QUJFOUFCRUFBQkVDXCIsXG4gICAgTWU6IFwiMDQ4ODA0ODkwNkRFMjBERC0yMEUwMjBFMi0yMEU0QTY3MC1BNjcyXCIsXG4gICAgTjogIFwiMDAzMC0wMDM5MDBCMjAwQjMwMEI5MDBCQy0wMEJFMDY2MC0wNjY5MDZGMC0wNkY5MDdDMC0wN0M5MDk2Ni0wOTZGMDlFNi0wOUVGMDlGNC0wOUY5MEE2Ni0wQTZGMEFFNi0wQUVGMEI2Ni0wQjZGMEJFNi0wQkYyMEM2Ni0wQzZGMEM3OC0wQzdFMENFNi0wQ0VGMEQ2Ni0wRDc1MEU1MC0wRTU5MEVEMC0wRUQ5MEYyMC0wRjMzMTA0MC0xMDQ5MTA5MC0xMDk5MTM2OS0xMzdDMTZFRS0xNkYwMTdFMC0xN0U5MTdGMC0xN0Y5MTgxMC0xODE5MTk0Ni0xOTRGMTlEMC0xOURBMUE4MC0xQTg5MUE5MC0xQTk5MUI1MC0xQjU5MUJCMC0xQkI5MUM0MC0xQzQ5MUM1MC0xQzU5MjA3MDIwNzQtMjA3OTIwODAtMjA4OTIxNTAtMjE4MjIxODUtMjE4OTI0NjAtMjQ5QjI0RUEtMjRGRjI3NzYtMjc5MzJDRkQzMDA3MzAyMS0zMDI5MzAzOC0zMDNBMzE5Mi0zMTk1MzIyMC0zMjI5MzI1MS0zMjVGMzI4MC0zMjg5MzJCMS0zMkJGQTYyMC1BNjI5QTZFNi1BNkVGQTgzMC1BODM1QThEMC1BOEQ5QTkwMC1BOTA5QTlEMC1BOUQ5QUE1MC1BQTU5QUJGMC1BQkY5RkYxMC1GRjE5XCIsXG4gICAgTmQ6IFwiMDAzMC0wMDM5MDY2MC0wNjY5MDZGMC0wNkY5MDdDMC0wN0M5MDk2Ni0wOTZGMDlFNi0wOUVGMEE2Ni0wQTZGMEFFNi0wQUVGMEI2Ni0wQjZGMEJFNi0wQkVGMEM2Ni0wQzZGMENFNi0wQ0VGMEQ2Ni0wRDZGMEU1MC0wRTU5MEVEMC0wRUQ5MEYyMC0wRjI5MTA0MC0xMDQ5MTA5MC0xMDk5MTdFMC0xN0U5MTgxMC0xODE5MTk0Ni0xOTRGMTlEMC0xOURBMUE4MC0xQTg5MUE5MC0xQTk5MUI1MC0xQjU5MUJCMC0xQkI5MUM0MC0xQzQ5MUM1MC0xQzU5QTYyMC1BNjI5QThEMC1BOEQ5QTkwMC1BOTA5QTlEMC1BOUQ5QUE1MC1BQTU5QUJGMC1BQkY5RkYxMC1GRjE5XCIsXG4gICAgTmw6IFwiMTZFRS0xNkYwMjE2MC0yMTgyMjE4NS0yMTg4MzAwNzMwMjEtMzAyOTMwMzgtMzAzQUE2RTYtQTZFRlwiLFxuICAgIE5vOiBcIjAwQjIwMEIzMDBCOTAwQkMtMDBCRTA5RjQtMDlGOTBCRjAtMEJGMjBDNzgtMEM3RTBENzAtMEQ3NTBGMkEtMEYzMzEzNjktMTM3QzE3RjAtMTdGOTIwNzAyMDc0LTIwNzkyMDgwLTIwODkyMTUwLTIxNUYyMTg5MjQ2MC0yNDlCMjRFQS0yNEZGMjc3Ni0yNzkzMkNGRDMxOTItMzE5NTMyMjAtMzIyOTMyNTEtMzI1RjMyODAtMzI4OTMyQjEtMzJCRkE4MzAtQTgzNVwiLFxuICAgIFA6ICBcIjAwMjEtMDAyMzAwMjUtMDAyQTAwMkMtMDAyRjAwM0EwMDNCMDAzRjAwNDAwMDVCLTAwNUQwMDVGMDA3QjAwN0QwMEExMDBBQjAwQjcwMEJCMDBCRjAzN0UwMzg3MDU1QS0wNTVGMDU4OTA1OEEwNUJFMDVDMDA1QzMwNUM2MDVGMzA1RjQwNjA5MDYwQTA2MEMwNjBEMDYxQjA2MUUwNjFGMDY2QS0wNjZEMDZENDA3MDAtMDcwRDA3RjctMDdGOTA4MzAtMDgzRTA5NjQwOTY1MDk3MDBERjQwRTRGMEU1QTBFNUIwRjA0LTBGMTIwRjNBLTBGM0QwRjg1MEZEMC0wRkQ0MTA0QS0xMDRGMTBGQjEzNjEtMTM2ODE0MDAxNjZEMTY2RTE2OUIxNjlDMTZFQi0xNkVEMTczNTE3MzYxN0Q0LTE3RDYxN0Q4LTE3REExODAwLTE4MEExOTQ0MTk0NTE5REUxOURGMUExRTFBMUYxQUEwLTFBQTYxQUE4LTFBQUQxQjVBLTFCNjAxQzNCLTFDM0YxQzdFMUM3RjFDRDMyMDEwLTIwMjcyMDMwLTIwNDMyMDQ1LTIwNTEyMDUzLTIwNUUyMDdEMjA3RTIwOEQyMDhFMjMyOTIzMkEyNzY4LTI3NzUyN0M1MjdDNjI3RTYtMjdFRjI5ODMtMjk5ODI5RDgtMjlEQjI5RkMyOUZEMkNGOS0yQ0ZDMkNGRTJDRkYyRTAwLTJFMkUyRTMwMkUzMTMwMDEtMzAwMzMwMDgtMzAxMTMwMTQtMzAxRjMwMzAzMDNEMzBBMDMwRkJBNEZFQTRGRkE2MEQtQTYwRkE2NzNBNjdFQTZGMi1BNkY3QTg3NC1BODc3QThDRUE4Q0ZBOEY4LUE4RkFBOTJFQTkyRkE5NUZBOUMxLUE5Q0RBOURFQTlERkFBNUMtQUE1RkFBREVBQURGQUJFQkZEM0VGRDNGRkUxMC1GRTE5RkUzMC1GRTUyRkU1NC1GRTYxRkU2M0ZFNjhGRTZBRkU2QkZGMDEtRkYwM0ZGMDUtRkYwQUZGMEMtRkYwRkZGMUFGRjFCRkYxRkZGMjBGRjNCLUZGM0RGRjNGRkY1QkZGNURGRjVGLUZGNjVcIixcbiAgICBQZDogXCIwMDJEMDU4QTA1QkUxNDAwMTgwNjIwMTAtMjAxNTJFMTcyRTFBMzAxQzMwMzAzMEEwRkUzMUZFMzJGRTU4RkU2M0ZGMERcIixcbiAgICBQczogXCIwMDI4MDA1QjAwN0IwRjNBMEYzQzE2OUIyMDFBMjAxRTIwNDUyMDdEMjA4RDIzMjkyNzY4Mjc2QTI3NkMyNzZFMjc3MDI3NzIyNzc0MjdDNTI3RTYyN0U4MjdFQTI3RUMyN0VFMjk4MzI5ODUyOTg3Mjk4OTI5OEIyOThEMjk4RjI5OTEyOTkzMjk5NTI5OTcyOUQ4MjlEQTI5RkMyRTIyMkUyNDJFMjYyRTI4MzAwODMwMEEzMDBDMzAwRTMwMTAzMDE0MzAxNjMwMTgzMDFBMzAxREZEM0VGRTE3RkUzNUZFMzdGRTM5RkUzQkZFM0RGRTNGRkU0MUZFNDNGRTQ3RkU1OUZFNUJGRTVERkYwOEZGM0JGRjVCRkY1RkZGNjJcIixcbiAgICBQZTogXCIwMDI5MDA1RDAwN0QwRjNCMEYzRDE2OUMyMDQ2MjA3RTIwOEUyMzJBMjc2OTI3NkIyNzZEMjc2RjI3NzEyNzczMjc3NTI3QzYyN0U3MjdFOTI3RUIyN0VEMjdFRjI5ODQyOTg2Mjk4ODI5OEEyOThDMjk4RTI5OTAyOTkyMjk5NDI5OTYyOTk4MjlEOTI5REIyOUZEMkUyMzJFMjUyRTI3MkUyOTMwMDkzMDBCMzAwRDMwMEYzMDExMzAxNTMwMTczMDE5MzAxQjMwMUUzMDFGRkQzRkZFMThGRTM2RkUzOEZFM0FGRTNDRkUzRUZFNDBGRTQyRkU0NEZFNDhGRTVBRkU1Q0ZFNUVGRjA5RkYzREZGNURGRjYwRkY2M1wiLFxuICAgIFBpOiBcIjAwQUIyMDE4MjAxQjIwMUMyMDFGMjAzOTJFMDIyRTA0MkUwOTJFMEMyRTFDMkUyMFwiLFxuICAgIFBmOiBcIjAwQkIyMDE5MjAxRDIwM0EyRTAzMkUwNTJFMEEyRTBEMkUxRDJFMjFcIixcbiAgICBQYzogXCIwMDVGMjAzRjIwNDAyMDU0RkUzM0ZFMzRGRTRELUZFNEZGRjNGXCIsXG4gICAgUG86IFwiMDAyMS0wMDIzMDAyNS0wMDI3MDAyQTAwMkMwMDJFMDAyRjAwM0EwMDNCMDAzRjAwNDAwMDVDMDBBMTAwQjcwMEJGMDM3RTAzODcwNTVBLTA1NUYwNTg5MDVDMDA1QzMwNUM2MDVGMzA1RjQwNjA5MDYwQTA2MEMwNjBEMDYxQjA2MUUwNjFGMDY2QS0wNjZEMDZENDA3MDAtMDcwRDA3RjctMDdGOTA4MzAtMDgzRTA5NjQwOTY1MDk3MDBERjQwRTRGMEU1QTBFNUIwRjA0LTBGMTIwRjg1MEZEMC0wRkQ0MTA0QS0xMDRGMTBGQjEzNjEtMTM2ODE2NkQxNjZFMTZFQi0xNkVEMTczNTE3MzYxN0Q0LTE3RDYxN0Q4LTE3REExODAwLTE4MDUxODA3LTE4MEExOTQ0MTk0NTE5REUxOURGMUExRTFBMUYxQUEwLTFBQTYxQUE4LTFBQUQxQjVBLTFCNjAxQzNCLTFDM0YxQzdFMUM3RjFDRDMyMDE2MjAxNzIwMjAtMjAyNzIwMzAtMjAzODIwM0ItMjAzRTIwNDEtMjA0MzIwNDctMjA1MTIwNTMyMDU1LTIwNUUyQ0Y5LTJDRkMyQ0ZFMkNGRjJFMDAyRTAxMkUwNi0yRTA4MkUwQjJFMEUtMkUxNjJFMTgyRTE5MkUxQjJFMUUyRTFGMkUyQS0yRTJFMkUzMDJFMzEzMDAxLTMwMDMzMDNEMzBGQkE0RkVBNEZGQTYwRC1BNjBGQTY3M0E2N0VBNkYyLUE2RjdBODc0LUE4NzdBOENFQThDRkE4RjgtQThGQUE5MkVBOTJGQTk1RkE5QzEtQTlDREE5REVBOURGQUE1Qy1BQTVGQUFERUFBREZBQkVCRkUxMC1GRTE2RkUxOUZFMzBGRTQ1RkU0NkZFNDktRkU0Q0ZFNTAtRkU1MkZFNTQtRkU1N0ZFNUYtRkU2MUZFNjhGRTZBRkU2QkZGMDEtRkYwM0ZGMDUtRkYwN0ZGMEFGRjBDRkYwRUZGMEZGRjFBRkYxQkZGMUZGRjIwRkYzQ0ZGNjFGRjY0RkY2NVwiLFxuICAgIFM6ICBcIjAwMjQwMDJCMDAzQy0wMDNFMDA1RTAwNjAwMDdDMDA3RTAwQTItMDBBOTAwQUMwMEFFLTAwQjEwMEI0MDBCNjAwQjgwMEQ3MDBGNzAyQzItMDJDNTAyRDItMDJERjAyRTUtMDJFQjAyRUQwMkVGLTAyRkYwMzc1MDM4NDAzODUwM0Y2MDQ4MjA2MDYtMDYwODA2MEIwNjBFMDYwRjA2RTkwNkZEMDZGRTA3RjYwOUYyMDlGMzA5RkEwOUZCMEFGMTBCNzAwQkYzLTBCRkEwQzdGMENGMTBDRjIwRDc5MEUzRjBGMDEtMEYwMzBGMTMtMEYxNzBGMUEtMEYxRjBGMzQwRjM2MEYzODBGQkUtMEZDNTBGQzctMEZDQzBGQ0UwRkNGMEZENS0wRkQ4MTA5RTEwOUYxMzYwMTM5MC0xMzk5MTdEQjE5NDAxOUUwLTE5RkYxQjYxLTFCNkExQjc0LTFCN0MxRkJEMUZCRi0xRkMxMUZDRC0xRkNGMUZERC0xRkRGMUZFRC0xRkVGMUZGRDFGRkUyMDQ0MjA1MjIwN0EtMjA3QzIwOEEtMjA4QzIwQTAtMjBCODIxMDAyMTAxMjEwMy0yMTA2MjEwODIxMDkyMTE0MjExNi0yMTE4MjExRS0yMTIzMjEyNTIxMjcyMTI5MjEyRTIxM0EyMTNCMjE0MC0yMTQ0MjE0QS0yMTREMjE0RjIxOTAtMjMyODIzMkItMjNFODI0MDAtMjQyNjI0NDAtMjQ0QTI0OUMtMjRFOTI1MDAtMjZDRDI2Q0YtMjZFMTI2RTMyNkU4LTI2RkYyNzAxLTI3MDQyNzA2LTI3MDkyNzBDLTI3MjcyNzI5LTI3NEIyNzREMjc0Ri0yNzUyMjc1Ni0yNzVFMjc2MS0yNzY3Mjc5NDI3OTgtMjdBRjI3QjEtMjdCRTI3QzAtMjdDNDI3QzctMjdDQTI3Q0MyN0QwLTI3RTUyN0YwLTI5ODIyOTk5LTI5RDcyOURDLTI5RkIyOUZFLTJCNEMyQjUwLTJCNTkyQ0U1LTJDRUEyRTgwLTJFOTkyRTlCLTJFRjMyRjAwLTJGRDUyRkYwLTJGRkIzMDA0MzAxMjMwMTMzMDIwMzAzNjMwMzczMDNFMzAzRjMwOUIzMDlDMzE5MDMxOTEzMTk2LTMxOUYzMUMwLTMxRTMzMjAwLTMyMUUzMjJBLTMyNTAzMjYwLTMyN0YzMjhBLTMyQjAzMkMwLTMyRkUzMzAwLTMzRkY0REMwLTRERkZBNDkwLUE0QzZBNzAwLUE3MTZBNzIwQTcyMUE3ODlBNzhBQTgyOC1BODJCQTgzNi1BODM5QUE3Ny1BQTc5RkIyOUZERkNGREZERkU2MkZFNjQtRkU2NkZFNjlGRjA0RkYwQkZGMUMtRkYxRUZGM0VGRjQwRkY1Q0ZGNUVGRkUwLUZGRTZGRkU4LUZGRUVGRkZDRkZGRFwiLFxuICAgIFNtOiBcIjAwMkIwMDNDLTAwM0UwMDdDMDA3RTAwQUMwMEIxMDBENzAwRjcwM0Y2MDYwNi0wNjA4MjA0NDIwNTIyMDdBLTIwN0MyMDhBLTIwOEMyMTQwLTIxNDQyMTRCMjE5MC0yMTk0MjE5QTIxOUIyMUEwMjFBMzIxQTYyMUFFMjFDRTIxQ0YyMUQyMjFENDIxRjQtMjJGRjIzMDgtMjMwQjIzMjAyMzIxMjM3QzIzOUItMjNCMzIzREMtMjNFMTI1QjcyNUMxMjVGOC0yNUZGMjY2RjI3QzAtMjdDNDI3QzctMjdDQTI3Q0MyN0QwLTI3RTUyN0YwLTI3RkYyOTAwLTI5ODIyOTk5LTI5RDcyOURDLTI5RkIyOUZFLTJBRkYyQjMwLTJCNDQyQjQ3LTJCNENGQjI5RkU2MkZFNjQtRkU2NkZGMEJGRjFDLUZGMUVGRjVDRkY1RUZGRTJGRkU5LUZGRUNcIixcbiAgICBTYzogXCIwMDI0MDBBMi0wMEE1MDYwQjA5RjIwOUYzMDlGQjBBRjEwQkY5MEUzRjE3REIyMEEwLTIwQjhBODM4RkRGQ0ZFNjlGRjA0RkZFMEZGRTFGRkU1RkZFNlwiLFxuICAgIFNrOiBcIjAwNUUwMDYwMDBBODAwQUYwMEI0MDBCODAyQzItMDJDNTAyRDItMDJERjAyRTUtMDJFQjAyRUQwMkVGLTAyRkYwMzc1MDM4NDAzODUxRkJEMUZCRi0xRkMxMUZDRC0xRkNGMUZERC0xRkRGMUZFRC0xRkVGMUZGRDFGRkUzMDlCMzA5Q0E3MDAtQTcxNkE3MjBBNzIxQTc4OUE3OEFGRjNFRkY0MEZGRTNcIixcbiAgICBTbzogXCIwMEE2MDBBNzAwQTkwMEFFMDBCMDAwQjYwNDgyMDYwRTA2MEYwNkU5MDZGRDA2RkUwN0Y2MDlGQTBCNzAwQkYzLTBCRjgwQkZBMEM3RjBDRjEwQ0YyMEQ3OTBGMDEtMEYwMzBGMTMtMEYxNzBGMUEtMEYxRjBGMzQwRjM2MEYzODBGQkUtMEZDNTBGQzctMEZDQzBGQ0UwRkNGMEZENS0wRkQ4MTA5RTEwOUYxMzYwMTM5MC0xMzk5MTk0MDE5RTAtMTlGRjFCNjEtMUI2QTFCNzQtMUI3QzIxMDAyMTAxMjEwMy0yMTA2MjEwODIxMDkyMTE0MjExNi0yMTE4MjExRS0yMTIzMjEyNTIxMjcyMTI5MjEyRTIxM0EyMTNCMjE0QTIxNEMyMTREMjE0RjIxOTUtMjE5OTIxOUMtMjE5RjIxQTEyMUEyMjFBNDIxQTUyMUE3LTIxQUQyMUFGLTIxQ0QyMUQwMjFEMTIxRDMyMUQ1LTIxRjMyMzAwLTIzMDcyMzBDLTIzMUYyMzIyLTIzMjgyMzJCLTIzN0IyMzdELTIzOUEyM0I0LTIzREIyM0UyLTIzRTgyNDAwLTI0MjYyNDQwLTI0NEEyNDlDLTI0RTkyNTAwLTI1QjYyNUI4LTI1QzAyNUMyLTI1RjcyNjAwLTI2NkUyNjcwLTI2Q0QyNkNGLTI2RTEyNkUzMjZFOC0yNkZGMjcwMS0yNzA0MjcwNi0yNzA5MjcwQy0yNzI3MjcyOS0yNzRCMjc0RDI3NEYtMjc1MjI3NTYtMjc1RTI3NjEtMjc2NzI3OTQyNzk4LTI3QUYyN0IxLTI3QkUyODAwLTI4RkYyQjAwLTJCMkYyQjQ1MkI0NjJCNTAtMkI1OTJDRTUtMkNFQTJFODAtMkU5OTJFOUItMkVGMzJGMDAtMkZENTJGRjAtMkZGQjMwMDQzMDEyMzAxMzMwMjAzMDM2MzAzNzMwM0UzMDNGMzE5MDMxOTEzMTk2LTMxOUYzMUMwLTMxRTMzMjAwLTMyMUUzMjJBLTMyNTAzMjYwLTMyN0YzMjhBLTMyQjAzMkMwLTMyRkUzMzAwLTMzRkY0REMwLTRERkZBNDkwLUE0QzZBODI4LUE4MkJBODM2QTgzN0E4MzlBQTc3LUFBNzlGREZERkZFNEZGRThGRkVERkZFRUZGRkNGRkZEXCIsXG4gICAgWjogIFwiMDAyMDAwQTAxNjgwMTgwRTIwMDAtMjAwQTIwMjgyMDI5MjAyRjIwNUYzMDAwXCIsXG4gICAgWnM6IFwiMDAyMDAwQTAxNjgwMTgwRTIwMDAtMjAwQTIwMkYyMDVGMzAwMFwiLFxuICAgIFpsOiBcIjIwMjhcIixcbiAgICBacDogXCIyMDI5XCIsXG4gICAgQzogIFwiMDAwMC0wMDFGMDA3Ri0wMDlGMDBBRDAzNzgwMzc5MDM3Ri0wMzgzMDM4QjAzOEQwM0EyMDUyNi0wNTMwMDU1NzA1NTgwNTYwMDU4ODA1OEItMDU5MDA1QzgtMDVDRjA1RUItMDVFRjA1RjUtMDYwNTA2MUMwNjFEMDYyMDA2NUYwNkREMDcwRTA3MEYwNzRCMDc0QzA3QjItMDdCRjA3RkItMDdGRjA4MkUwODJGMDgzRi0wOEZGMDkzQTA5M0IwOTRGMDk1NjA5NTcwOTczLTA5NzgwOTgwMDk4NDA5OEQwOThFMDk5MTA5OTIwOUE5MDlCMTA5QjMtMDlCNTA5QkEwOUJCMDlDNTA5QzYwOUM5MDlDQTA5Q0YtMDlENjA5RDgtMDlEQjA5REUwOUU0MDlFNTA5RkMtMEEwMDBBMDQwQTBCLTBBMEUwQTExMEExMjBBMjkwQTMxMEEzNDBBMzcwQTNBMEEzQjBBM0QwQTQzLTBBNDYwQTQ5MEE0QTBBNEUtMEE1MDBBNTItMEE1ODBBNUQwQTVGLTBBNjUwQTc2LTBBODAwQTg0MEE4RTBBOTIwQUE5MEFCMTBBQjQwQUJBMEFCQjBBQzYwQUNBMEFDRTBBQ0YwQUQxLTBBREYwQUU0MEFFNTBBRjAwQUYyLTBCMDAwQjA0MEIwRDBCMEUwQjExMEIxMjBCMjkwQjMxMEIzNDBCM0EwQjNCMEI0NTBCNDYwQjQ5MEI0QTBCNEUtMEI1NTBCNTgtMEI1QjBCNUUwQjY0MEI2NTBCNzItMEI4MTBCODQwQjhCLTBCOEQwQjkxMEI5Ni0wQjk4MEI5QjBCOUQwQkEwLTBCQTIwQkE1LTBCQTcwQkFCLTBCQUQwQkJBLTBCQkQwQkMzLTBCQzUwQkM5MEJDRTBCQ0YwQkQxLTBCRDYwQkQ4LTBCRTUwQkZCLTBDMDAwQzA0MEMwRDBDMTEwQzI5MEMzNDBDM0EtMEMzQzBDNDUwQzQ5MEM0RS0wQzU0MEM1NzBDNUEtMEM1RjBDNjQwQzY1MEM3MC0wQzc3MEM4MDBDODEwQzg0MEM4RDBDOTEwQ0E5MENCNDBDQkEwQ0JCMENDNTBDQzkwQ0NFLTBDRDQwQ0Q3LTBDREQwQ0RGMENFNDBDRTUwQ0YwMENGMy0wRDAxMEQwNDBEMEQwRDExMEQyOTBEM0EtMEQzQzBENDUwRDQ5MEQ0RS0wRDU2MEQ1OC0wRDVGMEQ2NDBENjUwRDc2LTBENzgwRDgwMEQ4MTBEODQwRDk3LTBEOTkwREIyMERCQzBEQkUwREJGMERDNy0wREM5MERDQi0wRENFMERENTBERDcwREUwLTBERjEwREY1LTBFMDAwRTNCLTBFM0UwRTVDLTBFODAwRTgzMEU4NTBFODYwRTg5MEU4QjBFOEMwRThFLTBFOTMwRTk4MEVBMDBFQTQwRUE2MEVBODBFQTkwRUFDMEVCQTBFQkUwRUJGMEVDNTBFQzcwRUNFMEVDRjBFREEwRURCMEVERS0wRUZGMEY0ODBGNkQtMEY3MDBGOEMtMEY4RjBGOTgwRkJEMEZDRDBGRDktMEZGRjEwQzYtMTBDRjEwRkQtMTBGRjEyNDkxMjRFMTI0RjEyNTcxMjU5MTI1RTEyNUYxMjg5MTI4RTEyOEYxMkIxMTJCNjEyQjcxMkJGMTJDMTEyQzYxMkM3MTJENzEzMTExMzE2MTMxNzEzNUItMTM1RTEzN0QtMTM3RjEzOUEtMTM5RjEzRjUtMTNGRjE2OUQtMTY5RjE2RjEtMTZGRjE3MEQxNzE1LTE3MUYxNzM3LTE3M0YxNzU0LTE3NUYxNzZEMTc3MTE3NzQtMTc3RjE3QjQxN0I1MTdERTE3REYxN0VBLTE3RUYxN0ZBLTE3RkYxODBGMTgxQS0xODFGMTg3OC0xODdGMThBQi0xOEFGMThGNi0xOEZGMTkxRC0xOTFGMTkyQy0xOTJGMTkzQy0xOTNGMTk0MS0xOTQzMTk2RTE5NkYxOTc1LTE5N0YxOUFDLTE5QUYxOUNBLTE5Q0YxOURCLTE5REQxQTFDMUExRDFBNUYxQTdEMUE3RTFBOEEtMUE4RjFBOUEtMUE5RjFBQUUtMUFGRjFCNEMtMUI0RjFCN0QtMUI3RjFCQUItMUJBRDFCQkEtMUJGRjFDMzgtMUMzQTFDNEEtMUM0QzFDODAtMUNDRjFDRjMtMUNGRjFERTctMURGQzFGMTYxRjE3MUYxRTFGMUYxRjQ2MUY0NzFGNEUxRjRGMUY1ODFGNUExRjVDMUY1RTFGN0UxRjdGMUZCNTFGQzUxRkQ0MUZENTFGREMxRkYwMUZGMTFGRjUxRkZGMjAwQi0yMDBGMjAyQS0yMDJFMjA2MC0yMDZGMjA3MjIwNzMyMDhGMjA5NS0yMDlGMjBCOS0yMENGMjBGMS0yMEZGMjE4QS0yMThGMjNFOS0yM0ZGMjQyNy0yNDNGMjQ0Qi0yNDVGMjZDRTI2RTIyNkU0LTI2RTcyNzAwMjcwNTI3MEEyNzBCMjcyODI3NEMyNzRFMjc1My0yNzU1Mjc1RjI3NjAyNzk1LTI3OTcyN0IwMjdCRjI3Q0IyN0NELTI3Q0YyQjRELTJCNEYyQjVBLTJCRkYyQzJGMkM1RjJDRjItMkNGODJEMjYtMkQyRjJENjYtMkQ2RTJENzAtMkQ3RjJEOTctMkQ5RjJEQTcyREFGMkRCNzJEQkYyREM3MkRDRjJERDcyRERGMkUzMi0yRTdGMkU5QTJFRjQtMkVGRjJGRDYtMkZFRjJGRkMtMkZGRjMwNDAzMDk3MzA5ODMxMDAtMzEwNDMxMkUtMzEzMDMxOEYzMUI4LTMxQkYzMUU0LTMxRUYzMjFGMzJGRjREQjYtNERCRjlGQ0MtOUZGRkE0OEQtQTQ4RkE0QzctQTRDRkE2MkMtQTYzRkE2NjBBNjYxQTY3NC1BNjdCQTY5OC1BNjlGQTZGOC1BNkZGQTc4RC1BN0ZBQTgyQy1BODJGQTgzQS1BODNGQTg3OC1BODdGQThDNS1BOENEQThEQS1BOERGQThGQy1BOEZGQTk1NC1BOTVFQTk3RC1BOTdGQTlDRUE5REEtQTlEREE5RTAtQTlGRkFBMzctQUEzRkFBNEVBQTRGQUE1QUFBNUJBQTdDLUFBN0ZBQUMzLUFBREFBQUUwLUFCQkZBQkVFQUJFRkFCRkEtQUJGRkQ3QTQtRDdBRkQ3QzctRDdDQUQ3RkMtRjhGRkZBMkVGQTJGRkE2RUZBNkZGQURBLUZBRkZGQjA3LUZCMTJGQjE4LUZCMUNGQjM3RkIzREZCM0ZGQjQyRkI0NUZCQjItRkJEMkZENDAtRkQ0RkZEOTBGRDkxRkRDOC1GREVGRkRGRUZERkZGRTFBLUZFMUZGRTI3LUZFMkZGRTUzRkU2N0ZFNkMtRkU2RkZFNzVGRUZELUZGMDBGRkJGLUZGQzFGRkM4RkZDOUZGRDBGRkQxRkZEOEZGRDlGRkRELUZGREZGRkU3RkZFRi1GRkZCRkZGRUZGRkZcIixcbiAgICBDYzogXCIwMDAwLTAwMUYwMDdGLTAwOUZcIixcbiAgICBDZjogXCIwMEFEMDYwMC0wNjAzMDZERDA3MEYxN0I0MTdCNTIwMEItMjAwRjIwMkEtMjAyRTIwNjAtMjA2NDIwNkEtMjA2RkZFRkZGRkY5LUZGRkJcIixcbiAgICBDbzogXCJFMDAwLUY4RkZcIixcbiAgICBDczogXCJEODAwLURGRkZcIixcbiAgICBDbjogXCIwMzc4MDM3OTAzN0YtMDM4MzAzOEIwMzhEMDNBMjA1MjYtMDUzMDA1NTcwNTU4MDU2MDA1ODgwNThCLTA1OTAwNUM4LTA1Q0YwNUVCLTA1RUYwNUY1LTA1RkYwNjA0MDYwNTA2MUMwNjFEMDYyMDA2NUYwNzBFMDc0QjA3NEMwN0IyLTA3QkYwN0ZCLTA3RkYwODJFMDgyRjA4M0YtMDhGRjA5M0EwOTNCMDk0RjA5NTYwOTU3MDk3My0wOTc4MDk4MDA5ODQwOThEMDk4RTA5OTEwOTkyMDlBOTA5QjEwOUIzLTA5QjUwOUJBMDlCQjA5QzUwOUM2MDlDOTA5Q0EwOUNGLTA5RDYwOUQ4LTA5REIwOURFMDlFNDA5RTUwOUZDLTBBMDAwQTA0MEEwQi0wQTBFMEExMTBBMTIwQTI5MEEzMTBBMzQwQTM3MEEzQTBBM0IwQTNEMEE0My0wQTQ2MEE0OTBBNEEwQTRFLTBBNTAwQTUyLTBBNTgwQTVEMEE1Ri0wQTY1MEE3Ni0wQTgwMEE4NDBBOEUwQTkyMEFBOTBBQjEwQUI0MEFCQTBBQkIwQUM2MEFDQTBBQ0UwQUNGMEFEMS0wQURGMEFFNDBBRTUwQUYwMEFGMi0wQjAwMEIwNDBCMEQwQjBFMEIxMTBCMTIwQjI5MEIzMTBCMzQwQjNBMEIzQjBCNDUwQjQ2MEI0OTBCNEEwQjRFLTBCNTUwQjU4LTBCNUIwQjVFMEI2NDBCNjUwQjcyLTBCODEwQjg0MEI4Qi0wQjhEMEI5MTBCOTYtMEI5ODBCOUIwQjlEMEJBMC0wQkEyMEJBNS0wQkE3MEJBQi0wQkFEMEJCQS0wQkJEMEJDMy0wQkM1MEJDOTBCQ0UwQkNGMEJEMS0wQkQ2MEJEOC0wQkU1MEJGQi0wQzAwMEMwNDBDMEQwQzExMEMyOTBDMzQwQzNBLTBDM0MwQzQ1MEM0OTBDNEUtMEM1NDBDNTcwQzVBLTBDNUYwQzY0MEM2NTBDNzAtMEM3NzBDODAwQzgxMEM4NDBDOEQwQzkxMENBOTBDQjQwQ0JBMENCQjBDQzUwQ0M5MENDRS0wQ0Q0MENENy0wQ0REMENERjBDRTQwQ0U1MENGMDBDRjMtMEQwMTBEMDQwRDBEMEQxMTBEMjkwRDNBLTBEM0MwRDQ1MEQ0OTBENEUtMEQ1NjBENTgtMEQ1RjBENjQwRDY1MEQ3Ni0wRDc4MEQ4MDBEODEwRDg0MEQ5Ny0wRDk5MERCMjBEQkMwREJFMERCRjBEQzctMERDOTBEQ0ItMERDRTBERDUwREQ3MERFMC0wREYxMERGNS0wRTAwMEUzQi0wRTNFMEU1Qy0wRTgwMEU4MzBFODUwRTg2MEU4OTBFOEIwRThDMEU4RS0wRTkzMEU5ODBFQTAwRUE0MEVBNjBFQTgwRUE5MEVBQzBFQkEwRUJFMEVCRjBFQzUwRUM3MEVDRTBFQ0YwRURBMEVEQjBFREUtMEVGRjBGNDgwRjZELTBGNzAwRjhDLTBGOEYwRjk4MEZCRDBGQ0QwRkQ5LTBGRkYxMEM2LTEwQ0YxMEZELTEwRkYxMjQ5MTI0RTEyNEYxMjU3MTI1OTEyNUUxMjVGMTI4OTEyOEUxMjhGMTJCMTEyQjYxMkI3MTJCRjEyQzExMkM2MTJDNzEyRDcxMzExMTMxNjEzMTcxMzVCLTEzNUUxMzdELTEzN0YxMzlBLTEzOUYxM0Y1LTEzRkYxNjlELTE2OUYxNkYxLTE2RkYxNzBEMTcxNS0xNzFGMTczNy0xNzNGMTc1NC0xNzVGMTc2RDE3NzExNzc0LTE3N0YxN0RFMTdERjE3RUEtMTdFRjE3RkEtMTdGRjE4MEYxODFBLTE4MUYxODc4LTE4N0YxOEFCLTE4QUYxOEY2LTE4RkYxOTFELTE5MUYxOTJDLTE5MkYxOTNDLTE5M0YxOTQxLTE5NDMxOTZFMTk2RjE5NzUtMTk3RjE5QUMtMTlBRjE5Q0EtMTlDRjE5REItMTlERDFBMUMxQTFEMUE1RjFBN0QxQTdFMUE4QS0xQThGMUE5QS0xQTlGMUFBRS0xQUZGMUI0Qy0xQjRGMUI3RC0xQjdGMUJBQi0xQkFEMUJCQS0xQkZGMUMzOC0xQzNBMUM0QS0xQzRDMUM4MC0xQ0NGMUNGMy0xQ0ZGMURFNy0xREZDMUYxNjFGMTcxRjFFMUYxRjFGNDYxRjQ3MUY0RTFGNEYxRjU4MUY1QTFGNUMxRjVFMUY3RTFGN0YxRkI1MUZDNTFGRDQxRkQ1MUZEQzFGRjAxRkYxMUZGNTFGRkYyMDY1LTIwNjkyMDcyMjA3MzIwOEYyMDk1LTIwOUYyMEI5LTIwQ0YyMEYxLTIwRkYyMThBLTIxOEYyM0U5LTIzRkYyNDI3LTI0M0YyNDRCLTI0NUYyNkNFMjZFMjI2RTQtMjZFNzI3MDAyNzA1MjcwQTI3MEIyNzI4Mjc0QzI3NEUyNzUzLTI3NTUyNzVGMjc2MDI3OTUtMjc5NzI3QjAyN0JGMjdDQjI3Q0QtMjdDRjJCNEQtMkI0RjJCNUEtMkJGRjJDMkYyQzVGMkNGMi0yQ0Y4MkQyNi0yRDJGMkQ2Ni0yRDZFMkQ3MC0yRDdGMkQ5Ny0yRDlGMkRBNzJEQUYyREI3MkRCRjJEQzcyRENGMkRENzJEREYyRTMyLTJFN0YyRTlBMkVGNC0yRUZGMkZENi0yRkVGMkZGQy0yRkZGMzA0MDMwOTczMDk4MzEwMC0zMTA0MzEyRS0zMTMwMzE4RjMxQjgtMzFCRjMxRTQtMzFFRjMyMUYzMkZGNERCNi00REJGOUZDQy05RkZGQTQ4RC1BNDhGQTRDNy1BNENGQTYyQy1BNjNGQTY2MEE2NjFBNjc0LUE2N0JBNjk4LUE2OUZBNkY4LUE2RkZBNzhELUE3RkFBODJDLUE4MkZBODNBLUE4M0ZBODc4LUE4N0ZBOEM1LUE4Q0RBOERBLUE4REZBOEZDLUE4RkZBOTU0LUE5NUVBOTdELUE5N0ZBOUNFQTlEQS1BOUREQTlFMC1BOUZGQUEzNy1BQTNGQUE0RUFBNEZBQTVBQUE1QkFBN0MtQUE3RkFBQzMtQUFEQUFBRTAtQUJCRkFCRUVBQkVGQUJGQS1BQkZGRDdBNC1EN0FGRDdDNy1EN0NBRDdGQy1EN0ZGRkEyRUZBMkZGQTZFRkE2RkZBREEtRkFGRkZCMDctRkIxMkZCMTgtRkIxQ0ZCMzdGQjNERkIzRkZCNDJGQjQ1RkJCMi1GQkQyRkQ0MC1GRDRGRkQ5MEZEOTFGREM4LUZERUZGREZFRkRGRkZFMUEtRkUxRkZFMjctRkUyRkZFNTNGRTY3RkU2Qy1GRTZGRkU3NUZFRkRGRUZFRkYwMEZGQkYtRkZDMUZGQzhGRkM5RkZEMEZGRDFGRkQ4RkZEOUZGREQtRkZERkZGRTdGRkVGLUZGRjhGRkZFRkZGRlwiXG59KTtcblxuZnVuY3Rpb24gYWRkVW5pY29kZVBhY2thZ2UgKHBhY2spIHtcbiAgICB2YXIgY29kZVBvaW50ID0gL1xcd3s0fS9nO1xuICAgIGZvciAodmFyIG5hbWUgaW4gcGFjaylcbiAgICAgICAgZXhwb3J0cy5wYWNrYWdlc1tuYW1lXSA9IHBhY2tbbmFtZV0ucmVwbGFjZShjb2RlUG9pbnQsIFwiXFxcXHUkJlwiKTtcbn07XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3Rva2VuX2l0ZXJhdG9yXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBUb2tlbkl0ZXJhdG9yID0gZnVuY3Rpb24oc2Vzc2lvbiwgaW5pdGlhbFJvdywgaW5pdGlhbENvbHVtbikge1xuICAgIHRoaXMuJHNlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuJHJvdyA9IGluaXRpYWxSb3c7XG4gICAgdGhpcy4kcm93VG9rZW5zID0gc2Vzc2lvbi5nZXRUb2tlbnMoaW5pdGlhbFJvdyk7XG5cbiAgICB2YXIgdG9rZW4gPSBzZXNzaW9uLmdldFRva2VuQXQoaW5pdGlhbFJvdywgaW5pdGlhbENvbHVtbik7XG4gICAgdGhpcy4kdG9rZW5JbmRleCA9IHRva2VuID8gdG9rZW4uaW5kZXggOiAtMTtcbn07XG5cbihmdW5jdGlvbigpIHsgXG4gICAgdGhpcy5zdGVwQmFja3dhcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kdG9rZW5JbmRleCAtPSAxO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKHRoaXMuJHRva2VuSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLiRyb3cgLT0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRyb3cgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcm93ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHJvd1Rva2VucyA9IHRoaXMuJHNlc3Npb24uZ2V0VG9rZW5zKHRoaXMuJHJvdyk7XG4gICAgICAgICAgICB0aGlzLiR0b2tlbkluZGV4ID0gdGhpcy4kcm93VG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy4kcm93VG9rZW5zW3RoaXMuJHRva2VuSW5kZXhdO1xuICAgIH07ICAgXG4gICAgdGhpcy5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiR0b2tlbkluZGV4ICs9IDE7XG4gICAgICAgIHZhciByb3dDb3VudDtcbiAgICAgICAgd2hpbGUgKHRoaXMuJHRva2VuSW5kZXggPj0gdGhpcy4kcm93VG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy4kcm93ICs9IDE7XG4gICAgICAgICAgICBpZiAoIXJvd0NvdW50KVxuICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy4kc2Vzc2lvbi5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRyb3cgPj0gcm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyb3cgPSByb3dDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJHJvd1Rva2VucyA9IHRoaXMuJHNlc3Npb24uZ2V0VG9rZW5zKHRoaXMuJHJvdyk7XG4gICAgICAgICAgICB0aGlzLiR0b2tlbkluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzLiRyb3dUb2tlbnNbdGhpcy4kdG9rZW5JbmRleF07XG4gICAgfTsgICAgICBcbiAgICB0aGlzLmdldEN1cnJlbnRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvd1Rva2Vuc1t0aGlzLiR0b2tlbkluZGV4XTtcbiAgICB9OyAgICAgIFxuICAgIHRoaXMuZ2V0Q3VycmVudFRva2VuUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcm93O1xuICAgIH07ICAgICBcbiAgICB0aGlzLmdldEN1cnJlbnRUb2tlbkNvbHVtbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93VG9rZW5zID0gdGhpcy4kcm93VG9rZW5zO1xuICAgICAgICB2YXIgdG9rZW5JbmRleCA9IHRoaXMuJHRva2VuSW5kZXg7XG4gICAgICAgIHZhciBjb2x1bW4gPSByb3dUb2tlbnNbdG9rZW5JbmRleF0uc3RhcnQ7XG4gICAgICAgIGlmIChjb2x1bW4gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgICAgICAgICBcbiAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKHRva2VuSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbkluZGV4IC09IDE7XG4gICAgICAgICAgICBjb2x1bW4gKz0gcm93VG9rZW5zW3Rva2VuSW5kZXhdLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvbHVtbjsgIFxuICAgIH07XG4gICAgICAgICAgICBcbn0pLmNhbGwoVG9rZW5JdGVyYXRvci5wcm90b3R5cGUpO1xuXG5leHBvcnRzLlRva2VuSXRlcmF0b3IgPSBUb2tlbkl0ZXJhdG9yO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS90ZXh0XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvdG9rZW5pemVyXCIsXCJhY2UvbW9kZS90ZXh0X2hpZ2hsaWdodF9ydWxlc1wiLFwiYWNlL21vZGUvYmVoYXZpb3VyXCIsXCJhY2UvdW5pY29kZVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvdG9rZW5faXRlcmF0b3JcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBUb2tlbml6ZXIgPSBhY2VxdWlyZShcIi4uL3Rva2VuaXplclwiKS5Ub2tlbml6ZXI7XG52YXIgVGV4dEhpZ2hsaWdodFJ1bGVzID0gYWNlcXVpcmUoXCIuL3RleHRfaGlnaGxpZ2h0X3J1bGVzXCIpLlRleHRIaWdobGlnaHRSdWxlcztcbnZhciBCZWhhdmlvdXIgPSBhY2VxdWlyZShcIi4vYmVoYXZpb3VyXCIpLkJlaGF2aW91cjtcbnZhciB1bmljb2RlID0gYWNlcXVpcmUoXCIuLi91bmljb2RlXCIpO1xudmFyIGxhbmcgPSBhY2VxdWlyZShcIi4uL2xpYi9sYW5nXCIpO1xudmFyIFRva2VuSXRlcmF0b3IgPSBhY2VxdWlyZShcIi4uL3Rva2VuX2l0ZXJhdG9yXCIpLlRva2VuSXRlcmF0b3I7XG52YXIgUmFuZ2UgPSBhY2VxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xuXG52YXIgTW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuSGlnaGxpZ2h0UnVsZXMgPSBUZXh0SGlnaGxpZ2h0UnVsZXM7XG4gICAgdGhpcy4kYmVoYXZpb3VyID0gbmV3IEJlaGF2aW91cigpO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy50b2tlblJlID0gbmV3IFJlZ0V4cChcIl5bXCJcbiAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLkxcbiAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLk1uICsgdW5pY29kZS5wYWNrYWdlcy5NY1xuICAgICAgICArIHVuaWNvZGUucGFja2FnZXMuTmRcbiAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLlBjICsgXCJcXFxcJF9dK1wiLCBcImdcIlxuICAgICk7XG5cbiAgICB0aGlzLm5vblRva2VuUmUgPSBuZXcgUmVnRXhwKFwiXig/OlteXCJcbiAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLkxcbiAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLk1uICsgdW5pY29kZS5wYWNrYWdlcy5NY1xuICAgICAgICArIHVuaWNvZGUucGFja2FnZXMuTmRcbiAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLlBjICsgXCJcXFxcJF9dfFxcXFxzXSkrXCIsIFwiZ1wiXG4gICAgKTtcblxuICAgIHRoaXMuZ2V0VG9rZW5pemVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy4kdG9rZW5pemVyKSB7XG4gICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRSdWxlcyA9IHRoaXMuJGhpZ2hsaWdodFJ1bGVzIHx8IG5ldyB0aGlzLkhpZ2hsaWdodFJ1bGVzKCk7XG4gICAgICAgICAgICB0aGlzLiR0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHRoaXMuJGhpZ2hsaWdodFJ1bGVzLmdldFJ1bGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiR0b2tlbml6ZXI7XG4gICAgfTtcblxuICAgIHRoaXMubGluZUNvbW1lbnRTdGFydCA9IFwiXCI7XG4gICAgdGhpcy5ibG9ja0NvbW1lbnQgPSBcIlwiO1xuXG4gICAgdGhpcy50b2dnbGVDb21tZW50TGluZXMgPSBmdW5jdGlvbihzdGF0ZSwgc2Vzc2lvbiwgc3RhcnRSb3csIGVuZFJvdykge1xuICAgICAgICB2YXIgZG9jID0gc2Vzc2lvbi5kb2M7XG5cbiAgICAgICAgdmFyIGlnbm9yZUJsYW5rTGluZXMgPSB0cnVlO1xuICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1pbkluZGVudCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgdGFiU2l6ZSA9IHNlc3Npb24uZ2V0VGFiU2l6ZSgpO1xuICAgICAgICB2YXIgaW5zZXJ0QXRUYWJTdG9wID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpbmVDb21tZW50U3RhcnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ibG9ja0NvbW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxpbmVDb21tZW50U3RhcnQgPSB0aGlzLmJsb2NrQ29tbWVudC5zdGFydDtcbiAgICAgICAgICAgIHZhciBsaW5lQ29tbWVudEVuZCA9IHRoaXMuYmxvY2tDb21tZW50LmVuZDtcbiAgICAgICAgICAgIHZhciByZWdleHBTdGFydCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKikoPzpcIiArIGxhbmcuZXNjYXBlUmVnRXhwKGxpbmVDb21tZW50U3RhcnQpICsgXCIpXCIpO1xuICAgICAgICAgICAgdmFyIHJlZ2V4cEVuZCA9IG5ldyBSZWdFeHAoXCIoPzpcIiArIGxhbmcuZXNjYXBlUmVnRXhwKGxpbmVDb21tZW50RW5kKSArIFwiKVxcXFxzKiRcIik7XG5cbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gZnVuY3Rpb24obGluZSwgaSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0UmVtb3ZlKGxpbmUsIGkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVCbGFua0xpbmVzIHx8IC9cXFMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jLmluc2VydEluTGluZSh7cm93OiBpLCBjb2x1bW46IGxpbmUubGVuZ3RofSwgbGluZUNvbW1lbnRFbmQpO1xuICAgICAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0SW5MaW5lKHtyb3c6IGksIGNvbHVtbjogbWluSW5kZW50fSwgbGluZUNvbW1lbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHVuY29tbWVudCA9IGZ1bmN0aW9uKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbTtcbiAgICAgICAgICAgICAgICBpZiAobSA9IGxpbmUubWF0Y2gocmVnZXhwRW5kKSlcbiAgICAgICAgICAgICAgICAgICAgZG9jLnJlbW92ZUluTGluZShpLCBsaW5lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoLCBsaW5lLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG0gPSBsaW5lLm1hdGNoKHJlZ2V4cFN0YXJ0KSlcbiAgICAgICAgICAgICAgICAgICAgZG9jLnJlbW92ZUluTGluZShpLCBtWzFdLmxlbmd0aCwgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRlc3RSZW1vdmUgPSBmdW5jdGlvbihsaW5lLCByb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXhwU3RhcnQudGVzdChsaW5lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHNlc3Npb24uZ2V0VG9rZW5zKHJvdyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saW5lQ29tbWVudFN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdleHBTdGFydCA9IHRoaXMubGluZUNvbW1lbnRTdGFydC5tYXAobGFuZy5lc2NhcGVSZWdFeHApLmpvaW4oXCJ8XCIpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lQ29tbWVudFN0YXJ0ID0gdGhpcy5saW5lQ29tbWVudFN0YXJ0WzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwU3RhcnQgPSBsYW5nLmVzY2FwZVJlZ0V4cCh0aGlzLmxpbmVDb21tZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lQ29tbWVudFN0YXJ0ID0gdGhpcy5saW5lQ29tbWVudFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnZXhwU3RhcnQgPSBuZXcgUmVnRXhwKFwiXihcXFxccyopKD86XCIgKyByZWdleHBTdGFydCArIFwiKSA/XCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpbnNlcnRBdFRhYlN0b3AgPSBzZXNzaW9uLmdldFVzZVNvZnRUYWJzKCk7XG5cbiAgICAgICAgICAgIHZhciB1bmNvbW1lbnQgPSBmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKHJlZ2V4cFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBtWzFdLmxlbmd0aCwgZW5kID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRJbnNlcnRTcGFjZShsaW5lLCBzdGFydCwgZW5kKSAmJiBtWzBdW2VuZCAtIDFdID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICBlbmQtLTtcbiAgICAgICAgICAgICAgICBkb2MucmVtb3ZlSW5MaW5lKGksIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb21tZW50V2l0aFNwYWNlID0gbGluZUNvbW1lbnRTdGFydCArIFwiIFwiO1xuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVCbGFua0xpbmVzIHx8IC9cXFMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEluc2VydFNwYWNlKGxpbmUsIG1pbkluZGVudCwgbWluSW5kZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5pbnNlcnRJbkxpbmUoe3JvdzogaSwgY29sdW1uOiBtaW5JbmRlbnR9LCBjb21tZW50V2l0aFNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLmluc2VydEluTGluZSh7cm93OiBpLCBjb2x1bW46IG1pbkluZGVudH0sIGxpbmVDb21tZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGVzdFJlbW92ZSA9IGZ1bmN0aW9uKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhwU3RhcnQudGVzdChsaW5lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBzaG91bGRJbnNlcnRTcGFjZSA9IGZ1bmN0aW9uKGxpbmUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYmVmb3JlLS0gJiYgbGluZS5jaGFyQXQoYmVmb3JlKSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VzKys7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlcyAlIHRhYlNpemUgIT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lLmNoYXJBdChhZnRlcisrKSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VzKys7XG4gICAgICAgICAgICAgICAgaWYgKHRhYlNpemUgPiAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VzICUgdGFiU2l6ZSAhPSB0YWJTaXplIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGFjZXMgJSB0YWJTaXplID09IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXRlcihmdW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7IGkrKylcbiAgICAgICAgICAgICAgICBmdW4oZG9jLmdldExpbmUoaSksIGkpO1xuICAgICAgICB9XG5cblxuICAgICAgICB2YXIgbWluRW1wdHlMZW5ndGggPSBJbmZpbml0eTtcbiAgICAgICAgaXRlcihmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gbGluZS5zZWFyY2goL1xcUy8pO1xuICAgICAgICAgICAgaWYgKGluZGVudCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbWluSW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBtaW5JbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSAmJiAhdGVzdFJlbW92ZShsaW5lLCBpKSlcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pbkVtcHR5TGVuZ3RoID4gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtaW5FbXB0eUxlbmd0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWluSW5kZW50ID09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBtaW5JbmRlbnQgPSBtaW5FbXB0eUxlbmd0aDtcbiAgICAgICAgICAgIGlnbm9yZUJsYW5rTGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHNob3VsZFJlbW92ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc2VydEF0VGFiU3RvcCAmJiBtaW5JbmRlbnQgJSB0YWJTaXplICE9IDApXG4gICAgICAgICAgICBtaW5JbmRlbnQgPSBNYXRoLmZsb29yKG1pbkluZGVudCAvIHRhYlNpemUpICogdGFiU2l6ZTtcblxuICAgICAgICBpdGVyKHNob3VsZFJlbW92ZSA/IHVuY29tbWVudCA6IGNvbW1lbnQpO1xuICAgIH07XG5cbiAgICB0aGlzLnRvZ2dsZUJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXRlLCBzZXNzaW9uLCByYW5nZSwgY3Vyc29yKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5ibG9ja0NvbW1lbnQ7XG4gICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjb21tZW50LnN0YXJ0ICYmIGNvbW1lbnRbMF0pXG4gICAgICAgICAgICBjb21tZW50ID0gY29tbWVudFswXTtcblxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcihzZXNzaW9uLCBjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG5cbiAgICAgICAgdmFyIHNlbCA9IHNlc3Npb24uc2VsZWN0aW9uO1xuICAgICAgICB2YXIgaW5pdGlhbFJhbmdlID0gc2Vzc2lvbi5zZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgIHZhciBzdGFydFJvdywgY29sRGlmZjtcblxuICAgICAgICBpZiAodG9rZW4gJiYgL2NvbW1lbnQvLnRlc3QodG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydFJhbmdlLCBlbmRSYW5nZTtcbiAgICAgICAgICAgIHdoaWxlICh0b2tlbiAmJiAvY29tbWVudC8udGVzdCh0b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdG9rZW4udmFsdWUuaW5kZXhPZihjb21tZW50LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIGk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBjb2x1bW4sIHJvdywgY29sdW1uICsgY29tbWVudC5zdGFydC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3Ioc2Vzc2lvbiwgY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgICAgIHdoaWxlICh0b2tlbiAmJiAvY29tbWVudC8udGVzdCh0b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdG9rZW4udmFsdWUuaW5kZXhPZihjb21tZW50LmVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyBpO1xuICAgICAgICAgICAgICAgICAgICBlbmRSYW5nZSA9IG5ldyBSYW5nZShyb3csIGNvbHVtbiwgcm93LCBjb2x1bW4gKyBjb21tZW50LmVuZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZFJhbmdlKVxuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlKGVuZFJhbmdlKTtcbiAgICAgICAgICAgIGlmIChzdGFydFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmUoc3RhcnRSYW5nZSk7XG4gICAgICAgICAgICAgICAgc3RhcnRSb3cgPSBzdGFydFJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICBjb2xEaWZmID0gLWNvbW1lbnQuc3RhcnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sRGlmZiA9IGNvbW1lbnQuc3RhcnQubGVuZ3RoO1xuICAgICAgICAgICAgc3RhcnRSb3cgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICBzZXNzaW9uLmluc2VydChyYW5nZS5lbmQsIGNvbW1lbnQuZW5kKTtcbiAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHJhbmdlLnN0YXJ0LCBjb21tZW50LnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFJhbmdlLnN0YXJ0LnJvdyA9PSBzdGFydFJvdylcbiAgICAgICAgICAgIGluaXRpYWxSYW5nZS5zdGFydC5jb2x1bW4gKz0gY29sRGlmZjtcbiAgICAgICAgaWYgKGluaXRpYWxSYW5nZS5lbmQucm93ID09IHN0YXJ0Um93KVxuICAgICAgICAgICAgaW5pdGlhbFJhbmdlLmVuZC5jb2x1bW4gKz0gY29sRGlmZjtcbiAgICAgICAgc2Vzc2lvbi5zZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2UoaW5pdGlhbFJhbmdlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXROZXh0TGluZUluZGVudCA9IGZ1bmN0aW9uKHN0YXRlLCBsaW5lLCB0YWIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGdldEluZGVudChsaW5lKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jaGVja091dGRlbnQgPSBmdW5jdGlvbihzdGF0ZSwgbGluZSwgaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmF1dG9PdXRkZW50ID0gZnVuY3Rpb24oc3RhdGUsIGRvYywgcm93KSB7XG4gICAgfTtcblxuICAgIHRoaXMuJGdldEluZGVudCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmUubWF0Y2goL15cXHMqLylbMF07XG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlV29ya2VyID0gZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGVNb2RlRGVsZWdhdGVzID0gZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdGhpcy4kZW1iZWRzID0gW107XG4gICAgICAgIHRoaXMuJG1vZGVzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgaW4gbWFwcGluZykge1xuICAgICAgICAgICAgaWYgKG1hcHBpbmdbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWJlZHMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRtb2Rlc1tpXSA9IG5ldyBtYXBwaW5nW2ldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsZWdhdGlvbnMgPSBbJ3RvZ2dsZUJsb2NrQ29tbWVudCcsICd0b2dnbGVDb21tZW50TGluZXMnLCAnZ2V0TmV4dExpbmVJbmRlbnQnLCBcbiAgICAgICAgICAgICdjaGVja091dGRlbnQnLCAnYXV0b091dGRlbnQnLCAndHJhbnNmb3JtQWN0aW9uJywgJ2dldENvbXBsZXRpb25zJ107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxlZ2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBkZWxlZ2F0aW9uc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGRlZmF1bHRIYW5kbGVyID0gc2NvcGVbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgICAgICAgc2NvcGVbZGVsZWdhdGlvbnNbaV1dID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZGVsZWdhdG9yKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRzLCBkZWZhdWx0SGFuZGxlcik7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9ICh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kZGVsZWdhdG9yID0gZnVuY3Rpb24obWV0aG9kLCBhcmdzLCBkZWZhdWx0SGFuZGxlcikge1xuICAgICAgICB2YXIgc3RhdGUgPSBhcmdzWzBdO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGVtYmVkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRtb2Rlc1t0aGlzLiRlbWJlZHNbaV1dKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIHNwbGl0ID0gc3RhdGUuc3BsaXQodGhpcy4kZW1iZWRzW2ldKTtcbiAgICAgICAgICAgIGlmICghc3BsaXRbMF0gJiYgc3BsaXRbMV0pIHtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gc3BsaXRbMV07XG4gICAgICAgICAgICAgICAgdmFyIG1vZGUgPSB0aGlzLiRtb2Rlc1t0aGlzLiRlbWJlZHNbaV1dO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlW21ldGhvZF0uYXBwbHkobW9kZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldCA9IGRlZmF1bHRIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdEhhbmRsZXIgPyByZXQgOiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIHRoaXMudHJhbnNmb3JtQWN0aW9uID0gZnVuY3Rpb24oc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCBwYXJhbSkge1xuICAgICAgICBpZiAodGhpcy4kYmVoYXZpb3VyKSB7XG4gICAgICAgICAgICB2YXIgYmVoYXZpb3VycyA9IHRoaXMuJGJlaGF2aW91ci5nZXRCZWhhdmlvdXJzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmVoYXZpb3Vycykge1xuICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvdXJzW2tleV1bYWN0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gYmVoYXZpb3Vyc1trZXldW2FjdGlvbl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRLZXl3b3JkcyA9IGZ1bmN0aW9uKGFwcGVuZCkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGxldGlvbktleXdvcmRzKSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLiR0b2tlbml6ZXIucnVsZXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGlvbktleXdvcmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBydWxlIGluIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVJdHIgPSBydWxlc1tydWxlXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgbCA9IHJ1bGVJdHIubGVuZ3RoOyByIDwgbDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZUl0cltyXS50b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9rZXl3b3JkfHN1cHBvcnR8c3RvcmFnZS8udGVzdChydWxlSXRyW3JdLnRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uS2V5d29yZHMucHVzaChydWxlSXRyW3JdLnJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZUl0cltyXS50b2tlbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDAsIGFMZW5ndGggPSBydWxlSXRyW3JdLnRva2VuLmxlbmd0aDsgYSA8IGFMZW5ndGg7IGErKykgeyAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL2tleXdvcmR8c3VwcG9ydHxzdG9yYWdlLy50ZXN0KHJ1bGVJdHJbcl0udG9rZW5bYV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlID0gcnVsZUl0cltyXS5yZWdleC5tYXRjaCgvXFwoLis/XFwpL2cpW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uS2V5d29yZHMucHVzaChydWxlLnN1YnN0cigxLCBydWxlLmxlbmd0aCAtIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25LZXl3b3JkcyA9IGNvbXBsZXRpb25LZXl3b3JkcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRrZXl3b3JkTGlzdDtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25LZXl3b3Jkcy5jb25jYXQodGhpcy4ka2V5d29yZExpc3QgfHwgW10pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy4kY3JlYXRlS2V5d29yZExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRoaWdobGlnaHRSdWxlcylcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5pemVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLiRrZXl3b3JkTGlzdCA9IHRoaXMuJGhpZ2hsaWdodFJ1bGVzLiRrZXl3b3JkTGlzdCB8fCBbXTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDb21wbGV0aW9ucyA9IGZ1bmN0aW9uKHN0YXRlLCBzZXNzaW9uLCBwb3MsIHByZWZpeCkge1xuICAgICAgICB2YXIga2V5d29yZHMgPSB0aGlzLiRrZXl3b3JkTGlzdCB8fCB0aGlzLiRjcmVhdGVLZXl3b3JkTGlzdCgpO1xuICAgICAgICByZXR1cm4ga2V5d29yZHMubWFwKGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogd29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgICAgICBtZXRhOiBcImtleXdvcmRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuJGlkID0gXCJhY2UvbW9kZS90ZXh0XCI7XG59KS5jYWxsKE1vZGUucHJvdG90eXBlKTtcblxuZXhwb3J0cy5Nb2RlID0gTW9kZTtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2FuY2hvclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZXZlbnRfZW1pdHRlclwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvb3AgPSBhY2VxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xuXG52YXIgQW5jaG9yID0gZXhwb3J0cy5BbmNob3IgPSBmdW5jdGlvbihkb2MsIHJvdywgY29sdW1uKSB7XG4gICAgdGhpcy4kb25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hdHRhY2goZG9jKTtcbiAgICBcbiAgICBpZiAodHlwZW9mIGNvbHVtbiA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHJvdy5yb3csIHJvdy5jb2x1bW4pO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihyb3csIGNvbHVtbik7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XG4gICAgdGhpcy5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudCh0aGlzLnJvdywgdGhpcy5jb2x1bW4pO1xuICAgIH07XG4gICAgdGhpcy5nZXREb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudDtcbiAgICB9O1xuICAgIHRoaXMuJGluc2VydFJpZ2h0ID0gZmFsc2U7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gZS5kYXRhO1xuICAgICAgICB2YXIgcmFuZ2UgPSBkZWx0YS5yYW5nZTtcblxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ID09IHJhbmdlLmVuZC5yb3cgJiYgcmFuZ2Uuc3RhcnQucm93ICE9IHRoaXMucm93KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPiB0aGlzLnJvdylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ID09IHRoaXMucm93ICYmIHJhbmdlLnN0YXJ0LmNvbHVtbiA+IHRoaXMuY29sdW1uKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciByb3cgPSB0aGlzLnJvdztcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcblxuICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09PSBcImluc2VydFRleHRcIikge1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnJvdyA9PT0gcm93ICYmIHN0YXJ0LmNvbHVtbiA8PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQuY29sdW1uID09PSBjb2x1bW4gJiYgdGhpcy4kaW5zZXJ0UmlnaHQpIHtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0LnJvdyA9PT0gZW5kLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gZW5kLmNvbHVtbiAtIHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gLT0gc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICByb3cgKz0gZW5kLnJvdyAtIHN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0LnJvdyAhPT0gZW5kLnJvdyAmJiBzdGFydC5yb3cgPCByb3cpIHtcbiAgICAgICAgICAgICAgICByb3cgKz0gZW5kLnJvdyAtIHN0YXJ0LnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT09IFwiaW5zZXJ0TGluZXNcIikge1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnJvdyA9PT0gcm93ICYmIGNvbHVtbiA9PT0gMCAmJiB0aGlzLiRpbnNlcnRSaWdodCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQucm93IDw9IHJvdykge1xuICAgICAgICAgICAgICAgIHJvdyArPSBlbmQucm93IC0gc3RhcnQucm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PT0gXCJyZW1vdmVUZXh0XCIpIHtcbiAgICAgICAgICAgIGlmIChzdGFydC5yb3cgPT09IHJvdyAmJiBzdGFydC5jb2x1bW4gPCBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kLmNvbHVtbiA+PSBjb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IE1hdGgubWF4KDAsIGNvbHVtbiAtIChlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uKSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQucm93ICE9PSBlbmQucm93ICYmIHN0YXJ0LnJvdyA8IHJvdykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQucm93ID09PSByb3cpXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IE1hdGgubWF4KDAsIGNvbHVtbiAtIGVuZC5jb2x1bW4pICsgc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgICAgIHJvdyAtPSAoZW5kLnJvdyAtIHN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZC5yb3cgPT09IHJvdykge1xuICAgICAgICAgICAgICAgIHJvdyAtPSBlbmQucm93IC0gc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IE1hdGgubWF4KDAsIGNvbHVtbiAtIGVuZC5jb2x1bW4pICsgc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZUxpbmVzXCIpIHtcbiAgICAgICAgICAgIGlmIChzdGFydC5yb3cgPD0gcm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZC5yb3cgPD0gcm93KVxuICAgICAgICAgICAgICAgICAgICByb3cgLT0gZW5kLnJvdyAtIHN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gc3RhcnQucm93O1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocm93LCBjb2x1bW4sIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHJvdywgY29sdW1uLCBub0NsaXApIHtcbiAgICAgICAgdmFyIHBvcztcbiAgICAgICAgaWYgKG5vQ2xpcCkge1xuICAgICAgICAgICAgcG9zID0ge1xuICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudChyb3csIGNvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yb3cgPT0gcG9zLnJvdyAmJiB0aGlzLmNvbHVtbiA9PSBwb3MuY29sdW1uKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBvbGQgPSB7XG4gICAgICAgICAgICByb3c6IHRoaXMucm93LFxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucm93ID0gcG9zLnJvdztcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBwb3MuY29sdW1uO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwge1xuICAgICAgICAgICAgb2xkOiBvbGQsXG4gICAgICAgICAgICB2YWx1ZTogcG9zXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuJG9uQ2hhbmdlKTtcbiAgICB9O1xuICAgIHRoaXMuYXR0YWNoID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2MgfHwgdGhpcy5kb2N1bWVudDtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5vbihcImNoYW5nZVwiLCB0aGlzLiRvbkNoYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHBvcyA9IHt9O1xuXG4gICAgICAgIGlmIChyb3cgPj0gdGhpcy5kb2N1bWVudC5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgcG9zLnJvdyA9IE1hdGgubWF4KDAsIHRoaXMuZG9jdW1lbnQuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgICAgIHBvcy5jb2x1bW4gPSB0aGlzLmRvY3VtZW50LmdldExpbmUocG9zLnJvdykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdyA8IDApIHtcbiAgICAgICAgICAgIHBvcy5yb3cgPSAwO1xuICAgICAgICAgICAgcG9zLmNvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3Mucm93ID0gcm93O1xuICAgICAgICAgICAgcG9zLmNvbHVtbiA9IE1hdGgubWluKHRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGgsIE1hdGgubWF4KDAsIGNvbHVtbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtbiA8IDApXG4gICAgICAgICAgICBwb3MuY29sdW1uID0gMDtcblxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG5cbn0pLmNhbGwoQW5jaG9yLnByb3RvdHlwZSk7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2RvY3VtZW50XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvcmFuZ2VcIixcImFjZS9hbmNob3JcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBSYW5nZSA9IGFjZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBBbmNob3IgPSBhY2VxdWlyZShcIi4vYW5jaG9yXCIpLkFuY2hvcjtcblxudmFyIERvY3VtZW50ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHRoaXMuJGxpbmVzID0gW107XG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuJGxpbmVzID0gW1wiXCJdO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0KSkge1xuICAgICAgICB0aGlzLl9pbnNlcnRMaW5lcygwLCB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc2VydCh7cm93OiAwLCBjb2x1bW46MH0sIHRleHQpO1xuICAgIH1cbn07XG5cbihmdW5jdGlvbigpIHtcblxuICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcbiAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUobmV3IFJhbmdlKDAsIDAsIGxlbiwgdGhpcy5nZXRMaW5lKGxlbi0xKS5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoe3JvdzogMCwgY29sdW1uOjB9LCB0ZXh0KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsTGluZXMoKS5qb2luKHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpKTtcbiAgICB9O1xuICAgIHRoaXMuY3JlYXRlQW5jaG9yID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmNob3IodGhpcywgcm93LCBjb2x1bW4pO1xuICAgIH07XG4gICAgaWYgKFwiYWFhXCIuc3BsaXQoL2EvKS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuJHNwbGl0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxyXFxufFxcci9nLCBcIlxcblwiKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgfTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuJHNwbGl0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XG4gICAgICAgIH07XG5cblxuICAgIHRoaXMuJGRldGVjdE5ld0xpbmUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goL14uKj8oXFxyXFxufFxccnxcXG4pL20pO1xuICAgICAgICB0aGlzLiRhdXRvTmV3TGluZSA9IG1hdGNoID8gbWF0Y2hbMV0gOiBcIlxcblwiO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VOZXdMaW5lTW9kZVwiKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuJG5ld0xpbmVNb2RlKSB7XG4gICAgICAgICAgY2FzZSBcIndpbmRvd3NcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcclxcblwiO1xuICAgICAgICAgIGNhc2UgXCJ1bml4XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJcXG5cIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGF1dG9OZXdMaW5lIHx8IFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kYXV0b05ld0xpbmUgPSBcIlwiO1xuICAgIHRoaXMuJG5ld0xpbmVNb2RlID0gXCJhdXRvXCI7XG4gICAgdGhpcy5zZXROZXdMaW5lTW9kZSA9IGZ1bmN0aW9uKG5ld0xpbmVNb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLiRuZXdMaW5lTW9kZSA9PT0gbmV3TGluZU1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGhpcy4kbmV3TGluZU1vZGUgPSBuZXdMaW5lTW9kZTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlTmV3TGluZU1vZGVcIik7XG4gICAgfTtcbiAgICB0aGlzLmdldE5ld0xpbmVNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRuZXdMaW5lTW9kZTtcbiAgICB9O1xuICAgIHRoaXMuaXNOZXdMaW5lID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICByZXR1cm4gKHRleHQgPT0gXCJcXHJcXG5cIiB8fCB0ZXh0ID09IFwiXFxyXCIgfHwgdGV4dCA9PSBcIlxcblwiKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TGluZSA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy4kbGluZXNbcm93XSB8fCBcIlwiO1xuICAgIH07XG4gICAgdGhpcy5nZXRMaW5lcyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRsaW5lcy5zbGljZShmaXJzdFJvdywgbGFzdFJvdyArIDEpO1xuICAgIH07XG4gICAgdGhpcy5nZXRBbGxMaW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lcygwLCB0aGlzLmdldExlbmd0aCgpKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRsaW5lcy5sZW5ndGg7XG4gICAgfTtcbiAgICB0aGlzLmdldFRleHRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpXG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4sIHJhbmdlLmVuZC5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lcyA9IHRoaXMuZ2V0TGluZXMocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5lbmQucm93KTtcbiAgICAgICAgbGluZXNbMF0gPSAobGluZXNbMF0gfHwgXCJcIikuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgIHZhciBsID0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZC5yb3cgLSByYW5nZS5zdGFydC5yb3cgPT0gbClcbiAgICAgICAgICAgIGxpbmVzW2xdID0gbGluZXNbbF0uc3Vic3RyaW5nKDAsIHJhbmdlLmVuZC5jb2x1bW4pO1xuICAgICAgICByZXR1cm4gbGluZXMuam9pbih0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKSk7XG4gICAgfTtcblxuICAgIHRoaXMuJGNsaXBQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICBpZiAocG9zaXRpb24ucm93ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcG9zaXRpb24ucm93ID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBwb3NpdGlvbi5jb2x1bW4gPSB0aGlzLmdldExpbmUobGVuZ3RoLTEpLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbi5yb3cgPCAwKVxuICAgICAgICAgICAgcG9zaXRpb24ucm93ID0gMDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG4gICAgdGhpcy5pbnNlcnQgPSBmdW5jdGlvbihwb3NpdGlvbiwgdGV4dCkge1xuICAgICAgICBpZiAoIXRleHQgfHwgdGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLiRjbGlwUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5nZXRMZW5ndGgoKSA8PSAxKVxuICAgICAgICAgICAgdGhpcy4kZGV0ZWN0TmV3TGluZSh0ZXh0KTtcblxuICAgICAgICB2YXIgbGluZXMgPSB0aGlzLiRzcGxpdCh0ZXh0KTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgdmFyIGxhc3RMaW5lID0gbGluZXMubGVuZ3RoID09IDAgPyBudWxsIDogbGluZXMuc3BsaWNlKGxpbmVzLmxlbmd0aCAtIDEsIDEpWzBdO1xuXG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5pbnNlcnRJbkxpbmUocG9zaXRpb24sIGZpcnN0TGluZSk7XG4gICAgICAgIGlmIChsYXN0TGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmluc2VydE5ld0xpbmUocG9zaXRpb24pOyAvLyB0ZXJtaW5hdGUgZmlyc3QgbGluZVxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9pbnNlcnRMaW5lcyhwb3NpdGlvbi5yb3csIGxpbmVzKTtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5pbnNlcnRJbkxpbmUocG9zaXRpb24sIGxhc3RMaW5lIHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9O1xuICAgIHRoaXMuaW5zZXJ0TGluZXMgPSBmdW5jdGlvbihyb3csIGxpbmVzKSB7XG4gICAgICAgIGlmIChyb3cgPj0gdGhpcy5nZXRMZW5ndGgoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2VydCh7cm93OiByb3csIGNvbHVtbjogMH0sIFwiXFxuXCIgKyBsaW5lcy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydExpbmVzKE1hdGgubWF4KHJvdywgMCksIGxpbmVzKTtcbiAgICB9O1xuICAgIHRoaXMuX2luc2VydExpbmVzID0gZnVuY3Rpb24ocm93LCBsaW5lcykge1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4ge3Jvdzogcm93LCBjb2x1bW46IDB9O1xuICAgICAgICB3aGlsZSAobGluZXMubGVuZ3RoID4gMjAwMDApIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9pbnNlcnRMaW5lcyhyb3csIGxpbmVzLnNsaWNlKDAsIDIwMDAwKSk7XG4gICAgICAgICAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDIwMDAwKTtcbiAgICAgICAgICAgIHJvdyA9IGVuZC5yb3c7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJncyA9IFtyb3csIDBdO1xuICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgbGluZXMpO1xuICAgICAgICB0aGlzLiRsaW5lcy5zcGxpY2UuYXBwbHkodGhpcy4kbGluZXMsIGFyZ3MpO1xuXG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShyb3csIDAsIHJvdyArIGxpbmVzLmxlbmd0aCwgMCk7XG4gICAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnNlcnRMaW5lc1wiLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgbGluZXM6IGxpbmVzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVwiLCB7IGRhdGE6IGRlbHRhIH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW5kO1xuICAgIH07XG4gICAgdGhpcy5pbnNlcnROZXdMaW5lID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLiRjbGlwUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuJGxpbmVzW3Bvc2l0aW9uLnJvd10gfHwgXCJcIjtcblxuICAgICAgICB0aGlzLiRsaW5lc1twb3NpdGlvbi5yb3ddID0gbGluZS5zdWJzdHJpbmcoMCwgcG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgdGhpcy4kbGluZXMuc3BsaWNlKHBvc2l0aW9uLnJvdyArIDEsIDAsIGxpbmUuc3Vic3RyaW5nKHBvc2l0aW9uLmNvbHVtbiwgbGluZS5sZW5ndGgpKTtcblxuICAgICAgICB2YXIgZW5kID0ge1xuICAgICAgICAgICAgcm93IDogcG9zaXRpb24ucm93ICsgMSxcbiAgICAgICAgICAgIGNvbHVtbiA6IDBcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGVsdGEgPSB7XG4gICAgICAgICAgICBhY3Rpb246IFwiaW5zZXJ0VGV4dFwiLFxuICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmZyb21Qb2ludHMocG9zaXRpb24sIGVuZCksXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwgeyBkYXRhOiBkZWx0YSB9KTtcblxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH07XG4gICAgdGhpcy5pbnNlcnRJbkxpbmUgPSBmdW5jdGlvbihwb3NpdGlvbiwgdGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcblxuICAgICAgICB2YXIgbGluZSA9IHRoaXMuJGxpbmVzW3Bvc2l0aW9uLnJvd10gfHwgXCJcIjtcblxuICAgICAgICB0aGlzLiRsaW5lc1twb3NpdGlvbi5yb3ddID0gbGluZS5zdWJzdHJpbmcoMCwgcG9zaXRpb24uY29sdW1uKSArIHRleHRcbiAgICAgICAgICAgICAgICArIGxpbmUuc3Vic3RyaW5nKHBvc2l0aW9uLmNvbHVtbik7XG5cbiAgICAgICAgdmFyIGVuZCA9IHtcbiAgICAgICAgICAgIHJvdyA6IHBvc2l0aW9uLnJvdyxcbiAgICAgICAgICAgIGNvbHVtbiA6IHBvc2l0aW9uLmNvbHVtbiArIHRleHQubGVuZ3RoXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlbHRhID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBcImluc2VydFRleHRcIixcbiAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5mcm9tUG9pbnRzKHBvc2l0aW9uLCBlbmQpLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwgeyBkYXRhOiBkZWx0YSB9KTtcblxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSlcbiAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgICAgcmFuZ2Uuc3RhcnQgPSB0aGlzLiRjbGlwUG9zaXRpb24ocmFuZ2Uuc3RhcnQpO1xuICAgICAgICByYW5nZS5lbmQgPSB0aGlzLiRjbGlwUG9zaXRpb24ocmFuZ2UuZW5kKTtcblxuICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xuXG4gICAgICAgIHZhciBmaXJzdFJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgdmFyIGxhc3RSb3cgPSByYW5nZS5lbmQucm93O1xuXG4gICAgICAgIGlmIChyYW5nZS5pc011bHRpTGluZSgpKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RGdWxsUm93ID0gcmFuZ2Uuc3RhcnQuY29sdW1uID09IDAgPyBmaXJzdFJvdyA6IGZpcnN0Um93ICsgMTtcbiAgICAgICAgICAgIHZhciBsYXN0RnVsbFJvdyA9IGxhc3RSb3cgLSAxO1xuXG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kLmNvbHVtbiA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJbkxpbmUobGFzdFJvdywgMCwgcmFuZ2UuZW5kLmNvbHVtbik7XG5cbiAgICAgICAgICAgIGlmIChsYXN0RnVsbFJvdyA+PSBmaXJzdEZ1bGxSb3cpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGluZXMoZmlyc3RGdWxsUm93LCBsYXN0RnVsbFJvdyk7XG5cbiAgICAgICAgICAgIGlmIChmaXJzdEZ1bGxSb3cgIT0gZmlyc3RSb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUluTGluZShmaXJzdFJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uLCB0aGlzLmdldExpbmUoZmlyc3RSb3cpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOZXdMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUluTGluZShmaXJzdFJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uLCByYW5nZS5lbmQuY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUluTGluZSA9IGZ1bmN0aW9uKHJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPT0gZW5kQ29sdW1uKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShyb3csIHN0YXJ0Q29sdW1uLCByb3csIGVuZENvbHVtbik7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciByZW1vdmVkID0gbGluZS5zdWJzdHJpbmcoc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG4gICAgICAgIHZhciBuZXdMaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgc3RhcnRDb2x1bW4pICsgbGluZS5zdWJzdHJpbmcoZW5kQ29sdW1uLCBsaW5lLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuJGxpbmVzLnNwbGljZShyb3csIDEsIG5ld0xpbmUpO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZW1vdmVUZXh0XCIsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICB0ZXh0OiByZW1vdmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVwiLCB7IGRhdGE6IGRlbHRhIH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZUxpbmVzID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgaWYgKGZpcnN0Um93IDwgMCB8fCBsYXN0Um93ID49IHRoaXMuZ2V0TGVuZ3RoKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUobmV3IFJhbmdlKGZpcnN0Um93LCAwLCBsYXN0Um93ICsgMSwgMCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlTGluZXMoZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVMaW5lcyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShmaXJzdFJvdywgMCwgbGFzdFJvdyArIDEsIDApO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuJGxpbmVzLnNwbGljZShmaXJzdFJvdywgbGFzdFJvdyAtIGZpcnN0Um93ICsgMSk7XG5cbiAgICAgICAgdmFyIGRlbHRhID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlbW92ZUxpbmVzXCIsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBubDogdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCksXG4gICAgICAgICAgICBsaW5lczogcmVtb3ZlZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VcIiwgeyBkYXRhOiBkZWx0YSB9KTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZU5ld0xpbmUgPSBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IHRoaXMuZ2V0TGluZShyb3cpO1xuICAgICAgICB2YXIgc2Vjb25kTGluZSA9IHRoaXMuZ2V0TGluZShyb3crMSk7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHJvdywgZmlyc3RMaW5lLmxlbmd0aCwgcm93KzEsIDApO1xuICAgICAgICB2YXIgbGluZSA9IGZpcnN0TGluZSArIHNlY29uZExpbmU7XG5cbiAgICAgICAgdGhpcy4kbGluZXMuc3BsaWNlKHJvdywgMiwgbGluZSk7XG5cbiAgICAgICAgdmFyIGRlbHRhID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlbW92ZVRleHRcIixcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVwiLCB7IGRhdGE6IGRlbHRhIH0pO1xuICAgIH07XG4gICAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24ocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpXG4gICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwICYmIHJhbmdlLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcbiAgICAgICAgaWYgKHRleHQgPT0gdGhpcy5nZXRUZXh0UmFuZ2UocmFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLmVuZDtcblxuICAgICAgICB0aGlzLnJlbW92ZShyYW5nZSk7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5pbnNlcnQocmFuZ2Uuc3RhcnQsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH07XG4gICAgdGhpcy5hcHBseURlbHRhcyA9IGZ1bmN0aW9uKGRlbHRhcykge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGRlbHRhLnJhbmdlLnN0YXJ0LCBkZWx0YS5yYW5nZS5lbmQpO1xuXG4gICAgICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0TGluZXNcIilcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydExpbmVzKHJhbmdlLnN0YXJ0LnJvdywgZGVsdGEubGluZXMpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0VGV4dFwiKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHJhbmdlLnN0YXJ0LCBkZWx0YS50ZXh0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZUxpbmVzXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGluZXMocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5lbmQucm93IC0gMSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVUZXh0XCIpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJldmVydERlbHRhcyA9IGZ1bmN0aW9uKGRlbHRhcykge1xuICAgICAgICBmb3IgKHZhciBpPWRlbHRhcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoZGVsdGEucmFuZ2Uuc3RhcnQsIGRlbHRhLnJhbmdlLmVuZCk7XG5cbiAgICAgICAgICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJpbnNlcnRMaW5lc1wiKVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpbmVzKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2UuZW5kLnJvdyAtIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFwiaW5zZXJ0VGV4dFwiKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZUxpbmVzXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0TGluZXMocmFuZ2Uuc3RhcnQucm93LCBkZWx0YS5saW5lcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVUZXh0XCIpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQocmFuZ2Uuc3RhcnQsIGRlbHRhLnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmluZGV4VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKGluZGV4LCBzdGFydFJvdykge1xuICAgICAgICB2YXIgbGluZXMgPSB0aGlzLiRsaW5lcyB8fCB0aGlzLmdldEFsbExpbmVzKCk7XG4gICAgICAgIHZhciBuZXdsaW5lTGVuZ3RoID0gdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRSb3cgfHwgMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaW5kZXggLT0gbGluZXNbaV0ubGVuZ3RoICsgbmV3bGluZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtyb3c6IGksIGNvbHVtbjogaW5kZXggKyBsaW5lc1tpXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RofTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3JvdzogbC0xLCBjb2x1bW46IGxpbmVzW2wtMV0ubGVuZ3RofTtcbiAgICB9O1xuICAgIHRoaXMucG9zaXRpb25Ub0luZGV4ID0gZnVuY3Rpb24ocG9zLCBzdGFydFJvdykge1xuICAgICAgICB2YXIgbGluZXMgPSB0aGlzLiRsaW5lcyB8fCB0aGlzLmdldEFsbExpbmVzKCk7XG4gICAgICAgIHZhciBuZXdsaW5lTGVuZ3RoID0gdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgcm93ID0gTWF0aC5taW4ocG9zLnJvdywgbGluZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93IHx8IDA7IGkgPCByb3c7ICsraSlcbiAgICAgICAgICAgIGluZGV4ICs9IGxpbmVzW2ldLmxlbmd0aCArIG5ld2xpbmVMZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIGluZGV4ICsgcG9zLmNvbHVtbjtcbiAgICB9O1xuXG59KS5jYWxsKERvY3VtZW50LnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuRG9jdW1lbnQgPSBEb2N1bWVudDtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2JhY2tncm91bmRfdG9rZW5pemVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBCYWNrZ3JvdW5kVG9rZW5pemVyID0gZnVuY3Rpb24odG9rZW5pemVyLCBlZGl0b3IpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRMaW5lID0gMDtcbiAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuJHdvcmtlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYucnVubmluZykgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgd29ya2VyU3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgY3VycmVudExpbmUgPSBzZWxmLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgZW5kTGluZSA9IC0xO1xuICAgICAgICB2YXIgZG9jID0gc2VsZi5kb2M7XG5cbiAgICAgICAgd2hpbGUgKHNlbGYubGluZXNbY3VycmVudExpbmVdKVxuICAgICAgICAgICAgY3VycmVudExpbmUrKztcblxuICAgICAgICB2YXIgc3RhcnRMaW5lID0gY3VycmVudExpbmU7XG5cbiAgICAgICAgdmFyIGxlbiA9IGRvYy5nZXRMZW5ndGgoKTtcbiAgICAgICAgdmFyIHByb2Nlc3NlZExpbmVzID0gMDtcbiAgICAgICAgc2VsZi5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChjdXJyZW50TGluZSA8IGxlbikge1xuICAgICAgICAgICAgc2VsZi4kdG9rZW5pemVSb3coY3VycmVudExpbmUpO1xuICAgICAgICAgICAgZW5kTGluZSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lKys7XG4gICAgICAgICAgICB9IHdoaWxlIChzZWxmLmxpbmVzW2N1cnJlbnRMaW5lXSk7XG4gICAgICAgICAgICBwcm9jZXNzZWRMaW5lcyArKztcbiAgICAgICAgICAgIGlmICgocHJvY2Vzc2VkTGluZXMgJSA1ID09PSAwKSAmJiAobmV3IERhdGUoKSAtIHdvcmtlclN0YXJ0KSA+IDIwKSB7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNlbGYucnVubmluZyA9IHNldFRpbWVvdXQoc2VsZi4kd29ya2VyLCAyMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jdXJyZW50TGluZSA9IGN1cnJlbnRMaW5lO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXJ0TGluZSA8PSBlbmRMaW5lKVxuICAgICAgICAgICAgc2VsZi5maXJlVXBkYXRlRXZlbnQoc3RhcnRMaW5lLCBlbmRMaW5lKTtcbiAgICB9O1xufTtcblxuKGZ1bmN0aW9uKCl7XG5cbiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XG4gICAgdGhpcy5zZXRUb2tlbml6ZXIgPSBmdW5jdGlvbih0b2tlbml6ZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnN0YXJ0KDApO1xuICAgIH07XG4gICAgdGhpcy5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG4gICAgdGhpcy5maXJlVXBkYXRlRXZlbnQgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGZpcnN0OiBmaXJzdFJvdyxcbiAgICAgICAgICAgIGxhc3Q6IGxhc3RSb3dcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwidXBkYXRlXCIsIHtkYXRhOiBkYXRhfSk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oc3RhcnRSb3cpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IE1hdGgubWluKHN0YXJ0Um93IHx8IDAsIHRoaXMuY3VycmVudExpbmUsIHRoaXMuZG9jLmdldExlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5saW5lcy5zcGxpY2UodGhpcy5jdXJyZW50TGluZSwgdGhpcy5saW5lcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlcy5zcGxpY2UodGhpcy5jdXJyZW50TGluZSwgdGhpcy5zdGF0ZXMubGVuZ3RoKTtcblxuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gc2V0VGltZW91dCh0aGlzLiR3b3JrZXIsIDcwMCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNjaGVkdWxlU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpXG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBzZXRUaW1lb3V0KHRoaXMuJHdvcmtlciwgNzAwKTtcbiAgICB9XG5cbiAgICB0aGlzLiR1cGRhdGVPbkNoYW5nZSA9IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRlbHRhLnJhbmdlO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBsZW4gPSByYW5nZS5lbmQucm93IC0gc3RhcnRSb3c7XG5cbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5lc1tzdGFydFJvd10gPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZVRleHRcIiB8fCBkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVMaW5lc1wiKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLnNwbGljZShzdGFydFJvdywgbGVuICsgMSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5zcGxpY2Uoc3RhcnRSb3csIGxlbiArIDEsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW4gKyAxKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChzdGFydFJvdywgMSk7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLnNwbGljZS5hcHBseSh0aGlzLmxpbmVzLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnNwbGljZS5hcHBseSh0aGlzLnN0YXRlcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gTWF0aC5taW4oc3RhcnRSb3csIHRoaXMuY3VycmVudExpbmUsIHRoaXMuZG9jLmdldExlbmd0aCgpKTtcblxuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucnVubmluZyk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5nZXRUb2tlbnMgPSBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXNbcm93XSB8fCB0aGlzLiR0b2tlbml6ZVJvdyhyb3cpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTdGF0ZSA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TGluZSA9PSByb3cpXG4gICAgICAgICAgICB0aGlzLiR0b2tlbml6ZVJvdyhyb3cpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbcm93XSB8fCBcInN0YXJ0XCI7XG4gICAgfTtcblxuICAgIHRoaXMuJHRva2VuaXplUm93ID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlc1tyb3cgLSAxXTtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMudG9rZW5pemVyLmdldExpbmVUb2tlbnMobGluZSwgc3RhdGUsIHJvdyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzW3Jvd10gKyBcIlwiICE9PSBkYXRhLnN0YXRlICsgXCJcIikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXNbcm93XSA9IGRhdGEuc3RhdGU7XG4gICAgICAgICAgICB0aGlzLmxpbmVzW3JvdyArIDFdID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMaW5lID4gcm93ICsgMSlcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gcm93ICsgMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRMaW5lID09IHJvdykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IHJvdyArIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tyb3ddID0gZGF0YS50b2tlbnM7XG4gICAgfTtcblxufSkuY2FsbChCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuQmFja2dyb3VuZFRva2VuaXplciA9IEJhY2tncm91bmRUb2tlbml6ZXI7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9zZWFyY2hfaGlnaGxpZ2h0XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9saWIvb29wXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgbGFuZyA9IGFjZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBvb3AgPSBhY2VxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBSYW5nZSA9IGFjZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcblxudmFyIFNlYXJjaEhpZ2hsaWdodCA9IGZ1bmN0aW9uKHJlZ0V4cCwgY2xhenosIHR5cGUpIHtcbiAgICB0aGlzLnNldFJlZ2V4cChyZWdFeHApO1xuICAgIHRoaXMuY2xhenogPSBjbGF6ejtcbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IFwidGV4dFwiO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuTUFYX1JBTkdFUyA9IDUwMDtcbiAgICBcbiAgICB0aGlzLnNldFJlZ2V4cCA9IGZ1bmN0aW9uKHJlZ0V4cCkge1xuICAgICAgICBpZiAodGhpcy5yZWdFeHArXCJcIiA9PSByZWdFeHArXCJcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZWdFeHAgPSByZWdFeHA7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBbXTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihodG1sLCBtYXJrZXJMYXllciwgc2Vzc2lvbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWdFeHApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBzdGFydCA9IGNvbmZpZy5maXJzdFJvdywgZW5kID0gY29uZmlnLmxhc3RSb3c7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5jYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcyA9IGxhbmcuZ2V0TWF0Y2hPZmZzZXRzKHNlc3Npb24uZ2V0TGluZShpKSwgdGhpcy5yZWdFeHApO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gdGhpcy5NQVhfUkFOR0VTKVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSByYW5nZXMuc2xpY2UoMCwgdGhpcy5NQVhfUkFOR0VTKTtcbiAgICAgICAgICAgICAgICByYW5nZXMgPSByYW5nZXMubWFwKGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UoaSwgbWF0Y2gub2Zmc2V0LCBpLCBtYXRjaC5vZmZzZXQgKyBtYXRjaC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbaV0gPSByYW5nZXMubGVuZ3RoID8gcmFuZ2VzIDogXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJhbmdlcy5sZW5ndGg7IGogLS07ICkge1xuICAgICAgICAgICAgICAgIG1hcmtlckxheWVyLmRyYXdTaW5nbGVMaW5lTWFya2VyKFxuICAgICAgICAgICAgICAgICAgICBodG1sLCByYW5nZXNbal0udG9TY3JlZW5SYW5nZShzZXNzaW9uKSwgdGhpcy5jbGF6eiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbn0pLmNhbGwoU2VhcmNoSGlnaGxpZ2h0LnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuU2VhcmNoSGlnaGxpZ2h0ID0gU2VhcmNoSGlnaGxpZ2h0O1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdF9zZXNzaW9uL2ZvbGRfbGluZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbmZ1bmN0aW9uIEZvbGRMaW5lKGZvbGREYXRhLCBmb2xkcykge1xuICAgIHRoaXMuZm9sZERhdGEgPSBmb2xkRGF0YTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmb2xkcykpIHtcbiAgICAgICAgdGhpcy5mb2xkcyA9IGZvbGRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbGRzID0gdGhpcy5mb2xkcyA9IFsgZm9sZHMgXTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IGZvbGRzW2ZvbGRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMucmFuZ2UgPSBuZXcgUmFuZ2UoZm9sZHNbMF0uc3RhcnQucm93LCBmb2xkc1swXS5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0LmVuZC5yb3csIGxhc3QuZW5kLmNvbHVtbik7XG4gICAgdGhpcy5zdGFydCA9IHRoaXMucmFuZ2Uuc3RhcnQ7XG4gICAgdGhpcy5lbmQgICA9IHRoaXMucmFuZ2UuZW5kO1xuXG4gICAgdGhpcy5mb2xkcy5mb3JFYWNoKGZ1bmN0aW9uKGZvbGQpIHtcbiAgICAgICAgZm9sZC5zZXRGb2xkTGluZSh0aGlzKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2hpZnRSb3cgPSBmdW5jdGlvbihzaGlmdCkge1xuICAgICAgICB0aGlzLnN0YXJ0LnJvdyArPSBzaGlmdDtcbiAgICAgICAgdGhpcy5lbmQucm93ICs9IHNoaWZ0O1xuICAgICAgICB0aGlzLmZvbGRzLmZvckVhY2goZnVuY3Rpb24oZm9sZCkge1xuICAgICAgICAgICAgZm9sZC5zdGFydC5yb3cgKz0gc2hpZnQ7XG4gICAgICAgICAgICBmb2xkLmVuZC5yb3cgKz0gc2hpZnQ7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZEZvbGQgPSBmdW5jdGlvbihmb2xkKSB7XG4gICAgICAgIGlmIChmb2xkLnNhbWVSb3cpIHtcbiAgICAgICAgICAgIGlmIChmb2xkLnN0YXJ0LnJvdyA8IHRoaXMuc3RhcnRSb3cgfHwgZm9sZC5lbmRSb3cgPiB0aGlzLmVuZFJvdykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGFkZCBhIGZvbGQgdG8gdGhpcyBGb2xkTGluZSBhcyBpdCBoYXMgbm8gY29ubmVjdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9sZHMucHVzaChmb2xkKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1hLnJhbmdlLmNvbXBhcmVFbmQoYi5zdGFydC5yb3csIGIuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2UuY29tcGFyZUVuZChmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4pID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kLnJvdyA9IGZvbGQuZW5kLnJvdztcbiAgICAgICAgICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPSAgZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlLmNvbXBhcmVTdGFydChmb2xkLmVuZC5yb3csIGZvbGQuZW5kLmNvbHVtbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydC5yb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbGQuc3RhcnQucm93ID09IHRoaXMuZW5kLnJvdykge1xuICAgICAgICAgICAgdGhpcy5mb2xkcy5wdXNoKGZvbGQpO1xuICAgICAgICAgICAgdGhpcy5lbmQucm93ID0gZm9sZC5lbmQucm93O1xuICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbGQuZW5kLnJvdyA9PSB0aGlzLnN0YXJ0LnJvdykge1xuICAgICAgICAgICAgdGhpcy5mb2xkcy51bnNoaWZ0KGZvbGQpO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5yb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID0gZm9sZC5zdGFydC5jb2x1bW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gYWRkIGZvbGQgdG8gRm9sZFJvdyB0aGF0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIHJvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBmb2xkLmZvbGRMaW5lID0gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5jb250YWluc1JvdyA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gcm93ID49IHRoaXMuc3RhcnQucm93ICYmIHJvdyA8PSB0aGlzLmVuZC5yb3c7XG4gICAgfTtcblxuICAgIHRoaXMud2FsayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbmRSb3csIGVuZENvbHVtbikge1xuICAgICAgICB2YXIgbGFzdEVuZCA9IDAsXG4gICAgICAgICAgICBmb2xkcyA9IHRoaXMuZm9sZHMsXG4gICAgICAgICAgICBmb2xkLFxuICAgICAgICAgICAgY21wLCBzdG9wLCBpc05ld1JvdyA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVuZFJvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRSb3cgPSB0aGlzLmVuZC5yb3c7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSB0aGlzLmVuZC5jb2x1bW47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb2xkID0gZm9sZHNbaV07XG5cbiAgICAgICAgICAgIGNtcCA9IGZvbGQucmFuZ2UuY29tcGFyZVN0YXJ0KGVuZFJvdywgZW5kQ29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBlbmRSb3csIGVuZENvbHVtbiwgbGFzdEVuZCwgaXNOZXdSb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcCA9IGNhbGxiYWNrKG51bGwsIGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbiwgbGFzdEVuZCwgaXNOZXdSb3cpO1xuICAgICAgICAgICAgc3RvcCA9ICFzdG9wICYmIGNhbGxiYWNrKGZvbGQucGxhY2Vob2xkZXIsIGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbiwgbGFzdEVuZCk7XG4gICAgICAgICAgICBpZiAoc3RvcCB8fCBjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc05ld1JvdyA9ICFmb2xkLnNhbWVSb3c7XG4gICAgICAgICAgICBsYXN0RW5kID0gZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGVuZFJvdywgZW5kQ29sdW1uLCBsYXN0RW5kLCBpc05ld1Jvdyk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0TmV4dEZvbGRUbyA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciBmb2xkLCBjbXA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9sZCA9IHRoaXMuZm9sZHNbaV07XG4gICAgICAgICAgICBjbXAgPSBmb2xkLnJhbmdlLmNvbXBhcmVFbmQocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGQ6IGZvbGQsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiYWZ0ZXJcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGQ6IGZvbGQsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiaW5zaWRlXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZFJlbW92ZUNoYXJzID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIGxlbikge1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy5nZXROZXh0Rm9sZFRvKHJvdywgY29sdW1uKSxcbiAgICAgICAgICAgIGZvbGQsIGZvbGRzO1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICBmb2xkID0gcmV0LmZvbGQ7XG4gICAgICAgICAgICBpZiAocmV0LmtpbmQgPT0gXCJpbnNpZGVcIlxuICAgICAgICAgICAgICAgICYmIGZvbGQuc3RhcnQuY29sdW1uICE9IGNvbHVtblxuICAgICAgICAgICAgICAgICYmIGZvbGQuc3RhcnQucm93ICE9IHJvdylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cocm93LCBjb2x1bW4sIGZvbGQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb2xkLnN0YXJ0LnJvdyA9PSByb3cpIHtcbiAgICAgICAgICAgICAgICBmb2xkcyA9IHRoaXMuZm9sZHM7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmb2xkcy5pbmRleE9mKGZvbGQpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uICs9IGxlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpOyBpIDwgZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZCA9IGZvbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb2xkLnN0YXJ0LmNvbHVtbiArPSBsZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9sZC5zYW1lUm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9sZC5lbmQuY29sdW1uICs9IGxlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnNwbGl0ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TmV4dEZvbGRUbyhyb3csIGNvbHVtbik7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXBvcyB8fCBwb3Mua2luZCA9PSBcImluc2lkZVwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgdmFyIGZvbGQgPSBwb3MuZm9sZDtcbiAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5mb2xkcztcbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy5mb2xkRGF0YTtcbiAgICAgICAgXG4gICAgICAgIHZhciBpID0gZm9sZHMuaW5kZXhPZihmb2xkKTtcbiAgICAgICAgdmFyIGZvbGRCZWZvcmUgPSBmb2xkc1tpIC0gMV07XG4gICAgICAgIHRoaXMuZW5kLnJvdyA9IGZvbGRCZWZvcmUuZW5kLnJvdztcbiAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gZm9sZEJlZm9yZS5lbmQuY29sdW1uO1xuICAgICAgICBmb2xkcyA9IGZvbGRzLnNwbGljZShpLCBmb2xkcy5sZW5ndGggLSBpKTtcblxuICAgICAgICB2YXIgbmV3Rm9sZExpbmUgPSBuZXcgRm9sZExpbmUoZm9sZERhdGEsIGZvbGRzKTtcbiAgICAgICAgZm9sZERhdGEuc3BsaWNlKGZvbGREYXRhLmluZGV4T2YodGhpcykgKyAxLCAwLCBuZXdGb2xkTGluZSk7XG4gICAgICAgIHJldHVybiBuZXdGb2xkTGluZTtcbiAgICB9O1xuXG4gICAgdGhpcy5tZXJnZSA9IGZ1bmN0aW9uKGZvbGRMaW5lTmV4dCkge1xuICAgICAgICB2YXIgZm9sZHMgPSBmb2xkTGluZU5leHQuZm9sZHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRm9sZChmb2xkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy5mb2xkRGF0YTtcbiAgICAgICAgZm9sZERhdGEuc3BsaWNlKGZvbGREYXRhLmluZGV4T2YoZm9sZExpbmVOZXh0KSwgMSk7XG4gICAgfTtcblxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJldCA9IFt0aGlzLnJhbmdlLnRvU3RyaW5nKCkgKyBcIjogW1wiIF07XG5cbiAgICAgICAgdGhpcy5mb2xkcy5mb3JFYWNoKGZ1bmN0aW9uKGZvbGQpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKFwiICBcIiArIGZvbGQudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXQucHVzaChcIl1cIik7XG4gICAgICAgIHJldHVybiByZXQuam9pbihcIlxcblwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5pZHhUb1Bvc2l0aW9uID0gZnVuY3Rpb24oaWR4KSB7XG4gICAgICAgIHZhciBsYXN0Rm9sZEVuZENvbHVtbiA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuZm9sZHNbaV07XG5cbiAgICAgICAgICAgIGlkeCAtPSBmb2xkLnN0YXJ0LmNvbHVtbiAtIGxhc3RGb2xkRW5kQ29sdW1uO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByb3c6IGZvbGQuc3RhcnQucm93LFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGZvbGQuc3RhcnQuY29sdW1uICsgaWR4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWR4IC09IGZvbGQucGxhY2Vob2xkZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9sZC5zdGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdEZvbGRFbmRDb2x1bW4gPSBmb2xkLmVuZC5jb2x1bW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93OiB0aGlzLmVuZC5yb3csXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuZW5kLmNvbHVtbiArIGlkeFxuICAgICAgICB9O1xuICAgIH07XG59KS5jYWxsKEZvbGRMaW5lLnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuRm9sZExpbmUgPSBGb2xkTGluZTtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3JhbmdlX2xpc3RcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUmFuZ2UgPSBhY2VxdWlyZShcIi4vcmFuZ2VcIikuUmFuZ2U7XG52YXIgY29tcGFyZVBvaW50cyA9IFJhbmdlLmNvbXBhcmVQb2ludHM7XG5cbnZhciBSYW5nZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJhbmdlcyA9IFtdO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29tcGFyZVBvaW50cyA9IGNvbXBhcmVQb2ludHM7XG5cbiAgICB0aGlzLnBvaW50SW5kZXggPSBmdW5jdGlvbihwb3MsIGV4Y2x1ZGVFZGdlcywgc3RhcnRJbmRleCkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmFuZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGNtcEVuZCA9IGNvbXBhcmVQb2ludHMocG9zLCByYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGNtcEVuZCA+IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgY21wU3RhcnQgPSBjb21wYXJlUG9pbnRzKHBvcywgcmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGNtcEVuZCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZUVkZ2VzICYmIGNtcFN0YXJ0ICE9PSAwID8gLWktMiA6IGk7XG4gICAgICAgICAgICBpZiAoY21wU3RhcnQgPiAwIHx8IChjbXBTdGFydCA9PT0gMCAmJiAhZXhjbHVkZUVkZ2VzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcblxuICAgICAgICAgICAgcmV0dXJuIC1pLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC1pIC0gMTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGQgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgZXhjbHVkZUVkZ2VzID0gIXJhbmdlLmlzRW1wdHkoKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLnBvaW50SW5kZXgocmFuZ2Uuc3RhcnQsIGV4Y2x1ZGVFZGdlcyk7XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgMClcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAtc3RhcnRJbmRleCAtIDE7XG5cbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHJhbmdlLmVuZCwgZXhjbHVkZUVkZ2VzLCBzdGFydEluZGV4KTtcblxuICAgICAgICBpZiAoZW5kSW5kZXggPCAwKVxuICAgICAgICAgICAgZW5kSW5kZXggPSAtZW5kSW5kZXggLSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlbmRJbmRleCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMuc3BsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4IC0gc3RhcnRJbmRleCwgcmFuZ2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZExpc3QgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaC5jYWxsKHJlbW92ZWQsIHRoaXMuYWRkKGxpc3RbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJzdHJhY3RQb2ludCA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICB2YXIgaSA9IHRoaXMucG9pbnRJbmRleChwb3MpO1xuXG4gICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMuc3BsaWNlKGksIDEpO1xuICAgIH07XG4gICAgdGhpcy5tZXJnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBcbiAgICAgICAgbGlzdCA9IGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50cyhhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbmV4dCA9IGxpc3RbMF0sIHJhbmdlO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmVQb2ludHMocmFuZ2UuZW5kLCBuZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoY21wID09IDAgJiYgIXJhbmdlLmlzRW1wdHkoKSAmJiAhbmV4dC5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5lbmQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBuZXh0LmVuZC5yb3c7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IG5leHQuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2gobmV4dCk7XG4gICAgICAgICAgICBuZXh0ID0gcmFuZ2U7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMucmFuZ2VzID0gbGlzdDtcblxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuXG4gICAgdGhpcy5jb250YWlucyA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50SW5kZXgoe3Jvdzogcm93LCBjb2x1bW46IGNvbHVtbn0pID49IDA7XG4gICAgfTtcblxuICAgIHRoaXMuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEluZGV4KHBvcykgPj0gMDtcbiAgICB9O1xuXG4gICAgdGhpcy5yYW5nZUF0UG9pbnQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnBvaW50SW5kZXgocG9zKTtcbiAgICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpXTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLmNsaXBSb3dzID0gZnVuY3Rpb24oc3RhcnRSb3csIGVuZFJvdykge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBpZiAobGlzdFswXS5zdGFydC5yb3cgPiBlbmRSb3cgfHwgbGlzdFtsaXN0Lmxlbmd0aCAtIDFdLnN0YXJ0LnJvdyA8IHN0YXJ0Um93KVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuXG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IDB9KTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCAwKVxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IC1zdGFydEluZGV4IC0gMTtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHtyb3c6IGVuZFJvdywgY29sdW1uOiAwfSwgc3RhcnRJbmRleCk7XG4gICAgICAgIGlmIChlbmRJbmRleCA8IDApXG4gICAgICAgICAgICBlbmRJbmRleCA9IC1lbmRJbmRleCAtIDE7XG5cbiAgICAgICAgdmFyIGNsaXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjbGlwcGVkLnB1c2gobGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaXBwZWQ7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5zcGxpY2UoMCwgdGhpcy5yYW5nZXMubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hdHRhY2ggPSBmdW5jdGlvbihzZXNzaW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLiRvbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG4gICAgfTtcblxuICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLiRvbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGNoYW5nZVJhbmdlID0gZS5kYXRhLnJhbmdlO1xuICAgICAgICBpZiAoZS5kYXRhLmFjdGlvblswXSA9PSBcImlcIil7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBjaGFuZ2VSYW5nZS5zdGFydDtcbiAgICAgICAgICAgIHZhciBlbmQgPSBjaGFuZ2VSYW5nZS5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gY2hhbmdlUmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBjaGFuZ2VSYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gc3RhcnQucm93O1xuICAgICAgICB2YXIgZW5kUm93ID0gZW5kLnJvdztcbiAgICAgICAgdmFyIGxpbmVEaWYgPSBlbmRSb3cgLSBzdGFydFJvdztcblxuICAgICAgICB2YXIgY29sRGlmZiA9IC1zdGFydC5jb2x1bW4gKyBlbmQuY29sdW1uO1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChyLmVuZC5yb3cgPCBzdGFydFJvdylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyLnN0YXJ0LnJvdyA+IHN0YXJ0Um93KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBpZiAoci5zdGFydC5yb3cgPT0gc3RhcnRSb3cgJiYgci5zdGFydC5jb2x1bW4gPj0gc3RhcnQuY29sdW1uICkge1xuICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0LmNvbHVtbiA9PSBzdGFydC5jb2x1bW4gJiYgdGhpcy4kaW5zZXJ0UmlnaHQpIHtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LmNvbHVtbiArPSBjb2xEaWZmO1xuICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyLmVuZC5yb3cgPT0gc3RhcnRSb3cgJiYgci5lbmQuY29sdW1uID49IHN0YXJ0LmNvbHVtbikge1xuICAgICAgICAgICAgICAgIGlmIChyLmVuZC5jb2x1bW4gPT0gc3RhcnQuY29sdW1uICYmIHRoaXMuJGluc2VydFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoci5lbmQuY29sdW1uID09IHN0YXJ0LmNvbHVtbiAmJiBjb2xEaWZmID4gMCAmJiBpIDwgbiAtIDEpIHsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmVuZC5jb2x1bW4gPiByLnN0YXJ0LmNvbHVtbiAmJiByLmVuZC5jb2x1bW4gPT0gcmFuZ2VzW2krMV0uc3RhcnQuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICAgICAgci5lbmQuY29sdW1uIC09IGNvbERpZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIuZW5kLmNvbHVtbiArPSBjb2xEaWZmO1xuICAgICAgICAgICAgICAgIHIuZW5kLnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmVEaWYgIT0gMCAmJiBpIDwgbikge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICByLnN0YXJ0LnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgICAgIHIuZW5kLnJvdyArPSBsaW5lRGlmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkuY2FsbChSYW5nZUxpc3QucHJvdG90eXBlKTtcblxuZXhwb3J0cy5SYW5nZUxpc3QgPSBSYW5nZUxpc3Q7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9lZGl0X3Nlc3Npb24vZm9sZFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvcmFuZ2VfbGlzdFwiLFwiYWNlL2xpYi9vb3BcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmFuZ2UgPSBhY2VxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIFJhbmdlTGlzdCA9IGFjZXF1aXJlKFwiLi4vcmFuZ2VfbGlzdFwiKS5SYW5nZUxpc3Q7XG52YXIgb29wID0gYWNlcXVpcmUoXCIuLi9saWIvb29wXCIpXG52YXIgRm9sZCA9IGV4cG9ydHMuRm9sZCA9IGZ1bmN0aW9uKHJhbmdlLCBwbGFjZWhvbGRlcikge1xuICAgIHRoaXMuZm9sZExpbmUgPSBudWxsO1xuICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgdGhpcy5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gcmFuZ2UuZW5kO1xuXG4gICAgdGhpcy5zYW1lUm93ID0gcmFuZ2Uuc3RhcnQucm93ID09IHJhbmdlLmVuZC5yb3c7XG4gICAgdGhpcy5zdWJGb2xkcyA9IHRoaXMucmFuZ2VzID0gW107XG59O1xuXG5vb3AuaW5oZXJpdHMoRm9sZCwgUmFuZ2VMaXN0KTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHRoaXMucGxhY2Vob2xkZXIgKyAnXCIgJyArIHRoaXMucmFuZ2UudG9TdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRGb2xkTGluZSA9IGZ1bmN0aW9uKGZvbGRMaW5lKSB7XG4gICAgICAgIHRoaXMuZm9sZExpbmUgPSBmb2xkTGluZTtcbiAgICAgICAgdGhpcy5zdWJGb2xkcy5mb3JFYWNoKGZ1bmN0aW9uKGZvbGQpIHtcbiAgICAgICAgICAgIGZvbGQuc2V0Rm9sZExpbmUoZm9sZExpbmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlLmNsb25lKCk7XG4gICAgICAgIHZhciBmb2xkID0gbmV3IEZvbGQocmFuZ2UsIHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnN1YkZvbGRzLmZvckVhY2goZnVuY3Rpb24oc3ViRm9sZCkge1xuICAgICAgICAgICAgZm9sZC5zdWJGb2xkcy5wdXNoKHN1YkZvbGQuY2xvbmUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb2xkLmNvbGxhcHNlQ2hpbGRyZW4gPSB0aGlzLmNvbGxhcHNlQ2hpbGRyZW47XG4gICAgICAgIHJldHVybiBmb2xkO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZFN1YkZvbGQgPSBmdW5jdGlvbihmb2xkKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlLmlzRXF1YWwoZm9sZCkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlLmNvbnRhaW5zUmFuZ2UoZm9sZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGZvbGQgY2FuJ3QgaW50ZXJzZWN0IGFscmVhZHkgZXhpc3RpbmcgZm9sZFwiICsgZm9sZC5yYW5nZSArIHRoaXMucmFuZ2UpO1xuICAgICAgICBjb25zdW1lUmFuZ2UoZm9sZCwgdGhpcy5zdGFydCk7XG5cbiAgICAgICAgdmFyIHJvdyA9IGZvbGQuc3RhcnQucm93LCBjb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNtcCA9IC0xOyBpIDwgdGhpcy5zdWJGb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY21wID0gdGhpcy5zdWJGb2xkc1tpXS5yYW5nZS5jb21wYXJlKHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChjbXAgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJTdGFydCA9IHRoaXMuc3ViRm9sZHNbaV07XG5cbiAgICAgICAgaWYgKGNtcCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyU3RhcnQuYWRkU3ViRm9sZChmb2xkKTtcbiAgICAgICAgdmFyIHJvdyA9IGZvbGQucmFuZ2UuZW5kLnJvdywgY29sdW1uID0gZm9sZC5yYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICBmb3IgKHZhciBqID0gaSwgY21wID0gLTE7IGogPCB0aGlzLnN1YkZvbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjbXAgPSB0aGlzLnN1YkZvbGRzW2pdLnJhbmdlLmNvbXBhcmUocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCAhPSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlckVuZCA9IHRoaXMuc3ViRm9sZHNbal07XG5cbiAgICAgICAgaWYgKGNtcCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBmb2xkIGNhbid0IGludGVyc2VjdCBhbHJlYWR5IGV4aXN0aW5nIGZvbGRcIiArIGZvbGQucmFuZ2UgKyB0aGlzLnJhbmdlKTtcblxuICAgICAgICB2YXIgY29uc3VtZWRGb2xkcyA9IHRoaXMuc3ViRm9sZHMuc3BsaWNlKGksIGogLSBpLCBmb2xkKTtcbiAgICAgICAgZm9sZC5zZXRGb2xkTGluZSh0aGlzLmZvbGRMaW5lKTtcblxuICAgICAgICByZXR1cm4gZm9sZDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVzdG9yZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RvcmVSYW5nZShyYW5nZSwgdGhpcy5zdGFydCk7XG4gICAgfTtcblxufSkuY2FsbChGb2xkLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNvbnN1bWVQb2ludChwb2ludCwgYW5jaG9yKSB7XG4gICAgcG9pbnQucm93IC09IGFuY2hvci5yb3c7XG4gICAgaWYgKHBvaW50LnJvdyA9PSAwKVxuICAgICAgICBwb2ludC5jb2x1bW4gLT0gYW5jaG9yLmNvbHVtbjtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVSYW5nZShyYW5nZSwgYW5jaG9yKSB7XG4gICAgY29uc3VtZVBvaW50KHJhbmdlLnN0YXJ0LCBhbmNob3IpO1xuICAgIGNvbnN1bWVQb2ludChyYW5nZS5lbmQsIGFuY2hvcik7XG59XG5mdW5jdGlvbiByZXN0b3JlUG9pbnQocG9pbnQsIGFuY2hvcikge1xuICAgIGlmIChwb2ludC5yb3cgPT0gMClcbiAgICAgICAgcG9pbnQuY29sdW1uICs9IGFuY2hvci5jb2x1bW47XG4gICAgcG9pbnQucm93ICs9IGFuY2hvci5yb3c7XG59XG5mdW5jdGlvbiByZXN0b3JlUmFuZ2UocmFuZ2UsIGFuY2hvcikge1xuICAgIHJlc3RvcmVQb2ludChyYW5nZS5zdGFydCwgYW5jaG9yKTtcbiAgICByZXN0b3JlUG9pbnQocmFuZ2UuZW5kLCBhbmNob3IpO1xufVxuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9lZGl0X3Nlc3Npb24vZm9sZGluZ1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvZWRpdF9zZXNzaW9uL2ZvbGRfbGluZVwiLFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkXCIsXCJhY2UvdG9rZW5faXRlcmF0b3JcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmFuZ2UgPSBhY2VxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xudmFyIEZvbGRMaW5lID0gYWNlcXVpcmUoXCIuL2ZvbGRfbGluZVwiKS5Gb2xkTGluZTtcbnZhciBGb2xkID0gYWNlcXVpcmUoXCIuL2ZvbGRcIikuRm9sZDtcbnZhciBUb2tlbkl0ZXJhdG9yID0gYWNlcXVpcmUoXCIuLi90b2tlbl9pdGVyYXRvclwiKS5Ub2tlbkl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBGb2xkaW5nKCkge1xuICAgIHRoaXMuZ2V0Rm9sZEF0ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIHNpZGUpIHtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3cpO1xuICAgICAgICBpZiAoIWZvbGRMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIGZvbGRzID0gZm9sZExpbmUuZm9sZHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmb2xkID0gZm9sZHNbaV07XG4gICAgICAgICAgICBpZiAoZm9sZC5yYW5nZS5jb250YWlucyhyb3csIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA9PSAxICYmIGZvbGQucmFuZ2UuaXNFbmQocm93LCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSAtMSAmJiBmb2xkLnJhbmdlLmlzU3RhcnQocm93LCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRGb2xkc0luUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgdmFyIGZvbGRMaW5lcyA9IHRoaXMuJGZvbGREYXRhO1xuICAgICAgICB2YXIgZm91bmRGb2xkcyA9IFtdO1xuXG4gICAgICAgIHN0YXJ0LmNvbHVtbiArPSAxO1xuICAgICAgICBlbmQuY29sdW1uIC09IDE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbXAgPSBmb2xkTGluZXNbaV0ucmFuZ2UuY29tcGFyZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGlmIChjbXAgPT0gMikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09IC0yKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb2xkcyA9IGZvbGRMaW5lc1tpXS5mb2xkcztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9sZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9sZCA9IGZvbGRzW2pdO1xuICAgICAgICAgICAgICAgIGNtcCA9IGZvbGQucmFuZ2UuY29tcGFyZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoY21wID09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PSA0Mikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm91bmRGb2xkcy5wdXNoKGZvbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0LmNvbHVtbiAtPSAxO1xuICAgICAgICBlbmQuY29sdW1uICs9IDE7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kRm9sZHM7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Rm9sZHNJblJhbmdlTGlzdCA9IGZ1bmN0aW9uKHJhbmdlcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZXMpKSB7XG4gICAgICAgICAgICB2YXIgZm9sZHMgPSBbXTtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZm9sZHMgPSBmb2xkcy5jb25jYXQodGhpcy5nZXRGb2xkc0luUmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UocmFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9sZHM7XG4gICAgfVxuICAgIHRoaXMuZ2V0QWxsRm9sZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZvbGRzID0gW107XG4gICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZExpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb2xkTGluZXNbaV0uZm9sZHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgZm9sZHMucHVzaChmb2xkTGluZXNbaV0uZm9sZHNbal0pO1xuXG4gICAgICAgIHJldHVybiBmb2xkcztcbiAgICB9O1xuICAgIHRoaXMuZ2V0Rm9sZFN0cmluZ0F0ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIHRyaW0sIGZvbGRMaW5lKSB7XG4gICAgICAgIGZvbGRMaW5lID0gZm9sZExpbmUgfHwgdGhpcy5nZXRGb2xkTGluZShyb3cpO1xuICAgICAgICBpZiAoIWZvbGRMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIGxhc3RGb2xkID0ge1xuICAgICAgICAgICAgZW5kOiB7IGNvbHVtbjogMCB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHIsIGZvbGQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZExpbmUuZm9sZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvbGQgPSBmb2xkTGluZS5mb2xkc1tpXTtcbiAgICAgICAgICAgIHZhciBjbXAgPSBmb2xkLnJhbmdlLmNvbXBhcmVFbmQocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLmdldExpbmUoZm9sZC5zdGFydC5yb3cpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcobGFzdEZvbGQuZW5kLmNvbHVtbiwgZm9sZC5zdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Rm9sZCA9IGZvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHIpXG4gICAgICAgICAgICBzdHIgPSB0aGlzLmdldExpbmUoZm9sZC5zdGFydC5yb3cpLnN1YnN0cmluZyhsYXN0Rm9sZC5lbmQuY29sdW1uKTtcblxuICAgICAgICBpZiAodHJpbSA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIGNvbHVtbiAtIGxhc3RGb2xkLmVuZC5jb2x1bW4pO1xuICAgICAgICBlbHNlIGlmICh0cmltID09IDEpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhjb2x1bW4gLSBsYXN0Rm9sZC5lbmQuY29sdW1uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGb2xkTGluZSA9IGZ1bmN0aW9uKGRvY1Jvdywgc3RhcnRGb2xkTGluZSkge1xuICAgICAgICB2YXIgZm9sZERhdGEgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoc3RhcnRGb2xkTGluZSlcbiAgICAgICAgICAgIGkgPSBmb2xkRGF0YS5pbmRleE9mKHN0YXJ0Rm9sZExpbmUpO1xuICAgICAgICBpZiAoaSA9PSAtMSlcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICBmb3IgKGk7IGkgPCBmb2xkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZERhdGFbaV07XG4gICAgICAgICAgICBpZiAoZm9sZExpbmUuc3RhcnQucm93IDw9IGRvY1JvdyAmJiBmb2xkTGluZS5lbmQucm93ID49IGRvY1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2xkTGluZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9sZExpbmUuZW5kLnJvdyA+IGRvY1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdGhpcy5nZXROZXh0Rm9sZExpbmUgPSBmdW5jdGlvbihkb2NSb3csIHN0YXJ0Rm9sZExpbmUpIHtcbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKHN0YXJ0Rm9sZExpbmUpXG4gICAgICAgICAgICBpID0gZm9sZERhdGEuaW5kZXhPZihzdGFydEZvbGRMaW5lKTtcbiAgICAgICAgaWYgKGkgPT0gLTEpXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgZm9yIChpOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IGZvbGREYXRhW2ldO1xuICAgICAgICAgICAgaWYgKGZvbGRMaW5lLmVuZC5yb3cgPj0gZG9jUm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvbGRMaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZvbGRlZFJvd0NvdW50ID0gZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGEsIHJvd0NvdW50ID0gbGFzdC1maXJzdCsxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkRGF0YVtpXSxcbiAgICAgICAgICAgICAgICBlbmQgPSBmb2xkTGluZS5lbmQucm93LFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgaWYoc3RhcnQgPCBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHN0YXJ0ID49IGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgLT0gbGFzdC1zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgPSAwOy8vaW4gb25lIGZvbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZW5kID49IGZpcnN0KXtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gZmlyc3QpIC8vZm9sZCBpbnNpZGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgLT0gIGVuZC1zdGFydDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50IC09ICBlbmQtZmlyc3QrMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93Q291bnQ7XG4gICAgfTtcblxuICAgIHRoaXMuJGFkZEZvbGRMaW5lID0gZnVuY3Rpb24oZm9sZExpbmUpIHtcbiAgICAgICAgdGhpcy4kZm9sZERhdGEucHVzaChmb2xkTGluZSk7XG4gICAgICAgIHRoaXMuJGZvbGREYXRhLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQucm93IC0gYi5zdGFydC5yb3c7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9sZExpbmU7XG4gICAgfTtcbiAgICB0aGlzLmFkZEZvbGQgPSBmdW5jdGlvbihwbGFjZWhvbGRlciwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgIHZhciBhZGRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZm9sZDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwbGFjZWhvbGRlciBpbnN0YW5jZW9mIEZvbGQpXG4gICAgICAgICAgICBmb2xkID0gcGxhY2Vob2xkZXI7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9sZCA9IG5ldyBGb2xkKHJhbmdlLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICBmb2xkLmNvbGxhcHNlQ2hpbGRyZW4gPSByYW5nZS5jb2xsYXBzZUNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGNsaXBSYW5nZVRvRG9jdW1lbnQoZm9sZC5yYW5nZSk7XG5cbiAgICAgICAgdmFyIHN0YXJ0Um93ID0gZm9sZC5zdGFydC5yb3c7XG4gICAgICAgIHZhciBzdGFydENvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgZW5kUm93ID0gZm9sZC5lbmQucm93O1xuICAgICAgICB2YXIgZW5kQ29sdW1uID0gZm9sZC5lbmQuY29sdW1uO1xuICAgICAgICBpZiAoIShzdGFydFJvdyA8IGVuZFJvdyB8fCBcbiAgICAgICAgICAgIHN0YXJ0Um93ID09IGVuZFJvdyAmJiBzdGFydENvbHVtbiA8PSBlbmRDb2x1bW4gLSAyKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByYW5nZSBoYXMgdG8gYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIHdpZHRoXCIpO1xuXG4gICAgICAgIHZhciBzdGFydEZvbGQgPSB0aGlzLmdldEZvbGRBdChzdGFydFJvdywgc3RhcnRDb2x1bW4sIDEpO1xuICAgICAgICB2YXIgZW5kRm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KGVuZFJvdywgZW5kQ29sdW1uLCAtMSk7XG4gICAgICAgIGlmIChzdGFydEZvbGQgJiYgZW5kRm9sZCA9PSBzdGFydEZvbGQpXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRGb2xkLmFkZFN1YkZvbGQoZm9sZCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0Rm9sZCAmJiAhc3RhcnRGb2xkLnJhbmdlLmlzU3RhcnQoc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSlcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChzdGFydEZvbGQpO1xuXG4gICAgICAgIGlmIChlbmRGb2xkICYmICFlbmRGb2xkLnJhbmdlLmlzRW5kKGVuZFJvdywgZW5kQ29sdW1uKSlcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChlbmRGb2xkKTtcbiAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UoZm9sZC5yYW5nZSk7XG4gICAgICAgIGlmIChmb2xkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGRzKGZvbGRzKTtcbiAgICAgICAgICAgIGZvbGRzLmZvckVhY2goZnVuY3Rpb24oc3ViRm9sZCkge1xuICAgICAgICAgICAgICAgIGZvbGQuYWRkU3ViRm9sZChzdWJGb2xkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZERhdGFbaV07XG4gICAgICAgICAgICBpZiAoZW5kUm93ID09IGZvbGRMaW5lLnN0YXJ0LnJvdykge1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZEZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFJvdyA9PSBmb2xkTGluZS5lbmQucm93KSB7XG4gICAgICAgICAgICAgICAgZm9sZExpbmUuYWRkRm9sZChmb2xkKTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFmb2xkLnNhbWVSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lTmV4dCA9IGZvbGREYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lTmV4dCAmJiBmb2xkTGluZU5leHQuc3RhcnQucm93ID09IGVuZFJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUubWVyZ2UoZm9sZExpbmVOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRSb3cgPD0gZm9sZExpbmUuc3RhcnQucm93KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFkZGVkKVxuICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLiRhZGRGb2xkTGluZShuZXcgRm9sZExpbmUodGhpcy4kZm9sZERhdGEsIGZvbGQpKTtcblxuICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpXG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YShmb2xkTGluZS5zdGFydC5yb3csIGZvbGRMaW5lLnN0YXJ0LnJvdyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd0xlbmd0aENhY2hlKGZvbGRMaW5lLnN0YXJ0LnJvdywgZm9sZExpbmUuc3RhcnQucm93KTtcbiAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlRm9sZFwiLCB7IGRhdGE6IGZvbGQsIGFjdGlvbjogXCJhZGRcIiB9KTtcblxuICAgICAgICByZXR1cm4gZm9sZDtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRGb2xkcyA9IGZ1bmN0aW9uKGZvbGRzKSB7XG4gICAgICAgIGZvbGRzLmZvckVhY2goZnVuY3Rpb24oZm9sZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRGb2xkKGZvbGQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVGb2xkID0gZnVuY3Rpb24oZm9sZCkge1xuICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkLmZvbGRMaW5lO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBlbmRSb3cgPSBmb2xkTGluZS5lbmQucm93O1xuXG4gICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgdmFyIGZvbGRzID0gZm9sZExpbmUuZm9sZHM7XG4gICAgICAgIGlmIChmb2xkcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgZm9sZExpbmVzLnNwbGljZShmb2xkTGluZXMuaW5kZXhPZihmb2xkTGluZSksIDEpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYgKGZvbGRMaW5lLnJhbmdlLmlzRW5kKGZvbGQuZW5kLnJvdywgZm9sZC5lbmQuY29sdW1uKSkge1xuICAgICAgICAgICAgZm9sZHMucG9wKCk7XG4gICAgICAgICAgICBmb2xkTGluZS5lbmQucm93ID0gZm9sZHNbZm9sZHMubGVuZ3RoIC0gMV0uZW5kLnJvdztcbiAgICAgICAgICAgIGZvbGRMaW5lLmVuZC5jb2x1bW4gPSBmb2xkc1tmb2xkcy5sZW5ndGggLSAxXS5lbmQuY29sdW1uO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYgKGZvbGRMaW5lLnJhbmdlLmlzU3RhcnQoZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKSkge1xuICAgICAgICAgICAgZm9sZHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGZvbGRMaW5lLnN0YXJ0LnJvdyA9IGZvbGRzWzBdLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGZvbGRMaW5lLnN0YXJ0LmNvbHVtbiA9IGZvbGRzWzBdLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgIGlmIChmb2xkLnNhbWVSb3cpIHtcbiAgICAgICAgICAgIGZvbGRzLnNwbGljZShmb2xkcy5pbmRleE9mKGZvbGQpLCAxKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuZXdGb2xkTGluZSA9IGZvbGRMaW5lLnNwbGl0KGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICBmb2xkcyA9IG5ld0ZvbGRMaW5lLmZvbGRzO1xuICAgICAgICAgICAgZm9sZHMuc2hpZnQoKTtcbiAgICAgICAgICAgIG5ld0ZvbGRMaW5lLnN0YXJ0LnJvdyA9IGZvbGRzWzBdLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIG5ld0ZvbGRMaW5lLnN0YXJ0LmNvbHVtbiA9IGZvbGRzWzBdLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy4kdXBkYXRpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YShzdGFydFJvdywgZW5kUm93KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVSb3dMZW5ndGhDYWNoZShzdGFydFJvdywgZW5kUm93KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VtaXQoXCJjaGFuZ2VGb2xkXCIsIHsgZGF0YTogZm9sZCwgYWN0aW9uOiBcInJlbW92ZVwiIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUZvbGRzID0gZnVuY3Rpb24oZm9sZHMpIHtcbiAgICAgICAgdmFyIGNsb25lRm9sZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xvbmVGb2xkcy5wdXNoKGZvbGRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lRm9sZHMuZm9yRWFjaChmdW5jdGlvbihmb2xkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGQoZm9sZCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgfTtcblxuICAgIHRoaXMuZXhwYW5kRm9sZCA9IGZ1bmN0aW9uKGZvbGQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICBmb2xkLnN1YkZvbGRzLmZvckVhY2goZnVuY3Rpb24oc3ViRm9sZCkge1xuICAgICAgICAgICAgZm9sZC5yZXN0b3JlUmFuZ2Uoc3ViRm9sZCk7XG4gICAgICAgICAgICB0aGlzLmFkZEZvbGQoc3ViRm9sZCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAoZm9sZC5jb2xsYXBzZUNoaWxkcmVuID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb2xkQWxsKGZvbGQuc3RhcnQucm93KzEsIGZvbGQuZW5kLnJvdywgZm9sZC5jb2xsYXBzZUNoaWxkcmVuLTEpO1xuICAgICAgICB9XG4gICAgICAgIGZvbGQuc3ViRm9sZHMgPSBbXTtcbiAgICB9O1xuXG4gICAgdGhpcy5leHBhbmRGb2xkcyA9IGZ1bmN0aW9uKGZvbGRzKSB7XG4gICAgICAgIGZvbGRzLmZvckVhY2goZnVuY3Rpb24oZm9sZCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkKGZvbGQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgdGhpcy51bmZvbGQgPSBmdW5jdGlvbihsb2NhdGlvbiwgZXhwYW5kSW5uZXIpIHtcbiAgICAgICAgdmFyIHJhbmdlLCBmb2xkcztcbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKDAsIDAsIHRoaXMuZ2V0TGVuZ3RoKCksIDApO1xuICAgICAgICAgICAgZXhwYW5kSW5uZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UobG9jYXRpb24sIDAsIGxvY2F0aW9uLCB0aGlzLmdldExpbmUobG9jYXRpb24pLmxlbmd0aCk7XG4gICAgICAgIGVsc2UgaWYgKFwicm93XCIgaW4gbG9jYXRpb24pXG4gICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMobG9jYXRpb24sIGxvY2F0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFuZ2UgPSBsb2NhdGlvbjtcbiAgICAgICAgXG4gICAgICAgIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2VMaXN0KHJhbmdlKTtcbiAgICAgICAgaWYgKGV4cGFuZElubmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGRzKGZvbGRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdWJGb2xkcyA9IGZvbGRzO1xuICAgICAgICAgICAgd2hpbGUgKHN1YkZvbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZHMoc3ViRm9sZHMpO1xuICAgICAgICAgICAgICAgIHN1YkZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2VMaXN0KHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9sZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZvbGRzO1xuICAgIH07XG4gICAgdGhpcy5pc1Jvd0ZvbGRlZCA9IGZ1bmN0aW9uKGRvY1Jvdywgc3RhcnRGb2xkUm93KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0Rm9sZExpbmUoZG9jUm93LCBzdGFydEZvbGRSb3cpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFJvd0ZvbGRFbmQgPSBmdW5jdGlvbihkb2NSb3csIHN0YXJ0Rm9sZFJvdykge1xuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKGRvY1Jvdywgc3RhcnRGb2xkUm93KTtcbiAgICAgICAgcmV0dXJuIGZvbGRMaW5lID8gZm9sZExpbmUuZW5kLnJvdyA6IGRvY1JvdztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRSb3dGb2xkU3RhcnQgPSBmdW5jdGlvbihkb2NSb3csIHN0YXJ0Rm9sZFJvdykge1xuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKGRvY1Jvdywgc3RhcnRGb2xkUm93KTtcbiAgICAgICAgcmV0dXJuIGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogZG9jUm93O1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZvbGREaXNwbGF5TGluZSA9IGZ1bmN0aW9uKGZvbGRMaW5lLCBlbmRSb3csIGVuZENvbHVtbiwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIGlmIChzdGFydFJvdyA9PSBudWxsKVxuICAgICAgICAgICAgc3RhcnRSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgIGlmIChzdGFydENvbHVtbiA9PSBudWxsKVxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICBpZiAoZW5kUm93ID09IG51bGwpXG4gICAgICAgICAgICBlbmRSb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICBpZiAoZW5kQ29sdW1uID09IG51bGwpXG4gICAgICAgICAgICBlbmRDb2x1bW4gPSB0aGlzLmdldExpbmUoZW5kUm93KS5sZW5ndGg7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgdmFyIHRleHRMaW5lID0gXCJcIjtcblxuICAgICAgICBmb2xkTGluZS53YWxrKGZ1bmN0aW9uKHBsYWNlaG9sZGVyLCByb3csIGNvbHVtbiwgbGFzdENvbHVtbikge1xuICAgICAgICAgICAgaWYgKHJvdyA8IHN0YXJ0Um93KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyb3cgPT0gc3RhcnRSb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uIDwgc3RhcnRDb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsYXN0Q29sdW1uID0gTWF0aC5tYXgoc3RhcnRDb2x1bW4sIGxhc3RDb2x1bW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lICs9IHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBkb2MuZ2V0TGluZShyb3cpLnN1YnN0cmluZyhsYXN0Q29sdW1uLCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlbmRSb3csIGVuZENvbHVtbik7XG4gICAgICAgIHJldHVybiB0ZXh0TGluZTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXREaXNwbGF5TGluZSA9IGZ1bmN0aW9uKHJvdywgZW5kQ29sdW1uLCBzdGFydFJvdywgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3cpO1xuXG4gICAgICAgIGlmICghZm9sZExpbmUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lO1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuZG9jLmdldExpbmUocm93KTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLnN1YnN0cmluZyhzdGFydENvbHVtbiB8fCAwLCBlbmRDb2x1bW4gfHwgbGluZS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9sZERpc3BsYXlMaW5lKFxuICAgICAgICAgICAgICAgIGZvbGRMaW5lLCByb3csIGVuZENvbHVtbiwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLiRjbG9uZUZvbGREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmZCA9IFtdO1xuICAgICAgICBmZCA9IHRoaXMuJGZvbGREYXRhLm1hcChmdW5jdGlvbihmb2xkTGluZSkge1xuICAgICAgICAgICAgdmFyIGZvbGRzID0gZm9sZExpbmUuZm9sZHMubWFwKGZ1bmN0aW9uKGZvbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9sZC5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRMaW5lKGZkLCBmb2xkcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmZDtcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVGb2xkID0gZnVuY3Rpb24odHJ5VG9VbmZvbGQpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgdmFyIGZvbGQ7XG4gICAgICAgIHZhciBicmFja2V0UG9zO1xuXG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIGZvbGQgPSB0aGlzLmdldEZvbGRBdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcblxuICAgICAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGQoZm9sZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChicmFja2V0UG9zID0gdGhpcy5maW5kTWF0Y2hpbmdCcmFja2V0KGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29tcGFyZVBvaW50KGJyYWNrZXRQb3MpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kID0gYnJhY2tldFBvcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydCA9IGJyYWNrZXRQb3M7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbisrO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChicmFja2V0UG9zID0gdGhpcy5maW5kTWF0Y2hpbmdCcmFja2V0KHtyb3c6IGN1cnNvci5yb3csIGNvbHVtbjogY3Vyc29yLmNvbHVtbiArIDF9KSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlUG9pbnQoYnJhY2tldFBvcykgPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kID0gYnJhY2tldFBvcztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gYnJhY2tldFBvcztcblxuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbisrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuZ2V0Q29tbWVudEZvbGRSYW5nZShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKSB8fCByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGlmICh0cnlUb1VuZm9sZCAmJiBmb2xkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGRzKGZvbGRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvbGRzLmxlbmd0aCA9PSAxICkge1xuICAgICAgICAgICAgICAgIGZvbGQgPSBmb2xkc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm9sZClcbiAgICAgICAgICAgIGZvbGQgPSB0aGlzLmdldEZvbGRBdChyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG5cbiAgICAgICAgaWYgKGZvbGQgJiYgZm9sZC5yYW5nZS50b1N0cmluZygpID09IHJhbmdlLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZChmb2xkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IFwiLi4uXCI7XG4gICAgICAgIGlmICghcmFuZ2UuaXNNdWx0aUxpbmUoKSkge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpZihwbGFjZWhvbGRlci5sZW5ndGggPCA0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXIudHJpbSgpLnN1YnN0cmluZygwLCAyKSArIFwiLi5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkRm9sZChwbGFjZWhvbGRlciwgcmFuZ2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldENvbW1lbnRGb2xkUmFuZ2UgPSBmdW5jdGlvbihyb3csIGNvbHVtbiwgZGlyKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHRoaXMsIHJvdywgY29sdW1uKTtcbiAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIGlmICh0b2tlbiAmJiAvXmNvbW1lbnR8c3RyaW5nLy50ZXN0KHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAodG9rZW4udHlwZS5yZXBsYWNlKC9cXC4uKi8sIFwiXFxcXC5cIikpO1xuICAgICAgICAgICAgaWYgKGRpciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUodG9rZW4gJiYgcmUudGVzdCh0b2tlbi50eXBlKSk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIDI7XG5cbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZGlyICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSh0b2tlbiAmJiByZS50ZXN0KHRva2VuLnR5cGUpKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcblxuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpO1xuICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgdG9rZW4udmFsdWUubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmZvbGRBbGwgPSBmdW5jdGlvbihzdGFydFJvdywgZW5kUm93LCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVwdGggPSAxMDAwMDA7IC8vIEpTT04uc3RyaW5naWZ5IGRvZXNuJ3QgaGFubGUgSW5maW5pdHlcbiAgICAgICAgdmFyIGZvbGRXaWRnZXRzID0gdGhpcy5mb2xkV2lkZ2V0cztcbiAgICAgICAgaWYgKCFmb2xkV2lkZ2V0cylcbiAgICAgICAgICAgIHJldHVybjsgLy8gbW9kZSBkb2Vzbid0IHN1cHBvcnQgZm9sZGluZ1xuICAgICAgICBlbmRSb3cgPSBlbmRSb3cgfHwgdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgc3RhcnRSb3cgPSBzdGFydFJvdyB8fCAwO1xuICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydFJvdzsgcm93IDwgZW5kUm93OyByb3crKykge1xuICAgICAgICAgICAgaWYgKGZvbGRXaWRnZXRzW3Jvd10gPT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb2xkV2lkZ2V0c1tyb3ddID0gdGhpcy5nZXRGb2xkV2lkZ2V0KHJvdyk7XG4gICAgICAgICAgICBpZiAoZm9sZFdpZGdldHNbcm93XSAhPSBcInN0YXJ0XCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlKHJvdyk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2UuaXNNdWx0aUxpbmUoKVxuICAgICAgICAgICAgICAgICYmIHJhbmdlLmVuZC5yb3cgPD0gZW5kUm93XG4gICAgICAgICAgICAgICAgJiYgcmFuZ2Uuc3RhcnQucm93ID49IHN0YXJ0Um93XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByb3cgPSByYW5nZS5lbmQucm93O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2xkID0gdGhpcy5hZGRGb2xkKFwiLi4uXCIsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkLmNvbGxhcHNlQ2hpbGRyZW4gPSBkZXB0aDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuJGZvbGRTdHlsZXMgPSB7XG4gICAgICAgIFwibWFudWFsXCI6IDEsXG4gICAgICAgIFwibWFya2JlZ2luXCI6IDEsXG4gICAgICAgIFwibWFya2JlZ2luZW5kXCI6IDFcbiAgICB9O1xuICAgIHRoaXMuJGZvbGRTdHlsZSA9IFwibWFya2JlZ2luXCI7XG4gICAgdGhpcy5zZXRGb2xkU3R5bGUgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBpZiAoIXRoaXMuJGZvbGRTdHlsZXNbc3R5bGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb2xkIHN0eWxlOiBcIiArIHN0eWxlICsgXCJbXCIgKyBPYmplY3Qua2V5cyh0aGlzLiRmb2xkU3R5bGVzKS5qb2luKFwiLCBcIikgKyBcIl1cIik7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy4kZm9sZFN0eWxlID09IHN0eWxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuJGZvbGRTdHlsZSA9IHN0eWxlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0eWxlID09IFwibWFudWFsXCIpXG4gICAgICAgICAgICB0aGlzLnVuZm9sZCgpO1xuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuJGZvbGRNb2RlO1xuICAgICAgICB0aGlzLiRzZXRGb2xkaW5nKG51bGwpO1xuICAgICAgICB0aGlzLiRzZXRGb2xkaW5nKG1vZGUpO1xuICAgIH07XG5cbiAgICB0aGlzLiRzZXRGb2xkaW5nID0gZnVuY3Rpb24oZm9sZE1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGZvbGRNb2RlID09IGZvbGRNb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuJGZvbGRNb2RlID0gZm9sZE1vZGU7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9mZignY2hhbmdlJywgdGhpcy4kdXBkYXRlRm9sZFdpZGdldHMpO1xuICAgICAgICB0aGlzLm9mZigndG9rZW5pemVyVXBkYXRlJywgdGhpcy4kdG9rZW5pemVyVXBkYXRlRm9sZFdpZGdldHMpO1xuICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZm9sZE1vZGUgfHwgdGhpcy4kZm9sZFN0eWxlID09IFwibWFudWFsXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZFdpZGdldHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmZvbGRXaWRnZXRzID0gW107XG4gICAgICAgIHRoaXMuZ2V0Rm9sZFdpZGdldCA9IGZvbGRNb2RlLmdldEZvbGRXaWRnZXQuYmluZChmb2xkTW9kZSwgdGhpcywgdGhpcy4kZm9sZFN0eWxlKTtcbiAgICAgICAgdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2UgPSBmb2xkTW9kZS5nZXRGb2xkV2lkZ2V0UmFuZ2UuYmluZChmb2xkTW9kZSwgdGhpcywgdGhpcy4kZm9sZFN0eWxlKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuJHVwZGF0ZUZvbGRXaWRnZXRzID0gdGhpcy51cGRhdGVGb2xkV2lkZ2V0cy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiR0b2tlbml6ZXJVcGRhdGVGb2xkV2lkZ2V0cyA9IHRoaXMudG9rZW5pemVyVXBkYXRlRm9sZFdpZGdldHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy4kdXBkYXRlRm9sZFdpZGdldHMpO1xuICAgICAgICB0aGlzLm9uKCd0b2tlbml6ZXJVcGRhdGUnLCB0aGlzLiR0b2tlbml6ZXJVcGRhdGVGb2xkV2lkZ2V0cyk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFyZW50Rm9sZFJhbmdlRGF0YSA9IGZ1bmN0aW9uIChyb3csIGlnbm9yZUN1cnJlbnQpIHtcbiAgICAgICAgdmFyIGZ3ID0gdGhpcy5mb2xkV2lkZ2V0cztcbiAgICAgICAgaWYgKCFmdyB8fCAoaWdub3JlQ3VycmVudCAmJiBmd1tyb3ddKSlcbiAgICAgICAgICAgIHJldHVybiB7fTtcblxuICAgICAgICB2YXIgaSA9IHJvdyAtIDEsIGZpcnN0UmFuZ2U7XG4gICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgIHZhciBjID0gZndbaV07XG4gICAgICAgICAgICBpZiAoYyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGMgPSBmd1tpXSA9IHRoaXMuZ2V0Rm9sZFdpZGdldChpKTtcblxuICAgICAgICAgICAgaWYgKGMgPT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2UoaSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJhbmdlKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmVuZC5yb3cgPj0gcm93KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogaSAhPT0gLTEgJiYgcmFuZ2UsXG4gICAgICAgICAgICBmaXJzdFJhbmdlOiBmaXJzdFJhbmdlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5vbkZvbGRXaWRnZXRDbGljayA9IGZ1bmN0aW9uKHJvdywgZSkge1xuICAgICAgICBlID0gZS5kb21FdmVudDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGFsbDogZS5jdHJsS2V5IHx8IGUubWV0YUtleSxcbiAgICAgICAgICAgIHNpYmxpbmdzOiBlLmFsdEtleVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy4kdG9nZ2xlRm9sZFdpZGdldChyb3csIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KVxuICAgICAgICAgICAgaWYgKGVsICYmIC9hY2VfZm9sZC13aWRnZXQvLnRlc3QoZWwuY2xhc3NOYW1lKSlcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgYWNlX2ludmFsaWRcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy4kdG9nZ2xlRm9sZFdpZGdldCA9IGZ1bmN0aW9uKHJvdywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0Rm9sZFdpZGdldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldEZvbGRXaWRnZXQocm93KTtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUocm93KTtcblxuICAgICAgICB2YXIgZGlyID0gdHlwZSA9PT0gXCJlbmRcIiA/IC0xIDogMTtcbiAgICAgICAgdmFyIGZvbGQgPSB0aGlzLmdldEZvbGRBdChyb3csIGRpciA9PT0gLTEgPyAwIDogbGluZS5sZW5ndGgsIGRpcik7XG5cbiAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNoaWxkcmVuIHx8IG9wdGlvbnMuYWxsKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChmb2xkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGQoZm9sZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEZvbGRXaWRnZXRSYW5nZShyb3csIHRydWUpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgIXJhbmdlLmlzTXVsdGlMaW5lKCkpIHtcbiAgICAgICAgICAgIGZvbGQgPSB0aGlzLmdldEZvbGRBdChyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbiwgMSk7XG4gICAgICAgICAgICBpZiAoZm9sZCAmJiByYW5nZS5pc0VxdWFsKGZvbGQucmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGZvbGQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG9wdGlvbnMuc2libGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRQYXJlbnRGb2xkUmFuZ2VEYXRhKHJvdyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGRhdGEucmFuZ2Uuc3RhcnQucm93ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUm93ID0gZGF0YS5yYW5nZS5lbmQucm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb2xkQWxsKHN0YXJ0Um93LCBlbmRSb3csIG9wdGlvbnMuYWxsID8gMTAwMDAgOiAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBlbmRSb3cgPSByYW5nZSA/IHJhbmdlLmVuZC5yb3cgOiB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkQWxsKHJvdyArIDEsIGVuZFJvdywgb3B0aW9ucy5hbGwgPyAxMDAwMCA6IDApO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGwpIFxuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlQ2hpbGRyZW4gPSAxMDAwMDtcbiAgICAgICAgICAgIHRoaXMuYWRkRm9sZChcIi4uLlwiLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIFxuICAgIFxuICAgIFxuICAgIHRoaXMudG9nZ2xlRm9sZFdpZGdldCA9IGZ1bmN0aW9uKHRvZ2dsZVBhcmVudCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkucm93O1xuICAgICAgICByb3cgPSB0aGlzLmdldFJvd0ZvbGRTdGFydChyb3cpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLiR0b2dnbGVGb2xkV2lkZ2V0KHJvdywge30pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0UGFyZW50Rm9sZFJhbmdlRGF0YShyb3csIHRydWUpO1xuICAgICAgICByYW5nZSA9IGRhdGEucmFuZ2UgfHwgZGF0YS5maXJzdFJhbmdlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICByb3cgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJvdywgdGhpcy5nZXRMaW5lKHJvdykubGVuZ3RoLCAxKTtcblxuICAgICAgICAgICAgaWYgKGZvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGQoZm9sZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZChcIi4uLlwiLCByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gZS5kYXRhO1xuICAgICAgICB2YXIgcmFuZ2UgPSBkZWx0YS5yYW5nZTtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gcmFuZ2Uuc3RhcnQucm93O1xuICAgICAgICB2YXIgbGVuID0gcmFuZ2UuZW5kLnJvdyAtIGZpcnN0Um93O1xuXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9sZFdpZGdldHNbZmlyc3RSb3ddID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVUZXh0XCIgfHwgZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlTGluZXNcIikge1xuICAgICAgICAgICAgdGhpcy5mb2xkV2lkZ2V0cy5zcGxpY2UoZmlyc3RSb3csIGxlbiArIDEsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW4gKyAxKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdChmaXJzdFJvdywgMSk7XG4gICAgICAgICAgICB0aGlzLmZvbGRXaWRnZXRzLnNwbGljZS5hcHBseSh0aGlzLmZvbGRXaWRnZXRzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy50b2tlbml6ZXJVcGRhdGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBlLmRhdGE7XG4gICAgICAgIGlmIChyb3dzLmZpcnN0ICE9IHJvd3MubGFzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9sZFdpZGdldHMubGVuZ3RoID4gcm93cy5maXJzdClcbiAgICAgICAgICAgICAgICB0aGlzLmZvbGRXaWRnZXRzLnNwbGljZShyb3dzLmZpcnN0LCB0aGlzLmZvbGRXaWRnZXRzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuRm9sZGluZyA9IEZvbGRpbmc7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2VkaXRfc2Vzc2lvbi9icmFja2V0X21hdGNoXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvdG9rZW5faXRlcmF0b3JcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBUb2tlbkl0ZXJhdG9yID0gYWNlcXVpcmUoXCIuLi90b2tlbl9pdGVyYXRvclwiKS5Ub2tlbkl0ZXJhdG9yO1xudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcblxuXG5mdW5jdGlvbiBCcmFja2V0TWF0Y2goKSB7XG5cbiAgICB0aGlzLmZpbmRNYXRjaGluZ0JyYWNrZXQgPSBmdW5jdGlvbihwb3NpdGlvbiwgY2hyKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbi5jb2x1bW4gPT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIGNoYXJCZWZvcmVDdXJzb3IgPSBjaHIgfHwgdGhpcy5nZXRMaW5lKHBvc2l0aW9uLnJvdykuY2hhckF0KHBvc2l0aW9uLmNvbHVtbi0xKTtcbiAgICAgICAgaWYgKGNoYXJCZWZvcmVDdXJzb3IgPT0gXCJcIikgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIG1hdGNoID0gY2hhckJlZm9yZUN1cnNvci5tYXRjaCgvKFtcXChcXFtcXHtdKXwoW1xcKVxcXVxcfV0pLyk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAobWF0Y2hbMV0pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZmluZENsb3NpbmdCcmFja2V0KG1hdGNoWzFdLCBwb3NpdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRmaW5kT3BlbmluZ0JyYWNrZXQobWF0Y2hbMl0sIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0QnJhY2tldFJhbmdlID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHBvcy5yb3cpO1xuICAgICAgICB2YXIgYmVmb3JlID0gdHJ1ZSwgcmFuZ2U7XG5cbiAgICAgICAgdmFyIGNociA9IGxpbmUuY2hhckF0KHBvcy5jb2x1bW4tMSk7XG4gICAgICAgIHZhciBtYXRjaCA9IGNociAmJiBjaHIubWF0Y2goLyhbXFwoXFxbXFx7XSl8KFtcXClcXF1cXH1dKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBjaHIgPSBsaW5lLmNoYXJBdChwb3MuY29sdW1uKTtcbiAgICAgICAgICAgIHBvcyA9IHtyb3c6IHBvcy5yb3csIGNvbHVtbjogcG9zLmNvbHVtbiArIDF9O1xuICAgICAgICAgICAgbWF0Y2ggPSBjaHIgJiYgY2hyLm1hdGNoKC8oW1xcKFxcW1xce10pfChbXFwpXFxdXFx9XSkvKTtcbiAgICAgICAgICAgIGJlZm9yZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIHZhciBicmFja2V0UG9zID0gdGhpcy4kZmluZENsb3NpbmdCcmFja2V0KG1hdGNoWzFdLCBwb3MpO1xuICAgICAgICAgICAgaWYgKCFicmFja2V0UG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKHBvcywgYnJhY2tldFBvcyk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHJhbmdlLmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBicmFja2V0UG9zID0gdGhpcy4kZmluZE9wZW5pbmdCcmFja2V0KG1hdGNoWzJdLCBwb3MpO1xuICAgICAgICAgICAgaWYgKCFicmFja2V0UG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGJyYWNrZXRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbisrO1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcblxuICAgIHRoaXMuJGJyYWNrZXRzID0ge1xuICAgICAgICBcIilcIjogXCIoXCIsXG4gICAgICAgIFwiKFwiOiBcIilcIixcbiAgICAgICAgXCJdXCI6IFwiW1wiLFxuICAgICAgICBcIltcIjogXCJdXCIsXG4gICAgICAgIFwie1wiOiBcIn1cIixcbiAgICAgICAgXCJ9XCI6IFwie1wiXG4gICAgfTtcblxuICAgIHRoaXMuJGZpbmRPcGVuaW5nQnJhY2tldCA9IGZ1bmN0aW9uKGJyYWNrZXQsIHBvc2l0aW9uLCB0eXBlUmUpIHtcbiAgICAgICAgdmFyIG9wZW5CcmFja2V0ID0gdGhpcy4kYnJhY2tldHNbYnJhY2tldF07XG4gICAgICAgIHZhciBkZXB0aCA9IDE7XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4pO1xuICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgICBpZiAoIXR5cGVSZSl7XG4gICAgICAgICAgICB0eXBlUmUgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgIFwiKFxcXFwuP1wiICtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlLnJlcGxhY2UoXCIuXCIsIFwiXFxcXC5cIikucmVwbGFjZShcInJwYXJlblwiLCBcIi5wYXJlblwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxiKD86ZW5kfHN0YXJ0fGJlZ2luKVxcYi8sIFwiXCIpXG4gICAgICAgICAgICAgICAgKyBcIikrXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlSW5kZXggPSBwb3NpdGlvbi5jb2x1bW4gLSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSAtIDI7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgXG4gICAgICAgICAgICB3aGlsZSAodmFsdWVJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNociA9IHZhbHVlLmNoYXJBdCh2YWx1ZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09IG9wZW5CcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3JvdzogaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB2YWx1ZUluZGV4ICsgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCl9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNociA9PSBicmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlSW5kZXggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xuICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgIXR5cGVSZS50ZXN0KHRva2VuLnR5cGUpKTtcblxuICAgICAgICAgICAgaWYgKHRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWVJbmRleCA9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLiRmaW5kQ2xvc2luZ0JyYWNrZXQgPSBmdW5jdGlvbihicmFja2V0LCBwb3NpdGlvbiwgdHlwZVJlKSB7XG4gICAgICAgIHZhciBjbG9zaW5nQnJhY2tldCA9IHRoaXMuJGJyYWNrZXRzW2JyYWNrZXRdO1xuICAgICAgICB2YXIgZGVwdGggPSAxO1xuXG4gICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHRoaXMsIHBvc2l0aW9uLnJvdywgcG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0eXBlUmUpe1xuICAgICAgICAgICAgdHlwZVJlID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICBcIihcXFxcLj9cIiArXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZS5yZXBsYWNlKFwiLlwiLCBcIlxcXFwuXCIpLnJlcGxhY2UoXCJscGFyZW5cIiwgXCIucGFyZW5cIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcYig/OmVuZHxzdGFydHxiZWdpbilcXGIvLCBcIlwiKVxuICAgICAgICAgICAgICAgICsgXCIpK1wiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZUluZGV4ID0gcG9zaXRpb24uY29sdW1uIC0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWVJbmRleCA8IHZhbHVlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNociA9IHZhbHVlLmNoYXJBdCh2YWx1ZUluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09IGNsb3NpbmdCcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3JvdzogaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB2YWx1ZUluZGV4ICsgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCl9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNociA9PSBicmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b2tlbiAmJiAhdHlwZVJlLnRlc3QodG9rZW4udHlwZSkpO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgdmFsdWVJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5leHBvcnRzLkJyYWNrZXRNYXRjaCA9IEJyYWNrZXRNYXRjaDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdF9zZXNzaW9uXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9zZWxlY3Rpb25cIixcImFjZS9tb2RlL3RleHRcIixcImFjZS9yYW5nZVwiLFwiYWNlL2RvY3VtZW50XCIsXCJhY2UvYmFja2dyb3VuZF90b2tlbml6ZXJcIixcImFjZS9zZWFyY2hfaGlnaGxpZ2h0XCIsXCJhY2UvZWRpdF9zZXNzaW9uL2ZvbGRpbmdcIixcImFjZS9lZGl0X3Nlc3Npb24vYnJhY2tldF9tYXRjaFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvb3AgPSBhY2VxdWlyZShcIi4vbGliL29vcFwiKTtcbnZhciBsYW5nID0gYWNlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIGNvbmZpZyA9IGFjZXF1aXJlKFwiLi9jb25maWdcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBTZWxlY3Rpb24gPSBhY2VxdWlyZShcIi4vc2VsZWN0aW9uXCIpLlNlbGVjdGlvbjtcbnZhciBUZXh0TW9kZSA9IGFjZXF1aXJlKFwiLi9tb2RlL3RleHRcIikuTW9kZTtcbnZhciBSYW5nZSA9IGFjZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBEb2N1bWVudCA9IGFjZXF1aXJlKFwiLi9kb2N1bWVudFwiKS5Eb2N1bWVudDtcbnZhciBCYWNrZ3JvdW5kVG9rZW5pemVyID0gYWNlcXVpcmUoXCIuL2JhY2tncm91bmRfdG9rZW5pemVyXCIpLkJhY2tncm91bmRUb2tlbml6ZXI7XG52YXIgU2VhcmNoSGlnaGxpZ2h0ID0gYWNlcXVpcmUoXCIuL3NlYXJjaF9oaWdobGlnaHRcIikuU2VhcmNoSGlnaGxpZ2h0O1xuXG52YXIgRWRpdFNlc3Npb24gPSBmdW5jdGlvbih0ZXh0LCBtb2RlKSB7XG4gICAgdGhpcy4kYnJlYWtwb2ludHMgPSBbXTtcbiAgICB0aGlzLiRkZWNvcmF0aW9ucyA9IFtdO1xuICAgIHRoaXMuJGZyb250TWFya2VycyA9IHt9O1xuICAgIHRoaXMuJGJhY2tNYXJrZXJzID0ge307XG4gICAgdGhpcy4kbWFya2VySWQgPSAxO1xuICAgIHRoaXMuJHVuZG9TZWxlY3QgPSB0cnVlO1xuXG4gICAgdGhpcy4kZm9sZERhdGEgPSBbXTtcbiAgICB0aGlzLiRmb2xkRGF0YS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICB0aGlzLm9uKFwiY2hhbmdlRm9sZFwiLCB0aGlzLm9uQ2hhbmdlRm9sZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiRvbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCAhPSBcIm9iamVjdFwiIHx8ICF0ZXh0LmdldExpbmUpXG4gICAgICAgIHRleHQgPSBuZXcgRG9jdW1lbnQodGV4dCk7XG5cbiAgICB0aGlzLnNldERvY3VtZW50KHRleHQpO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbih0aGlzKTtcblxuICAgIGNvbmZpZy5yZXNldE9wdGlvbnModGhpcyk7XG4gICAgdGhpcy5zZXRNb2RlKG1vZGUpO1xuICAgIGNvbmZpZy5fc2lnbmFsKFwic2Vzc2lvblwiLCB0aGlzKTtcbn07XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuICAgIHRoaXMuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jKVxuICAgICAgICAgICAgdGhpcy5kb2MucmVtb3ZlTGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy4kb25DaGFuZ2UpO1xuXG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICBkb2Mub24oXCJjaGFuZ2VcIiwgdGhpcy4kb25DaGFuZ2UpO1xuXG4gICAgICAgIGlmICh0aGlzLmJnVG9rZW5pemVyKVxuICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5zZXREb2N1bWVudCh0aGlzLmdldERvY3VtZW50KCkpO1xuXG4gICAgICAgIHRoaXMucmVzZXRDYWNoZXMoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jO1xuICAgIH07XG4gICAgdGhpcy4kcmVzZXRSb3dDYWNoZSA9IGZ1bmN0aW9uKGRvY1Jvdykge1xuICAgICAgICBpZiAoIWRvY1Jvdykge1xuICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuJHNjcmVlblJvd0NhY2hlID0gW107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGwgPSB0aGlzLiRkb2NSb3dDYWNoZS5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gdGhpcy4kZ2V0Um93Q2FjaGVJbmRleCh0aGlzLiRkb2NSb3dDYWNoZSwgZG9jUm93KSArIDE7XG4gICAgICAgIGlmIChsID4gaSkge1xuICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUuc3BsaWNlKGksIGwpO1xuICAgICAgICAgICAgdGhpcy4kc2NyZWVuUm93Q2FjaGUuc3BsaWNlKGksIGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuJGdldFJvd0NhY2hlSW5kZXggPSBmdW5jdGlvbihjYWNoZUFycmF5LCB2YWwpIHtcbiAgICAgICAgdmFyIGxvdyA9IDA7XG4gICAgICAgIHZhciBoaSA9IGNhY2hlQXJyYXkubGVuZ3RoIC0gMTtcblxuICAgICAgICB3aGlsZSAobG93IDw9IGhpKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpKSA+PiAxO1xuICAgICAgICAgICAgdmFyIGMgPSBjYWNoZUFycmF5W21pZF07XG5cbiAgICAgICAgICAgIGlmICh2YWwgPiBjKVxuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCBjKVxuICAgICAgICAgICAgICAgIGhpID0gbWlkIC0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvdyAtMTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldENhY2hlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJHdyYXBEYXRhID0gW107XG4gICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlID0gW107XG4gICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoMCk7XG4gICAgICAgIGlmICh0aGlzLmJnVG9rZW5pemVyKVxuICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5zdGFydCgwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNoYW5nZUZvbGQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBmb2xkID0gZS5kYXRhO1xuICAgICAgICB0aGlzLiRyZXNldFJvd0NhY2hlKGZvbGQuc3RhcnQucm93KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gZS5kYXRhO1xuICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZShkZWx0YS5yYW5nZS5zdGFydC5yb3cpO1xuXG4gICAgICAgIHZhciByZW1vdmVkRm9sZHMgPSB0aGlzLiR1cGRhdGVJbnRlcm5hbERhdGFPbkNoYW5nZShlKTtcbiAgICAgICAgaWYgKCF0aGlzLiRmcm9tVW5kbyAmJiB0aGlzLiR1bmRvTWFuYWdlciAmJiAhZGVsdGEuaWdub3JlKSB7XG4gICAgICAgICAgICB0aGlzLiRkZWx0YXNEb2MucHVzaChkZWx0YSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZEZvbGRzICYmIHJlbW92ZWRGb2xkcy5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRlbHRhc0ZvbGQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZW1vdmVGb2xkc1wiLFxuICAgICAgICAgICAgICAgICAgICBmb2xkczogIHJlbW92ZWRGb2xkc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRpbmZvcm1VbmRvTWFuYWdlci5zY2hlZHVsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iZ1Rva2VuaXplciAmJiB0aGlzLmJnVG9rZW5pemVyLiR1cGRhdGVPbkNoYW5nZShkZWx0YSk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVwiLCBlKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHRoaXMuZG9jLnNldFZhbHVlKHRleHQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlVG8oMCwgMCk7XG5cbiAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcbiAgICAgICAgdGhpcy4kZGVsdGFzID0gW107XG4gICAgICAgIHRoaXMuJGRlbHRhc0RvYyA9IFtdO1xuICAgICAgICB0aGlzLiRkZWx0YXNGb2xkID0gW107XG4gICAgICAgIHRoaXMuc2V0VW5kb01hbmFnZXIodGhpcy4kdW5kb01hbmFnZXIpO1xuICAgICAgICB0aGlzLmdldFVuZG9NYW5hZ2VyKCkucmVzZXQoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VmFsdWUgPVxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldFZhbHVlKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb247XG4gICAgfTtcbiAgICB0aGlzLmdldFN0YXRlID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJnVG9rZW5pemVyLmdldFN0YXRlKHJvdyk7XG4gICAgfTtcbiAgICB0aGlzLmdldFRva2VucyA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZ1Rva2VuaXplci5nZXRUb2tlbnMocm93KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VG9rZW5BdCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLmJnVG9rZW5pemVyLmdldFRva2Vucyhyb3cpO1xuICAgICAgICB2YXIgdG9rZW4sIGMgPSAwO1xuICAgICAgICBpZiAoY29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICAgIGkgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGMgPSB0aGlzLmdldExpbmUocm93KS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGMgKz0gdG9rZW5zW2ldLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoYyA+PSBjb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRva2VuLmluZGV4ID0gaTtcbiAgICAgICAgdG9rZW4uc3RhcnQgPSBjIC0gdG9rZW4udmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICB0aGlzLnNldFVuZG9NYW5hZ2VyID0gZnVuY3Rpb24odW5kb01hbmFnZXIpIHtcbiAgICAgICAgdGhpcy4kdW5kb01hbmFnZXIgPSB1bmRvTWFuYWdlcjtcbiAgICAgICAgdGhpcy4kZGVsdGFzID0gW107XG4gICAgICAgIHRoaXMuJGRlbHRhc0RvYyA9IFtdO1xuICAgICAgICB0aGlzLiRkZWx0YXNGb2xkID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuJGluZm9ybVVuZG9NYW5hZ2VyKVxuICAgICAgICAgICAgdGhpcy4kaW5mb3JtVW5kb01hbmFnZXIuY2FuY2VsKCk7XG5cbiAgICAgICAgaWYgKHVuZG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuJGluZm9ybVVuZG9NYW5hZ2VyLmNhbmNlbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuJGRlbHRhc0ZvbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBcImZvbGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhczogc2VsZi4kZGVsdGFzRm9sZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kZGVsdGFzRm9sZCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLiRkZWx0YXNEb2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJGRlbHRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBcImRvY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzOiBzZWxmLiRkZWx0YXNEb2NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJGRlbHRhc0RvYyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLiRkZWx0YXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB1bmRvTWFuYWdlci5leGVjdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhY2V1cGRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtzZWxmLiRkZWx0YXMsIHNlbGZdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2U6IHNlbGYubWVyZ2VVbmRvRGVsdGFzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLm1lcmdlVW5kb0RlbHRhcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuJGRlbHRhcyA9IFtdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuJGluZm9ybVVuZG9NYW5hZ2VyID0gbGFuZy5kZWxheWVkQ2FsbCh0aGlzLiRzeW5jSW5mb3JtVW5kb01hbmFnZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1hcmtVbmRvR3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlcilcbiAgICAgICAgICAgIHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlcigpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy4kZGVmYXVsdFVuZG9NYW5hZ2VyID0ge1xuICAgICAgICB1bmRvOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICByZWRvOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7fVxuICAgIH07XG4gICAgdGhpcy5nZXRVbmRvTWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdW5kb01hbmFnZXIgfHwgdGhpcy4kZGVmYXVsdFVuZG9NYW5hZ2VyO1xuICAgIH07XG4gICAgdGhpcy5nZXRUYWJTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VXNlU29mdFRhYnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcuc3RyaW5nUmVwZWF0KFwiIFwiLCB0aGlzLmdldFRhYlNpemUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXHRcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZXRVc2VTb2Z0VGFicyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInVzZVNvZnRUYWJzXCIsIHZhbCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFVzZVNvZnRUYWJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1c2VTb2Z0VGFicyAmJiAhdGhpcy4kbW9kZS4kaW5kZW50V2l0aFRhYnM7XG4gICAgfTtcbiAgICB0aGlzLnNldFRhYlNpemUgPSBmdW5jdGlvbih0YWJTaXplKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwidGFiU2l6ZVwiLCB0YWJTaXplKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VGFiU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGFiU2l6ZTtcbiAgICB9O1xuICAgIHRoaXMuaXNUYWJTdG9wID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHVzZVNvZnRUYWJzICYmIChwb3NpdGlvbi5jb2x1bW4gJSB0aGlzLiR0YWJTaXplID09PSAwKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kb3ZlcndyaXRlID0gZmFsc2U7XG4gICAgdGhpcy5zZXRPdmVyd3JpdGUgPSBmdW5jdGlvbihvdmVyd3JpdGUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJvdmVyd3JpdGVcIiwgb3ZlcndyaXRlKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T3ZlcndyaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRvdmVyd3JpdGU7XG4gICAgfTtcbiAgICB0aGlzLnRvZ2dsZU92ZXJ3cml0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldE92ZXJ3cml0ZSghdGhpcy4kb3ZlcndyaXRlKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGVjb3JhdGlvbnNbcm93XSlcbiAgICAgICAgICAgIHRoaXMuJGRlY29yYXRpb25zW3Jvd10gPSBcIlwiO1xuICAgICAgICB0aGlzLiRkZWNvcmF0aW9uc1tyb3ddICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuJGRlY29yYXRpb25zW3Jvd10gPSAodGhpcy4kZGVjb3JhdGlvbnNbcm93XSB8fCBcIlwiKS5yZXBsYWNlKFwiIFwiICsgY2xhc3NOYW1lLCBcIlwiKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB7fSk7XG4gICAgfTtcbiAgICB0aGlzLmdldEJyZWFrcG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRicmVha3BvaW50cztcbiAgICB9O1xuICAgIHRoaXMuc2V0QnJlYWtwb2ludHMgPSBmdW5jdGlvbihyb3dzKSB7XG4gICAgICAgIHRoaXMuJGJyZWFrcG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxyb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLiRicmVha3BvaW50c1tyb3dzW2ldXSA9IFwiYWNlX2JyZWFrcG9pbnRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJCcmVha3BvaW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRicmVha3BvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIHRoaXMuc2V0QnJlYWtwb2ludCA9IGZ1bmN0aW9uKHJvdywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IFwiYWNlX2JyZWFrcG9pbnRcIjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSlcbiAgICAgICAgICAgIHRoaXMuJGJyZWFrcG9pbnRzW3Jvd10gPSBjbGFzc05hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRicmVha3BvaW50c1tyb3ddO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJCcmVha3BvaW50ID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLiRicmVha3BvaW50c1tyb3ddO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIsIHt9KTtcbiAgICB9O1xuICAgIHRoaXMuYWRkTWFya2VyID0gZnVuY3Rpb24ocmFuZ2UsIGNsYXp6LCB0eXBlLCBpbkZyb250KSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuJG1hcmtlcklkKys7XG5cbiAgICAgICAgdmFyIG1hcmtlciA9IHtcbiAgICAgICAgICAgIHJhbmdlIDogcmFuZ2UsXG4gICAgICAgICAgICB0eXBlIDogdHlwZSB8fCBcImxpbmVcIixcbiAgICAgICAgICAgIHJlbmRlcmVyOiB0eXBlb2YgdHlwZSA9PSBcImZ1bmN0aW9uXCIgPyB0eXBlIDogbnVsbCxcbiAgICAgICAgICAgIGNsYXp6IDogY2xhenosXG4gICAgICAgICAgICBpbkZyb250OiAhIWluRnJvbnQsXG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5Gcm9udCkge1xuICAgICAgICAgICAgdGhpcy4kZnJvbnRNYXJrZXJzW2lkXSA9IG1hcmtlcjtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUZyb250TWFya2VyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kYmFja01hcmtlcnNbaWRdID0gbWFya2VyO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIHRoaXMuYWRkRHluYW1pY01hcmtlciA9IGZ1bmN0aW9uKG1hcmtlciwgaW5Gcm9udCkge1xuICAgICAgICBpZiAoIW1hcmtlci51cGRhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpZCA9IHRoaXMuJG1hcmtlcklkKys7XG4gICAgICAgIG1hcmtlci5pZCA9IGlkO1xuICAgICAgICBtYXJrZXIuaW5Gcm9udCA9ICEhaW5Gcm9udDtcblxuICAgICAgICBpZiAoaW5Gcm9udCkge1xuICAgICAgICAgICAgdGhpcy4kZnJvbnRNYXJrZXJzW2lkXSA9IG1hcmtlcjtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUZyb250TWFya2VyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kYmFja01hcmtlcnNbaWRdID0gbWFya2VyO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZU1hcmtlciA9IGZ1bmN0aW9uKG1hcmtlcklkKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLiRmcm9udE1hcmtlcnNbbWFya2VySWRdIHx8IHRoaXMuJGJhY2tNYXJrZXJzW21hcmtlcklkXTtcbiAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIG1hcmtlcnMgPSBtYXJrZXIuaW5Gcm9udCA/IHRoaXMuJGZyb250TWFya2VycyA6IHRoaXMuJGJhY2tNYXJrZXJzO1xuICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICBkZWxldGUgKG1hcmtlcnNbbWFya2VySWRdKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChtYXJrZXIuaW5Gcm9udCA/IFwiY2hhbmdlRnJvbnRNYXJrZXJcIiA6IFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oaW5Gcm9udCkge1xuICAgICAgICByZXR1cm4gaW5Gcm9udCA/IHRoaXMuJGZyb250TWFya2VycyA6IHRoaXMuJGJhY2tNYXJrZXJzO1xuICAgIH07XG5cbiAgICB0aGlzLmhpZ2hsaWdodCA9IGZ1bmN0aW9uKHJlKSB7XG4gICAgICAgIGlmICghdGhpcy4kc2VhcmNoSGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gbmV3IFNlYXJjaEhpZ2hsaWdodChudWxsLCBcImFjZV9zZWxlY3RlZC13b3JkXCIsIFwidGV4dFwiKTtcbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaEhpZ2hsaWdodCA9IHRoaXMuYWRkRHluYW1pY01hcmtlcihoaWdobGlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHNlYXJjaEhpZ2hsaWdodC5zZXRSZWdleHAocmUpO1xuICAgIH07XG4gICAgdGhpcy5oaWdobGlnaHRMaW5lcyA9IGZ1bmN0aW9uKHN0YXJ0Um93LCBlbmRSb3csIGNsYXp6LCBpbkZyb250KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kUm93ICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNsYXp6ID0gZW5kUm93O1xuICAgICAgICAgICAgZW5kUm93ID0gc3RhcnRSb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjbGF6eilcbiAgICAgICAgICAgIGNsYXp6ID0gXCJhY2Vfc3RlcFwiO1xuXG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShzdGFydFJvdywgMCwgZW5kUm93LCBJbmZpbml0eSk7XG4gICAgICAgIHJhbmdlLmlkID0gdGhpcy5hZGRNYXJrZXIocmFuZ2UsIGNsYXp6LCBcImZ1bGxMaW5lXCIsIGluRnJvbnQpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLnNldEFubm90YXRpb25zID0gZnVuY3Rpb24oYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlQW5ub3RhdGlvblwiLCB7fSk7XG4gICAgfTtcbiAgICB0aGlzLmdldEFubm90YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRhbm5vdGF0aW9ucyB8fCBbXTtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldEFubm90YXRpb25zKFtdKTtcbiAgICB9O1xuICAgIHRoaXMuJGRldGVjdE5ld0xpbmUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goL14uKj8oXFxyP1xcbikvbSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdGhpcy4kYXV0b05ld0xpbmUgPSBtYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGF1dG9OZXdMaW5lID0gXCJcXG5cIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRXb3JkUmFuZ2UgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ2V0TGluZShyb3cpO1xuXG4gICAgICAgIHZhciBpblRva2VuID0gZmFsc2U7XG4gICAgICAgIGlmIChjb2x1bW4gPiAwKVxuICAgICAgICAgICAgaW5Ub2tlbiA9ICEhbGluZS5jaGFyQXQoY29sdW1uIC0gMSkubWF0Y2godGhpcy50b2tlblJlKTtcblxuICAgICAgICBpZiAoIWluVG9rZW4pXG4gICAgICAgICAgICBpblRva2VuID0gISFsaW5lLmNoYXJBdChjb2x1bW4pLm1hdGNoKHRoaXMudG9rZW5SZSk7XG5cbiAgICAgICAgaWYgKGluVG9rZW4pXG4gICAgICAgICAgICB2YXIgcmUgPSB0aGlzLnRva2VuUmU7XG4gICAgICAgIGVsc2UgaWYgKC9eXFxzKyQvLnRlc3QobGluZS5zbGljZShjb2x1bW4tMSwgY29sdW1uKzEpKSlcbiAgICAgICAgICAgIHZhciByZSA9IC9cXHMvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YXIgcmUgPSB0aGlzLm5vblRva2VuUmU7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gY29sdW1uO1xuICAgICAgICBpZiAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdGFydCA+PSAwICYmIGxpbmUuY2hhckF0KHN0YXJ0KS5tYXRjaChyZSkpO1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBjb2x1bW47XG4gICAgICAgIHdoaWxlIChlbmQgPCBsaW5lLmxlbmd0aCAmJiBsaW5lLmNoYXJBdChlbmQpLm1hdGNoKHJlKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJvdywgc3RhcnQsIHJvdywgZW5kKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0QVdvcmRSYW5nZSA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHZhciB3b3JkUmFuZ2UgPSB0aGlzLmdldFdvcmRSYW5nZShyb3csIGNvbHVtbik7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHdvcmRSYW5nZS5lbmQucm93KTtcblxuICAgICAgICB3aGlsZSAobGluZS5jaGFyQXQod29yZFJhbmdlLmVuZC5jb2x1bW4pLm1hdGNoKC9bIFxcdF0vKSkge1xuICAgICAgICAgICAgd29yZFJhbmdlLmVuZC5jb2x1bW4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZFJhbmdlO1xuICAgIH07XG4gICAgdGhpcy5zZXROZXdMaW5lTW9kZSA9IGZ1bmN0aW9uKG5ld0xpbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuZG9jLnNldE5ld0xpbmVNb2RlKG5ld0xpbmVNb2RlKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TmV3TGluZU1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldE5ld0xpbmVNb2RlKCk7XG4gICAgfTtcbiAgICB0aGlzLnNldFVzZVdvcmtlciA9IGZ1bmN0aW9uKHVzZVdvcmtlcikgeyB0aGlzLnNldE9wdGlvbihcInVzZVdvcmtlclwiLCB1c2VXb3JrZXIpOyB9O1xuICAgIHRoaXMuZ2V0VXNlV29ya2VyID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLiR1c2VXb3JrZXI7IH07XG4gICAgdGhpcy5vblJlbG9hZFRva2VuaXplciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBlLmRhdGE7XG4gICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc3RhcnQocm93cy5maXJzdCk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcInRva2VuaXplclVwZGF0ZVwiLCBlKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kbW9kZXMgPSB7fTtcbiAgICB0aGlzLiRtb2RlID0gbnVsbDtcbiAgICB0aGlzLiRtb2RlSWQgPSBudWxsO1xuICAgIHRoaXMuc2V0TW9kZSA9IGZ1bmN0aW9uKG1vZGUsIGNiKSB7XG4gICAgICAgIGlmIChtb2RlICYmIHR5cGVvZiBtb2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAobW9kZS5nZXRUb2tlbml6ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9uQ2hhbmdlTW9kZShtb2RlKTtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gbW9kZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gb3B0aW9ucy5wYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IG1vZGUgfHwgXCJhY2UvbW9kZS90ZXh0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiRtb2Rlc1tcImFjZS9tb2RlL3RleHRcIl0pXG4gICAgICAgICAgICB0aGlzLiRtb2Rlc1tcImFjZS9tb2RlL3RleHRcIl0gPSBuZXcgVGV4dE1vZGUoKTtcblxuICAgICAgICBpZiAodGhpcy4kbW9kZXNbcGF0aF0gJiYgIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlTW9kZSh0aGlzLiRtb2Rlc1twYXRoXSk7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJG1vZGVJZCA9IHBhdGg7XG4gICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFtcIm1vZGVcIiwgcGF0aF0sIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiRtb2RlSWQgIT09IHBhdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgICAgICAgICBpZiAodGhpcy4kbW9kZXNbcGF0aF0gJiYgIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRvbkNoYW5nZU1vZGUodGhpcy4kbW9kZXNbcGF0aF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtICYmIG0uTW9kZSkge1xuICAgICAgICAgICAgICAgIG0gPSBuZXcgbS5Nb2RlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRtb2Rlc1twYXRoXSA9IG07XG4gICAgICAgICAgICAgICAgICAgIG0uJGlkID0gcGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKCF0aGlzLiRtb2RlKVxuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlKHRoaXMuJG1vZGVzW1wiYWNlL21vZGUvdGV4dFwiXSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuJG9uQ2hhbmdlTW9kZSA9IGZ1bmN0aW9uKG1vZGUsICRpc1BsYWNlaG9sZGVyKSB7XG4gICAgICAgIGlmICghJGlzUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICB0aGlzLiRtb2RlSWQgPSBtb2RlLiRpZDtcbiAgICAgICAgaWYgKHRoaXMuJG1vZGUgPT09IG1vZGUpIFxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuJG1vZGUgPSBtb2RlO1xuXG4gICAgICAgIHRoaXMuJHN0b3BXb3JrZXIoKTtcblxuICAgICAgICBpZiAodGhpcy4kdXNlV29ya2VyKVxuICAgICAgICAgICAgdGhpcy4kc3RhcnRXb3JrZXIoKTtcblxuICAgICAgICB2YXIgdG9rZW5pemVyID0gbW9kZS5nZXRUb2tlbml6ZXIoKTtcblxuICAgICAgICBpZih0b2tlbml6ZXIuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgb25SZWxvYWRUb2tlbml6ZXIgPSB0aGlzLm9uUmVsb2FkVG9rZW5pemVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0b2tlbml6ZXIuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZVwiLCBvblJlbG9hZFRva2VuaXplcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYmdUb2tlbml6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIgPSBuZXcgQmFja2dyb3VuZFRva2VuaXplcih0b2tlbml6ZXIpO1xuICAgICAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgX3NlbGYuX3NpZ25hbChcInRva2VuaXplclVwZGF0ZVwiLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5zZXRUb2tlbml6ZXIodG9rZW5pemVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc2V0RG9jdW1lbnQodGhpcy5nZXREb2N1bWVudCgpKTtcblxuICAgICAgICB0aGlzLnRva2VuUmUgPSBtb2RlLnRva2VuUmU7XG4gICAgICAgIHRoaXMubm9uVG9rZW5SZSA9IG1vZGUubm9uVG9rZW5SZTtcblxuICAgICAgICBcbiAgICAgICAgaWYgKCEkaXNQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgaWYgKG1vZGUuYXR0YWNoVG9TZXNzaW9uKVxuICAgICAgICAgICAgICAgIG1vZGUuYXR0YWNoVG9TZXNzaW9uKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kb3B0aW9ucy53cmFwTWV0aG9kLnNldC5jYWxsKHRoaXMsIHRoaXMuJHdyYXBNZXRob2QpO1xuICAgICAgICAgICAgdGhpcy4kc2V0Rm9sZGluZyhtb2RlLmZvbGRpbmdSdWxlcyk7XG4gICAgICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnN0YXJ0KDApO1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZU1vZGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kc3RvcFdvcmtlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy4kd29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLiR3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB0aGlzLiR3b3JrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuJHN0YXJ0V29ya2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLiR3b3JrZXIgPSB0aGlzLiRtb2RlLmNyZWF0ZVdvcmtlcih0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uZmlnLndhcm4oXCJDb3VsZCBub3QgbG9hZCB3b3JrZXJcIiwgZSk7XG4gICAgICAgICAgICB0aGlzLiR3b3JrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vZGU7XG4gICAgfTtcblxuICAgIHRoaXMuJHNjcm9sbFRvcCA9IDA7XG4gICAgdGhpcy5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbihzY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFRvcCA9PT0gc2Nyb2xsVG9wIHx8IGlzTmFOKHNjcm9sbFRvcCkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGhpcy4kc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VTY3JvbGxUb3BcIiwgc2Nyb2xsVG9wKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzY3JvbGxUb3A7XG4gICAgfTtcblxuICAgIHRoaXMuJHNjcm9sbExlZnQgPSAwO1xuICAgIHRoaXMuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uKHNjcm9sbExlZnQpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbExlZnQgPT09IHNjcm9sbExlZnQgfHwgaXNOYU4oc2Nyb2xsTGVmdCkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGhpcy4kc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNjcm9sbExlZnRcIiwgc2Nyb2xsTGVmdCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNjcm9sbExlZnQ7XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcmVlbldpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGNvbXB1dGVXaWR0aCgpO1xuICAgICAgICBpZiAodGhpcy5saW5lV2lkZ2V0cykgXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nZXRMaW5lV2lkZ2V0TWF4V2lkdGgoKSwgdGhpcy5zY3JlZW5XaWR0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbldpZHRoO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRMaW5lV2lkZ2V0TWF4V2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHNXaWR0aCAhPSBudWxsKSByZXR1cm4gdGhpcy5saW5lV2lkZ2V0c1dpZHRoO1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB0aGlzLmxpbmVXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgICAgICAgaWYgKHcgJiYgdy5zY3JlZW5XaWR0aCA+IHdpZHRoKVxuICAgICAgICAgICAgICAgIHdpZHRoID0gdy5zY3JlZW5XaWR0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVXaWRnZXRXaWR0aCA9IHdpZHRoO1xuICAgIH07XG5cbiAgICB0aGlzLiRjb21wdXRlV2lkdGggPSBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy4kbW9kaWZpZWQgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW5XaWR0aCA9IHRoaXMuJHdyYXBMaW1pdDtcblxuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5kb2MuZ2V0QWxsTGluZXMoKTtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHRoaXMuJHJvd0xlbmd0aENhY2hlO1xuICAgICAgICAgICAgdmFyIGxvbmdlc3RTY3JlZW5MaW5lID0gMDtcbiAgICAgICAgICAgIHZhciBmb2xkSW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy4kZm9sZERhdGFbZm9sZEluZGV4XTtcbiAgICAgICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBmb2xkTGluZS5lbmQucm93ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy4kZm9sZERhdGFbZm9sZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZVtpXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjYWNoZVtpXSA9IHRoaXMuJGdldFN0cmluZ1NjcmVlbldpZHRoKGxpbmVzW2ldKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChjYWNoZVtpXSA+IGxvbmdlc3RTY3JlZW5MaW5lKVxuICAgICAgICAgICAgICAgICAgICBsb25nZXN0U2NyZWVuTGluZSA9IGNhY2hlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JlZW5XaWR0aCA9IGxvbmdlc3RTY3JlZW5MaW5lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldExpbmUgPSBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldExpbmUocm93KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TGluZXMgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MuZ2V0TGluZXMoZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgIH07XG4gICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldExlbmd0aCgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRUZXh0UmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MuZ2V0VGV4dFJhbmdlKHJhbmdlIHx8IHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCkpO1xuICAgIH07XG4gICAgdGhpcy5pbnNlcnQgPSBmdW5jdGlvbihwb3NpdGlvbiwgdGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MuaW5zZXJ0KHBvc2l0aW9uLCB0ZXh0KTtcbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnJlbW92ZShyYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLnVuZG9DaGFuZ2VzID0gZnVuY3Rpb24oZGVsdGFzLCBkb250U2VsZWN0KSB7XG4gICAgICAgIGlmICghZGVsdGFzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IHRydWU7XG4gICAgICAgIHZhciBsYXN0VW5kb1JhbmdlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlbHRhcy5sZW5ndGggLSAxOyBpICE9IC0xOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGRlbHRhc1tpXTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5ncm91cCA9PSBcImRvY1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MucmV2ZXJ0RGVsdGFzKGRlbHRhLmRlbHRhcyk7XG4gICAgICAgICAgICAgICAgbGFzdFVuZG9SYW5nZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdldFVuZG9TZWxlY3Rpb24oZGVsdGEuZGVsdGFzLCB0cnVlLCBsYXN0VW5kb1JhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsdGEuZGVsdGFzLmZvckVhY2goZnVuY3Rpb24oZm9sZERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZHMoZm9sZERlbHRhLmZvbGRzKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IGZhbHNlO1xuICAgICAgICBsYXN0VW5kb1JhbmdlICYmXG4gICAgICAgICAgICB0aGlzLiR1bmRvU2VsZWN0ICYmXG4gICAgICAgICAgICAhZG9udFNlbGVjdCAmJlxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UobGFzdFVuZG9SYW5nZSk7XG4gICAgICAgIHJldHVybiBsYXN0VW5kb1JhbmdlO1xuICAgIH07XG4gICAgdGhpcy5yZWRvQ2hhbmdlcyA9IGZ1bmN0aW9uKGRlbHRhcywgZG9udFNlbGVjdCkge1xuICAgICAgICBpZiAoIWRlbHRhcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSB0cnVlO1xuICAgICAgICB2YXIgbGFzdFVuZG9SYW5nZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XG4gICAgICAgICAgICBpZiAoZGVsdGEuZ3JvdXAgPT0gXCJkb2NcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jLmFwcGx5RGVsdGFzKGRlbHRhLmRlbHRhcyk7XG4gICAgICAgICAgICAgICAgbGFzdFVuZG9SYW5nZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdldFVuZG9TZWxlY3Rpb24oZGVsdGEuZGVsdGFzLCBmYWxzZSwgbGFzdFVuZG9SYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSBmYWxzZTtcbiAgICAgICAgbGFzdFVuZG9SYW5nZSAmJlxuICAgICAgICAgICAgdGhpcy4kdW5kb1NlbGVjdCAmJlxuICAgICAgICAgICAgIWRvbnRTZWxlY3QgJiZcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKGxhc3RVbmRvUmFuZ2UpO1xuICAgICAgICByZXR1cm4gbGFzdFVuZG9SYW5nZTtcbiAgICB9O1xuICAgIHRoaXMuc2V0VW5kb1NlbGVjdCA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuICAgICAgICB0aGlzLiR1bmRvU2VsZWN0ID0gZW5hYmxlO1xuICAgIH07XG5cbiAgICB0aGlzLiRnZXRVbmRvU2VsZWN0aW9uID0gZnVuY3Rpb24oZGVsdGFzLCBpc1VuZG8sIGxhc3RVbmRvUmFuZ2UpIHtcbiAgICAgICAgZnVuY3Rpb24gaXNJbnNlcnQoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBpbnNlcnQgPVxuICAgICAgICAgICAgICAgIGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRUZXh0XCIgfHwgZGVsdGEuYWN0aW9uID09PSBcImluc2VydExpbmVzXCI7XG4gICAgICAgICAgICByZXR1cm4gaXNVbmRvID8gIWluc2VydCA6IGluc2VydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IGRlbHRhc1swXTtcbiAgICAgICAgdmFyIHJhbmdlLCBwb2ludDtcbiAgICAgICAgdmFyIGxhc3REZWx0YUlzSW5zZXJ0ID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0luc2VydChkZWx0YSkpIHtcbiAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhkZWx0YS5yYW5nZS5zdGFydCwgZGVsdGEucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGxhc3REZWx0YUlzSW5zZXJ0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhkZWx0YS5yYW5nZS5zdGFydCwgZGVsdGEucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGFzdERlbHRhSXNJbnNlcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhc1tpXTtcbiAgICAgICAgICAgIGlmIChpc0luc2VydChkZWx0YSkpIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGRlbHRhLnJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKHBvaW50LnJvdywgcG9pbnQuY29sdW1uKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChkZWx0YS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvaW50ID0gZGVsdGEucmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKHBvaW50LnJvdywgcG9pbnQuY29sdW1uKSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChkZWx0YS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0RGVsdGFJc0luc2VydCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gZGVsdGEucmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmUocG9pbnQucm93LCBwb2ludC5jb2x1bW4pID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFJhbmdlLmZyb21Qb2ludHMoZGVsdGEucmFuZ2Uuc3RhcnQsIGRlbHRhLnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdERlbHRhSXNJbnNlcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFVuZG9SYW5nZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoUmFuZ2UuY29tcGFyZVBvaW50cyhsYXN0VW5kb1JhbmdlLnN0YXJ0LCByYW5nZS5zdGFydCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0VW5kb1JhbmdlLnN0YXJ0LmNvbHVtbiArPSByYW5nZS5lbmQuY29sdW1uIC0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgICAgIGxhc3RVbmRvUmFuZ2UuZW5kLmNvbHVtbiArPSByYW5nZS5lbmQuY29sdW1uIC0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY21wID0gbGFzdFVuZG9SYW5nZS5jb21wYXJlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobGFzdFVuZG9SYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChsYXN0VW5kb1JhbmdlLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLnJlcGxhY2UgPSBmdW5jdGlvbihyYW5nZSwgdGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2MucmVwbGFjZShyYW5nZSwgdGV4dCk7XG4gICAgfTtcbiAgICB0aGlzLm1vdmVUZXh0ID0gZnVuY3Rpb24oZnJvbVJhbmdlLCB0b1Bvc2l0aW9uLCBjb3B5KSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRUZXh0UmFuZ2UoZnJvbVJhbmdlKTtcbiAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UoZnJvbVJhbmdlKTtcblxuICAgICAgICB2YXIgdG9SYW5nZSA9IFJhbmdlLmZyb21Qb2ludHModG9Qb3NpdGlvbiwgdG9Qb3NpdGlvbik7XG4gICAgICAgIGlmICghY29weSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZnJvbVJhbmdlKTtcbiAgICAgICAgICAgIHZhciByb3dEaWZmID0gZnJvbVJhbmdlLnN0YXJ0LnJvdyAtIGZyb21SYW5nZS5lbmQucm93O1xuICAgICAgICAgICAgdmFyIGNvbGxEaWZmID0gcm93RGlmZiA/IC1mcm9tUmFuZ2UuZW5kLmNvbHVtbiA6IGZyb21SYW5nZS5zdGFydC5jb2x1bW4gLSBmcm9tUmFuZ2UuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChjb2xsRGlmZikge1xuICAgICAgICAgICAgICAgIGlmICh0b1JhbmdlLnN0YXJ0LnJvdyA9PSBmcm9tUmFuZ2UuZW5kLnJvdyAmJiB0b1JhbmdlLnN0YXJ0LmNvbHVtbiA+IGZyb21SYW5nZS5lbmQuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICB0b1JhbmdlLnN0YXJ0LmNvbHVtbiArPSBjb2xsRGlmZjtcbiAgICAgICAgICAgICAgICBpZiAodG9SYW5nZS5lbmQucm93ID09IGZyb21SYW5nZS5lbmQucm93ICYmIHRvUmFuZ2UuZW5kLmNvbHVtbiA+IGZyb21SYW5nZS5lbmQuY29sdW1uKVxuICAgICAgICAgICAgICAgICAgICB0b1JhbmdlLmVuZC5jb2x1bW4gKz0gY29sbERpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93RGlmZiAmJiB0b1JhbmdlLnN0YXJ0LnJvdyA+PSBmcm9tUmFuZ2UuZW5kLnJvdykge1xuICAgICAgICAgICAgICAgIHRvUmFuZ2Uuc3RhcnQucm93ICs9IHJvd0RpZmY7XG4gICAgICAgICAgICAgICAgdG9SYW5nZS5lbmQucm93ICs9IHJvd0RpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b1JhbmdlLmVuZCA9IHRoaXMuaW5zZXJ0KHRvUmFuZ2Uuc3RhcnQsIHRleHQpO1xuICAgICAgICBpZiAoZm9sZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RhcnQgPSBmcm9tUmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSB0b1JhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIHJvd0RpZmYgPSBuZXdTdGFydC5yb3cgLSBvbGRTdGFydC5yb3c7XG4gICAgICAgICAgICB2YXIgY29sbERpZmYgPSBuZXdTdGFydC5jb2x1bW4gLSBvbGRTdGFydC5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLmFkZEZvbGRzKGZvbGRzLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoeC5zdGFydC5yb3cgPT0gb2xkU3RhcnQucm93KVxuICAgICAgICAgICAgICAgICAgICB4LnN0YXJ0LmNvbHVtbiArPSBjb2xsRGlmZjtcbiAgICAgICAgICAgICAgICBpZiAoeC5lbmQucm93ID09IG9sZFN0YXJ0LnJvdylcbiAgICAgICAgICAgICAgICAgICAgeC5lbmQuY29sdW1uICs9IGNvbGxEaWZmO1xuICAgICAgICAgICAgICAgIHguc3RhcnQucm93ICs9IHJvd0RpZmY7XG4gICAgICAgICAgICAgICAgeC5lbmQucm93ICs9IHJvd0RpZmY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9SYW5nZTtcbiAgICB9O1xuICAgIHRoaXMuaW5kZW50Um93cyA9IGZ1bmN0aW9uKHN0YXJ0Um93LCBlbmRSb3csIGluZGVudFN0cmluZykge1xuICAgICAgICBpbmRlbnRTdHJpbmcgPSBpbmRlbnRTdHJpbmcucmVwbGFjZSgvXFx0L2csIHRoaXMuZ2V0VGFiU3RyaW5nKCkpO1xuICAgICAgICBmb3IgKHZhciByb3c9c3RhcnRSb3c7IHJvdzw9ZW5kUm93OyByb3crKylcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHtyb3c6IHJvdywgY29sdW1uOjB9LCBpbmRlbnRTdHJpbmcpO1xuICAgIH07XG4gICAgdGhpcy5vdXRkZW50Um93cyA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgcm93UmFuZ2UgPSByYW5nZS5jb2xsYXBzZVJvd3MoKTtcbiAgICAgICAgdmFyIGRlbGV0ZVJhbmdlID0gbmV3IFJhbmdlKDAsIDAsIDAsIDApO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGFiU2l6ZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSByb3dSYW5nZS5zdGFydC5yb3c7IGkgPD0gcm93UmFuZ2UuZW5kLnJvdzsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ2V0TGluZShpKTtcblxuICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc3RhcnQucm93ID0gaTtcbiAgICAgICAgICAgIGRlbGV0ZVJhbmdlLmVuZC5yb3cgPSBpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplOyArK2opXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuY2hhckF0KGopICE9ICcgJylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoaiA8IHNpemUgJiYgbGluZS5jaGFyQXQoaikgPT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSYW5nZS5zdGFydC5jb2x1bW4gPSBqO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlLmVuZC5jb2x1bW4gPSBqICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc3RhcnQuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQuY29sdW1uID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRlbGV0ZVJhbmdlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLiRtb3ZlTGluZXMgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdywgZGlyKSB7XG4gICAgICAgIGZpcnN0Um93ID0gdGhpcy5nZXRSb3dGb2xkU3RhcnQoZmlyc3RSb3cpO1xuICAgICAgICBsYXN0Um93ID0gdGhpcy5nZXRSb3dGb2xkRW5kKGxhc3RSb3cpO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93Rm9sZFN0YXJ0KGZpcnN0Um93ICsgZGlyKTtcbiAgICAgICAgICAgIGlmIChyb3cgPCAwKSByZXR1cm4gMDtcbiAgICAgICAgICAgIHZhciBkaWZmID0gcm93LWZpcnN0Um93O1xuICAgICAgICB9IGVsc2UgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvd0ZvbGRFbmQobGFzdFJvdyArIGRpcik7XG4gICAgICAgICAgICBpZiAocm93ID4gdGhpcy5kb2MuZ2V0TGVuZ3RoKCktMSkgcmV0dXJuIDA7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHJvdy1sYXN0Um93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlyc3RSb3cgPSB0aGlzLiRjbGlwUm93VG9Eb2N1bWVudChmaXJzdFJvdyk7XG4gICAgICAgICAgICBsYXN0Um93ID0gdGhpcy4kY2xpcFJvd1RvRG9jdW1lbnQobGFzdFJvdyk7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGxhc3RSb3cgLSBmaXJzdFJvdyArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoZmlyc3RSb3csIDAsIGxhc3RSb3csIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShyYW5nZSkubWFwKGZ1bmN0aW9uKHgpe1xuICAgICAgICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICAgICAgICAgIHguc3RhcnQucm93ICs9IGRpZmY7XG4gICAgICAgICAgICB4LmVuZC5yb3cgKz0gZGlmZjtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbGluZXMgPSBkaXIgPT0gMFxuICAgICAgICAgICAgPyB0aGlzLmRvYy5nZXRMaW5lcyhmaXJzdFJvdywgbGFzdFJvdylcbiAgICAgICAgICAgIDogdGhpcy5kb2MucmVtb3ZlTGluZXMoZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgICAgICB0aGlzLmRvYy5pbnNlcnRMaW5lcyhmaXJzdFJvdytkaWZmLCBsaW5lcyk7XG4gICAgICAgIGZvbGRzLmxlbmd0aCAmJiB0aGlzLmFkZEZvbGRzKGZvbGRzKTtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfTtcbiAgICB0aGlzLm1vdmVMaW5lc1VwID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vdmVMaW5lcyhmaXJzdFJvdywgbGFzdFJvdywgLTEpO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlTGluZXNEb3duID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vdmVMaW5lcyhmaXJzdFJvdywgbGFzdFJvdywgMSk7XG4gICAgfTtcbiAgICB0aGlzLmR1cGxpY2F0ZUxpbmVzID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG1vdmVMaW5lcyhmaXJzdFJvdywgbGFzdFJvdywgMCk7XG4gICAgfTtcblxuXG4gICAgdGhpcy4kY2xpcFJvd1RvRG9jdW1lbnQgPSBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHJvdywgdGhpcy5kb2MuZ2V0TGVuZ3RoKCktMSkpO1xuICAgIH07XG5cbiAgICB0aGlzLiRjbGlwQ29sdW1uVG9Sb3cgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uIDwgMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5kb2MuZ2V0TGluZShyb3cpLmxlbmd0aCwgY29sdW1uKTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgY29sdW1uID0gTWF0aC5tYXgoMCwgY29sdW1uKTtcblxuICAgICAgICBpZiAocm93IDwgMCkge1xuICAgICAgICAgICAgcm93ID0gMDtcbiAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAocm93ID49IGxlbikge1xuICAgICAgICAgICAgICAgIHJvdyA9IGxlbiAtIDE7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gdGhpcy5kb2MuZ2V0TGluZShsZW4tMSkubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLm1pbih0aGlzLmRvYy5nZXRMaW5lKHJvdykubGVuZ3RoLCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy4kY2xpcFJhbmdlVG9Eb2N1bWVudCA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPCAwKSB7XG4gICAgICAgICAgICByYW5nZS5zdGFydC5yb3cgPSAwO1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHRoaXMuJGNsaXBDb2x1bW5Ub1JvdyhcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5yb3csXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuZG9jLmdldExlbmd0aCgpIC0gMTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZC5yb3cgPiBsZW4pIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBsZW47XG4gICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gdGhpcy5kb2MuZ2V0TGluZShsZW4pLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSB0aGlzLiRjbGlwQ29sdW1uVG9Sb3coXG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyxcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIHRoaXMuJHdyYXBMaW1pdCA9IDgwO1xuICAgIHRoaXMuJHVzZVdyYXBNb2RlID0gZmFsc2U7XG4gICAgdGhpcy4kd3JhcExpbWl0UmFuZ2UgPSB7XG4gICAgICAgIG1pbiA6IG51bGwsXG4gICAgICAgIG1heCA6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUgPSBmdW5jdGlvbih1c2VXcmFwTW9kZSkge1xuICAgICAgICBpZiAodXNlV3JhcE1vZGUgIT0gdGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuJHVzZVdyYXBNb2RlID0gdXNlV3JhcE1vZGU7XG4gICAgICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiRyZXNldFJvd0NhY2hlKDApO1xuICAgICAgICAgICAgaWYgKHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kd3JhcERhdGEgPSBBcnJheShsZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVdyYXBEYXRhKDAsIGxlbiAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VXcmFwTW9kZVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRVc2VXcmFwTW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdXNlV3JhcE1vZGU7XG4gICAgfTtcbiAgICB0aGlzLnNldFdyYXBMaW1pdFJhbmdlID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgICAgaWYgKHRoaXMuJHdyYXBMaW1pdFJhbmdlLm1pbiAhPT0gbWluIHx8IHRoaXMuJHdyYXBMaW1pdFJhbmdlLm1heCAhPT0gbWF4KSB7XG4gICAgICAgICAgICB0aGlzLiR3cmFwTGltaXRSYW5nZSA9IHsgbWluOiBtaW4sIG1heDogbWF4IH07XG4gICAgICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlV3JhcE1vZGVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRqdXN0V3JhcExpbWl0ID0gZnVuY3Rpb24oZGVzaXJlZExpbWl0LCAkcHJpbnRNYXJnaW4pIHtcbiAgICAgICAgdmFyIGxpbWl0cyA9IHRoaXMuJHdyYXBMaW1pdFJhbmdlO1xuICAgICAgICBpZiAobGltaXRzLm1heCA8IDApXG4gICAgICAgICAgICBsaW1pdHMgPSB7bWluOiAkcHJpbnRNYXJnaW4sIG1heDogJHByaW50TWFyZ2lufTtcbiAgICAgICAgdmFyIHdyYXBMaW1pdCA9IHRoaXMuJGNvbnN0cmFpbldyYXBMaW1pdChkZXNpcmVkTGltaXQsIGxpbWl0cy5taW4sIGxpbWl0cy5tYXgpO1xuICAgICAgICBpZiAod3JhcExpbWl0ICE9IHRoaXMuJHdyYXBMaW1pdCAmJiB3cmFwTGltaXQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLiR3cmFwTGltaXQgPSB3cmFwTGltaXQ7XG4gICAgICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YSgwLCB0aGlzLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VXcmFwTGltaXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuJGNvbnN0cmFpbldyYXBMaW1pdCA9IGZ1bmN0aW9uKHdyYXBMaW1pdCwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKG1pbilcbiAgICAgICAgICAgIHdyYXBMaW1pdCA9IE1hdGgubWF4KG1pbiwgd3JhcExpbWl0KTtcblxuICAgICAgICBpZiAobWF4KVxuICAgICAgICAgICAgd3JhcExpbWl0ID0gTWF0aC5taW4obWF4LCB3cmFwTGltaXQpO1xuXG4gICAgICAgIHJldHVybiB3cmFwTGltaXQ7XG4gICAgfTtcbiAgICB0aGlzLmdldFdyYXBMaW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kd3JhcExpbWl0O1xuICAgIH07XG4gICAgdGhpcy5zZXRXcmFwTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcbiAgICAgICAgdGhpcy5zZXRXcmFwTGltaXRSYW5nZShsaW1pdCwgbGltaXQpO1xuICAgIH07XG4gICAgdGhpcy5nZXRXcmFwTGltaXRSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluIDogdGhpcy4kd3JhcExpbWl0UmFuZ2UubWluLFxuICAgICAgICAgICAgbWF4IDogdGhpcy4kd3JhcExpbWl0UmFuZ2UubWF4XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHRoaXMuJHVwZGF0ZUludGVybmFsRGF0YU9uQ2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgdXNlV3JhcE1vZGUgPSB0aGlzLiR1c2VXcmFwTW9kZTtcbiAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IGUuZGF0YS5hY3Rpb247XG4gICAgICAgIHZhciBmaXJzdFJvdyA9IGUuZGF0YS5yYW5nZS5zdGFydC5yb3c7XG4gICAgICAgIHZhciBsYXN0Um93ID0gZS5kYXRhLnJhbmdlLmVuZC5yb3c7XG4gICAgICAgIHZhciBzdGFydCA9IGUuZGF0YS5yYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IGUuZGF0YS5yYW5nZS5lbmQ7XG4gICAgICAgIHZhciByZW1vdmVkRm9sZHMgPSBudWxsO1xuXG4gICAgICAgIGlmIChhY3Rpb24uaW5kZXhPZihcIkxpbmVzXCIpICE9IC0xKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IFwiaW5zZXJ0TGluZXNcIikge1xuICAgICAgICAgICAgICAgIGxhc3RSb3cgPSBmaXJzdFJvdyArIChlLmRhdGEubGluZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdFJvdyA9IGZpcnN0Um93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuID0gZS5kYXRhLmxpbmVzID8gZS5kYXRhLmxpbmVzLmxlbmd0aCA6IGxhc3RSb3cgLSBmaXJzdFJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbiA9IGxhc3RSb3cgLSBmaXJzdFJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbiAhPSAwKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmluZGV4T2YoXCJyZW1vdmVcIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3VzZVdyYXBNb2RlID8gXCIkd3JhcERhdGFcIiA6IFwiJHJvd0xlbmd0aENhY2hlXCJdLnNwbGljZShmaXJzdFJvdywgbGVuKTtcblxuICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgICAgICAgICByZW1vdmVkRm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShlLmRhdGEucmFuZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZHMocmVtb3ZlZEZvbGRzKTtcblxuICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZW5kLnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZFJlbW92ZUNoYXJzKGVuZC5yb3csIGVuZC5jb2x1bW4sIHN0YXJ0LmNvbHVtbiAtIGVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdygtbGVuKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmVCZWZvcmUgPSB0aGlzLmdldEZvbGRMaW5lKGZpcnN0Um93KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lQmVmb3JlICYmIGZvbGRMaW5lQmVmb3JlICE9PSBmb2xkTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmVCZWZvcmUubWVyZ2UoZm9sZExpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSBmb2xkTGluZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZHggPSBmb2xkTGluZXMuaW5kZXhPZihmb2xkTGluZSkgKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaWR4OyBpZHggPCBmb2xkTGluZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkTGluZXNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lLnN0YXJ0LnJvdyA+PSBlbmQucm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdygtbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxhc3RSb3cgPSBmaXJzdFJvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW4pO1xuICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChmaXJzdFJvdywgMCk7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IHVzZVdyYXBNb2RlID8gdGhpcy4kd3JhcERhdGEgOiB0aGlzLiRyb3dMZW5ndGhDYWNoZVxuICAgICAgICAgICAgICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmVzID0gdGhpcy4kZm9sZERhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShmaXJzdFJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbXAgPSBmb2xkTGluZS5yYW5nZS5jb21wYXJlSW5zaWRlKHN0YXJ0LnJvdywgc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZSA9IGZvbGRMaW5lLnNwbGl0KHN0YXJ0LnJvdywgc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLnNoaWZ0Um93KGxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUuYWRkUmVtb3ZlQ2hhcnMobGFzdFJvdywgMCwgZW5kLmNvbHVtbiAtIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRSZW1vdmVDaGFycyhmaXJzdFJvdywgMCwgZW5kLmNvbHVtbiAtIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdyhsZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGZvbGRMaW5lcy5pbmRleE9mKGZvbGRMaW5lKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpZHg7IGlkeCA8IGZvbGRMaW5lcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IGZvbGRMaW5lc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUuc3RhcnQucm93ID49IGZpcnN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdyhsZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuID0gTWF0aC5hYnMoZS5kYXRhLnJhbmdlLnN0YXJ0LmNvbHVtbiAtIGUuZGF0YS5yYW5nZS5lbmQuY29sdW1uKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uaW5kZXhPZihcInJlbW92ZVwiKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRGb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlKGUuZGF0YS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkcyhyZW1vdmVkRm9sZHMpO1xuXG4gICAgICAgICAgICAgICAgbGVuID0gLWxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZmlyc3RSb3cpO1xuICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICAgICAgZm9sZExpbmUuYWRkUmVtb3ZlQ2hhcnMoZmlyc3RSb3csIHN0YXJ0LmNvbHVtbiwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VXcmFwTW9kZSAmJiB0aGlzLiR3cmFwRGF0YS5sZW5ndGggIT0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkb2MuZ2V0TGVuZ3RoKCkgYW5kICR3cmFwRGF0YS5sZW5ndGggaGF2ZSB0byBiZSB0aGUgc2FtZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodXNlV3JhcE1vZGUpXG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YShmaXJzdFJvdywgbGFzdFJvdyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd0xlbmd0aENhY2hlKGZpcnN0Um93LCBsYXN0Um93KTtcblxuICAgICAgICByZXR1cm4gcmVtb3ZlZEZvbGRzO1xuICAgIH07XG5cbiAgICB0aGlzLiR1cGRhdGVSb3dMZW5ndGhDYWNoZSA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93LCBiKSB7XG4gICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlW2ZpcnN0Um93XSA9IG51bGw7XG4gICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlW2xhc3RSb3ddID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy4kdXBkYXRlV3JhcERhdGEgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xuICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmRvYy5nZXRBbGxMaW5lcygpO1xuICAgICAgICB2YXIgdGFiU2l6ZSA9IHRoaXMuZ2V0VGFiU2l6ZSgpO1xuICAgICAgICB2YXIgd3JhcERhdGEgPSB0aGlzLiR3cmFwRGF0YTtcbiAgICAgICAgdmFyIHdyYXBMaW1pdCA9IHRoaXMuJHdyYXBMaW1pdDtcbiAgICAgICAgdmFyIHRva2VucztcbiAgICAgICAgdmFyIGZvbGRMaW5lO1xuXG4gICAgICAgIHZhciByb3cgPSBmaXJzdFJvdztcbiAgICAgICAgbGFzdFJvdyA9IE1hdGgubWluKGxhc3RSb3csIGxpbmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICB3aGlsZSAocm93IDw9IGxhc3RSb3cpIHtcbiAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3csIGZvbGRMaW5lKTtcbiAgICAgICAgICAgIGlmICghZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSB0aGlzLiRnZXREaXNwbGF5VG9rZW5zKGxpbmVzW3Jvd10pO1xuICAgICAgICAgICAgICAgIHdyYXBEYXRhW3Jvd10gPSB0aGlzLiRjb21wdXRlV3JhcFNwbGl0cyh0b2tlbnMsIHdyYXBMaW1pdCwgdGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcm93ICsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb2xkTGluZS53YWxrKGZ1bmN0aW9uKHBsYWNlaG9sZGVyLCByb3csIGNvbHVtbiwgbGFzdENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtUb2tlbnMgPSB0aGlzLiRnZXREaXNwbGF5VG9rZW5zKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciwgdG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa1Rva2Vuc1swXSA9IFBMQUNFSE9MREVSX1NUQVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgd2Fsa1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrVG9rZW5zW2ldID0gUExBQ0VIT0xERVJfQk9EWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtUb2tlbnMgPSB0aGlzLiRnZXREaXNwbGF5VG9rZW5zKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tyb3ddLnN1YnN0cmluZyhsYXN0Q29sdW1uLCBjb2x1bW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQod2Fsa1Rva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUuZW5kLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbZm9sZExpbmUuZW5kLnJvd10ubGVuZ3RoICsgMVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB3cmFwRGF0YVtmb2xkTGluZS5zdGFydC5yb3ddID0gdGhpcy4kY29tcHV0ZVdyYXBTcGxpdHModG9rZW5zLCB3cmFwTGltaXQsIHRhYlNpemUpO1xuICAgICAgICAgICAgICAgIHJvdyA9IGZvbGRMaW5lLmVuZC5yb3cgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgQ0hBUiA9IDEsXG4gICAgICAgIENIQVJfRVhUID0gMixcbiAgICAgICAgUExBQ0VIT0xERVJfU1RBUlQgPSAzLFxuICAgICAgICBQTEFDRUhPTERFUl9CT0RZID0gIDQsXG4gICAgICAgIFBVTkNUVUFUSU9OID0gOSxcbiAgICAgICAgU1BBQ0UgPSAxMCxcbiAgICAgICAgVEFCID0gMTEsXG4gICAgICAgIFRBQl9TUEFDRSA9IDEyO1xuXG5cbiAgICB0aGlzLiRjb21wdXRlV3JhcFNwbGl0cyA9IGZ1bmN0aW9uKHRva2Vucywgd3JhcExpbWl0KSB7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGxpdHMgPSBbXTtcbiAgICAgICAgdmFyIGRpc3BsYXlMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdFNwbGl0ID0gMCwgbGFzdERvY1NwbGl0ID0gMDtcblxuICAgICAgICB2YXIgaXNDb2RlID0gdGhpcy4kd3JhcEFzQ29kZTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRTcGxpdChzY3JlZW5Qb3MpIHtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5ZWQgPSB0b2tlbnMuc2xpY2UobGFzdFNwbGl0LCBzY3JlZW5Qb3MpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRpc3BsYXllZC5sZW5ndGg7XG4gICAgICAgICAgICBkaXNwbGF5ZWQuam9pbihcIlwiKS5cbiAgICAgICAgICAgICAgICByZXBsYWNlKC8xMi9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgICAgICAgfSkuXG4gICAgICAgICAgICAgICAgcmVwbGFjZSgvMi9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxhc3REb2NTcGxpdCArPSBsZW47XG4gICAgICAgICAgICBzcGxpdHMucHVzaChsYXN0RG9jU3BsaXQpO1xuICAgICAgICAgICAgbGFzdFNwbGl0ID0gc2NyZWVuUG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGRpc3BsYXlMZW5ndGggLSBsYXN0U3BsaXQgPiB3cmFwTGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IGxhc3RTcGxpdCArIHdyYXBMaW1pdDtcbiAgICAgICAgICAgIGlmICh0b2tlbnNbc3BsaXQgLSAxXSA+PSBTUEFDRSAmJiB0b2tlbnNbc3BsaXRdID49IFNQQUNFKSB7XG4gICAgICAgICAgICAgICAgYWRkU3BsaXQoc3BsaXQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2Vuc1tzcGxpdF0gPT0gUExBQ0VIT0xERVJfU1RBUlQgfHwgdG9rZW5zW3NwbGl0XSA9PSBQTEFDRUhPTERFUl9CT0RZKSB7XG4gICAgICAgICAgICAgICAgZm9yIChzcGxpdDsgc3BsaXQgIT0gbGFzdFNwbGl0IC0gMTsgc3BsaXQtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSA9PSBQTEFDRUhPTERFUl9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0ID4gbGFzdFNwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNwbGl0KHNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwbGl0ID0gbGFzdFNwbGl0ICsgd3JhcExpbWl0O1xuICAgICAgICAgICAgICAgIGZvciAoc3BsaXQ7IHNwbGl0IDwgdG9rZW5zLmxlbmd0aDsgc3BsaXQrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSAhPSBQTEFDRUhPTERFUl9CT0RZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQgPT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgIC8vIEJyZWFrcyB0aGUgd2hpbGUtbG9vcC5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkU3BsaXQoc3BsaXQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pblNwbGl0ID0gTWF0aC5tYXgoc3BsaXQgLSAoaXNDb2RlID8gMTAgOiB3cmFwTGltaXQtKHdyYXBMaW1pdD4+MikpLCBsYXN0U3BsaXQgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPCBQTEFDRUhPTERFUl9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHNwbGl0IC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ29kZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPCBQTEFDRUhPTERFUl9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCAtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwbGl0ID4gbWluU3BsaXQgJiYgdG9rZW5zW3NwbGl0XSA9PSBQVU5DVFVBVElPTikge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCAtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPCBTUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCAtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXQgPiBtaW5TcGxpdCkge1xuICAgICAgICAgICAgICAgIGFkZFNwbGl0KCsrc3BsaXQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3BsaXQgPSBsYXN0U3BsaXQgKyB3cmFwTGltaXQ7XG4gICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSA9PSBDSEFSX0VYVClcbiAgICAgICAgICAgICAgICBzcGxpdC0tO1xuICAgICAgICAgICAgYWRkU3BsaXQoc3BsaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdHM7XG4gICAgfTtcbiAgICB0aGlzLiRnZXREaXNwbGF5VG9rZW5zID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICB2YXIgdGFiU2l6ZTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PSA5KSB7XG4gICAgICAgICAgICAgICAgdGFiU2l6ZSA9IHRoaXMuZ2V0U2NyZWVuVGFiU2l6ZShhcnIubGVuZ3RoICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChUQUIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgdGFiU2l6ZTsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKFRBQl9TUEFDRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSAzMikge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKFNQQUNFKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZigoYyA+IDM5ICYmIGMgPCA0OCkgfHwgKGMgPiA1NyAmJiBjIDwgNjQpKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goUFVOQ1RVQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA+PSAweDExMDAgJiYgaXNGdWxsV2lkdGgoYykpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChDSEFSLCBDSEFSX0VYVCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKENIQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgICB0aGlzLiRnZXRTdHJpbmdTY3JlZW5XaWR0aCA9IGZ1bmN0aW9uKHN0ciwgbWF4U2NyZWVuQ29sdW1uLCBzY3JlZW5Db2x1bW4pIHtcbiAgICAgICAgaWYgKG1heFNjcmVlbkNvbHVtbiA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgaWYgKG1heFNjcmVlbkNvbHVtbiA9PSBudWxsKVxuICAgICAgICAgICAgbWF4U2NyZWVuQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICAgIHNjcmVlbkNvbHVtbiA9IHNjcmVlbkNvbHVtbiB8fCAwO1xuXG4gICAgICAgIHZhciBjLCBjb2x1bW47XG4gICAgICAgIGZvciAoY29sdW1uID0gMDsgY29sdW1uIDwgc3RyLmxlbmd0aDsgY29sdW1uKyspIHtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChjb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGMgPT0gOSkge1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSB0aGlzLmdldFNjcmVlblRhYlNpemUoc2NyZWVuQ29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPj0gMHgxMTAwICYmIGlzRnVsbFdpZHRoKGMpKSB7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjcmVlbkNvbHVtbiA+IG1heFNjcmVlbkNvbHVtbikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtzY3JlZW5Db2x1bW4sIGNvbHVtbl07XG4gICAgfTtcblxuICAgIHRoaXMubGluZVdpZGdldHMgPSBudWxsO1xuICAgIHRoaXMuZ2V0Um93TGVuZ3RoID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXaWRnZXRzKVxuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmxpbmVXaWRnZXRzW3Jvd10gJiYgdGhpcy5saW5lV2lkZ2V0c1tyb3ddLnJvd0NvdW50IHx8IDA7XG4gICAgICAgIGVsc2UgXG4gICAgICAgICAgICBoID0gMFxuICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlIHx8ICF0aGlzLiR3cmFwRGF0YVtyb3ddKSB7XG4gICAgICAgICAgICByZXR1cm4gMSArIGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kd3JhcERhdGFbcm93XS5sZW5ndGggKyAxICsgaDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRSb3dMaW5lQ291bnQgPSBmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR1c2VXcmFwTW9kZSB8fCAhdGhpcy4kd3JhcERhdGFbcm93XSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kd3JhcERhdGFbcm93XS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcmVlbkxhc3RSb3dDb2x1bW4gPSBmdW5jdGlvbihzY3JlZW5Sb3cpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VG9TY3JlZW5Db2x1bW4ocG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgfTtcbiAgICB0aGlzLmdldERvY3VtZW50TGFzdFJvd0NvbHVtbiA9IGZ1bmN0aW9uKGRvY1JvdywgZG9jQ29sdW1uKSB7XG4gICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLmRvY3VtZW50VG9TY3JlZW5Sb3coZG9jUm93LCBkb2NDb2x1bW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JlZW5MYXN0Um93Q29sdW1uKHNjcmVlblJvdyk7XG4gICAgfTtcbiAgICB0aGlzLmdldERvY3VtZW50TGFzdFJvd0NvbHVtblBvc2l0aW9uID0gZnVuY3Rpb24oZG9jUm93LCBkb2NDb2x1bW4pIHtcbiAgICAgICAgdmFyIHNjcmVlblJvdyA9IHRoaXMuZG9jdW1lbnRUb1NjcmVlblJvdyhkb2NSb3csIGRvY0NvbHVtbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Sb3csIE51bWJlci5NQVhfVkFMVUUgLyAxMCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFJvd1NwbGl0RGF0YSA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHdyYXBEYXRhW3Jvd107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0U2NyZWVuVGFiU2l6ZSA9IGZ1bmN0aW9uKHNjcmVlbkNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGFiU2l6ZSAtIHNjcmVlbkNvbHVtbiAlIHRoaXMuJHRhYlNpemU7XG4gICAgfTtcblxuXG4gICAgdGhpcy5zY3JlZW5Ub0RvY3VtZW50Um93ID0gZnVuY3Rpb24oc2NyZWVuUm93LCBzY3JlZW5Db2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKS5yb3c7XG4gICAgfTtcblxuXG4gICAgdGhpcy5zY3JlZW5Ub0RvY3VtZW50Q29sdW1uID0gZnVuY3Rpb24oc2NyZWVuUm93LCBzY3JlZW5Db2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKS5jb2x1bW47XG4gICAgfTtcbiAgICB0aGlzLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKSB7XG4gICAgICAgIGlmIChzY3JlZW5Sb3cgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHtyb3c6IDAsIGNvbHVtbjogMH07XG5cbiAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgIHZhciBkb2NSb3cgPSAwO1xuICAgICAgICB2YXIgZG9jQ29sdW1uID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbjtcbiAgICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICAgIHZhciByb3dMZW5ndGggPSAwO1xuXG4gICAgICAgIHZhciByb3dDYWNoZSA9IHRoaXMuJHNjcmVlblJvd0NhY2hlO1xuICAgICAgICB2YXIgaSA9IHRoaXMuJGdldFJvd0NhY2hlSW5kZXgocm93Q2FjaGUsIHNjcmVlblJvdyk7XG4gICAgICAgIHZhciBsID0gcm93Q2FjaGUubGVuZ3RoO1xuICAgICAgICBpZiAobCAmJiBpID49IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSByb3dDYWNoZVtpXTtcbiAgICAgICAgICAgIHZhciBkb2NSb3cgPSB0aGlzLiRkb2NSb3dDYWNoZVtpXTtcbiAgICAgICAgICAgIHZhciBkb0NhY2hlID0gc2NyZWVuUm93ID4gcm93Q2FjaGVbbCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRvQ2FjaGUgPSAhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXhSb3cgPSB0aGlzLmdldExlbmd0aCgpIC0gMTtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXROZXh0Rm9sZExpbmUoZG9jUm93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG5cbiAgICAgICAgd2hpbGUgKHJvdyA8PSBzY3JlZW5Sb3cpIHtcbiAgICAgICAgICAgIHJvd0xlbmd0aCA9IHRoaXMuZ2V0Um93TGVuZ3RoKGRvY1Jvdyk7XG4gICAgICAgICAgICBpZiAocm93ICsgcm93TGVuZ3RoID4gc2NyZWVuUm93IHx8IGRvY1JvdyA+PSBtYXhSb3cpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93ICs9IHJvd0xlbmd0aDtcbiAgICAgICAgICAgICAgICBkb2NSb3crKztcbiAgICAgICAgICAgICAgICBpZiAoZG9jUm93ID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY1JvdyA9IGZvbGRMaW5lLmVuZC5yb3crMTtcbiAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLmdldE5leHRGb2xkTGluZShkb2NSb3csIGZvbGRMaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUucHVzaChkb2NSb3cpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjcmVlblJvd0NhY2hlLnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2xkTGluZSAmJiBmb2xkTGluZS5zdGFydC5yb3cgPD0gZG9jUm93KSB7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5nZXRGb2xkRGlzcGxheUxpbmUoZm9sZExpbmUpO1xuICAgICAgICAgICAgZG9jUm93ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICB9IGVsc2UgaWYgKHJvdyArIHJvd0xlbmd0aCA8PSBzY3JlZW5Sb3cgfHwgZG9jUm93ID4gbWF4Um93KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvdzogbWF4Um93LFxuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5nZXRMaW5lKG1heFJvdykubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuZ2V0TGluZShkb2NSb3cpO1xuICAgICAgICAgICAgZm9sZExpbmUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXRzID0gdGhpcy4kd3JhcERhdGFbZG9jUm93XTtcbiAgICAgICAgICAgIGlmIChzcGxpdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3Ioc2NyZWVuUm93IC0gcm93KTtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBzcGxpdHNbc3BsaXRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYoc3BsaXRJbmRleCA+IDAgJiYgc3BsaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb2NDb2x1bW4gPSBzcGxpdHNbc3BsaXRJbmRleCAtIDFdIHx8IHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZyhkb2NDb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRvY0NvbHVtbiArPSB0aGlzLiRnZXRTdHJpbmdTY3JlZW5XaWR0aChsaW5lLCBzY3JlZW5Db2x1bW4pWzFdO1xuICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUgJiYgZG9jQ29sdW1uID49IGNvbHVtbilcbiAgICAgICAgICAgIGRvY0NvbHVtbiA9IGNvbHVtbiAtIDE7XG5cbiAgICAgICAgaWYgKGZvbGRMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIGZvbGRMaW5lLmlkeFRvUG9zaXRpb24oZG9jQ29sdW1uKTtcblxuICAgICAgICByZXR1cm4ge3JvdzogZG9jUm93LCBjb2x1bW46IGRvY0NvbHVtbn07XG4gICAgfTtcbiAgICB0aGlzLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbiA9IGZ1bmN0aW9uKGRvY1JvdywgZG9jQ29sdW1uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jQ29sdW1uID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQoZG9jUm93LnJvdywgZG9jUm93LmNvbHVtbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQoZG9jUm93LCBkb2NDb2x1bW4pO1xuXG4gICAgICAgIGRvY1JvdyA9IHBvcy5yb3c7XG4gICAgICAgIGRvY0NvbHVtbiA9IHBvcy5jb2x1bW47XG5cbiAgICAgICAgdmFyIHNjcmVlblJvdyA9IDA7XG4gICAgICAgIHZhciBmb2xkU3RhcnRSb3cgPSBudWxsO1xuICAgICAgICB2YXIgZm9sZCA9IG51bGw7XG4gICAgICAgIGZvbGQgPSB0aGlzLmdldEZvbGRBdChkb2NSb3csIGRvY0NvbHVtbiwgMSk7XG4gICAgICAgIGlmIChmb2xkKSB7XG4gICAgICAgICAgICBkb2NSb3cgPSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIGRvY0NvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvd0VuZCwgcm93ID0gMDtcblxuXG4gICAgICAgIHZhciByb3dDYWNoZSA9IHRoaXMuJGRvY1Jvd0NhY2hlO1xuICAgICAgICB2YXIgaSA9IHRoaXMuJGdldFJvd0NhY2hlSW5kZXgocm93Q2FjaGUsIGRvY1Jvdyk7XG4gICAgICAgIHZhciBsID0gcm93Q2FjaGUubGVuZ3RoO1xuICAgICAgICBpZiAobCAmJiBpID49IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSByb3dDYWNoZVtpXTtcbiAgICAgICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLiRzY3JlZW5Sb3dDYWNoZVtpXTtcbiAgICAgICAgICAgIHZhciBkb0NhY2hlID0gZG9jUm93ID4gcm93Q2FjaGVbbCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRvQ2FjaGUgPSAhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0TmV4dEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/Zm9sZExpbmUuc3RhcnQucm93IDpJbmZpbml0eTtcblxuICAgICAgICB3aGlsZSAocm93IDwgZG9jUm93KSB7XG4gICAgICAgICAgICBpZiAocm93ID49IGZvbGRTdGFydCkge1xuICAgICAgICAgICAgICAgIHJvd0VuZCA9IGZvbGRMaW5lLmVuZC5yb3cgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChyb3dFbmQgPiBkb2NSb3cpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5nZXROZXh0Rm9sZExpbmUocm93RW5kLCBmb2xkTGluZSk7XG4gICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgP2ZvbGRMaW5lLnN0YXJ0LnJvdyA6SW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3dFbmQgPSByb3cgKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY3JlZW5Sb3cgKz0gdGhpcy5nZXRSb3dMZW5ndGgocm93KTtcbiAgICAgICAgICAgIHJvdyA9IHJvd0VuZDtcblxuICAgICAgICAgICAgaWYgKGRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkb2NSb3dDYWNoZS5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kc2NyZWVuUm93Q2FjaGUucHVzaChzY3JlZW5Sb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0TGluZSA9IFwiXCI7XG4gICAgICAgIGlmIChmb2xkTGluZSAmJiByb3cgPj0gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICB0ZXh0TGluZSA9IHRoaXMuZ2V0Rm9sZERpc3BsYXlMaW5lKGZvbGRMaW5lLCBkb2NSb3csIGRvY0NvbHVtbik7XG4gICAgICAgICAgICBmb2xkU3RhcnRSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0TGluZSA9IHRoaXMuZ2V0TGluZShkb2NSb3cpLnN1YnN0cmluZygwLCBkb2NDb2x1bW4pO1xuICAgICAgICAgICAgZm9sZFN0YXJ0Um93ID0gZG9jUm93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSkge1xuICAgICAgICAgICAgdmFyIHdyYXBSb3cgPSB0aGlzLiR3cmFwRGF0YVtmb2xkU3RhcnRSb3ddO1xuICAgICAgICAgICAgaWYgKHdyYXBSb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NyZWVuUm93T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGV4dExpbmUubGVuZ3RoID49IHdyYXBSb3dbc2NyZWVuUm93T2Zmc2V0XSkge1xuICAgICAgICAgICAgICAgICAgICBzY3JlZW5Sb3cgKys7XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblJvd09mZnNldCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0TGluZSA9IHRleHRMaW5lLnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgd3JhcFJvd1tzY3JlZW5Sb3dPZmZzZXQgLSAxXSB8fCAwLCB0ZXh0TGluZS5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogc2NyZWVuUm93LFxuICAgICAgICAgICAgY29sdW1uOiB0aGlzLiRnZXRTdHJpbmdTY3JlZW5XaWR0aCh0ZXh0TGluZSlbMF1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMuZG9jdW1lbnRUb1NjcmVlbkNvbHVtbiA9IGZ1bmN0aW9uKHJvdywgZG9jQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihyb3csIGRvY0NvbHVtbikuY29sdW1uO1xuICAgIH07XG4gICAgdGhpcy5kb2N1bWVudFRvU2NyZWVuUm93ID0gZnVuY3Rpb24oZG9jUm93LCBkb2NDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKGRvY1JvdywgZG9jQ29sdW1uKS5yb3c7XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcmVlbkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NyZWVuUm93cyA9IDA7XG4gICAgICAgIHZhciBmb2xkID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLiR1c2VXcmFwTW9kZSkge1xuICAgICAgICAgICAgc2NyZWVuUm93cyA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgZm9sZERhdGEgPSB0aGlzLiRmb2xkRGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb2xkID0gZm9sZERhdGFbaV07XG4gICAgICAgICAgICAgICAgc2NyZWVuUm93cyAtPSBmb2xkLmVuZC5yb3cgLSBmb2xkLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsYXN0Um93ID0gdGhpcy4kd3JhcERhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJvdyA9IDAsIGkgPSAwO1xuICAgICAgICAgICAgdmFyIGZvbGQgPSB0aGlzLiRmb2xkRGF0YVtpKytdO1xuICAgICAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGQgPyBmb2xkLnN0YXJ0LnJvdyA6SW5maW5pdHk7XG5cbiAgICAgICAgICAgIHdoaWxlIChyb3cgPCBsYXN0Um93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0cyA9IHRoaXMuJHdyYXBEYXRhW3Jvd107XG4gICAgICAgICAgICAgICAgc2NyZWVuUm93cyArPSBzcGxpdHMgPyBzcGxpdHMubGVuZ3RoICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgcm93ICsrO1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPiBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gZm9sZC5lbmQucm93KzE7XG4gICAgICAgICAgICAgICAgICAgIGZvbGQgPSB0aGlzLiRmb2xkRGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkID9mb2xkLnN0YXJ0LnJvdyA6SW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVXaWRnZXRzKVxuICAgICAgICAgICAgc2NyZWVuUm93cyArPSB0aGlzLiRnZXRXaWRnZXRTY3JlZW5MZW5ndGgoKTtcblxuICAgICAgICByZXR1cm4gc2NyZWVuUm93cztcbiAgICB9O1xuICAgIHRoaXMuJHNldEZvbnRNZXRyaWNzID0gZnVuY3Rpb24oZm0pIHtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5iZ1Rva2VuaXplcikge1xuICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5zZXREb2N1bWVudChudWxsKTtcbiAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHN0b3BXb3JrZXIoKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzRnVsbFdpZHRoKGMpIHtcbiAgICAgICAgaWYgKGMgPCAweDExMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjID49IDB4MTEwMCAmJiBjIDw9IDB4MTE1RiB8fFxuICAgICAgICAgICAgICAgYyA+PSAweDExQTMgJiYgYyA8PSAweDExQTcgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHgxMUZBICYmIGMgPD0gMHgxMUZGIHx8XG4gICAgICAgICAgICAgICBjID49IDB4MjMyOSAmJiBjIDw9IDB4MjMyQSB8fFxuICAgICAgICAgICAgICAgYyA+PSAweDJFODAgJiYgYyA8PSAweDJFOTkgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHgyRTlCICYmIGMgPD0gMHgyRUYzIHx8XG4gICAgICAgICAgICAgICBjID49IDB4MkYwMCAmJiBjIDw9IDB4MkZENSB8fFxuICAgICAgICAgICAgICAgYyA+PSAweDJGRjAgJiYgYyA8PSAweDJGRkIgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHgzMDAwICYmIGMgPD0gMHgzMDNFIHx8XG4gICAgICAgICAgICAgICBjID49IDB4MzA0MSAmJiBjIDw9IDB4MzA5NiB8fFxuICAgICAgICAgICAgICAgYyA+PSAweDMwOTkgJiYgYyA8PSAweDMwRkYgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHgzMTA1ICYmIGMgPD0gMHgzMTJEIHx8XG4gICAgICAgICAgICAgICBjID49IDB4MzEzMSAmJiBjIDw9IDB4MzE4RSB8fFxuICAgICAgICAgICAgICAgYyA+PSAweDMxOTAgJiYgYyA8PSAweDMxQkEgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHgzMUMwICYmIGMgPD0gMHgzMUUzIHx8XG4gICAgICAgICAgICAgICBjID49IDB4MzFGMCAmJiBjIDw9IDB4MzIxRSB8fFxuICAgICAgICAgICAgICAgYyA+PSAweDMyMjAgJiYgYyA8PSAweDMyNDcgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHgzMjUwICYmIGMgPD0gMHgzMkZFIHx8XG4gICAgICAgICAgICAgICBjID49IDB4MzMwMCAmJiBjIDw9IDB4NERCRiB8fFxuICAgICAgICAgICAgICAgYyA+PSAweDRFMDAgJiYgYyA8PSAweEE0OEMgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHhBNDkwICYmIGMgPD0gMHhBNEM2IHx8XG4gICAgICAgICAgICAgICBjID49IDB4QTk2MCAmJiBjIDw9IDB4QTk3QyB8fFxuICAgICAgICAgICAgICAgYyA+PSAweEFDMDAgJiYgYyA8PSAweEQ3QTMgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHhEN0IwICYmIGMgPD0gMHhEN0M2IHx8XG4gICAgICAgICAgICAgICBjID49IDB4RDdDQiAmJiBjIDw9IDB4RDdGQiB8fFxuICAgICAgICAgICAgICAgYyA+PSAweEY5MDAgJiYgYyA8PSAweEZBRkYgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHhGRTEwICYmIGMgPD0gMHhGRTE5IHx8XG4gICAgICAgICAgICAgICBjID49IDB4RkUzMCAmJiBjIDw9IDB4RkU1MiB8fFxuICAgICAgICAgICAgICAgYyA+PSAweEZFNTQgJiYgYyA8PSAweEZFNjYgfHxcbiAgICAgICAgICAgICAgIGMgPj0gMHhGRTY4ICYmIGMgPD0gMHhGRTZCIHx8XG4gICAgICAgICAgICAgICBjID49IDB4RkYwMSAmJiBjIDw9IDB4RkY2MCB8fFxuICAgICAgICAgICAgICAgYyA+PSAweEZGRTAgJiYgYyA8PSAweEZGRTY7XG4gICAgfTtcblxufSkuY2FsbChFZGl0U2Vzc2lvbi5wcm90b3R5cGUpO1xuXG5hY2VxdWlyZShcIi4vZWRpdF9zZXNzaW9uL2ZvbGRpbmdcIikuRm9sZGluZy5jYWxsKEVkaXRTZXNzaW9uLnByb3RvdHlwZSk7XG5hY2VxdWlyZShcIi4vZWRpdF9zZXNzaW9uL2JyYWNrZXRfbWF0Y2hcIikuQnJhY2tldE1hdGNoLmNhbGwoRWRpdFNlc3Npb24ucHJvdG90eXBlKTtcblxuXG5jb25maWcuZGVmaW5lT3B0aW9ucyhFZGl0U2Vzc2lvbi5wcm90b3R5cGUsIFwic2Vzc2lvblwiLCB7XG4gICAgd3JhcDoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09IFwib2ZmXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwiZnJlZVwiKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwicHJpbnRNYXJnaW5cIilcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy4kd3JhcCA9PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLiR3cmFwID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVc2VXcmFwTW9kZShmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFdyYXBMaW1pdFJhbmdlKGNvbCwgY29sKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFVzZVdyYXBNb2RlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VXNlV3JhcE1vZGUoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiR3cmFwID09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmludE1hcmdpblwiO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRXcmFwTGltaXRSYW5nZSgpLm1pbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnJlZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiR3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwib2ZmXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9LCAgICBcbiAgICB3cmFwTWV0aG9kOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwgPT0gXCJhdXRvXCJcbiAgICAgICAgICAgICAgICA/IHRoaXMuJG1vZGUudHlwZSAhPSBcInRleHRcIlxuICAgICAgICAgICAgICAgIDogdmFsICE9IFwidGV4dFwiO1xuICAgICAgICAgICAgaWYgKHZhbCAhPSB0aGlzLiR3cmFwQXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kd3JhcEFzQ29kZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRyZXNldFJvd0NhY2hlKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YSgwLCB0aGlzLmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IFwiYXV0b1wiXG4gICAgfSxcbiAgICBmaXJzdExpbmVOdW1iZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbigpIHt0aGlzLl9zaWduYWwoXCJjaGFuZ2VCcmVha3BvaW50XCIpO30sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogMVxuICAgIH0sXG4gICAgdXNlV29ya2VyOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odXNlV29ya2VyKSB7XG4gICAgICAgICAgICB0aGlzLiR1c2VXb3JrZXIgPSB1c2VXb3JrZXI7XG5cbiAgICAgICAgICAgIHRoaXMuJHN0b3BXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmICh1c2VXb3JrZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kc3RhcnRXb3JrZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB1c2VTb2Z0VGFiczoge2luaXRpYWxWYWx1ZTogdHJ1ZX0sXG4gICAgdGFiU2l6ZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRhYlNpemUpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0YWJTaXplKSB8fCB0aGlzLiR0YWJTaXplID09PSB0YWJTaXplKSByZXR1cm47XG5cbiAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlID0gW107XG4gICAgICAgICAgICB0aGlzLiR0YWJTaXplID0gdGFiU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVRhYlNpemVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogNCxcbiAgICAgICAgaGFuZGxlc1NldDogdHJ1ZVxuICAgIH0sXG4gICAgb3ZlcndyaXRlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7dGhpcy5fc2lnbmFsKFwiY2hhbmdlT3ZlcndyaXRlXCIpO30sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIG5ld0xpbmVNb2RlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7dGhpcy5kb2Muc2V0TmV3TGluZU1vZGUodmFsKX0sXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZG9jLmdldE5ld0xpbmVNb2RlKCl9LFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlXG4gICAgfSxcbiAgICBtb2RlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7IHRoaXMuc2V0TW9kZSh2YWwpIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLiRtb2RlSWQgfVxuICAgIH1cbn0pO1xuXG5leHBvcnRzLkVkaXRTZXNzaW9uID0gRWRpdFNlc3Npb247XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9zZWFyY2hcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9yYW5nZVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBsYW5nID0gYWNlcXVpcmUoXCIuL2xpYi9sYW5nXCIpO1xudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xuXG52YXIgU2VhcmNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kb3B0aW9ucyA9IHt9O1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvb3AubWl4aW4odGhpcy4kb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5nZXRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsYW5nLmNvcHlPYmplY3QodGhpcy4kb3B0aW9ucyk7XG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG4gICAgdGhpcy5maW5kID0gZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuJG1hdGNoSXRlcmF0b3Ioc2Vzc2lvbiwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghaXRlcmF0b3IpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGZpcnN0UmFuZ2UgPSBudWxsO1xuICAgICAgICBpdGVyYXRvci5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlLCByb3csIG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5zdGFydCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSByYW5nZS5vZmZzZXQgKyAob2Zmc2V0IHx8IDApO1xuICAgICAgICAgICAgICAgIGZpcnN0UmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBjb2x1bW4sIHJvdywgY29sdW1uICsgcmFuZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlLmxlbmd0aCAmJiBvcHRpb25zLnN0YXJ0ICYmIG9wdGlvbnMuc3RhcnQuc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgJiYgb3B0aW9ucy5za2lwQ3VycmVudCAhPSBmYWxzZSAmJiBmaXJzdFJhbmdlLmlzRXF1YWwob3B0aW9ucy5zdGFydClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBmaXJzdFJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZpcnN0UmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLmZpbmRBbGwgPSBmdW5jdGlvbihzZXNzaW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAgICAgaWYgKCFvcHRpb25zLm5lZWRsZSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdGhpcy4kYXNzZW1ibGVSZWdFeHAob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgdmFyIGxpbmVzID0gcmFuZ2VcbiAgICAgICAgICAgID8gc2Vzc2lvbi5nZXRMaW5lcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cpXG4gICAgICAgICAgICA6IHNlc3Npb24uZG9jLmdldEFsbExpbmVzKCk7XG5cbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgICAgICB2YXIgcmUgPSBvcHRpb25zLnJlO1xuICAgICAgICBpZiAob3B0aW9ucy4kaXNNdWx0aUxpbmUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSByZS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbWF4Um93ID0gbGluZXMubGVuZ3RoIC0gbGVuO1xuICAgICAgICAgICAgdmFyIHByZXZSYW5nZTtcbiAgICAgICAgICAgIG91dGVyOiBmb3IgKHZhciByb3cgPSByZS5vZmZzZXQgfHwgMDsgcm93IDw9IG1heFJvdzsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZXNbcm93ICsgal0uc2VhcmNoKHJlW2pdKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmUgPSBsaW5lc1tyb3ddO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbcm93ICsgbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBzdGFydExpbmUubGVuZ3RoIC0gc3RhcnRMaW5lLm1hdGNoKHJlWzBdKVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gbGluZS5tYXRjaChyZVtsZW4gLSAxXSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChwcmV2UmFuZ2UgJiYgcHJldlJhbmdlLmVuZC5yb3cgPT09IHJvdyAmJlxuICAgICAgICAgICAgICAgICAgICBwcmV2UmFuZ2UuZW5kLmNvbHVtbiA+IHN0YXJ0SW5kZXhcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHByZXZSYW5nZSA9IG5ldyBSYW5nZShcbiAgICAgICAgICAgICAgICAgICAgcm93LCBzdGFydEluZGV4LCByb3cgKyBsZW4gLSAxLCBlbmRJbmRleFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAyKVxuICAgICAgICAgICAgICAgICAgICByb3cgPSByb3cgKyBsZW4gLSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGFuZy5nZXRNYXRjaE9mZnNldHMobGluZXNbaV0sIHJlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGksIG1hdGNoLm9mZnNldCwgaSwgbWF0Y2gub2Zmc2V0ICsgbWF0Y2gubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSByYW5nZS5zdGFydC5jb2x1bW47XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgdmFyIGkgPSAwLCBqID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGogJiYgcmFuZ2VzW2ldLnN0YXJ0LmNvbHVtbiA8IHN0YXJ0Q29sdW1uICYmIHJhbmdlc1tpXS5zdGFydC5yb3cgPT0gcmFuZ2Uuc3RhcnQucm93KVxuICAgICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgd2hpbGUgKGkgPCBqICYmIHJhbmdlc1tqXS5lbmQuY29sdW1uID4gZW5kQ29sdW1uICYmIHJhbmdlc1tqXS5lbmQucm93ID09IHJhbmdlLmVuZC5yb3cpXG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByYW5nZXMgPSByYW5nZXMuc2xpY2UoaSwgaiArIDEpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0uc3RhcnQucm93ICs9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0uZW5kLnJvdyArPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH07XG4gICAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24oaW5wdXQsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcblxuICAgICAgICB2YXIgcmUgPSB0aGlzLiRhc3NlbWJsZVJlZ0V4cChvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlzTXVsdGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuXG4gICAgICAgIGlmICghcmUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhpbnB1dCk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2hbMF0ubGVuZ3RoICE9IGlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBpbnB1dC5yZXBsYWNlKHJlLCByZXBsYWNlbWVudCk7XG4gICAgICAgIGlmIChvcHRpb25zLnByZXNlcnZlQ2FzZSkge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIGlucHV0Lmxlbmd0aCk7IGktLTsgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gaW5wdXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoLnRvTG93ZXJDYXNlKCkgIT0gY2gpXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50W2ldID0gcmVwbGFjZW1lbnRbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50W2ldID0gcmVwbGFjZW1lbnRbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgIH07XG5cbiAgICB0aGlzLiRtYXRjaEl0ZXJhdG9yID0gZnVuY3Rpb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmUgPSB0aGlzLiRhc3NlbWJsZVJlZ0V4cChvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICAgIGlmIChvcHRpb25zLiRpc011bHRpTGluZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHJlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtYXRjaEl0ZXJhdG9yID0gZnVuY3Rpb24obGluZSwgcm93LCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGxpbmUuc2VhcmNoKHJlWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cgKyBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc2VhcmNoKHJlW2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBsaW5lLm1hdGNoKHJlW2xlbiAtIDFdKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBzdGFydEluZGV4LCByb3cgKyBsZW4gLSAxLCBlbmRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlLm9mZnNldCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LnJvdy0tO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gKz0gb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYmFja3dhcmRzKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hJdGVyYXRvciA9IGZ1bmN0aW9uKGxpbmUsIHJvdywgc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGFuZy5nZXRNYXRjaE9mZnNldHMobGluZSwgcmUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaGVzLmxlbmd0aC0xOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG1hdGNoZXNbaV0sIHJvdywgc3RhcnRJbmRleCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hJdGVyYXRvciA9IGZ1bmN0aW9uKGxpbmUsIHJvdywgc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGFuZy5nZXRNYXRjaE9mZnNldHMobGluZSwgcmUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG1hdGNoZXNbaV0sIHJvdywgc3RhcnRJbmRleCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZUl0ZXJhdG9yID0gdGhpcy4kbGluZUl0ZXJhdG9yKHNlc3Npb24sIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbihfY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IF9jYWxsYmFjaztcbiAgICAgICAgICAgICAgICBsaW5lSXRlcmF0b3IuZm9yRWFjaChtYXRjaEl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy4kYXNzZW1ibGVSZWdFeHAgPSBmdW5jdGlvbihvcHRpb25zLCAkZGlzYWJsZUZha2VNdWx0aWxpbmUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubmVlZGxlIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmUgPSBvcHRpb25zLm5lZWRsZTtcblxuICAgICAgICB2YXIgbmVlZGxlID0gb3B0aW9ucy5uZWVkbGU7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLm5lZWRsZSlcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnJlZ0V4cClcbiAgICAgICAgICAgIG5lZWRsZSA9IGxhbmcuZXNjYXBlUmVnRXhwKG5lZWRsZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2hvbGVXb3JkKVxuICAgICAgICAgICAgbmVlZGxlID0gXCJcXFxcYlwiICsgbmVlZGxlICsgXCJcXFxcYlwiO1xuXG4gICAgICAgIHZhciBtb2RpZmllciA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IFwiZ21cIiA6IFwiZ21pXCI7XG5cbiAgICAgICAgb3B0aW9ucy4kaXNNdWx0aUxpbmUgPSAhJGRpc2FibGVGYWtlTXVsdGlsaW5lICYmIC9bXFxuXFxyXS8udGVzdChuZWVkbGUpO1xuICAgICAgICBpZiAob3B0aW9ucy4kaXNNdWx0aUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZSA9IHRoaXMuJGFzc2VtYmxlTXVsdGlsaW5lUmVnRXhwKG5lZWRsZSwgbW9kaWZpZXIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKG5lZWRsZSwgbW9kaWZpZXIpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmUgPSByZTtcbiAgICB9O1xuXG4gICAgdGhpcy4kYXNzZW1ibGVNdWx0aWxpbmVSZWdFeHAgPSBmdW5jdGlvbihuZWVkbGUsIG1vZGlmaWVyKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5lZWRsZS5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLCBcIiRcXG5eXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgcmUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykgdHJ5IHtcbiAgICAgICAgICAgIHJlLnB1c2gobmV3IFJlZ0V4cChwYXJ0c1tpXSwgbW9kaWZpZXIpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzWzBdID09IFwiXCIpIHtcbiAgICAgICAgICAgIHJlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZS5vZmZzZXQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmUub2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmU7XG4gICAgfTtcblxuICAgIHRoaXMuJGxpbmVJdGVyYXRvciA9IGZ1bmN0aW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGJhY2t3YXJkcyA9IG9wdGlvbnMuYmFja3dhcmRzID09IHRydWU7XG4gICAgICAgIHZhciBza2lwQ3VycmVudCA9IG9wdGlvbnMuc2tpcEN1cnJlbnQgIT0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2UgPyByYW5nZVtiYWNrd2FyZHMgPyBcImVuZFwiIDogXCJzdGFydFwiXSA6IHNlc3Npb24uc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICAgICBcbiAgICAgICAgaWYgKHN0YXJ0LnN0YXJ0KVxuICAgICAgICAgICAgc3RhcnQgPSBzdGFydFtza2lwQ3VycmVudCAhPSBiYWNrd2FyZHMgPyBcImVuZFwiIDogXCJzdGFydFwiXTtcblxuICAgICAgICB2YXIgZmlyc3RSb3cgPSByYW5nZSA/IHJhbmdlLnN0YXJ0LnJvdyA6IDA7XG4gICAgICAgIHZhciBsYXN0Um93ID0gcmFuZ2UgPyByYW5nZS5lbmQucm93IDogc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDE7XG5cbiAgICAgICAgdmFyIGZvckVhY2ggPSBiYWNrd2FyZHMgPyBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBzdGFydC5yb3c7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cpLnN1YnN0cmluZygwLCBzdGFydC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhsaW5lLCByb3cpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHJvdy0tOyByb3cgPj0gZmlyc3RSb3c7IHJvdy0tKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soc2Vzc2lvbi5nZXRMaW5lKHJvdyksIHJvdykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53cmFwID09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IGxhc3RSb3csIGZpcnN0Um93ID0gc3RhcnQucm93OyByb3cgPj0gZmlyc3RSb3c7IHJvdy0tKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soc2Vzc2lvbi5nZXRMaW5lKHJvdyksIHJvdykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gc3RhcnQucm93O1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93KS5zdWJzdHIoc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sobGluZSwgcm93LCBzdGFydC5jb2x1bW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IHJvdysxOyByb3cgPD0gbGFzdFJvdzsgcm93KyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhzZXNzaW9uLmdldExpbmUocm93KSwgcm93KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndyYXAgPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGZvciAocm93ID0gZmlyc3RSb3csIGxhc3RSb3cgPSBzdGFydC5yb3c7IHJvdyA8PSBsYXN0Um93OyByb3crKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHNlc3Npb24uZ2V0TGluZShyb3cpLCByb3cpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7Zm9yRWFjaDogZm9yRWFjaH07XG4gICAgfTtcblxufSkuY2FsbChTZWFyY2gucHJvdG90eXBlKTtcblxuZXhwb3J0cy5TZWFyY2ggPSBTZWFyY2g7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIva2V5c1wiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5VXRpbCA9IGFjZXF1aXJlKFwiLi4vbGliL2tleXNcIik7XG52YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIEtFWV9NT0RTID0ga2V5VXRpbC5LRVlfTU9EUztcblxuZnVuY3Rpb24gSGFzaEhhbmRsZXIoY29uZmlnLCBwbGF0Zm9ybSkge1xuICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybSB8fCAodXNlcmFnZW50LmlzTWFjID8gXCJtYWNcIiA6IFwid2luXCIpO1xuICAgIHRoaXMuY29tbWFuZHMgPSB7fTtcbiAgICB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nID0ge307XG4gICAgdGhpcy5hZGRDb21tYW5kcyhjb25maWcpO1xuICAgIHRoaXMuJHNpbmdsZUNvbW1hbmQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBNdWx0aUhhc2hIYW5kbGVyKGNvbmZpZywgcGxhdGZvcm0pIHtcbiAgICBIYXNoSGFuZGxlci5jYWxsKHRoaXMsIGNvbmZpZywgcGxhdGZvcm0pO1xuICAgIHRoaXMuJHNpbmdsZUNvbW1hbmQgPSBmYWxzZTtcbn1cblxuTXVsdGlIYXNoSGFuZGxlci5wcm90b3R5cGUgPSBIYXNoSGFuZGxlci5wcm90b3R5cGU7XG5cbihmdW5jdGlvbigpIHtcblxuXG4gICAgdGhpcy5hZGRDb21tYW5kID0gZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgICBpZiAodGhpcy5jb21tYW5kc1tjb21tYW5kLm5hbWVdKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb21tYW5kKGNvbW1hbmQpO1xuXG4gICAgICAgIHRoaXMuY29tbWFuZHNbY29tbWFuZC5uYW1lXSA9IGNvbW1hbmQ7XG5cbiAgICAgICAgaWYgKGNvbW1hbmQuYmluZEtleSlcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkS2V5SGFzaChjb21tYW5kKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVDb21tYW5kID0gZnVuY3Rpb24oY29tbWFuZCwga2VlcENvbW1hbmQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjb21tYW5kICYmICh0eXBlb2YgY29tbWFuZCA9PT0gJ3N0cmluZycgPyBjb21tYW5kIDogY29tbWFuZC5uYW1lKTtcbiAgICAgICAgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbbmFtZV07XG4gICAgICAgIGlmICgha2VlcENvbW1hbmQpXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jb21tYW5kc1tuYW1lXTtcbiAgICAgICAgdmFyIGNrYiA9IHRoaXMuY29tbWFuZEtleUJpbmRpbmc7XG4gICAgICAgIGZvciAodmFyIGtleUlkIGluIGNrYikge1xuICAgICAgICAgICAgdmFyIGNtZEdyb3VwID0gY2tiW2tleUlkXTtcbiAgICAgICAgICAgIGlmIChjbWRHcm91cCA9PSBjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNrYltrZXlJZF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY21kR3JvdXApKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBjbWRHcm91cC5pbmRleE9mKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIGlmIChpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtZEdyb3VwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtZEdyb3VwLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2tiW2tleUlkXSA9IGNtZEdyb3VwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmJpbmRLZXkgPSBmdW5jdGlvbihrZXksIGNvbW1hbmQsIGFzRGVmYXVsdCkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAga2V5ID0ga2V5W3RoaXMucGxhdGZvcm1dO1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZENvbW1hbmQoe2V4ZWM6IGNvbW1hbmQsIGJpbmRLZXk6IGtleSwgbmFtZTogY29tbWFuZC5uYW1lIHx8IGtleX0pO1xuXG4gICAgICAgIGtleS5zcGxpdChcInxcIikuZm9yRWFjaChmdW5jdGlvbihrZXlQYXJ0KSB7XG4gICAgICAgICAgICB2YXIgY2hhaW4gPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGtleVBhcnQuaW5kZXhPZihcIiBcIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXlQYXJ0LnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICAgICAga2V5UGFydCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24oa2V5UGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMucGFyc2VLZXlzKGtleVBhcnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBLRVlfTU9EU1tiaW5kaW5nLmhhc2hJZF0gKyBiaW5kaW5nLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4gKz0gKGNoYWluID8gXCIgXCIgOiBcIlwiKSArIGlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDb21tYW5kVG9CaW5kaW5nKGNoYWluLCBcImNoYWluS2V5c1wiKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICBjaGFpbiArPSBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5wYXJzZUtleXMoa2V5UGFydCk7XG4gICAgICAgICAgICB2YXIgaWQgPSBLRVlfTU9EU1tiaW5kaW5nLmhhc2hJZF0gKyBiaW5kaW5nLmtleTtcbiAgICAgICAgICAgIHRoaXMuX2FkZENvbW1hbmRUb0JpbmRpbmcoY2hhaW4gKyBpZCwgY29tbWFuZCwgYXNEZWZhdWx0KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIHRoaXMuX2FkZENvbW1hbmRUb0JpbmRpbmcgPSBmdW5jdGlvbihrZXlJZCwgY29tbWFuZCwgYXNEZWZhdWx0KSB7XG4gICAgICAgIHZhciBja2IgPSB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nLCBpO1xuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBja2Jba2V5SWRdO1xuICAgICAgICB9IGVsc2UgaWYgKCFja2Jba2V5SWRdIHx8IHRoaXMuJHNpbmdsZUNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNrYltrZXlJZF0gPSBjb21tYW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNrYltrZXlJZF0pKSB7XG4gICAgICAgICAgICAgICAgY2tiW2tleUlkXSA9IFtja2Jba2V5SWRdXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGkgPSBja2Jba2V5SWRdLmluZGV4T2YoY29tbWFuZCkpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgY2tiW2tleUlkXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhc0RlZmF1bHQgfHwgY29tbWFuZC5pc0RlZmF1bHQpXG4gICAgICAgICAgICAgICAgY2tiW2tleUlkXS51bnNoaWZ0KGNvbW1hbmQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNrYltrZXlJZF0ucHVzaChjb21tYW5kKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmFkZENvbW1hbmRzID0gZnVuY3Rpb24oY29tbWFuZHMpIHtcbiAgICAgICAgY29tbWFuZHMgJiYgT2JqZWN0LmtleXMoY29tbWFuZHMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kS2V5KGNvbW1hbmQsIG5hbWUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb21tYW5kID0geyBleGVjOiBjb21tYW5kIH07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICghY29tbWFuZC5uYW1lKVxuICAgICAgICAgICAgICAgIGNvbW1hbmQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlQ29tbWFuZHMgPSBmdW5jdGlvbihjb21tYW5kcykge1xuICAgICAgICBPYmplY3Qua2V5cyhjb21tYW5kcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbW1hbmQoY29tbWFuZHNbbmFtZV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5iaW5kS2V5cyA9IGZ1bmN0aW9uKGtleUxpc3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5TGlzdCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZEtleShrZXksIGtleUxpc3Rba2V5XSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgICB0aGlzLl9idWlsZEtleUhhc2ggPSBmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgICAgIHRoaXMuYmluZEtleShjb21tYW5kLmJpbmRLZXksIGNvbW1hbmQpO1xuICAgIH07XG4gICAgdGhpcy5wYXJzZUtleXMgPSBmdW5jdGlvbihrZXlzKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGtleXMudG9Mb3dlckNhc2UoKS5zcGxpdCgvW1xcLVxcK10oW1xcLVxcK10pPy8pLmZpbHRlcihmdW5jdGlvbih4KXtyZXR1cm4geH0pO1xuICAgICAgICB2YXIga2V5ID0gcGFydHMucG9wKCk7XG5cbiAgICAgICAgdmFyIGtleUNvZGUgPSBrZXlVdGlsW2tleV07XG4gICAgICAgIGlmIChrZXlVdGlsLkZVTkNUSU9OX0tFWVNba2V5Q29kZV0pXG4gICAgICAgICAgICBrZXkgPSBrZXlVdGlsLkZVTkNUSU9OX0tFWVNba2V5Q29kZV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZWxzZSBpZiAoIXBhcnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB7a2V5OiBrZXksIGhhc2hJZDogLTF9O1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXSA9PSBcInNoaWZ0XCIpXG4gICAgICAgICAgICByZXR1cm4ge2tleToga2V5LnRvVXBwZXJDYXNlKCksIGhhc2hJZDogLTF9O1xuXG4gICAgICAgIHZhciBoYXNoSWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSBrZXlVdGlsLktFWV9NT0RTW3BhcnRzW2ldXTtcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJpbnZhbGlkIG1vZGlmaWVyIFwiICsgcGFydHNbaV0gKyBcIiBpbiBcIiArIGtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc2hJZCB8PSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2tleToga2V5LCBoYXNoSWQ6IGhhc2hJZH07XG4gICAgfTtcblxuICAgIHRoaXMuZmluZEtleUNvbW1hbmQgPSBmdW5jdGlvbiBmaW5kS2V5Q29tbWFuZChoYXNoSWQsIGtleVN0cmluZykge1xuICAgICAgICB2YXIga2V5ID0gS0VZX01PRFNbaGFzaElkXSArIGtleVN0cmluZztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZEtleUJpbmRpbmdba2V5XTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVLZXlib2FyZCA9IGZ1bmN0aW9uKGRhdGEsIGhhc2hJZCwga2V5U3RyaW5nLCBrZXlDb2RlKSB7XG4gICAgICAgIHZhciBrZXkgPSBLRVlfTU9EU1toYXNoSWRdICsga2V5U3RyaW5nO1xuICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuY29tbWFuZEtleUJpbmRpbmdba2V5XTtcbiAgICAgICAgaWYgKGRhdGEuJGtleUNoYWluKSB7XG4gICAgICAgICAgICBkYXRhLiRrZXlDaGFpbiArPSBcIiBcIiArIGtleTtcbiAgICAgICAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nW2RhdGEuJGtleUNoYWluXSB8fCBjb21tYW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChjb21tYW5kID09IFwiY2hhaW5LZXlzXCIgfHwgY29tbWFuZFtjb21tYW5kLmxlbmd0aCAtIDFdID09IFwiY2hhaW5LZXlzXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLiRrZXlDaGFpbiA9IGRhdGEuJGtleUNoYWluIHx8IGtleTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2NvbW1hbmQ6IFwibnVsbFwifTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLiRrZXlDaGFpbiAmJiBrZXlDb2RlID4gMClcbiAgICAgICAgICAgIGRhdGEuJGtleUNoYWluID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHtjb21tYW5kOiBjb21tYW5kfTtcbiAgICB9O1xuXG59KS5jYWxsKEhhc2hIYW5kbGVyLnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuSGFzaEhhbmRsZXIgPSBIYXNoSGFuZGxlcjtcbmV4cG9ydHMuTXVsdGlIYXNoSGFuZGxlciA9IE11bHRpSGFzaEhhbmRsZXI7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jb21tYW5kcy9jb21tYW5kX21hbmFnZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuLi9saWIvb29wXCIpO1xudmFyIE11bHRpSGFzaEhhbmRsZXIgPSBhY2VxdWlyZShcIi4uL2tleWJvYXJkL2hhc2hfaGFuZGxlclwiKS5NdWx0aUhhc2hIYW5kbGVyO1xudmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFwiLi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xuXG52YXIgQ29tbWFuZE1hbmFnZXIgPSBmdW5jdGlvbihwbGF0Zm9ybSwgY29tbWFuZHMpIHtcbiAgICBNdWx0aUhhc2hIYW5kbGVyLmNhbGwodGhpcywgY29tbWFuZHMsIHBsYXRmb3JtKTtcbiAgICB0aGlzLmJ5TmFtZSA9IHRoaXMuY29tbWFuZHM7XG4gICAgdGhpcy5zZXREZWZhdWx0SGFuZGxlcihcImV4ZWNcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS5jb21tYW5kLmV4ZWMoZS5lZGl0b3IsIGUuYXJncyB8fCB7fSk7XG4gICAgfSk7XG59O1xuXG5vb3AuaW5oZXJpdHMoQ29tbWFuZE1hbmFnZXIsIE11bHRpSGFzaEhhbmRsZXIpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XG5cbiAgICB0aGlzLmV4ZWMgPSBmdW5jdGlvbihjb21tYW5kLCBlZGl0b3IsIGFyZ3MpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWFuZCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBjb21tYW5kLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5leGVjKGNvbW1hbmRbaV0sIGVkaXRvciwgYXJncykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbY29tbWFuZF07XG5cbiAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmIChlZGl0b3IgJiYgZWRpdG9yLiRyZWFkT25seSAmJiAhY29tbWFuZC5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgZSA9IHtlZGl0b3I6IGVkaXRvciwgY29tbWFuZDogY29tbWFuZCwgYXJnczogYXJnc307XG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSB0aGlzLl9lbWl0KFwiZXhlY1wiLCBlKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiYWZ0ZXJFeGVjXCIsIGUpO1xuXG4gICAgICAgIHJldHVybiBlLnJldHVyblZhbHVlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVSZWNvcmRpbmcgPSBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMuJGluUmVwbGF5KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGVkaXRvciAmJiBlZGl0b3IuX2VtaXQoXCJjaGFuZ2VTdGF0dXNcIik7XG4gICAgICAgIGlmICh0aGlzLnJlY29yZGluZykge1xuICAgICAgICAgICAgdGhpcy5tYWNyby5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImV4ZWNcIiwgdGhpcy4kYWRkQ29tbWFuZFRvTWFjcm8pO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMubWFjcm8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubWFjcm8gPSB0aGlzLm9sZE1hY3JvO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuJGFkZENvbW1hbmRUb01hY3JvKSB7XG4gICAgICAgICAgICB0aGlzLiRhZGRDb21tYW5kVG9NYWNybyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hY3JvLnB1c2goW2UuY29tbWFuZCwgZS5hcmdzXSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9sZE1hY3JvID0gdGhpcy5tYWNybztcbiAgICAgICAgdGhpcy5tYWNybyA9IFtdO1xuICAgICAgICB0aGlzLm9uKFwiZXhlY1wiLCB0aGlzLiRhZGRDb21tYW5kVG9NYWNybyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY29yZGluZyA9IHRydWU7XG4gICAgfTtcblxuICAgIHRoaXMucmVwbGF5ID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLiRpblJlcGxheSB8fCAhdGhpcy5tYWNybylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAodGhpcy5yZWNvcmRpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVSZWNvcmRpbmcoZWRpdG9yKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kaW5SZXBsYXkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWNyby5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjKHgsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWMoeFswXSwgZWRpdG9yLCB4WzFdKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy4kaW5SZXBsYXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRyaW1NYWNybyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIG0ubWFwKGZ1bmN0aW9uKHgpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB4WzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgeFswXSA9IHhbMF0ubmFtZTtcbiAgICAgICAgICAgIGlmICgheFsxXSlcbiAgICAgICAgICAgICAgICB4ID0geFswXTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG59KS5jYWxsKENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuQ29tbWFuZE1hbmFnZXIgPSBDb21tYW5kTWFuYWdlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvY29tbWFuZHMvZGVmYXVsdF9jb21tYW5kc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgbGFuZyA9IGFjZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgY29uZmlnID0gYWNlcXVpcmUoXCIuLi9jb25maWdcIik7XG52YXIgUmFuZ2UgPSBhY2VxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xuXG5mdW5jdGlvbiBiaW5kS2V5KHdpbiwgbWFjKSB7XG4gICAgcmV0dXJuIHt3aW46IHdpbiwgbWFjOiBtYWN9O1xufVxuZXhwb3J0cy5jb21tYW5kcyA9IFt7XG4gICAgbmFtZTogXCJzaG93U2V0dGluZ3NNZW51XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtLFwiLCBcIkNvbW1hbmQtLFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L3NldHRpbmdzX21lbnVcIiwgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICBtb2R1bGUuaW5pdChlZGl0b3IpO1xuICAgICAgICAgICAgZWRpdG9yLnNob3dTZXR0aW5nc01lbnUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiZ29Ub05leHRFcnJvclwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtRVwiLCBcIkN0cmwtRVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L2Vycm9yX21hcmtlclwiLCBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZS5zaG93RXJyb3JNYXJrZXIoZWRpdG9yLCAxKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcImdvVG9QcmV2aW91c0Vycm9yXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC1FXCIsIFwiQ3RybC1TaGlmdC1FXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICBjb25maWcubG9hZE1vZHVsZShcImFjZS9leHQvZXJyb3JfbWFya2VyXCIsIGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgbW9kdWxlLnNob3dFcnJvck1hcmtlcihlZGl0b3IsIC0xKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInNlbGVjdGFsbFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUFcIiwgXCJDb21tYW5kLUFcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RBbGwoKTsgfSxcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiY2VudGVyc2VsZWN0aW9uXCIsXG4gICAgYmluZEtleTogYmluZEtleShudWxsLCBcIkN0cmwtTFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNlbnRlclNlbGVjdGlvbigpOyB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJnb3RvbGluZVwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUxcIiwgXCJDb21tYW5kLUxcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VJbnQocHJvbXB0KFwiRW50ZXIgbGluZSBudW1iZXI6XCIpLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4obGluZSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5nb3RvTGluZShsaW5lKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcImZvbGRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LUx8Q3RybC1GMVwiLCBcIkNvbW1hbmQtQWx0LUx8Q29tbWFuZC1GMVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24udG9nZ2xlRm9sZChmYWxzZSk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJ1bmZvbGRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LUx8Q3RybC1TaGlmdC1GMVwiLCBcIkNvbW1hbmQtQWx0LVNoaWZ0LUx8Q29tbWFuZC1TaGlmdC1GMVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24udG9nZ2xlRm9sZCh0cnVlKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY2VudGVyXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInRvZ2dsZUZvbGRXaWRnZXRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiRjJcIiwgXCJGMlwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24udG9nZ2xlRm9sZFdpZGdldCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwidG9nZ2xlUGFyZW50Rm9sZFdpZGdldFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtRjJcIiwgXCJBbHQtRjJcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnRvZ2dsZUZvbGRXaWRnZXQodHJ1ZSk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJmb2xkYWxsXCIsXG4gICAgYmluZEtleTogYmluZEtleShudWxsLCBcIkN0cmwtQ29tbWFuZC1PcHRpb24tMFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24uZm9sZEFsbCgpOyB9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJmb2xkT3RoZXJcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LTBcIiwgXCJDb21tYW5kLU9wdGlvbi0wXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBcbiAgICAgICAgZWRpdG9yLnNlc3Npb24uZm9sZEFsbCgpO1xuICAgICAgICBlZGl0b3Iuc2Vzc2lvbi51bmZvbGQoZWRpdG9yLnNlbGVjdGlvbi5nZXRBbGxSYW5nZXMoKSk7XG4gICAgfSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjZW50ZXJcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwidW5mb2xkYWxsXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC0wXCIsIFwiQ29tbWFuZC1PcHRpb24tU2hpZnQtMFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlc3Npb24udW5mb2xkKCk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY2VudGVyXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcImZpbmRuZXh0XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtS1wiLCBcIkNvbW1hbmQtR1wiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmZpbmROZXh0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJmaW5kcHJldmlvdXNcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1LXCIsIFwiQ29tbWFuZC1TaGlmdC1HXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZmluZFByZXZpb3VzKCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImNlbnRlclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3RPckZpbmROZXh0XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkFsdC1LXCIsIFwiQ3RybC1HXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpXG4gICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZWRpdG9yLmZpbmROZXh0KCk7IFxuICAgIH0sXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInNlbGVjdE9yRmluZFByZXZpb3VzXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkFsdC1TaGlmdC1LXCIsIFwiQ3RybC1TaGlmdC1HXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVkaXRvci5maW5kUHJldmlvdXMoKTtcbiAgICB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJmaW5kXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtRlwiLCBcIkNvbW1hbmQtRlwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L3NlYXJjaGJveFwiLCBmdW5jdGlvbihlKSB7ZS5TZWFyY2goZWRpdG9yKX0pO1xuICAgIH0sXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcIm92ZXJ3cml0ZVwiLFxuICAgIGJpbmRLZXk6IFwiSW5zZXJ0XCIsXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci50b2dnbGVPdmVyd3JpdGUoKTsgfSxcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwic2VsZWN0dG9zdGFydFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUhvbWVcIiwgXCJDb21tYW5kLVNoaWZ0LVVwXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0RmlsZVN0YXJ0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICBhY2VDb21tYW5kR3JvdXA6IFwiZmlsZUp1bXBcIlxufSwge1xuICAgIG5hbWU6IFwiZ290b3N0YXJ0XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtSG9tZVwiLCBcIkNvbW1hbmQtSG9tZXxDb21tYW5kLVVwXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVGaWxlU3RhcnQoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgcmVhZE9ubHk6IHRydWUsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgIGFjZUNvbW1hbmRHcm91cDogXCJmaWxlSnVtcFwiXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3R1cFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1VcFwiLCBcIlNoaWZ0LVVwXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0VXAoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcImdvbGluZXVwXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIlVwXCIsIFwiVXB8Q3RybC1QXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvciwgYXJncykgeyBlZGl0b3IubmF2aWdhdGVVcChhcmdzLnRpbWVzKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInNlbGVjdHRvZW5kXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtRW5kXCIsIFwiQ29tbWFuZC1TaGlmdC1Eb3duXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0RmlsZUVuZCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICByZWFkT25seTogdHJ1ZSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgYWNlQ29tbWFuZEdyb3VwOiBcImZpbGVKdW1wXCJcbn0sIHtcbiAgICBuYW1lOiBcImdvdG9lbmRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1FbmRcIiwgXCJDb21tYW5kLUVuZHxDb21tYW5kLURvd25cIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZUZpbGVFbmQoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgcmVhZE9ubHk6IHRydWUsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgIGFjZUNvbW1hbmRHcm91cDogXCJmaWxlSnVtcFwiXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3Rkb3duXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIlNoaWZ0LURvd25cIiwgXCJTaGlmdC1Eb3duXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0RG93bigpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiZ29saW5lZG93blwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJEb3duXCIsIFwiRG93bnxDdHJsLU5cIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yLCBhcmdzKSB7IGVkaXRvci5uYXZpZ2F0ZURvd24oYXJncy50aW1lcyk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3R3b3JkbGVmdFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUxlZnRcIiwgXCJPcHRpb24tU2hpZnQtTGVmdFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdFdvcmRMZWZ0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJnb3Rvd29yZGxlZnRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1MZWZ0XCIsIFwiT3B0aW9uLUxlZnRcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZVdvcmRMZWZ0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3R0b2xpbmVzdGFydFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtU2hpZnQtTGVmdFwiLCBcIkNvbW1hbmQtU2hpZnQtTGVmdFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdExpbmVTdGFydCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiZ290b2xpbmVzdGFydFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtTGVmdHxIb21lXCIsIFwiQ29tbWFuZC1MZWZ0fEhvbWV8Q3RybC1BXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVMaW5lU3RhcnQoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInNlbGVjdGxlZnRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiU2hpZnQtTGVmdFwiLCBcIlNoaWZ0LUxlZnRcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RMZWZ0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJnb3RvbGVmdFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJMZWZ0XCIsIFwiTGVmdHxDdHJsLUJcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yLCBhcmdzKSB7IGVkaXRvci5uYXZpZ2F0ZUxlZnQoYXJncy50aW1lcyk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3R3b3JkcmlnaHRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1SaWdodFwiLCBcIk9wdGlvbi1TaGlmdC1SaWdodFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdFdvcmRSaWdodCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiZ290b3dvcmRyaWdodFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVJpZ2h0XCIsIFwiT3B0aW9uLVJpZ2h0XCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVXb3JkUmlnaHQoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInNlbGVjdHRvbGluZWVuZFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtU2hpZnQtUmlnaHRcIiwgXCJDb21tYW5kLVNoaWZ0LVJpZ2h0XCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0TGluZUVuZCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiZ290b2xpbmVlbmRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVJpZ2h0fEVuZFwiLCBcIkNvbW1hbmQtUmlnaHR8RW5kfEN0cmwtRVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLm5hdmlnYXRlTGluZUVuZCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwic2VsZWN0cmlnaHRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiU2hpZnQtUmlnaHRcIiwgXCJTaGlmdC1SaWdodFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdFJpZ2h0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJnb3RvcmlnaHRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiUmlnaHRcIiwgXCJSaWdodHxDdHJsLUZcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yLCBhcmdzKSB7IGVkaXRvci5uYXZpZ2F0ZVJpZ2h0KGFyZ3MudGltZXMpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwic2VsZWN0cGFnZWRvd25cIixcbiAgICBiaW5kS2V5OiBcIlNoaWZ0LVBhZ2VEb3duXCIsXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RQYWdlRG93bigpOyB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJwYWdlZG93blwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgXCJPcHRpb24tUGFnZURvd25cIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zY3JvbGxQYWdlRG93bigpOyB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJnb3RvcGFnZWRvd25cIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiUGFnZURvd25cIiwgXCJQYWdlRG93bnxDdHJsLVZcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5nb3RvUGFnZURvd24oKTsgfSxcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwic2VsZWN0cGFnZXVwXCIsXG4gICAgYmluZEtleTogXCJTaGlmdC1QYWdlVXBcIixcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdFBhZ2VVcCgpOyB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJwYWdldXBcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiT3B0aW9uLVBhZ2VVcFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNjcm9sbFBhZ2VVcCgpOyB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJnb3RvcGFnZXVwXCIsXG4gICAgYmluZEtleTogXCJQYWdlVXBcIixcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdvdG9QYWdlVXAoKTsgfSxcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwic2Nyb2xsdXBcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1VcFwiLCBudWxsKSxcbiAgICBleGVjOiBmdW5jdGlvbihlKSB7IGUucmVuZGVyZXIuc2Nyb2xsQnkoMCwgLTIgKiBlLnJlbmRlcmVyLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQpOyB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzY3JvbGxkb3duXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtRG93blwiLCBudWxsKSxcbiAgICBleGVjOiBmdW5jdGlvbihlKSB7IGUucmVuZGVyZXIuc2Nyb2xsQnkoMCwgMiAqIGUucmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodCk7IH0sXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInNlbGVjdGxpbmVzdGFydFwiLFxuICAgIGJpbmRLZXk6IFwiU2hpZnQtSG9tZVwiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0TGluZVN0YXJ0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3RsaW5lZW5kXCIsXG4gICAgYmluZEtleTogXCJTaGlmdC1FbmRcIixcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdExpbmVFbmQoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInRvZ2dsZXJlY29yZGluZ1wiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLUFsdC1FXCIsIFwiQ29tbWFuZC1PcHRpb24tRVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVJlY29yZGluZyhlZGl0b3IpOyB9LFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJyZXBsYXltYWNyb1wiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LUVcIiwgXCJDb21tYW5kLVNoaWZ0LUVcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5jb21tYW5kcy5yZXBsYXkoZWRpdG9yKTsgfSxcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwianVtcHRvbWF0Y2hpbmdcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1QXCIsIFwiQ3RybC1QXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuanVtcFRvTWF0Y2hpbmcoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiYW5pbWF0ZVwiLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3R0b21hdGNoaW5nXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtUFwiLCBcIkN0cmwtU2hpZnQtUFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmp1bXBUb01hdGNoaW5nKHRydWUpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJhbmltYXRlXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcImV4cGFuZFRvTWF0Y2hpbmdcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1TaGlmdC1NXCIsIFwiQ3RybC1TaGlmdC1NXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuanVtcFRvTWF0Y2hpbmcodHJ1ZSwgdHJ1ZSk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImFuaW1hdGVcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwicGFzc0tleXNUb0Jyb3dzZXJcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIG51bGwpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKCkge30sXG4gICAgcGFzc0V2ZW50OiB0cnVlLFxuICAgIHJlYWRPbmx5OiB0cnVlXG59LFxue1xuICAgIG5hbWU6IFwiY3V0XCIsXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBlZGl0b3IuX2VtaXQoXCJjdXRcIiwgcmFuZ2UpO1xuXG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXNzaW9uLnJlbW92ZShyYW5nZSk7XG4gICAgICAgICAgICBlZGl0b3IuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiXG59LCB7XG4gICAgbmFtZTogXCJyZW1vdmVsaW5lXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtRFwiLCBcIkNvbW1hbmQtRFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZUxpbmVzKCk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIlxufSwge1xuICAgIG5hbWU6IFwiZHVwbGljYXRlU2VsZWN0aW9uXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtRFwiLCBcIkNvbW1hbmQtU2hpZnQtRFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmR1cGxpY2F0ZVNlbGVjdGlvbigpOyB9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIlxufSwge1xuICAgIG5hbWU6IFwic29ydGxpbmVzXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtQWx0LVNcIiwgXCJDb21tYW5kLUFsdC1TXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc29ydExpbmVzKCk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwic2VsZWN0aW9uXCIsXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIlxufSwge1xuICAgIG5hbWU6IFwidG9nZ2xlY29tbWVudFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLS9cIiwgXCJDb21tYW5kLS9cIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci50b2dnbGVDb21tZW50TGluZXMoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoTGluZVwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcInNlbGVjdGlvblBhcnRcIlxufSwge1xuICAgIG5hbWU6IFwidG9nZ2xlQmxvY2tDb21tZW50XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtL1wiLCBcIkNvbW1hbmQtU2hpZnQtL1wiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnRvZ2dsZUJsb2NrQ29tbWVudCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbn0sIHtcbiAgICBuYW1lOiBcIm1vZGlmeU51bWJlclVwXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtVXBcIiwgXCJBbHQtU2hpZnQtVXBcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5tb2RpZnlOdW1iZXIoMSk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiXG59LCB7XG4gICAgbmFtZTogXCJtb2RpZnlOdW1iZXJEb3duXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtRG93blwiLCBcIkFsdC1TaGlmdC1Eb3duXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubW9kaWZ5TnVtYmVyKC0xKTsgfSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCJcbn0sIHtcbiAgICBuYW1lOiBcInJlcGxhY2VcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1IXCIsIFwiQ29tbWFuZC1PcHRpb24tRlwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXCJhY2UvZXh0L3NlYXJjaGJveFwiLCBmdW5jdGlvbihlKSB7ZS5TZWFyY2goZWRpdG9yLCB0cnVlKX0pO1xuICAgIH1cbn0sIHtcbiAgICBuYW1lOiBcInVuZG9cIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1aXCIsIFwiQ29tbWFuZC1aXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IudW5kbygpOyB9XG59LCB7XG4gICAgbmFtZTogXCJyZWRvXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtWnxDdHJsLVlcIiwgXCJDb21tYW5kLVNoaWZ0LVp8Q29tbWFuZC1ZXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IucmVkbygpOyB9XG59LCB7XG4gICAgbmFtZTogXCJjb3B5bGluZXN1cFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJBbHQtU2hpZnQtVXBcIiwgXCJDb21tYW5kLU9wdGlvbi1VcFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNvcHlMaW5lc1VwKCk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbn0sIHtcbiAgICBuYW1lOiBcIm1vdmVsaW5lc3VwXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkFsdC1VcFwiLCBcIk9wdGlvbi1VcFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLm1vdmVMaW5lc1VwKCk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbn0sIHtcbiAgICBuYW1lOiBcImNvcHlsaW5lc2Rvd25cIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LVNoaWZ0LURvd25cIiwgXCJDb21tYW5kLU9wdGlvbi1Eb3duXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuY29weUxpbmVzRG93bigpOyB9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJtb3ZlbGluZXNkb3duXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkFsdC1Eb3duXCIsIFwiT3B0aW9uLURvd25cIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5tb3ZlTGluZXNEb3duKCk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbn0sIHtcbiAgICBuYW1lOiBcImRlbFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJEZWxldGVcIiwgXCJEZWxldGV8Q3RybC1EfFNoaWZ0LURlbGV0ZVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZShcInJpZ2h0XCIpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxufSwge1xuICAgIG5hbWU6IFwiYmFja3NwYWNlXCIsXG4gICAgYmluZEtleTogYmluZEtleShcbiAgICAgICAgXCJTaGlmdC1CYWNrc3BhY2V8QmFja3NwYWNlXCIsXG4gICAgICAgIFwiQ3RybC1CYWNrc3BhY2V8U2hpZnQtQmFja3NwYWNlfEJhY2tzcGFjZXxDdHJsLUhcIlxuICAgICksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5yZW1vdmUoXCJsZWZ0XCIpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxufSwge1xuICAgIG5hbWU6IFwiY3V0X29yX2RlbGV0ZVwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJTaGlmdC1EZWxldGVcIiwgbnVsbCksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IFxuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmUoXCJsZWZ0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbn0sIHtcbiAgICBuYW1lOiBcInJlbW92ZXRvbGluZXN0YXJ0XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkFsdC1CYWNrc3BhY2VcIiwgXCJDb21tYW5kLUJhY2tzcGFjZVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVRvTGluZVN0YXJ0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJyZW1vdmV0b2xpbmVlbmRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQWx0LURlbGV0ZVwiLCBcIkN0cmwtS1wiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVRvTGluZUVuZCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxufSwge1xuICAgIG5hbWU6IFwicmVtb3Zld29yZGxlZnRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1CYWNrc3BhY2VcIiwgXCJBbHQtQmFja3NwYWNlfEN0cmwtQWx0LUJhY2tzcGFjZVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVdvcmRMZWZ0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJyZW1vdmV3b3JkcmlnaHRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1EZWxldGVcIiwgXCJBbHQtRGVsZXRlXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IucmVtb3ZlV29yZFJpZ2h0KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJvdXRkZW50XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIlNoaWZ0LVRhYlwiLCBcIlNoaWZ0LVRhYlwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmJsb2NrT3V0ZGVudCgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbn0sIHtcbiAgICBuYW1lOiBcImluZGVudFwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJUYWJcIiwgXCJUYWJcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5pbmRlbnQoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwic2VsZWN0aW9uUGFydFwiXG59LCB7XG4gICAgbmFtZTogXCJibG9ja291dGRlbnRcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KFwiQ3RybC1bXCIsIFwiQ3RybC1bXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuYmxvY2tPdXRkZW50KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbn0sIHtcbiAgICBuYW1lOiBcImJsb2NraW5kZW50XCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtXVwiLCBcIkN0cmwtXVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmJsb2NrSW5kZW50KCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaExpbmVcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJzZWxlY3Rpb25QYXJ0XCJcbn0sIHtcbiAgICBuYW1lOiBcImluc2VydHN0cmluZ1wiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvciwgc3RyKSB7IGVkaXRvci5pbnNlcnQoc3RyKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbn0sIHtcbiAgICBuYW1lOiBcImluc2VydHRleHRcIixcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IsIGFyZ3MpIHtcbiAgICAgICAgZWRpdG9yLmluc2VydChsYW5nLnN0cmluZ1JlcGVhdChhcmdzLnRleHQgIHx8IFwiXCIsIGFyZ3MudGltZXMgfHwgMSkpO1xuICAgIH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJzcGxpdGxpbmVcIixcbiAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFwiQ3RybC1PXCIpLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc3BsaXRMaW5lKCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJ0cmFuc3Bvc2VsZXR0ZXJzXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtVFwiLCBcIkN0cmwtVFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnRyYW5zcG9zZUxldHRlcnMoKTsgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogZnVuY3Rpb24oZWRpdG9yKSB7ZWRpdG9yLnRyYW5zcG9zZVNlbGVjdGlvbnMoMSk7IH0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCJcbn0sIHtcbiAgICBuYW1lOiBcInRvdXBwZXJjYXNlXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtVVwiLCBcIkN0cmwtVVwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgbXVsdGlTZWxlY3RBY3Rpb246IFwiZm9yRWFjaFwiLFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJ0b2xvd2VyY2FzZVwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkoXCJDdHJsLVNoaWZ0LVVcIiwgXCJDdHJsLVNoaWZ0LVVcIiksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci50b0xvd2VyQ2FzZSgpOyB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIlxufSwge1xuICAgIG5hbWU6IFwiZXhwYW5kdG9saW5lXCIsXG4gICAgYmluZEtleTogYmluZEtleShcIkN0cmwtU2hpZnQtTFwiLCBcIkNvbW1hbmQtU2hpZnQtTFwiKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuXG4gICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW4gPSAwO1xuICAgICAgICByYW5nZS5lbmQucm93Kys7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0UmFuZ2UocmFuZ2UsIGZhbHNlKTtcbiAgICB9LFxuICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcImZvckVhY2hcIixcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkT25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiam9pbmxpbmVzXCIsXG4gICAgYmluZEtleTogYmluZEtleShudWxsLCBudWxsKSxcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgdmFyIGlzQmFja3dhcmRzID0gZWRpdG9yLnNlbGVjdGlvbi5pc0JhY2t3YXJkcygpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBpc0JhY2t3YXJkcyA/IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uTGVhZCgpIDogZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25BbmNob3IoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGlzQmFja3dhcmRzID8gZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25BbmNob3IoKSA6IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uTGVhZCgpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lRW5kQ29sID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldExpbmUoc2VsZWN0aW9uU3RhcnQucm93KS5sZW5ndGg7XG4gICAgICAgIHZhciBzZWxlY3RlZFRleHQgPSBlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKGVkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKSk7XG4gICAgICAgIHZhciBzZWxlY3RlZENvdW50ID0gc2VsZWN0ZWRUZXh0LnJlcGxhY2UoL1xcblxccyovLCBcIiBcIikubGVuZ3RoO1xuICAgICAgICB2YXIgaW5zZXJ0TGluZSA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKHNlbGVjdGlvblN0YXJ0LnJvdyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHNlbGVjdGlvblN0YXJ0LnJvdyArIDE7IGkgPD0gc2VsZWN0aW9uRW5kLnJvdyArIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGN1ckxpbmUgPSBsYW5nLnN0cmluZ1RyaW1MZWZ0KGxhbmcuc3RyaW5nVHJpbVJpZ2h0KGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKGkpKSk7XG4gICAgICAgICAgICBpZiAoY3VyTGluZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJMaW5lID0gXCIgXCIgKyBjdXJMaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zZXJ0TGluZSArPSBjdXJMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbkVuZC5yb3cgKyAxIDwgKGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMZW5ndGgoKSAtIDEpKSB7XG4gICAgICAgICAgICBpbnNlcnRMaW5lICs9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgZWRpdG9yLnNlc3Npb24uZG9jLnJlcGxhY2UobmV3IFJhbmdlKHNlbGVjdGlvblN0YXJ0LnJvdywgMCwgc2VsZWN0aW9uRW5kLnJvdyArIDIsIDApLCBpbnNlcnRMaW5lKTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZUN1cnNvclRvKHNlbGVjdGlvblN0YXJ0LnJvdywgc2VsZWN0aW9uU3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0VG8oc2VsZWN0aW9uU3RhcnQucm93LCBzZWxlY3Rpb25TdGFydC5jb2x1bW4gKyBzZWxlY3RlZENvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0TGluZUVuZENvbCA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKHNlbGVjdGlvblN0YXJ0LnJvdykubGVuZ3RoID4gZmlyc3RMaW5lRW5kQ29sID8gKGZpcnN0TGluZUVuZENvbCArIDEpIDogZmlyc3RMaW5lRW5kQ29sO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG8oc2VsZWN0aW9uU3RhcnQucm93LCBmaXJzdExpbmVFbmRDb2wpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtdWx0aVNlbGVjdEFjdGlvbjogXCJmb3JFYWNoXCIsXG4gICAgcmVhZE9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcImludmVydFNlbGVjdGlvblwiLFxuICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgbnVsbCksXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHZhciBlbmRSb3cgPSBlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xuICAgICAgICB2YXIgZW5kQ29sID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldExpbmUoZW5kUm93KS5sZW5ndGg7XG4gICAgICAgIHZhciByYW5nZXMgPSBlZGl0b3Iuc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZXM7XG4gICAgICAgIHZhciBuZXdSYW5nZXMgPSBbXTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByYW5nZXMgPSBbZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSAocmFuZ2VzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmFuZ2VzW2ldLmVuZC5yb3cgPT09IGVuZFJvdyAmJiByYW5nZXNbaV0uZW5kLmNvbHVtbiA9PT0gZW5kQ29sKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChuZXcgUmFuZ2UocmFuZ2VzW2ldLmVuZC5yb3csIHJhbmdlc1tpXS5lbmQuY29sdW1uLCBlbmRSb3csIGVuZENvbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyYW5nZXNbaV0uc3RhcnQucm93ID09PSAwICYmIHJhbmdlc1tpXS5zdGFydC5jb2x1bW4gPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Jhbmdlcy5wdXNoKG5ldyBSYW5nZSgwLCAwLCByYW5nZXNbaV0uc3RhcnQucm93LCByYW5nZXNbaV0uc3RhcnQuY29sdW1uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChuZXcgUmFuZ2UocmFuZ2VzW2ktMV0uZW5kLnJvdywgcmFuZ2VzW2ktMV0uZW5kLmNvbHVtbiwgcmFuZ2VzW2ldLnN0YXJ0LnJvdywgcmFuZ2VzW2ldLnN0YXJ0LmNvbHVtbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLmV4aXRNdWx0aVNlbGVjdE1vZGUoKTtcbiAgICAgICAgZWRpdG9yLmNsZWFyU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5ld1Jhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZXNbaV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVhZE9ubHk6IHRydWUsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwibm9uZVwiXG59XTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvZWRpdG9yXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2ZpeG9sZGJyb3dzZXJzXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9kb21cIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi91c2VyYWdlbnRcIixcImFjZS9rZXlib2FyZC90ZXh0aW5wdXRcIixcImFjZS9tb3VzZS9tb3VzZV9oYW5kbGVyXCIsXCJhY2UvbW91c2UvZm9sZF9oYW5kbGVyXCIsXCJhY2Uva2V5Ym9hcmQva2V5YmluZGluZ1wiLFwiYWNlL2VkaXRfc2Vzc2lvblwiLFwiYWNlL3NlYXJjaFwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9jb21tYW5kcy9jb21tYW5kX21hbmFnZXJcIixcImFjZS9jb21tYW5kcy9kZWZhdWx0X2NvbW1hbmRzXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvdG9rZW5faXRlcmF0b3JcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG5hY2VxdWlyZShcIi4vbGliL2ZpeG9sZGJyb3dzZXJzXCIpO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gYWNlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgbGFuZyA9IGFjZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciB1c2VyYWdlbnQgPSBhY2VxdWlyZShcIi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBUZXh0SW5wdXQgPSBhY2VxdWlyZShcIi4va2V5Ym9hcmQvdGV4dGlucHV0XCIpLlRleHRJbnB1dDtcbnZhciBNb3VzZUhhbmRsZXIgPSBhY2VxdWlyZShcIi4vbW91c2UvbW91c2VfaGFuZGxlclwiKS5Nb3VzZUhhbmRsZXI7XG52YXIgRm9sZEhhbmRsZXIgPSBhY2VxdWlyZShcIi4vbW91c2UvZm9sZF9oYW5kbGVyXCIpLkZvbGRIYW5kbGVyO1xudmFyIEtleUJpbmRpbmcgPSBhY2VxdWlyZShcIi4va2V5Ym9hcmQva2V5YmluZGluZ1wiKS5LZXlCaW5kaW5nO1xudmFyIEVkaXRTZXNzaW9uID0gYWNlcXVpcmUoXCIuL2VkaXRfc2Vzc2lvblwiKS5FZGl0U2Vzc2lvbjtcbnZhciBTZWFyY2ggPSBhY2VxdWlyZShcIi4vc2VhcmNoXCIpLlNlYXJjaDtcbnZhciBSYW5nZSA9IGFjZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIENvbW1hbmRNYW5hZ2VyID0gYWNlcXVpcmUoXCIuL2NvbW1hbmRzL2NvbW1hbmRfbWFuYWdlclwiKS5Db21tYW5kTWFuYWdlcjtcbnZhciBkZWZhdWx0Q29tbWFuZHMgPSBhY2VxdWlyZShcIi4vY29tbWFuZHMvZGVmYXVsdF9jb21tYW5kc1wiKS5jb21tYW5kcztcbnZhciBjb25maWcgPSBhY2VxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIFRva2VuSXRlcmF0b3IgPSBhY2VxdWlyZShcIi4vdG9rZW5faXRlcmF0b3JcIikuVG9rZW5JdGVyYXRvcjtcbnZhciBFZGl0b3IgPSBmdW5jdGlvbihyZW5kZXJlciwgc2Vzc2lvbikge1xuICAgIHZhciBjb250YWluZXIgPSByZW5kZXJlci5nZXRDb250YWluZXJFbGVtZW50KCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gICAgdGhpcy5jb21tYW5kcyA9IG5ldyBDb21tYW5kTWFuYWdlcih1c2VyYWdlbnQuaXNNYWMgPyBcIm1hY1wiIDogXCJ3aW5cIiwgZGVmYXVsdENvbW1hbmRzKTtcbiAgICB0aGlzLnRleHRJbnB1dCAgPSBuZXcgVGV4dElucHV0KHJlbmRlcmVyLmdldFRleHRBcmVhQ29udGFpbmVyKCksIHRoaXMpO1xuICAgIHRoaXMucmVuZGVyZXIudGV4dGFyZWEgPSB0aGlzLnRleHRJbnB1dC5nZXRFbGVtZW50KCk7XG4gICAgdGhpcy5rZXlCaW5kaW5nID0gbmV3IEtleUJpbmRpbmcodGhpcyk7XG4gICAgdGhpcy4kbW91c2VIYW5kbGVyID0gbmV3IE1vdXNlSGFuZGxlcih0aGlzKTtcbiAgICBuZXcgRm9sZEhhbmRsZXIodGhpcyk7XG5cbiAgICB0aGlzLiRibG9ja1Njcm9sbGluZyA9IDA7XG4gICAgdGhpcy4kc2VhcmNoID0gbmV3IFNlYXJjaCgpLnNldCh7XG4gICAgICAgIHdyYXA6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuJGhpc3RvcnlUcmFja2VyID0gdGhpcy4kaGlzdG9yeVRyYWNrZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNvbW1hbmRzLm9uKFwiZXhlY1wiLCB0aGlzLiRoaXN0b3J5VHJhY2tlcik7XG5cbiAgICB0aGlzLiRpbml0T3BlcmF0aW9uTGlzdGVuZXJzKCk7XG4gICAgXG4gICAgdGhpcy5fJGVtaXRJbnB1dEV2ZW50ID0gbGFuZy5kZWxheWVkQ2FsbChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiaW5wdXRcIiwge30pO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi5iZ1Rva2VuaXplcilcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5iZ1Rva2VuaXplci5zY2hlZHVsZVN0YXJ0KCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICBcbiAgICB0aGlzLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKF8sIF9zZWxmKSB7XG4gICAgICAgIF9zZWxmLl8kZW1pdElucHV0RXZlbnQuc2NoZWR1bGUoMzEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRTZXNzaW9uKHNlc3Npb24gfHwgbmV3IEVkaXRTZXNzaW9uKFwiXCIpKTtcbiAgICBjb25maWcucmVzZXRPcHRpb25zKHRoaXMpO1xuICAgIGNvbmZpZy5fc2lnbmFsKFwiZWRpdG9yXCIsIHRoaXMpO1xufTtcblxuKGZ1bmN0aW9uKCl7XG5cbiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XG5cbiAgICB0aGlzLiRpbml0T3BlcmF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxhc3QoYSkge3JldHVybiBhW2EubGVuZ3RoIC0gMV19XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuY29tbWFuZHMub24oXCJleGVjXCIsIHRoaXMuc3RhcnRPcGVyYXRpb24uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tbWFuZHMub24oXCJhZnRlckV4ZWNcIiwgdGhpcy5lbmRPcGVyYXRpb24uYmluZCh0aGlzKSwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy4kb3BSZXNldFRpbWVyID0gbGFuZy5kZWxheWVkQ2FsbCh0aGlzLmVuZE9wZXJhdGlvbi5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jdXJPcCB8fCB0aGlzLnN0YXJ0T3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmN1ck9wLmRvY0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9LmJpbmQodGhpcyksIHRydWUpO1xuXG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmN1ck9wIHx8IHRoaXMuc3RhcnRPcGVyYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuY3VyT3AgPSBudWxsO1xuICAgIHRoaXMucHJldk9wID0ge307XG4gICAgdGhpcy5zdGFydE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGNvbW1hZEV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmN1ck9wKSB7XG4gICAgICAgICAgICBpZiAoIWNvbW1hZEV2ZW50IHx8IHRoaXMuY3VyT3AuY29tbWFuZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnByZXZPcCA9IHRoaXMuY3VyT3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21tYWRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgICAgICAgICAgY29tbWFkRXZlbnQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJG9wUmVzZXRUaW1lci5zY2hlZHVsZSgpO1xuICAgICAgICB0aGlzLmN1ck9wID0ge1xuICAgICAgICAgICAgY29tbWFuZDogY29tbWFkRXZlbnQuY29tbWFuZCB8fCB7fSxcbiAgICAgICAgICAgIGFyZ3M6IGNvbW1hZEV2ZW50LmFyZ3MsXG4gICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMucmVuZGVyZXIuc2Nyb2xsVG9wXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmN1ck9wLmNvbW1hbmQubmFtZSAmJiB0aGlzLmN1ck9wLmNvbW1hbmQuc2Nyb2xsSW50b1ZpZXcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuJGJsb2NrU2Nyb2xsaW5nKys7XG4gICAgfTtcblxuICAgIHRoaXMuZW5kT3BlcmF0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJPcCkge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VyT3AgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYmVmb3JlRW5kT3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmN1ck9wLmNvbW1hbmQ7XG4gICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lICYmIHRoaXMuJGJsb2NrU2Nyb2xsaW5nID4gMClcbiAgICAgICAgICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZy0tO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQgJiYgY29tbWFuZC5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZC5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFuaW1hdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImN1cnNvclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3Rpb25QYXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMucmVuZGVyZXIubGF5ZXJDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ID49IGNvbmZpZy5sYXN0Um93IHx8IHJhbmdlLmVuZC5yb3cgPD0gY29uZmlnLmZpcnN0Um93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxTZWxlY3Rpb25JbnRvVmlldyh0aGlzLnNlbGVjdGlvbi5hbmNob3IsIHRoaXMuc2VsZWN0aW9uLmxlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuc2Nyb2xsSW50b1ZpZXcgPT0gXCJhbmltYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYW5pbWF0ZVNjcm9sbGluZyh0aGlzLmN1ck9wLnNjcm9sbFRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucHJldk9wID0gdGhpcy5jdXJPcDtcbiAgICAgICAgICAgIHRoaXMuY3VyT3AgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLiRtZXJnZWFibGVDb21tYW5kcyA9IFtcImJhY2tzcGFjZVwiLCBcImRlbFwiLCBcImluc2VydHN0cmluZ1wiXTtcbiAgICB0aGlzLiRoaXN0b3J5VHJhY2tlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRtZXJnZVVuZG9EZWx0YXMpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZPcDtcbiAgICAgICAgdmFyIG1lcmdlYWJsZUNvbW1hbmRzID0gdGhpcy4kbWVyZ2VhYmxlQ29tbWFuZHM7XG4gICAgICAgIHZhciBzaG91bGRNZXJnZSA9IHByZXYuY29tbWFuZCAmJiAoZS5jb21tYW5kLm5hbWUgPT0gcHJldi5jb21tYW5kLm5hbWUpO1xuICAgICAgICBpZiAoZS5jb21tYW5kLm5hbWUgPT0gXCJpbnNlcnRzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBlLmFyZ3M7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXJnZU5leHRDb21tYW5kID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZU5leHRDb21tYW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgc2hvdWxkTWVyZ2UgPSBzaG91bGRNZXJnZVxuICAgICAgICAgICAgICAgICYmIHRoaXMubWVyZ2VOZXh0Q29tbWFuZCAvLyBwcmV2aW91cyBjb21tYW5kIGFsbG93cyB0byBjb2FsZXNjZSB3aXRoXG4gICAgICAgICAgICAgICAgJiYgKCEvXFxzLy50ZXN0KHRleHQpIHx8IC9cXHMvLnRlc3QocHJldi5hcmdzKSk7IC8vIHByZXZpb3VzIGluc2VydGlvbiB3YXMgb2Ygc2FtZSB0eXBlXG5cbiAgICAgICAgICAgIHRoaXMubWVyZ2VOZXh0Q29tbWFuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG91bGRNZXJnZSA9IHNob3VsZE1lcmdlXG4gICAgICAgICAgICAgICAgJiYgbWVyZ2VhYmxlQ29tbWFuZHMuaW5kZXhPZihlLmNvbW1hbmQubmFtZSkgIT09IC0xOyAvLyB0aGUgY29tbWFuZCBpcyBtZXJnZWFibGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuJG1lcmdlVW5kb0RlbHRhcyAhPSBcImFsd2F5c1wiXG4gICAgICAgICAgICAmJiBEYXRlLm5vdygpIC0gdGhpcy5zZXF1ZW5jZVN0YXJ0VGltZSA+IDIwMDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBzaG91bGRNZXJnZSA9IGZhbHNlOyAvLyB0aGUgc2VxdWVuY2UgaXMgdG9vIGxvbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRNZXJnZSlcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5tZXJnZVVuZG9EZWx0YXMgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChtZXJnZWFibGVDb21tYW5kcy5pbmRleE9mKGUuY29tbWFuZC5uYW1lKSAhPT0gLTEpXG4gICAgICAgICAgICB0aGlzLnNlcXVlbmNlU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0S2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24oa2V5Ym9hcmRIYW5kbGVyLCBjYikge1xuICAgICAgICBpZiAoa2V5Ym9hcmRIYW5kbGVyICYmIHR5cGVvZiBrZXlib2FyZEhhbmRsZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuJGtleWJpbmRpbmdJZCA9IGtleWJvYXJkSGFuZGxlcjtcbiAgICAgICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjb25maWcubG9hZE1vZHVsZShbXCJrZXliaW5kaW5nXCIsIGtleWJvYXJkSGFuZGxlcl0sIGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGlmIChfc2VsZi4ka2V5YmluZGluZ0lkID09IGtleWJvYXJkSGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYua2V5QmluZGluZy5zZXRLZXlib2FyZEhhbmRsZXIobW9kdWxlICYmIG1vZHVsZS5oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRrZXliaW5kaW5nSWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5rZXlCaW5kaW5nLnNldEtleWJvYXJkSGFuZGxlcihrZXlib2FyZEhhbmRsZXIpO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5QmluZGluZy5nZXRLZXlib2FyZEhhbmRsZXIoKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PSBzZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBvbGRTZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAob2xkU2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy4kb25Eb2N1bWVudENoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZU1vZGVcIiwgdGhpcy4kb25DaGFuZ2VNb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwidG9rZW5pemVyVXBkYXRlXCIsIHRoaXMuJG9uVG9rZW5pemVyVXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlVGFiU2l6ZVwiLCB0aGlzLiRvbkNoYW5nZVRhYlNpemUpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VXcmFwTGltaXRcIiwgdGhpcy4kb25DaGFuZ2VXcmFwTGltaXQpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VXcmFwTW9kZVwiLCB0aGlzLiRvbkNoYW5nZVdyYXBNb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwib25DaGFuZ2VGb2xkXCIsIHRoaXMuJG9uQ2hhbmdlRm9sZCk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZUZyb250TWFya2VyXCIsIHRoaXMuJG9uQ2hhbmdlRnJvbnRNYXJrZXIpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VCYWNrTWFya2VyXCIsIHRoaXMuJG9uQ2hhbmdlQmFja01hcmtlcik7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZUJyZWFrcG9pbnRcIiwgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlQW5ub3RhdGlvblwiLCB0aGlzLiRvbkNoYW5nZUFubm90YXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VPdmVyd3JpdGVcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VTY3JvbGxUb3BcIiwgdGhpcy4kb25TY3JvbGxUb3BDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VTY3JvbGxMZWZ0XCIsIHRoaXMuJG9uU2Nyb2xsTGVmdENoYW5nZSk7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlc3Npb24uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZUN1cnNvclwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG4gICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVNlbGVjdGlvblwiLCB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy4kb25Eb2N1bWVudENoYW5nZSA9IHRoaXMub25Eb2N1bWVudENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuJG9uRG9jdW1lbnRDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTZXNzaW9uKHNlc3Npb24pO1xuICAgIFxuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlID0gdGhpcy5vbkNoYW5nZU1vZGUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZU1vZGVcIiwgdGhpcy4kb25DaGFuZ2VNb2RlKTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuJG9uVG9rZW5pemVyVXBkYXRlID0gdGhpcy5vblRva2VuaXplclVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFwidG9rZW5pemVyVXBkYXRlXCIsIHRoaXMuJG9uVG9rZW5pemVyVXBkYXRlKTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlVGFiU2l6ZSA9IHRoaXMucmVuZGVyZXIub25DaGFuZ2VUYWJTaXplLmJpbmQodGhpcy5yZW5kZXJlcik7XG4gICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VUYWJTaXplXCIsIHRoaXMuJG9uQ2hhbmdlVGFiU2l6ZSk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLiRvbkNoYW5nZVdyYXBMaW1pdCA9IHRoaXMub25DaGFuZ2VXcmFwTGltaXQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVdyYXBMaW1pdFwiLCB0aGlzLiRvbkNoYW5nZVdyYXBMaW1pdCk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLiRvbkNoYW5nZVdyYXBNb2RlID0gdGhpcy5vbkNoYW5nZVdyYXBNb2RlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VXcmFwTW9kZVwiLCB0aGlzLiRvbkNoYW5nZVdyYXBNb2RlKTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlRm9sZCA9IHRoaXMub25DaGFuZ2VGb2xkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VGb2xkXCIsIHRoaXMuJG9uQ2hhbmdlRm9sZCk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLiRvbkNoYW5nZUZyb250TWFya2VyID0gdGhpcy5vbkNoYW5nZUZyb250TWFya2VyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZUZyb250TWFya2VyXCIsIHRoaXMuJG9uQ2hhbmdlRnJvbnRNYXJrZXIpO1xuICAgIFxuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VCYWNrTWFya2VyID0gdGhpcy5vbkNoYW5nZUJhY2tNYXJrZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlQmFja01hcmtlclwiLCB0aGlzLiRvbkNoYW5nZUJhY2tNYXJrZXIpO1xuICAgIFxuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50ID0gdGhpcy5vbkNoYW5nZUJyZWFrcG9pbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlQnJlYWtwb2ludFwiLCB0aGlzLiRvbkNoYW5nZUJyZWFrcG9pbnQpO1xuICAgIFxuICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VBbm5vdGF0aW9uID0gdGhpcy5vbkNoYW5nZUFubm90YXRpb24uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlQW5ub3RhdGlvblwiLCB0aGlzLiRvbkNoYW5nZUFubm90YXRpb24pO1xuICAgIFxuICAgICAgICAgICAgdGhpcy4kb25DdXJzb3JDaGFuZ2UgPSB0aGlzLm9uQ3Vyc29yQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZU92ZXJ3cml0ZVwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLiRvblNjcm9sbFRvcENoYW5nZSA9IHRoaXMub25TY3JvbGxUb3BDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlU2Nyb2xsVG9wXCIsIHRoaXMuJG9uU2Nyb2xsVG9wQ2hhbmdlKTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuJG9uU2Nyb2xsTGVmdENoYW5nZSA9IHRoaXMub25TY3JvbGxMZWZ0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVNjcm9sbExlZnRcIiwgdGhpcy4kb25TY3JvbGxMZWZ0Q2hhbmdlKTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2Vzc2lvbi5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VDdXJzb3JcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xuICAgIFxuICAgICAgICAgICAgdGhpcy4kb25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMuJG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VNb2RlKCk7XG4gICAgXG4gICAgICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyArPSAxO1xuICAgICAgICAgICAgdGhpcy5vbkN1cnNvckNoYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgLT0gMTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMub25TY3JvbGxUb3BDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMub25TY3JvbGxMZWZ0Q2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlRnJvbnRNYXJrZXIoKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VCYWNrTWFya2VyKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQnJlYWtwb2ludCgpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUFubm90YXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRVc2VXcmFwTW9kZSgpICYmIHRoaXMucmVuZGVyZXIuYWRqdXN0V3JhcExpbWl0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUZ1bGwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlc3Npb25cIiwge1xuICAgICAgICAgICAgc2Vzc2lvbjogc2Vzc2lvbixcbiAgICAgICAgICAgIG9sZFNlc3Npb246IG9sZFNlc3Npb25cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBvbGRTZXNzaW9uICYmIG9sZFNlc3Npb24uX3NpZ25hbChcImNoYW5nZUVkaXRvclwiLCB7b2xkRWRpdG9yOiB0aGlzfSk7XG4gICAgICAgIHNlc3Npb24gJiYgc2Vzc2lvbi5fc2lnbmFsKFwiY2hhbmdlRWRpdG9yXCIsIHtlZGl0b3I6IHRoaXN9KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uO1xuICAgIH07XG4gICAgdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbCwgY3Vyc29yUG9zKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5kb2Muc2V0VmFsdWUodmFsKTtcblxuICAgICAgICBpZiAoIWN1cnNvclBvcylcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsKCk7XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvclBvcyA9PSAxKVxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUZpbGVFbmQoKTtcbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yUG9zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUZpbGVTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0VmFsdWUoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbjtcbiAgICB9O1xuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vblJlc2l6ZShmb3JjZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldFRoZW1lID0gZnVuY3Rpb24odGhlbWUsIGNiKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0VGhlbWUodGhlbWUsIGNiKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VGhlbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0VGhlbWUoKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0U3R5bGUgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9O1xuICAgIHRoaXMudW5zZXRTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudW5zZXRTdHlsZShzdHlsZSk7XG4gICAgfTtcbiAgICB0aGlzLmdldEZvbnRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJmb250U2l6ZVwiKSB8fFxuICAgICAgICAgICBkb20uY29tcHV0ZWRTdHlsZSh0aGlzLmNvbnRhaW5lciwgXCJmb250U2l6ZVwiKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0Rm9udFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiZm9udFNpemVcIiwgc2l6ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuJGhpZ2hsaWdodEJyYWNrZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uJGJyYWNrZXRIaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVNYXJrZXIodGhpcy5zZXNzaW9uLiRicmFja2V0SGlnaGxpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0UGVuZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy4kaGlnaGxpZ2h0UGVuZGluZyA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLiRoaWdobGlnaHRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHNlbGYuc2Vzc2lvbjtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5iZ1Rva2VuaXplcikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHNlc3Npb24uZmluZE1hdGNoaW5nQnJhY2tldChzZWxmLmdldEN1cnNvclBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uLCBwb3Mucm93LCBwb3MuY29sdW1uICsgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlc3Npb24uJG1vZGUuZ2V0TWF0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZXNzaW9uLiRtb2RlLmdldE1hdGNoaW5nKHNlbGYuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodCA9IHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcImFjZV9icmFja2V0XCIsIFwidGV4dFwiKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH07XG4gICAgdGhpcy4kaGlnaGxpZ2h0VGFncyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0VGFnUGVuZGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiRoaWdobGlnaHRUYWdQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuJGhpZ2hsaWdodFRhZ1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNlc3Npb24gPSBzZWxmLnNlc3Npb247XG4gICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24uYmdUb2tlbml6ZXIpIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBvcyA9IHNlbGYuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlbGYuc2Vzc2lvbiwgcG9zLnJvdywgcG9zLmNvbHVtbik7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCAhL1xcYig/OnRhZy1vcGVufHRhZy1uYW1lKS8udGVzdCh0b2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKHNlc3Npb24uJHRhZ0hpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlLmluZGV4T2YoXCJ0YWctb3BlblwiKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0YWcgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgICAgICB2YXIgcHJldlRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT0gJzwnKXtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4udmFsdWUgPT09IHRhZyAmJiB0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJzwvJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0b2tlbiAmJiBkZXB0aCA+PSAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHByZXZUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcHJldlRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4udmFsdWUgPT09IHRhZyAmJiB0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8LycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldlRva2VuICYmIGRlcHRoIDw9IDApO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZU1hcmtlcihzZXNzaW9uLiR0YWdIaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uJHRhZ0hpZ2hsaWdodCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBjb2x1bW4sIHJvdywgY29sdW1uK3Rva2VuLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0ICYmIHJhbmdlLmNvbXBhcmVSYW5nZShzZXNzaW9uLiRiYWNrTWFya2Vyc1tzZXNzaW9uLiR0YWdIaWdobGlnaHRdLnJhbmdlKSE9PTApIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZU1hcmtlcihzZXNzaW9uLiR0YWdIaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uJHRhZ0hpZ2hsaWdodCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAhc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0KVxuICAgICAgICAgICAgICAgIHNlc3Npb24uJHRhZ0hpZ2hsaWdodCA9IHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcImFjZV9icmFja2V0XCIsIFwidGV4dFwiKTtcbiAgICAgICAgfSwgNTApO1xuICAgIH07XG4gICAgdGhpcy5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3NlbGYudGV4dElucHV0LmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRleHRJbnB1dC5mb2N1cygpO1xuICAgIH07XG4gICAgdGhpcy5pc0ZvY3VzZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dElucHV0LmlzRm9jdXNlZCgpO1xuICAgIH07XG4gICAgdGhpcy5ibHVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGV4dElucHV0LmJsdXIoKTtcbiAgICB9O1xuICAgIHRoaXMub25Gb2N1cyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzRm9jdXNlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaG93Q3Vyc29yKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudmlzdWFsaXplRm9jdXMoKTtcbiAgICAgICAgdGhpcy5fZW1pdChcImZvY3VzXCIsIGUpO1xuICAgIH07XG4gICAgdGhpcy5vbkJsdXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy4kaXNGb2N1c2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiRpc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5oaWRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudmlzdWFsaXplQmx1cigpO1xuICAgICAgICB0aGlzLl9lbWl0KFwiYmx1clwiLCBlKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kY3Vyc29yQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgfTtcbiAgICB0aGlzLm9uRG9jdW1lbnRDaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGUuZGF0YTtcbiAgICAgICAgdmFyIHJhbmdlID0gZGVsdGEucmFuZ2U7XG4gICAgICAgIHZhciBsYXN0Um93O1xuXG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdyAmJiBkZWx0YS5hY3Rpb24gIT0gXCJpbnNlcnRMaW5lc1wiICYmIGRlbHRhLmFjdGlvbiAhPSBcInJlbW92ZUxpbmVzXCIpXG4gICAgICAgICAgICBsYXN0Um93ID0gcmFuZ2UuZW5kLnJvdztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGFzdFJvdyA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUxpbmVzKHJhbmdlLnN0YXJ0LnJvdywgbGFzdFJvdywgdGhpcy5zZXNzaW9uLiR1c2VXcmFwTW9kZSk7XG5cbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiY2hhbmdlXCIsIGUpO1xuICAgICAgICB0aGlzLiRjdXJzb3JDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy4kdXBkYXRlSGlnaGxpZ2h0QWN0aXZlTGluZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uVG9rZW5pemVyVXBkYXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcm93cyA9IGUuZGF0YTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVMaW5lcyhyb3dzLmZpcnN0LCByb3dzLmxhc3QpO1xuICAgIH07XG5cblxuICAgIHRoaXMub25TY3JvbGxUb3BDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb1kodGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblNjcm9sbExlZnRDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb1godGhpcy5zZXNzaW9uLmdldFNjcm9sbExlZnQoKSk7XG4gICAgfTtcbiAgICB0aGlzLm9uQ3Vyc29yQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGN1cnNvckNoYW5nZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy4kYmxvY2tTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIGNvbmZpZy53YXJuKFwiQXV0b21hdGljYWxseSBzY3JvbGxpbmcgY3Vyc29yIGludG8gdmlldyBhZnRlciBzZWxlY3Rpb24gY2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgXCJ0aGlzIHdpbGwgYmUgZGlzYWJsZWQgaW4gdGhlIG5leHQgdmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIFwic2V0IGVkaXRvci4kYmxvY2tTY3JvbGxpbmcgPSBJbmZpbml0eSB0byBkaXNhYmxlIHRoaXMgbWVzc2FnZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kaGlnaGxpZ2h0QnJhY2tldHMoKTtcbiAgICAgICAgdGhpcy4kaGlnaGxpZ2h0VGFncygpO1xuICAgICAgICB0aGlzLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lKCk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kdXBkYXRlSGlnaGxpZ2h0QWN0aXZlTGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuZ2V0U2Vzc2lvbigpO1xuXG4gICAgICAgIHZhciBoaWdobGlnaHQ7XG4gICAgICAgIGlmICh0aGlzLiRoaWdobGlnaHRBY3RpdmVMaW5lKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuJHNlbGVjdGlvblN0eWxlICE9IFwibGluZVwiIHx8ICF0aGlzLnNlbGVjdGlvbi5pc011bHRpTGluZSgpKSlcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlci4kbWF4TGluZXMgJiYgdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpID09PSAxICYmICEodGhpcy5yZW5kZXJlci4kbWluTGluZXMgPiAxKSlcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyICYmICFoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuaWQpO1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIgJiYgaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoaGlnaGxpZ2h0LnJvdywgaGlnaGxpZ2h0LmNvbHVtbiwgaGlnaGxpZ2h0LnJvdywgSW5maW5pdHkpO1xuICAgICAgICAgICAgcmFuZ2UuaWQgPSBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgXCJhY2VfYWN0aXZlLWxpbmVcIiwgXCJzY3JlZW5MaW5lXCIpO1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlciA9IHJhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlci5zdGFydC5yb3cgPSBoaWdobGlnaHQucm93O1xuICAgICAgICAgICAgc2Vzc2lvbi4kaGlnaGxpZ2h0TGluZU1hcmtlci5lbmQucm93ID0gaGlnaGxpZ2h0LnJvdztcbiAgICAgICAgICAgIHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuc3RhcnQuY29sdW1uID0gaGlnaGxpZ2h0LmNvbHVtbjtcbiAgICAgICAgICAgIHNlc3Npb24uX3NpZ25hbChcImNoYW5nZUJhY2tNYXJrZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICAgICAgaWYgKHNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcikge1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIoc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXIgPSBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZSgpO1xuICAgICAgICAgICAgc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VyID0gc2Vzc2lvbi5hZGRNYXJrZXIocmFuZ2UsIFwiYWNlX3NlbGVjdGlvblwiLCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmUgPSB0aGlzLiRoaWdobGlnaHRTZWxlY3RlZFdvcmQgJiYgdGhpcy4kZ2V0U2VsZWN0aW9uSGlnaExpZ2h0UmVnZXhwKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5oaWdobGlnaHQocmUpO1xuXG4gICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kZ2V0U2VsZWN0aW9uSGlnaExpZ2h0UmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuXG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uaXNFbXB0eSgpIHx8IHNlbGVjdGlvbi5pc011bHRpTGluZSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzdGFydE91dGVyID0gc2VsZWN0aW9uLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgICAgIHZhciBlbmRPdXRlciA9IHNlbGVjdGlvbi5lbmQuY29sdW1uICsgMTtcbiAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoc2VsZWN0aW9uLnN0YXJ0LnJvdyk7XG4gICAgICAgIHZhciBsaW5lQ29scyA9IGxpbmUubGVuZ3RoO1xuICAgICAgICB2YXIgbmVlZGxlID0gbGluZS5zdWJzdHJpbmcoTWF0aC5tYXgoc3RhcnRPdXRlciwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihlbmRPdXRlciwgbGluZUNvbHMpKTtcbiAgICAgICAgaWYgKChzdGFydE91dGVyID49IDAgJiYgL15bXFx3XFxkXS8udGVzdChuZWVkbGUpKSB8fFxuICAgICAgICAgICAgKGVuZE91dGVyIDw9IGxpbmVDb2xzICYmIC9bXFx3XFxkXSQvLnRlc3QobmVlZGxlKSkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbmVlZGxlID0gbGluZS5zdWJzdHJpbmcoc2VsZWN0aW9uLnN0YXJ0LmNvbHVtbiwgc2VsZWN0aW9uLmVuZC5jb2x1bW4pO1xuICAgICAgICBpZiAoIS9eW1xcd1xcZF0rJC8udGVzdChuZWVkbGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciByZSA9IHRoaXMuJHNlYXJjaC4kYXNzZW1ibGVSZWdFeHAoe1xuICAgICAgICAgICAgd2hvbGVXb3JkOiB0cnVlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG5lZWRsZTogbmVlZGxlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLm9uQ2hhbmdlRnJvbnRNYXJrZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVGcm9udE1hcmtlcnMoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNoYW5nZUJhY2tNYXJrZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xuICAgIH07XG5cblxuICAgIHRoaXMub25DaGFuZ2VCcmVha3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQnJlYWtwb2ludHMoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNoYW5nZUFubm90YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbm5vdGF0aW9ucyh0aGlzLnNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKSk7XG4gICAgfTtcblxuXG4gICAgdGhpcy5vbkNoYW5nZU1vZGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlVGV4dCgpO1xuICAgICAgICB0aGlzLl9lbWl0KFwiY2hhbmdlTW9kZVwiLCBlKTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLm9uQ2hhbmdlV3JhcExpbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uQ2hhbmdlV3JhcE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vblJlc2l6ZSh0cnVlKTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLm9uQ2hhbmdlRm9sZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q29weVRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJjb3B5XCIsIHRleHQpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIHRoaXMub25Db3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImNvcHlcIiwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm9uQ3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImN1dFwiLCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMub25QYXN0ZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuJHJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBlID0ge3RleHQ6IHRleHR9O1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJwYXN0ZVwiLCBlKTtcbiAgICAgICAgdGV4dCA9IGUudGV4dDtcbiAgICAgICAgaWYgKCF0aGlzLmluTXVsdGlTZWxlY3RNb2RlIHx8IHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQodGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZXM7XG5cbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiByYW5nZXMubGVuZ3RoIHx8IGxpbmVzLmxlbmd0aCA8IDIgfHwgIWxpbmVzWzFdKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRzdHJpbmdcIiwgdGhpcywgdGV4dCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5pbnNlcnQocmFuZ2Uuc3RhcnQsIGxpbmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG4gICAgfTtcblxuICAgIHRoaXMuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbihjb21tYW5kLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzLmV4ZWMoY29tbWFuZCwgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICB0aGlzLmluc2VydCA9IGZ1bmN0aW9uKHRleHQsIHBhc3RlZCkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIG1vZGUgPSBzZXNzaW9uLmdldE1vZGUoKTtcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5nZXRCZWhhdmlvdXJzRW5hYmxlZCgpICYmICFwYXN0ZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtb2RlLnRyYW5zZm9ybUFjdGlvbihzZXNzaW9uLmdldFN0YXRlKGN1cnNvci5yb3cpLCAnaW5zZXJ0aW9uJywgdGhpcywgc2Vzc2lvbiwgdGV4dCk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQgIT09IHRyYW5zZm9ybS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5tZXJnZVVuZG9EZWx0YXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWVyZ2VOZXh0Q29tbWFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ID0gdHJhbnNmb3JtLnRleHQ7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRleHQgPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICBjdXJzb3IgPSB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlc3Npb24uZ2V0T3ZlcndyaXRlKCkpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZS5mcm9tUG9pbnRzKGN1cnNvciwgY3Vyc29yKTtcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0ID09IFwiXFxuXCIgfHwgdGV4dCA9PSBcIlxcclxcblwiKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgICAgIGlmIChjdXJzb3IuY29sdW1uID4gbGluZS5zZWFyY2goL1xcU3wkLykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pLnNlYXJjaCgvXFxTfCQvKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmRvYy5yZW1vdmVJbkxpbmUoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblxuICAgICAgICB2YXIgc3RhcnQgPSBjdXJzb3IuY29sdW1uO1xuICAgICAgICB2YXIgbGluZVN0YXRlID0gc2Vzc2lvbi5nZXRTdGF0ZShjdXJzb3Iucm93KTtcbiAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgIHZhciBzaG91bGRPdXRkZW50ID0gbW9kZS5jaGVja091dGRlbnQobGluZVN0YXRlLCBsaW5lLCB0ZXh0KTtcbiAgICAgICAgdmFyIGVuZCA9IHNlc3Npb24uaW5zZXJ0KGN1cnNvciwgdGV4dCk7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0uc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtLnNlbGVjdGlvbi5sZW5ndGggPT0gMikgeyAvLyBUcmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY29sdW1uXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZShjdXJzb3Iucm93LCBzdGFydCArIHRyYW5zZm9ybS5zZWxlY3Rpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iucm93LCBzdGFydCArIHRyYW5zZm9ybS5zZWxlY3Rpb25bMV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIFRyYW5zZm9ybSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCByb3cuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZShjdXJzb3Iucm93ICsgdHJhbnNmb3JtLnNlbGVjdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5zZWxlY3Rpb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iucm93ICsgdHJhbnNmb3JtLnNlbGVjdGlvblsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5zZWxlY3Rpb25bM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXNzaW9uLmdldERvY3VtZW50KCkuaXNOZXdMaW5lKHRleHQpKSB7XG4gICAgICAgICAgICB2YXIgbGluZUluZGVudCA9IG1vZGUuZ2V0TmV4dExpbmVJbmRlbnQobGluZVN0YXRlLCBsaW5lLnNsaWNlKDAsIGN1cnNvci5jb2x1bW4pLCBzZXNzaW9uLmdldFRhYlN0cmluZygpKTtcblxuICAgICAgICAgICAgc2Vzc2lvbi5pbnNlcnQoe3JvdzogY3Vyc29yLnJvdysxLCBjb2x1bW46IDB9LCBsaW5lSW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkT3V0ZGVudClcbiAgICAgICAgICAgIG1vZGUuYXV0b091dGRlbnQobGluZVN0YXRlLCBzZXNzaW9uLCBjdXJzb3Iucm93KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblRleHRJbnB1dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdGhpcy5rZXlCaW5kaW5nLm9uVGV4dElucHV0KHRleHQpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uQ29tbWFuZEtleSA9IGZ1bmN0aW9uKGUsIGhhc2hJZCwga2V5Q29kZSkge1xuICAgICAgICB0aGlzLmtleUJpbmRpbmcub25Db21tYW5kS2V5KGUsIGhhc2hJZCwga2V5Q29kZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uKG92ZXJ3cml0ZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24uc2V0T3ZlcndyaXRlKG92ZXJ3cml0ZSk7XG4gICAgfTtcbiAgICB0aGlzLmdldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldE92ZXJ3cml0ZSgpO1xuICAgIH07XG4gICAgdGhpcy50b2dnbGVPdmVyd3JpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnRvZ2dsZU92ZXJ3cml0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5zZXRTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwic2Nyb2xsU3BlZWRcIiwgc3BlZWQpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJzY3JvbGxTcGVlZFwiKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0RHJhZ0RlbGF5ID0gZnVuY3Rpb24oZHJhZ0RlbGF5KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiZHJhZ0RlbGF5XCIsIGRyYWdEZWxheSk7XG4gICAgfTtcbiAgICB0aGlzLmdldERyYWdEZWxheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJkcmFnRGVsYXlcIik7XG4gICAgfTtcbiAgICB0aGlzLnNldFNlbGVjdGlvblN0eWxlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwic2VsZWN0aW9uU3R5bGVcIiwgdmFsKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwic2VsZWN0aW9uU3R5bGVcIik7XG4gICAgfTtcbiAgICB0aGlzLnNldEhpZ2hsaWdodEFjdGl2ZUxpbmUgPSBmdW5jdGlvbihzaG91bGRIaWdobGlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJoaWdobGlnaHRBY3RpdmVMaW5lXCIsIHNob3VsZEhpZ2hsaWdodCk7XG4gICAgfTtcbiAgICB0aGlzLmdldEhpZ2hsaWdodEFjdGl2ZUxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwiaGlnaGxpZ2h0QWN0aXZlTGluZVwiKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0SGlnaGxpZ2h0R3V0dGVyTGluZSA9IGZ1bmN0aW9uKHNob3VsZEhpZ2hsaWdodCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImhpZ2hsaWdodEd1dHRlckxpbmVcIiwgc2hvdWxkSGlnaGxpZ2h0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRIaWdobGlnaHRHdXR0ZXJMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImhpZ2hsaWdodEd1dHRlckxpbmVcIik7XG4gICAgfTtcbiAgICB0aGlzLnNldEhpZ2hsaWdodFNlbGVjdGVkV29yZCA9IGZ1bmN0aW9uKHNob3VsZEhpZ2hsaWdodCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImhpZ2hsaWdodFNlbGVjdGVkV29yZFwiLCBzaG91bGRIaWdobGlnaHQpO1xuICAgIH07XG4gICAgdGhpcy5nZXRIaWdobGlnaHRTZWxlY3RlZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGhpZ2hsaWdodFNlbGVjdGVkV29yZDtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRBbmltYXRlZFNjcm9sbCA9IGZ1bmN0aW9uKHNob3VsZEFuaW1hdGUpe1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEFuaW1hdGVkU2Nyb2xsKHNob3VsZEFuaW1hdGUpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEFuaW1hdGVkU2Nyb2xsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0QW5pbWF0ZWRTY3JvbGwoKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbihzaG93SW52aXNpYmxlcykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNob3dJbnZpc2libGVzKHNob3dJbnZpc2libGVzKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0U2hvd0ludmlzaWJsZXMoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXREaXNwbGF5SW5kZW50R3VpZGVzID0gZnVuY3Rpb24oZGlzcGxheSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldERpc3BsYXlJbmRlbnRHdWlkZXMoZGlzcGxheSk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXREaXNwbGF5SW5kZW50R3VpZGVzKCk7XG4gICAgfTtcbiAgICB0aGlzLnNldFNob3dQcmludE1hcmdpbiA9IGZ1bmN0aW9uKHNob3dQcmludE1hcmdpbikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNob3dQcmludE1hcmdpbihzaG93UHJpbnRNYXJnaW4pO1xuICAgIH07XG4gICAgdGhpcy5nZXRTaG93UHJpbnRNYXJnaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0U2hvd1ByaW50TWFyZ2luKCk7XG4gICAgfTtcbiAgICB0aGlzLnNldFByaW50TWFyZ2luQ29sdW1uID0gZnVuY3Rpb24oc2hvd1ByaW50TWFyZ2luKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJpbnRNYXJnaW5Db2x1bW4oc2hvd1ByaW50TWFyZ2luKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UHJpbnRNYXJnaW5Db2x1bW4oKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0UmVhZE9ubHkgPSBmdW5jdGlvbihyZWFkT25seSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcInJlYWRPbmx5XCIsIHJlYWRPbmx5KTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0UmVhZE9ubHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFwicmVhZE9ubHlcIik7XG4gICAgfTtcbiAgICB0aGlzLnNldEJlaGF2aW91cnNFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJiZWhhdmlvdXJzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0QmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImJlaGF2aW91cnNFbmFibGVkXCIpO1xuICAgIH07XG4gICAgdGhpcy5zZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcIndyYXBCZWhhdmlvdXJzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0V3JhcEJlaGF2aW91cnNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJ3cmFwQmVoYXZpb3Vyc0VuYWJsZWRcIik7XG4gICAgfTtcbiAgICB0aGlzLnNldFNob3dGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKHNob3cpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJzaG93Rm9sZFdpZGdldHNcIiwgc2hvdyk7XG5cbiAgICB9O1xuICAgIHRoaXMuZ2V0U2hvd0ZvbGRXaWRnZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dGb2xkV2lkZ2V0c1wiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRGYWRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbihmYWRlKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiZmFkZUZvbGRXaWRnZXRzXCIsIGZhZGUpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZhZGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJmYWRlRm9sZFdpZGdldHNcIik7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uKGRpcikge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKXtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gXCJsZWZ0XCIpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0TGVmdCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFJpZ2h0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmICh0aGlzLmdldEJlaGF2aW91cnNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gc2Vzc2lvbi5nZXRTdGF0ZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIG5ld19yYW5nZSA9IHNlc3Npb24uZ2V0TW9kZSgpLnRyYW5zZm9ybUFjdGlvbihzdGF0ZSwgJ2RlbGV0aW9uJywgdGhpcywgc2Vzc2lvbiwgcmFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kLmNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyYW5nZS5lbmQucm93KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eXFxzKyQvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdfcmFuZ2UpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXdfcmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVXb3JkUmlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFdvcmRSaWdodCgpO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVXb3JkTGVmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0V29yZExlZnQoKTtcblxuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlVG9MaW5lU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdExpbmVTdGFydCgpO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVUb0xpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdExpbmVFbmQoKTtcblxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydC5jb2x1bW4gPT0gcmFuZ2UuZW5kLmNvbHVtbiAmJiByYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdykge1xuICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICByYW5nZS5lbmQucm93Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5zcGxpdExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0KFwiXFxuXCIpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKGN1cnNvcik7XG4gICAgfTtcbiAgICB0aGlzLnRyYW5zcG9zZUxldHRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBjb2x1bW4gPSBjdXJzb3IuY29sdW1uO1xuICAgICAgICBpZiAoY29sdW1uID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgIHZhciBzd2FwLCByYW5nZTtcbiAgICAgICAgaWYgKGNvbHVtbiA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2FwID0gbGluZS5jaGFyQXQoY29sdW1uKSArIGxpbmUuY2hhckF0KGNvbHVtbi0xKTtcbiAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5yb3csIGNvbHVtbi0xLCBjdXJzb3Iucm93LCBjb2x1bW4rMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2FwID0gbGluZS5jaGFyQXQoY29sdW1uLTEpICsgbGluZS5jaGFyQXQoY29sdW1uLTIpO1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLnJvdywgY29sdW1uLTIsIGN1cnNvci5yb3csIGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLnJlcGxhY2UocmFuZ2UsIHN3YXApO1xuICAgIH07XG4gICAgdGhpcy50b0xvd2VyQ2FzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxSYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0V29yZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVwbGFjZShyYW5nZSwgdGV4dC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2Uob3JpZ2luYWxSYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLnRvVXBwZXJDYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCB0ZXh0LnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShvcmlnaW5hbFJhbmdlKTtcbiAgICB9O1xuICAgIHRoaXMuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG5cbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA8IHJhbmdlLmVuZC5yb3cpIHtcbiAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgICAgICBzZXNzaW9uLmluZGVudFJvd3Mocm93cy5maXJzdCwgcm93cy5sYXN0LCBcIlxcdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5zdGFydC5jb2x1bW4gPCByYW5nZS5lbmQuY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGlmICghL15cXHMrJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5pbmRlbnRSb3dzKHJvd3MuZmlyc3QsIHJvd3MubGFzdCwgXCJcXHRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSByYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIHNpemUgPSBzZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlbkNvbHVtbihwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XG5cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5nZXRVc2VTb2Z0VGFicygpKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAoc2l6ZSAtIGNvbHVtbiAlIHNpemUpO1xuICAgICAgICAgICAgdmFyIGluZGVudFN0cmluZyA9IGxhbmcuc3RyaW5nUmVwZWF0KFwiIFwiLCBjb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBjb2x1bW4gJSBzaXplO1xuICAgICAgICAgICAgd2hpbGUgKGxpbmVbcmFuZ2Uuc3RhcnQuY29sdW1uXSA9PSBcIiBcIiAmJiBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbi0tO1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBpbmRlbnRTdHJpbmcgPSBcIlxcdFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChpbmRlbnRTdHJpbmcpO1xuICAgIH07XG4gICAgdGhpcy5ibG9ja0luZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB0aGlzLnNlc3Npb24uaW5kZW50Um93cyhyb3dzLmZpcnN0LCByb3dzLmxhc3QsIFwiXFx0XCIpO1xuICAgIH07XG4gICAgdGhpcy5ibG9ja091dGRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2Vzc2lvbi5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLm91dGRlbnRSb3dzKHNlbGVjdGlvbi5nZXRSYW5nZSgpKTtcbiAgICB9O1xuICAgIHRoaXMuc29ydExpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSByb3dzLmZpcnN0OyBpIDw9IHJvd3MubGFzdDsgaSsrKVxuICAgICAgICAgICAgbGluZXMucHVzaChzZXNzaW9uLmdldExpbmUoaSkpO1xuXG4gICAgICAgIGxpbmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKGEudG9Mb3dlckNhc2UoKSA8IGIudG9Mb3dlckNhc2UoKSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGEudG9Mb3dlckNhc2UoKSA+IGIudG9Mb3dlckNhc2UoKSkgcmV0dXJuIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGRlbGV0ZVJhbmdlID0gbmV3IFJhbmdlKDAsIDAsIDAsIDApO1xuICAgICAgICBmb3IgKHZhciBpID0gcm93cy5maXJzdDsgaSA8PSByb3dzLmxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoaSk7XG4gICAgICAgICAgICBkZWxldGVSYW5nZS5zdGFydC5yb3cgPSBpO1xuICAgICAgICAgICAgZGVsZXRlUmFuZ2UuZW5kLnJvdyA9IGk7XG4gICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQuY29sdW1uID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBzZXNzaW9uLnJlcGxhY2UoZGVsZXRlUmFuZ2UsIGxpbmVzW2ktcm93cy5maXJzdF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnRvZ2dsZUNvbW1lbnRMaW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNlc3Npb24uZ2V0U3RhdGUodGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpLnJvdyk7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRNb2RlKCkudG9nZ2xlQ29tbWVudExpbmVzKHN0YXRlLCB0aGlzLnNlc3Npb24sIHJvd3MuZmlyc3QsIHJvd3MubGFzdCk7XG4gICAgfTtcblxuICAgIHRoaXMudG9nZ2xlQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Vzc2lvbi5nZXRTdGF0ZShjdXJzb3Iucm93KTtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB0aGlzLnNlc3Npb24uZ2V0TW9kZSgpLnRvZ2dsZUJsb2NrQ29tbWVudChzdGF0ZSwgdGhpcy5zZXNzaW9uLCByYW5nZSwgY3Vyc29yKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TnVtYmVyQXQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgX251bWJlclJ4ID0gL1tcXC1dP1swLTldKyg/OlxcLlswLTldKyk/L2c7XG4gICAgICAgIF9udW1iZXJSeC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgIHZhciBzID0gdGhpcy5zZXNzaW9uLmdldExpbmUocm93KTtcbiAgICAgICAgd2hpbGUgKF9udW1iZXJSeC5sYXN0SW5kZXggPCBjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBtID0gX251bWJlclJ4LmV4ZWMocyk7XG4gICAgICAgICAgICBpZihtLmluZGV4IDw9IGNvbHVtbiAmJiBtLmluZGV4K21bMF0ubGVuZ3RoID49IGNvbHVtbil7XG4gICAgICAgICAgICAgICAgdmFyIG51bWJlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1bMF0sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBtLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG0uaW5kZXgrbVswXS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICB0aGlzLm1vZGlmeU51bWJlciA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkucm93O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkuY29sdW1uO1xuICAgICAgICB2YXIgY2hhclJhbmdlID0gbmV3IFJhbmdlKHJvdywgY29sdW1uLTEsIHJvdywgY29sdW1uKTtcblxuICAgICAgICB2YXIgYyA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UoY2hhclJhbmdlKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KGMpKSAmJiBpc0Zpbml0ZShjKSkge1xuICAgICAgICAgICAgdmFyIG5yID0gdGhpcy5nZXROdW1iZXJBdChyb3csIGNvbHVtbik7XG4gICAgICAgICAgICBpZiAobnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnAgPSBuci52YWx1ZS5pbmRleE9mKFwiLlwiKSA+PSAwID8gbnIuc3RhcnQgKyBuci52YWx1ZS5pbmRleE9mKFwiLlwiKSArIDEgOiBuci5lbmQ7XG4gICAgICAgICAgICAgICAgdmFyIGRlY2ltYWxzID0gbnIuc3RhcnQgKyBuci52YWx1ZS5sZW5ndGggLSBmcDtcblxuICAgICAgICAgICAgICAgIHZhciB0ID0gcGFyc2VGbG9hdChuci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdCAqPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuXG5cbiAgICAgICAgICAgICAgICBpZihmcCAhPT0gbnIuZW5kICYmIGNvbHVtbiA8IGZwKXtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50ICo9IE1hdGgucG93KDEwLCBuci5lbmQgLSBjb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQgKj0gTWF0aC5wb3coMTAsIG5yLmVuZCAtIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdCArPSBhbW91bnQ7XG4gICAgICAgICAgICAgICAgdCAvPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIHZhciBubnIgPSB0LnRvRml4ZWQoZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlUmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBuci5zdGFydCwgcm93LCBuci5lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJlcGxhY2VSYW5nZSwgbm5yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIE1hdGgubWF4KG5yLnN0YXJ0ICsxLCBjb2x1bW4gKyBubnIubGVuZ3RoIC0gbnIudmFsdWUubGVuZ3RoKSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZW1vdmVMaW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB2YXIgcmFuZ2U7XG4gICAgICAgIGlmIChyb3dzLmZpcnN0ID09PSAwIHx8IHJvd3MubGFzdCsxIDwgdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpKVxuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2Uocm93cy5maXJzdCwgMCwgcm93cy5sYXN0KzEsIDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShcbiAgICAgICAgICAgICAgICByb3dzLmZpcnN0LTEsIHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvd3MuZmlyc3QtMSkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHJvd3MubGFzdCwgdGhpcy5zZXNzaW9uLmdldExpbmUocm93cy5sYXN0KS5sZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZHVwbGljYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIGRvYyA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIHJhbmdlID0gc2VsLmdldFJhbmdlKCk7XG4gICAgICAgIHZhciByZXZlcnNlID0gc2VsLmlzQmFja3dhcmRzKCk7XG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICBkb2MuZHVwbGljYXRlTGluZXMocm93LCByb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHJhbmdlLnN0YXJ0IDogcmFuZ2UuZW5kO1xuICAgICAgICAgICAgdmFyIGVuZFBvaW50ID0gZG9jLmluc2VydChwb2ludCwgZG9jLmdldFRleHRSYW5nZShyYW5nZSksIGZhbHNlKTtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gcG9pbnQ7XG4gICAgICAgICAgICByYW5nZS5lbmQgPSBlbmRQb2ludDtcblxuICAgICAgICAgICAgc2VsLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlLCByZXZlcnNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tb3ZlTGluZXNEb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVMaW5lcygxLCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLm1vdmVMaW5lc1VwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVMaW5lcygtMSwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlVGV4dCA9IGZ1bmN0aW9uKHJhbmdlLCB0b1Bvc2l0aW9uLCBjb3B5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24ubW92ZVRleHQocmFuZ2UsIHRvUG9zaXRpb24sIGNvcHkpO1xuICAgIH07XG4gICAgdGhpcy5jb3B5TGluZXNVcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtb3ZlTGluZXMoLTEsIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5jb3B5TGluZXNEb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVMaW5lcygxLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuJG1vdmVMaW5lcyA9IGZ1bmN0aW9uKGRpciwgY29weSkge1xuICAgICAgICB2YXIgcm93cywgbW92ZWQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24uaW5NdWx0aVNlbGVjdE1vZGUgfHwgdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgICAgICByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKHJhbmdlKTtcbiAgICAgICAgICAgIG1vdmVkID0gdGhpcy5zZXNzaW9uLiRtb3ZlTGluZXMocm93cy5maXJzdCwgcm93cy5sYXN0LCBjb3B5ID8gMCA6IGRpcik7XG4gICAgICAgICAgICBpZiAoY29weSAmJiBkaXIgPT0gLTEpIG1vdmVkID0gMDtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVCeShtb3ZlZCwgMCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VzO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnJhbmdlTGlzdC5kZXRhY2godGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBkaWZmID0gMDtcbiAgICAgICAgICAgIHZhciB0b3RhbERpZmYgPSAwO1xuICAgICAgICAgICAgdmFyIGwgPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzW2ldLm1vdmVCeShkaWZmLCAwKTtcbiAgICAgICAgICAgICAgICByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gcm93cy5maXJzdDtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHJvd3MubGFzdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxEaWZmKSByYW5nZXNbaV0ubW92ZUJ5KHRvdGFsRGlmZiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJSb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3B5ICYmIHN1YlJvd3MuZmlyc3QgIT0gbGFzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghY29weSAmJiBzdWJSb3dzLmZpcnN0ID4gbGFzdCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHN1YlJvd3MubGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLnNlc3Npb24uJG1vdmVMaW5lcyhmaXJzdCwgbGFzdCwgY29weSA/IDAgOiBkaXIpO1xuICAgICAgICAgICAgICAgIGlmIChjb3B5ICYmIGRpciA9PSAtMSkgcmFuZ2VJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZUluZGV4IDw9IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzW3JhbmdlSW5kZXhdLm1vdmVCeShkaWZmLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpIGRpZmYgPSAwO1xuICAgICAgICAgICAgICAgIHRvdGFsRGlmZiArPSBkaWZmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2Uoc2VsZWN0aW9uLnJhbmdlc1swXSk7XG4gICAgICAgICAgICBzZWxlY3Rpb24ucmFuZ2VMaXN0LmF0dGFjaCh0aGlzLnNlc3Npb24pO1xuICAgICAgICAgICAgdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuJGdldFNlbGVjdGVkUm93cyA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gKHJhbmdlIHx8IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSkuY29sbGFwc2VSb3dzKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcnN0OiB0aGlzLnNlc3Npb24uZ2V0Um93Rm9sZFN0YXJ0KHJhbmdlLnN0YXJ0LnJvdyksXG4gICAgICAgICAgICBsYXN0OiB0aGlzLnNlc3Npb24uZ2V0Um93Rm9sZEVuZChyYW5nZS5lbmQucm93KVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLm9uQ29tcG9zaXRpb25TdGFydCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaG93Q29tcG9zaXRpb24odGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNvbXBvc2l0aW9uVXBkYXRlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENvbXBvc2l0aW9uVGV4dCh0ZXh0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuaGlkZUNvbXBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldEZpcnN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRGaXJzdFZpc2libGVSb3coKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TGFzdFZpc2libGVSb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0TGFzdFZpc2libGVSb3coKTtcbiAgICB9O1xuICAgIHRoaXMuaXNSb3dWaXNpYmxlID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiAocm93ID49IHRoaXMuZ2V0Rmlyc3RWaXNpYmxlUm93KCkgJiYgcm93IDw9IHRoaXMuZ2V0TGFzdFZpc2libGVSb3coKSk7XG4gICAgfTtcbiAgICB0aGlzLmlzUm93RnVsbHlWaXNpYmxlID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiAocm93ID49IHRoaXMucmVuZGVyZXIuZ2V0Rmlyc3RGdWxseVZpc2libGVSb3coKSAmJiByb3cgPD0gdGhpcy5yZW5kZXJlci5nZXRMYXN0RnVsbHlWaXNpYmxlUm93KCkpO1xuICAgIH07XG4gICAgdGhpcy4kZ2V0VmlzaWJsZVJvd0NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFNjcm9sbEJvdHRvbVJvdygpIC0gdGhpcy5yZW5kZXJlci5nZXRTY3JvbGxUb3BSb3coKSArIDE7XG4gICAgfTtcblxuICAgIHRoaXMuJG1vdmVCeVBhZ2UgPSBmdW5jdGlvbihkaXIsIHNlbGVjdCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5yZW5kZXJlci5sYXllckNvbmZpZztcbiAgICAgICAgdmFyIHJvd3MgPSBkaXIgKiBNYXRoLmZsb29yKGNvbmZpZy5oZWlnaHQgLyBjb25maWcubGluZUhlaWdodCk7XG5cbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcrKztcbiAgICAgICAgaWYgKHNlbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uJG1vdmVTZWxlY3Rpb24oZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JCeShyb3dzLCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JCeShyb3dzLCAwKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmctLTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gcmVuZGVyZXIuc2Nyb2xsVG9wO1xuXG4gICAgICAgIHJlbmRlcmVyLnNjcm9sbEJ5KDAsIHJvd3MgKiBjb25maWcubGluZUhlaWdodCk7XG4gICAgICAgIGlmIChzZWxlY3QgIT0gbnVsbClcbiAgICAgICAgICAgIHJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XG5cbiAgICAgICAgcmVuZGVyZXIuYW5pbWF0ZVNjcm9sbGluZyhzY3JvbGxUb3ApO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RQYWdlRG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtb3ZlQnlQYWdlKDEsIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RQYWdlVXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kbW92ZUJ5UGFnZSgtMSwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmdvdG9QYWdlRG93biA9IGZ1bmN0aW9uKCkge1xuICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoMSwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5nb3RvUGFnZVVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoLTEsIGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsUGFnZURvd24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kbW92ZUJ5UGFnZSgxKTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsUGFnZVVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoLTEpO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb1JvdyA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvUm93KHJvdyk7XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvTGluZSA9IGZ1bmN0aW9uKGxpbmUsIGNlbnRlciwgYW5pbWF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb0xpbmUobGluZSwgY2VudGVyLCBhbmltYXRlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmNlbnRlclNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgICAgICByb3c6IE1hdGguZmxvb3IocmFuZ2Uuc3RhcnQucm93ICsgKHJhbmdlLmVuZC5yb3cgLSByYW5nZS5zdGFydC5yb3cpIC8gMiksXG4gICAgICAgICAgICBjb2x1bW46IE1hdGguZmxvb3IocmFuZ2Uuc3RhcnQuY29sdW1uICsgKHJhbmdlLmVuZC5jb2x1bW4gLSByYW5nZS5zdGFydC5jb2x1bW4pIC8gMilcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hbGlnbkN1cnNvcihwb3MsIDAuNSk7XG4gICAgfTtcbiAgICB0aGlzLmdldEN1cnNvclBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb25TY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgfTtcbiAgICB0aGlzLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyArPSAxO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgLT0gMTtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvclRvID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvclRvKHJvdywgY29sdW1uKTtcbiAgICB9O1xuICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24gPSBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvclRvUG9zaXRpb24ocG9zKTtcbiAgICB9O1xuICAgIHRoaXMuanVtcFRvTWF0Y2hpbmcgPSBmdW5jdGlvbihzZWxlY3QsIGV4cGFuZCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLnNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICB2YXIgcHJldlRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHZhciB0b2tlbiA9IHByZXZUb2tlbiB8fCBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuXG4gICAgICAgIGlmICghdG9rZW4pIHJldHVybjtcbiAgICAgICAgdmFyIG1hdGNoVHlwZTtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIHZhciBkZXB0aCA9IHt9O1xuICAgICAgICB2YXIgaSA9IGN1cnNvci5jb2x1bW4gLSB0b2tlbi5zdGFydDtcbiAgICAgICAgdmFyIGJyYWNrZXRUeXBlO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSB7XG4gICAgICAgICAgICBcIilcIjogXCIoXCIsXG4gICAgICAgICAgICBcIihcIjogXCIoXCIsXG4gICAgICAgICAgICBcIl1cIjogXCJbXCIsXG4gICAgICAgICAgICBcIltcIjogXCJbXCIsXG4gICAgICAgICAgICBcIntcIjogXCJ7XCIsXG4gICAgICAgICAgICBcIn1cIjogXCJ7XCJcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZS5tYXRjaCgvW3t9KClcXFtcXF1dL2cpKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCB0b2tlbi52YWx1ZS5sZW5ndGggJiYgIWZvdW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFicmFja2V0c1t0b2tlbi52YWx1ZVtpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJhY2tldFR5cGUgPSBicmFja2V0c1t0b2tlbi52YWx1ZVtpXV0gKyAnLicgKyB0b2tlbi50eXBlLnJlcGxhY2UoXCJycGFyZW5cIiwgXCJscGFyZW5cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGRlcHRoW2JyYWNrZXRUeXBlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoW2JyYWNrZXRUeXBlXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhbYnJhY2tldFR5cGVdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhbYnJhY2tldFR5cGVdLS07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhbYnJhY2tldFR5cGVdID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFR5cGUgPSAnYnJhY2tldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuICYmIHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGVwdGhbdG9rZW4udmFsdWVdKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aFt0b2tlbi52YWx1ZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhbdG9rZW4udmFsdWVdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJzwvJykge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aFt0b2tlbi52YWx1ZV0tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoW3Rva2VuLnZhbHVlXSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hUeXBlID0gJ3RhZyc7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICBwcmV2VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRva2VuICYmICFmb3VuZCk7XG4gICAgICAgIGlmICghbWF0Y2hUeXBlKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciByYW5nZSwgcG9zO1xuICAgICAgICBpZiAobWF0Y2hUeXBlID09PSAnYnJhY2tldCcpIHtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5zZXNzaW9uLmdldEJyYWNrZXRSYW5nZShjdXJzb3IpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKFxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSxcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyBpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgaSAtIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBvcyA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmQgfHwgcG9zLnJvdyA9PT0gY3Vyc29yLnJvdyAmJiBNYXRoLmFicyhwb3MuY29sdW1uIC0gY3Vyc29yLmNvbHVtbikgPCAyKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuc2Vzc2lvbi5nZXRCcmFja2V0UmFuZ2UocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpICE9PSAtMSkgXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgLSAyLFxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpIC0gMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gcHJldlRva2VuO1xuICAgICAgICAgICAgICAgICAgICBwcmV2VG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udHlwZS5pbmRleE9mKCd0YWctY2xvc2UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCksIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gdGFnICYmIHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhbdGFnXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8LycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhbdGFnXS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhbdGFnXSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldlRva2VuICYmICFmb3VuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5yb3cgPT0gY3Vyc29yLnJvdyAmJiBNYXRoLmFicyhwb3MuY29sdW1uIC0gY3Vyc29yLmNvbHVtbikgPCAyKVxuICAgICAgICAgICAgICAgICAgICBwb3MgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSByYW5nZSAmJiByYW5nZS5jdXJzb3IgfHwgcG9zO1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIGV4cGFuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZSAmJiByYW5nZS5pc0VxdWFsKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFRvKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZVRvKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdvdG9MaW5lID0gZnVuY3Rpb24obGluZU51bWJlciwgY29sdW1uLCBhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi51bmZvbGQoe3JvdzogbGluZU51bWJlciAtIDEsIGNvbHVtbjogY29sdW1uIHx8IDB9KTtcblxuICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyArPSAxO1xuICAgICAgICB0aGlzLmV4aXRNdWx0aVNlbGVjdE1vZGUgJiYgdGhpcy5leGl0TXVsdGlTZWxlY3RNb2RlKCk7XG4gICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGxpbmVOdW1iZXIgLSAxLCBjb2x1bW4gfHwgMCk7XG4gICAgICAgIHRoaXMuJGJsb2NrU2Nyb2xsaW5nIC09IDE7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzUm93RnVsbHlWaXNpYmxlKGxpbmVOdW1iZXIgLSAxKSlcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9MaW5lKGxpbmVOdW1iZXIgLSAxLCB0cnVlLCBhbmltYXRlKTtcbiAgICB9O1xuICAgIHRoaXMubmF2aWdhdGVUbyA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVUbyhyb3csIGNvbHVtbik7XG4gICAgfTtcbiAgICB0aGlzLm5hdmlnYXRlVXAgPSBmdW5jdGlvbih0aW1lcykge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNNdWx0aUxpbmUoKSAmJiAhdGhpcy5zZWxlY3Rpb24uaXNCYWNrd2FyZHMoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb24uYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckJ5KC10aW1lcyB8fCAtMSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLm5hdmlnYXRlRG93biA9IGZ1bmN0aW9uKHRpbWVzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc011bHRpTGluZSgpICYmIHRoaXMuc2VsZWN0aW9uLmlzQmFja3dhcmRzKCkpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbi5hbmNob3IuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHNlbGVjdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckJ5KHRpbWVzIHx8IDEsIDApO1xuICAgIH07XG4gICAgdGhpcy5uYXZpZ2F0ZUxlZnQgPSBmdW5jdGlvbih0aW1lcykge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aW1lcyA9IHRpbWVzIHx8IDE7XG4gICAgICAgICAgICB3aGlsZSAodGltZXMtLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JMZWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5uYXZpZ2F0ZVJpZ2h0ID0gZnVuY3Rpb24odGltZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkuZW5kO1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGltZXMgPSB0aW1lcyB8fCAxO1xuICAgICAgICAgICAgd2hpbGUgKHRpbWVzLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yUmlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLm5hdmlnYXRlTGluZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JMaW5lU3RhcnQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5uYXZpZ2F0ZUxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckxpbmVFbmQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5uYXZpZ2F0ZUZpbGVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckZpbGVFbmQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5uYXZpZ2F0ZUZpbGVTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yRmlsZVN0YXJ0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIHRoaXMubmF2aWdhdGVXb3JkUmlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvcldvcmRSaWdodCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLm5hdmlnYXRlV29yZExlZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvcldvcmRMZWZ0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIHRoaXMucmVwbGFjZSA9IGZ1bmN0aW9uKHJlcGxhY2VtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoLnNldChvcHRpb25zKTtcblxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLiRzZWFyY2guZmluZCh0aGlzLnNlc3Npb24pO1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSAwO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VkO1xuXG4gICAgICAgIGlmICh0aGlzLiR0cnlSZXBsYWNlKHJhbmdlLCByZXBsYWNlbWVudCkpIHtcbiAgICAgICAgICAgIHJlcGxhY2VkID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVwbGFjZWQ7XG4gICAgfTtcbiAgICB0aGlzLnJlcGxhY2VBbGwgPSBmdW5jdGlvbihyZXBsYWNlbWVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy4kc2VhcmNoLnNldChvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLiRzZWFyY2guZmluZEFsbCh0aGlzLnNlc3Npb24pO1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSAwO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZWQ7XG5cbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgKz0gMTtcblxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlVG8oMCwgMCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYodGhpcy4kdHJ5UmVwbGFjZShyYW5nZXNbaV0sIHJlcGxhY2VtZW50KSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyAtPSAxO1xuXG4gICAgICAgIHJldHVybiByZXBsYWNlZDtcbiAgICB9O1xuXG4gICAgdGhpcy4kdHJ5UmVwbGFjZSA9IGZ1bmN0aW9uKHJhbmdlLCByZXBsYWNlbWVudCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSB0aGlzLiRzZWFyY2gucmVwbGFjZShpbnB1dCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICBpZiAocmVwbGFjZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJhbmdlLmVuZCA9IHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRMYXN0U2VhcmNoT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VhcmNoLmdldE9wdGlvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuZmluZCA9IGZ1bmN0aW9uKG5lZWRsZSwgb3B0aW9ucywgYW5pbWF0ZSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuZWVkbGUgPT0gXCJzdHJpbmdcIiB8fCBuZWVkbGUgaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgICAgICBvcHRpb25zLm5lZWRsZSA9IG5lZWRsZTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5lZWRsZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgb29wLm1peGluKG9wdGlvbnMsIG5lZWRsZSk7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubmVlZGxlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5lZWRsZSA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy4kc2VhcmNoLiRvcHRpb25zLm5lZWRsZTtcbiAgICAgICAgICAgIGlmICghbmVlZGxlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnNlc3Npb24uZ2V0V29yZFJhbmdlKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICBuZWVkbGUgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaC5zZXQoe25lZWRsZTogbmVlZGxlfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRzZWFyY2guc2V0KG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RhcnQpXG4gICAgICAgICAgICB0aGlzLiRzZWFyY2guc2V0KHtzdGFydDogcmFuZ2V9KTtcblxuICAgICAgICB2YXIgbmV3UmFuZ2UgPSB0aGlzLiRzZWFyY2guZmluZCh0aGlzLnNlc3Npb24pO1xuICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50U2Nyb2xsKVxuICAgICAgICAgICAgcmV0dXJuIG5ld1JhbmdlO1xuICAgICAgICBpZiAobmV3UmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmV2ZWFsUmFuZ2UobmV3UmFuZ2UsIGFuaW1hdGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1JhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmJhY2t3YXJkcylcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gcmFuZ2UuZW5kO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5nZS5lbmQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UocmFuZ2UpO1xuICAgIH07XG4gICAgdGhpcy5maW5kTmV4dCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5maW5kKHtza2lwQ3VycmVudDogdHJ1ZSwgYmFja3dhcmRzOiBmYWxzZX0sIG9wdGlvbnMsIGFuaW1hdGUpO1xuICAgIH07XG4gICAgdGhpcy5maW5kUHJldmlvdXMgPSBmdW5jdGlvbihvcHRpb25zLCBhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuZmluZChvcHRpb25zLCB7c2tpcEN1cnJlbnQ6IHRydWUsIGJhY2t3YXJkczogdHJ1ZX0sIGFuaW1hdGUpO1xuICAgIH07XG5cbiAgICB0aGlzLnJldmVhbFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UsIGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgKz0gMTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnVuZm9sZChyYW5nZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlKTtcbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgLT0gMTtcblxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5yZW5kZXJlci5zY3JvbGxUb3A7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgMC41KTtcbiAgICAgICAgaWYgKGFuaW1hdGUgIT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hbmltYXRlU2Nyb2xsaW5nKHNjcm9sbFRvcCk7XG4gICAgfTtcbiAgICB0aGlzLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcrKztcbiAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkudW5kbygpO1xuICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZy0tO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XG4gICAgfTtcbiAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcrKztcbiAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkucmVkbygpO1xuICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZy0tO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XG4gICAgfTtcbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3NpZ25hbChcImRlc3Ryb3lcIiwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3ID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgIGlmICghZW5hYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcmVjdDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2hvdWxkU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy4kc2Nyb2xsQW5jaG9yKVxuICAgICAgICAgICAgdGhpcy4kc2Nyb2xsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIHNjcm9sbEFuY2hvciA9IHRoaXMuJHNjcm9sbEFuY2hvcjtcbiAgICAgICAgc2Nyb2xsQW5jaG9yLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlXCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShzY3JvbGxBbmNob3IsIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB2YXIgb25DaGFuZ2VTZWxlY3Rpb24gPSB0aGlzLm9uKFwiY2hhbmdlU2VsZWN0aW9uXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2hvdWxkU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvbkJlZm9yZVJlbmRlciA9IHRoaXMucmVuZGVyZXIub24oXCJiZWZvcmVSZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKVxuICAgICAgICAgICAgICAgIHJlY3QgPSBzZWxmLnJlbmRlcmVyLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvbkFmdGVyUmVuZGVyID0gdGhpcy5yZW5kZXJlci5vbihcImFmdGVyUmVuZGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiByZWN0ICYmIChzZWxmLmlzRm9jdXNlZCgpXG4gICAgICAgICAgICAgICAgfHwgc2VsZi5zZWFyY2hCb3ggJiYgc2VsZi5zZWFyY2hCb3guaXNGb2N1c2VkKCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBzZWxmLnJlbmRlcmVyO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSByZW5kZXJlci4kY3Vyc29yTGF5ZXIuJHBpeGVsUG9zO1xuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSByZW5kZXJlci5sYXllckNvbmZpZztcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gcG9zLnRvcCAtIGNvbmZpZy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy50b3AgPj0gMCAmJiB0b3AgKyByZWN0LnRvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy50b3AgPCBjb25maWcuaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgIHBvcy50b3AgKyByZWN0LnRvcCArIGNvbmZpZy5saW5lSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFNjcm9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc3R5bGUuaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvci5zY3JvbGxJbnRvVmlldyhzaG91bGRTY3JvbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSByZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3ID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNldEF1dG9TY3JvbGxFZGl0b3JJbnRvVmlldztcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVNlbGVjdGlvblwiLCBvbkNoYW5nZVNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZnRlclJlbmRlclwiLCBvbkFmdGVyUmVuZGVyKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZVJlbmRlclwiLCBvbkJlZm9yZVJlbmRlcik7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdGhpcy4kcmVzZXRDdXJzb3JTdHlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLiRjdXJzb3JTdHlsZSB8fCBcImFjZVwiO1xuICAgICAgICB2YXIgY3Vyc29yTGF5ZXIgPSB0aGlzLnJlbmRlcmVyLiRjdXJzb3JMYXllcjtcbiAgICAgICAgaWYgKCFjdXJzb3JMYXllcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3Vyc29yTGF5ZXIuc2V0U21vb3RoQmxpbmtpbmcoL3Ntb290aC8udGVzdChzdHlsZSkpO1xuICAgICAgICBjdXJzb3JMYXllci5pc0JsaW5raW5nID0gIXRoaXMuJHJlYWRPbmx5ICYmIHN0eWxlICE9IFwid2lkZVwiO1xuICAgICAgICBkb20uc2V0Q3NzQ2xhc3MoY3Vyc29yTGF5ZXIuZWxlbWVudCwgXCJhY2Vfc2xpbS1jdXJzb3JzXCIsIC9zbGltLy50ZXN0KHN0eWxlKSk7XG4gICAgfTtcblxufSkuY2FsbChFZGl0b3IucHJvdG90eXBlKTtcblxuXG5cbmNvbmZpZy5kZWZpbmVPcHRpb25zKEVkaXRvci5wcm90b3R5cGUsIFwiZWRpdG9yXCIsIHtcbiAgICBzZWxlY3Rpb25TdHlsZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJjaGFuZ2VTZWxlY3Rpb25TdHlsZVwiLCB7ZGF0YTogc3R5bGV9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBcImxpbmVcIlxuICAgIH0sXG4gICAgaGlnaGxpZ2h0QWN0aXZlTGluZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge3RoaXMuJHVwZGF0ZUhpZ2hsaWdodEFjdGl2ZUxpbmUoKTt9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGhpZ2hsaWdodFNlbGVjdGVkV29yZDoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHNob3VsZEhpZ2hsaWdodCkge3RoaXMuJG9uU2VsZWN0aW9uQ2hhbmdlKCk7fSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICByZWFkT25seToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHJlYWRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLiRyZXNldEN1cnNvclN0eWxlKCk7IFxuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXG4gICAgfSxcbiAgICBjdXJzb3JTdHlsZToge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkgeyB0aGlzLiRyZXNldEN1cnNvclN0eWxlKCk7IH0sXG4gICAgICAgIHZhbHVlczogW1wiYWNlXCIsIFwic2xpbVwiLCBcInNtb290aFwiLCBcIndpZGVcIl0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogXCJhY2VcIlxuICAgIH0sXG4gICAgbWVyZ2VVbmRvRGVsdGFzOiB7XG4gICAgICAgIHZhbHVlczogW2ZhbHNlLCB0cnVlLCBcImFsd2F5c1wiXSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBiZWhhdmlvdXJzRW5hYmxlZDoge2luaXRpYWxWYWx1ZTogdHJ1ZX0sXG4gICAgd3JhcEJlaGF2aW91cnNFbmFibGVkOiB7aW5pdGlhbFZhbHVlOiB0cnVlfSxcbiAgICBhdXRvU2Nyb2xsRWRpdG9ySW50b1ZpZXc6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHt0aGlzLnNldEF1dG9TY3JvbGxFZGl0b3JJbnRvVmlldyh2YWwpfVxuICAgIH0sXG5cbiAgICBoU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZTogXCJyZW5kZXJlclwiLFxuICAgIHZTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiBcInJlbmRlcmVyXCIsXG4gICAgaGlnaGxpZ2h0R3V0dGVyTGluZTogXCJyZW5kZXJlclwiLFxuICAgIGFuaW1hdGVkU2Nyb2xsOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0ludmlzaWJsZXM6IFwicmVuZGVyZXJcIixcbiAgICBzaG93UHJpbnRNYXJnaW46IFwicmVuZGVyZXJcIixcbiAgICBwcmludE1hcmdpbkNvbHVtbjogXCJyZW5kZXJlclwiLFxuICAgIHByaW50TWFyZ2luOiBcInJlbmRlcmVyXCIsXG4gICAgZmFkZUZvbGRXaWRnZXRzOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0ZvbGRXaWRnZXRzOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0xpbmVOdW1iZXJzOiBcInJlbmRlcmVyXCIsXG4gICAgc2hvd0d1dHRlcjogXCJyZW5kZXJlclwiLFxuICAgIGRpc3BsYXlJbmRlbnRHdWlkZXM6IFwicmVuZGVyZXJcIixcbiAgICBmb250U2l6ZTogXCJyZW5kZXJlclwiLFxuICAgIGZvbnRGYW1pbHk6IFwicmVuZGVyZXJcIixcbiAgICBtYXhMaW5lczogXCJyZW5kZXJlclwiLFxuICAgIG1pbkxpbmVzOiBcInJlbmRlcmVyXCIsXG4gICAgc2Nyb2xsUGFzdEVuZDogXCJyZW5kZXJlclwiLFxuICAgIGZpeGVkV2lkdGhHdXR0ZXI6IFwicmVuZGVyZXJcIixcbiAgICB0aGVtZTogXCJyZW5kZXJlclwiLFxuXG4gICAgc2Nyb2xsU3BlZWQ6IFwiJG1vdXNlSGFuZGxlclwiLFxuICAgIGRyYWdEZWxheTogXCIkbW91c2VIYW5kbGVyXCIsXG4gICAgZHJhZ0VuYWJsZWQ6IFwiJG1vdXNlSGFuZGxlclwiLFxuICAgIGZvY3VzVGltb3V0OiBcIiRtb3VzZUhhbmRsZXJcIixcbiAgICB0b29sdGlwRm9sbG93c01vdXNlOiBcIiRtb3VzZUhhbmRsZXJcIixcblxuICAgIGZpcnN0TGluZU51bWJlcjogXCJzZXNzaW9uXCIsXG4gICAgb3ZlcndyaXRlOiBcInNlc3Npb25cIixcbiAgICBuZXdMaW5lTW9kZTogXCJzZXNzaW9uXCIsXG4gICAgdXNlV29ya2VyOiBcInNlc3Npb25cIixcbiAgICB1c2VTb2Z0VGFiczogXCJzZXNzaW9uXCIsXG4gICAgdGFiU2l6ZTogXCJzZXNzaW9uXCIsXG4gICAgd3JhcDogXCJzZXNzaW9uXCIsXG4gICAgZm9sZFN0eWxlOiBcInNlc3Npb25cIixcbiAgICBtb2RlOiBcInNlc3Npb25cIlxufSk7XG5cbmV4cG9ydHMuRWRpdG9yID0gRWRpdG9yO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdW5kb21hbmFnZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xudmFyIFVuZG9NYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldCgpO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlbHRhcyA9IG9wdGlvbnMuYXJnc1swXTtcbiAgICAgICAgdGhpcy4kZG9jICA9IG9wdGlvbnMuYXJnc1sxXTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWVyZ2UgJiYgdGhpcy5oYXNVbmRvKCkpe1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUNvdW50ZXItLTtcbiAgICAgICAgICAgIGRlbHRhcyA9IHRoaXMuJHVuZG9TdGFjay5wb3AoKS5jb25jYXQoZGVsdGFzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR1bmRvU3RhY2sucHVzaChkZWx0YXMpO1xuICAgICAgICB0aGlzLiRyZWRvU3RhY2sgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5kaXJ0eUNvdW50ZXIgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5Q291bnRlciA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5Q291bnRlcisrO1xuICAgIH07XG4gICAgdGhpcy51bmRvID0gZnVuY3Rpb24oZG9udFNlbGVjdCkge1xuICAgICAgICB2YXIgZGVsdGFzID0gdGhpcy4kdW5kb1N0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgdW5kb1NlbGVjdGlvblJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKGRlbHRhcykge1xuICAgICAgICAgICAgdW5kb1NlbGVjdGlvblJhbmdlID1cbiAgICAgICAgICAgICAgICB0aGlzLiRkb2MudW5kb0NoYW5nZXMoZGVsdGFzLCBkb250U2VsZWN0KTtcbiAgICAgICAgICAgIHRoaXMuJHJlZG9TdGFjay5wdXNoKGRlbHRhcyk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5Q291bnRlci0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZG9TZWxlY3Rpb25SYW5nZTtcbiAgICB9O1xuICAgIHRoaXMucmVkbyA9IGZ1bmN0aW9uKGRvbnRTZWxlY3QpIHtcbiAgICAgICAgdmFyIGRlbHRhcyA9IHRoaXMuJHJlZG9TdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHJlZG9TZWxlY3Rpb25SYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChkZWx0YXMpIHtcbiAgICAgICAgICAgIHJlZG9TZWxlY3Rpb25SYW5nZSA9XG4gICAgICAgICAgICAgICAgdGhpcy4kZG9jLnJlZG9DaGFuZ2VzKGRlbHRhcywgZG9udFNlbGVjdCk7XG4gICAgICAgICAgICB0aGlzLiR1bmRvU3RhY2sucHVzaChkZWx0YXMpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUNvdW50ZXIrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWRvU2VsZWN0aW9uUmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJHVuZG9TdGFjayA9IFtdO1xuICAgICAgICB0aGlzLiRyZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5kaXJ0eUNvdW50ZXIgPSAwO1xuICAgIH07XG4gICAgdGhpcy5oYXNVbmRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR1bmRvU3RhY2subGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIHRoaXMuaGFzUmVkbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICB0aGlzLm1hcmtDbGVhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpcnR5Q291bnRlciA9IDA7XG4gICAgfTtcbiAgICB0aGlzLmlzQ2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHlDb3VudGVyID09PSAwO1xuICAgIH07XG5cbn0pLmNhbGwoVW5kb01hbmFnZXIucHJvdG90eXBlKTtcblxuZXhwb3J0cy5VbmRvTWFuYWdlciA9IFVuZG9NYW5hZ2VyO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvZ3V0dGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGRvbSA9IGFjZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcbnZhciBvb3AgPSBhY2VxdWlyZShcIi4uL2xpYi9vb3BcIik7XG52YXIgbGFuZyA9IGFjZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXCIuLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBHdXR0ZXIgPSBmdW5jdGlvbihwYXJlbnRFbCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9sYXllciBhY2VfZ3V0dGVyLWxheWVyXCI7XG4gICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLnNldFNob3dGb2xkV2lkZ2V0cyh0aGlzLiRzaG93Rm9sZFdpZGdldHMpO1xuICAgIFxuICAgIHRoaXMuZ3V0dGVyV2lkdGggPSAwO1xuXG4gICAgdGhpcy4kYW5ub3RhdGlvbnMgPSBbXTtcbiAgICB0aGlzLiR1cGRhdGVBbm5vdGF0aW9ucyA9IHRoaXMuJHVwZGF0ZUFubm90YXRpb25zLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLiRjZWxscyA9IFtdO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuXG4gICAgdGhpcy5zZXRTZXNzaW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy4kdXBkYXRlQW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbilcbiAgICAgICAgICAgIHNlc3Npb24ub24oXCJjaGFuZ2VcIiwgdGhpcy4kdXBkYXRlQW5ub3RhdGlvbnMpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZEd1dHRlckRlY29yYXRpb24gPSBmdW5jdGlvbihyb3csIGNsYXNzTmFtZSl7XG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZSlcbiAgICAgICAgICAgIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oXCJkZXByZWNhdGVkIHVzZSBzZXNzaW9uLmFkZEd1dHRlckRlY29yYXRpb25cIik7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uID0gZnVuY3Rpb24ocm93LCBjbGFzc05hbWUpe1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuKFwiZGVwcmVjYXRlZCB1c2Ugc2Vzc2lvbi5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uXCIpO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbihyb3csIGNsYXNzTmFtZSk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLiRhbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xuICAgICAgICAgICAgdmFyIHJvdyA9IGFubm90YXRpb24ucm93O1xuICAgICAgICAgICAgdmFyIHJvd0luZm8gPSB0aGlzLiRhbm5vdGF0aW9uc1tyb3ddO1xuICAgICAgICAgICAgaWYgKCFyb3dJbmZvKVxuICAgICAgICAgICAgICAgIHJvd0luZm8gPSB0aGlzLiRhbm5vdGF0aW9uc1tyb3ddID0ge3RleHQ6IFtdfTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYW5ub1RleHQgPSBhbm5vdGF0aW9uLnRleHQ7XG4gICAgICAgICAgICBhbm5vVGV4dCA9IGFubm9UZXh0ID8gbGFuZy5lc2NhcGVIVE1MKGFubm9UZXh0KSA6IGFubm90YXRpb24uaHRtbCB8fCBcIlwiO1xuXG4gICAgICAgICAgICBpZiAocm93SW5mby50ZXh0LmluZGV4T2YoYW5ub1RleHQpID09PSAtMSlcbiAgICAgICAgICAgICAgICByb3dJbmZvLnRleHQucHVzaChhbm5vVGV4dCk7XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYW5ub3RhdGlvbi50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJvd0luZm8uY2xhc3NOYW1lID0gXCIgYWNlX2Vycm9yXCI7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwid2FybmluZ1wiICYmIHJvd0luZm8uY2xhc3NOYW1lICE9IFwiIGFjZV9lcnJvclwiKVxuICAgICAgICAgICAgICAgIHJvd0luZm8uY2xhc3NOYW1lID0gXCIgYWNlX3dhcm5pbmdcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJpbmZvXCIgJiYgKCFyb3dJbmZvLmNsYXNzTmFtZSkpXG4gICAgICAgICAgICAgICAgcm93SW5mby5jbGFzc05hbWUgPSBcIiBhY2VfaW5mb1wiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuJHVwZGF0ZUFubm90YXRpb25zID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBkZWx0YSA9IGUuZGF0YTtcbiAgICAgICAgdmFyIHJhbmdlID0gZGVsdGEucmFuZ2U7XG4gICAgICAgIHZhciBmaXJzdFJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgdmFyIGxlbiA9IHJhbmdlLmVuZC5yb3cgLSBmaXJzdFJvdztcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZVRleHRcIiB8fCBkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVMaW5lc1wiKSB7XG4gICAgICAgICAgICB0aGlzLiRhbm5vdGF0aW9ucy5zcGxpY2UoZmlyc3RSb3csIGxlbiArIDEsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoZmlyc3RSb3csIDEpO1xuICAgICAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMuc3BsaWNlLmFwcGx5KHRoaXMuJGFubm90YXRpb25zLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gY29uZmlnLmZpcnN0Um93O1xuICAgICAgICB2YXIgbGFzdFJvdyA9IE1hdGgubWluKGNvbmZpZy5sYXN0Um93ICsgY29uZmlnLmd1dHRlck9mZnNldCwgIC8vIG5lZWRlZCB0byBjb21wZW5zYXRlIGZvciBob3Igc2NvbGxiYXJcbiAgICAgICAgICAgIHNlc3Npb24uZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgdmFyIGZvbGQgPSBzZXNzaW9uLmdldE5leHRGb2xkTGluZShmaXJzdFJvdyk7XG4gICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkID8gZm9sZC5zdGFydC5yb3cgOiBJbmZpbml0eTtcbiAgICAgICAgdmFyIGZvbGRXaWRnZXRzID0gdGhpcy4kc2hvd0ZvbGRXaWRnZXRzICYmIHNlc3Npb24uZm9sZFdpZGdldHM7XG4gICAgICAgIHZhciBicmVha3BvaW50cyA9IHNlc3Npb24uJGJyZWFrcG9pbnRzO1xuICAgICAgICB2YXIgZGVjb3JhdGlvbnMgPSBzZXNzaW9uLiRkZWNvcmF0aW9ucztcbiAgICAgICAgdmFyIGZpcnN0TGluZU51bWJlciA9IHNlc3Npb24uJGZpcnN0TGluZU51bWJlcjtcbiAgICAgICAgdmFyIGxhc3RMaW5lTnVtYmVyID0gMDtcbiAgICAgICAgXG4gICAgICAgIHZhciBndXR0ZXJSZW5kZXJlciA9IHNlc3Npb24uZ3V0dGVyUmVuZGVyZXIgfHwgdGhpcy4kcmVuZGVyZXI7XG5cbiAgICAgICAgdmFyIGNlbGwgPSBudWxsO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHJvdyA9IGZpcnN0Um93O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGRTdGFydCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IGZvbGQuZW5kLnJvdyArIDE7XG4gICAgICAgICAgICAgICAgZm9sZCA9IHNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdywgZm9sZCk7XG4gICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZCA/IGZvbGQuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93ID4gbGFzdFJvdykge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLiRjZWxscy5sZW5ndGggPiBpbmRleCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbCA9IHRoaXMuJGNlbGxzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoY2VsbC5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNlbGwgPSB0aGlzLiRjZWxsc1srK2luZGV4XTtcbiAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICAgIGNlbGwgPSB7ZWxlbWVudDogbnVsbCwgdGV4dE5vZGU6IG51bGwsIGZvbGRXaWRnZXQ6IG51bGx9O1xuICAgICAgICAgICAgICAgIGNlbGwuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGNlbGwudGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICAgICAgY2VsbC5lbGVtZW50LmFwcGVuZENoaWxkKGNlbGwudGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChjZWxsLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNlbGxzW2luZGV4XSA9IGNlbGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBcImFjZV9ndXR0ZXItY2VsbCBcIjtcbiAgICAgICAgICAgIGlmIChicmVha3BvaW50c1tyb3ddKVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArPSBicmVha3BvaW50c1tyb3ddO1xuICAgICAgICAgICAgaWYgKGRlY29yYXRpb25zW3Jvd10pXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IGRlY29yYXRpb25zW3Jvd107XG4gICAgICAgICAgICBpZiAodGhpcy4kYW5ub3RhdGlvbnNbcm93XSlcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gdGhpcy4kYW5ub3RhdGlvbnNbcm93XS5jbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAoY2VsbC5lbGVtZW50LmNsYXNzTmFtZSAhPSBjbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgY2VsbC5lbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNlc3Npb24uZ2V0Um93TGVuZ3RoKHJvdykgKiBjb25maWcubGluZUhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT0gY2VsbC5lbGVtZW50LnN0eWxlLmhlaWdodClcbiAgICAgICAgICAgICAgICBjZWxsLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoZm9sZFdpZGdldHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGZvbGRXaWRnZXRzW3Jvd107XG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYyA9IGZvbGRXaWRnZXRzW3Jvd10gPSBzZXNzaW9uLmdldEZvbGRXaWRnZXQocm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwuZm9sZFdpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmZvbGRXaWRnZXQgPSBkb20uY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZWxlbWVudC5hcHBlbmRDaGlsZChjZWxsLmZvbGRXaWRnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJhY2VfZm9sZC13aWRnZXQgYWNlX1wiICsgYztcbiAgICAgICAgICAgICAgICBpZiAoYyA9PSBcInN0YXJ0XCIgJiYgcm93ID09IGZvbGRTdGFydCAmJiByb3cgPCBmb2xkLmVuZC5yb3cpXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArPSBcIiBhY2VfY2xvc2VkXCI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gXCIgYWNlX29wZW5cIjtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5mb2xkV2lkZ2V0LmNsYXNzTmFtZSAhPSBjbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZm9sZFdpZGdldC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuZm9sZFdpZGdldC5zdHlsZS5oZWlnaHQgIT0gaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBjZWxsLmZvbGRXaWRnZXQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5mb2xkV2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuZWxlbWVudC5yZW1vdmVDaGlsZChjZWxsLmZvbGRXaWRnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmZvbGRXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHRleHQgPSBsYXN0TGluZU51bWJlciA9IGd1dHRlclJlbmRlcmVyXG4gICAgICAgICAgICAgICAgPyBndXR0ZXJSZW5kZXJlci5nZXRUZXh0KHNlc3Npb24sIHJvdylcbiAgICAgICAgICAgICAgICA6IHJvdyArIGZpcnN0TGluZU51bWJlcjtcbiAgICAgICAgICAgIGlmICh0ZXh0ICE9IGNlbGwudGV4dE5vZGUuZGF0YSlcbiAgICAgICAgICAgICAgICBjZWxsLnRleHROb2RlLmRhdGEgPSB0ZXh0O1xuXG4gICAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBjb25maWcubWluSGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgIGlmICh0aGlzLiRmaXhlZFdpZHRoIHx8IHNlc3Npb24uJHVzZVdyYXBNb2RlKVxuICAgICAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBzZXNzaW9uLmdldExlbmd0aCgpICsgZmlyc3RMaW5lTnVtYmVyO1xuXG4gICAgICAgIHZhciBndXR0ZXJXaWR0aCA9IGd1dHRlclJlbmRlcmVyIFxuICAgICAgICAgICAgPyBndXR0ZXJSZW5kZXJlci5nZXRXaWR0aChzZXNzaW9uLCBsYXN0TGluZU51bWJlciwgY29uZmlnKVxuICAgICAgICAgICAgOiBsYXN0TGluZU51bWJlci50b1N0cmluZygpLmxlbmd0aCAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy4kcGFkZGluZyB8fCB0aGlzLiRjb21wdXRlUGFkZGluZygpO1xuICAgICAgICBndXR0ZXJXaWR0aCArPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICAgICAgICBpZiAoZ3V0dGVyV2lkdGggIT09IHRoaXMuZ3V0dGVyV2lkdGggJiYgIWlzTmFOKGd1dHRlcldpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5ndXR0ZXJXaWR0aCA9IGd1dHRlcldpZHRoO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gTWF0aC5jZWlsKHRoaXMuZ3V0dGVyV2lkdGgpICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZUd1dHRlcldpZHRoXCIsIGd1dHRlcldpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLiRmaXhlZFdpZHRoID0gZmFsc2U7XG4gICAgXG4gICAgdGhpcy4kc2hvd0xpbmVOdW1iZXJzID0gdHJ1ZTtcbiAgICB0aGlzLiRyZW5kZXJlciA9IFwiXCI7XG4gICAgdGhpcy5zZXRTaG93TGluZU51bWJlcnMgPSBmdW5jdGlvbihzaG93KSB7XG4gICAgICAgIHRoaXMuJHJlbmRlcmVyID0gIXNob3cgJiYge1xuICAgICAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge3JldHVybiBcIlwifSxcbiAgICAgICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKCkge3JldHVybiBcIlwifVxuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRTaG93TGluZU51bWJlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNob3dMaW5lTnVtYmVycztcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuJHNob3dGb2xkV2lkZ2V0cyA9IHRydWU7XG4gICAgdGhpcy5zZXRTaG93Rm9sZFdpZGdldHMgPSBmdW5jdGlvbihzaG93KSB7XG4gICAgICAgIGlmIChzaG93KVxuICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2VfZm9sZGluZy1lbmFibGVkXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy5lbGVtZW50LCBcImFjZV9mb2xkaW5nLWVuYWJsZWRcIik7XG5cbiAgICAgICAgdGhpcy4kc2hvd0ZvbGRXaWRnZXRzID0gc2hvdztcbiAgICAgICAgdGhpcy4kcGFkZGluZyA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmdldFNob3dGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2hvd0ZvbGRXaWRnZXRzO1xuICAgIH07XG5cbiAgICB0aGlzLiRjb21wdXRlUGFkZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIHtsZWZ0OiAwLCByaWdodDogMH07XG4gICAgICAgIHZhciBzdHlsZSA9IGRvbS5jb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgdGhpcy4kcGFkZGluZyA9IHt9O1xuICAgICAgICB0aGlzLiRwYWRkaW5nLmxlZnQgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCkgKyAxIHx8IDA7XG4gICAgICAgIHRoaXMuJHBhZGRpbmcucmlnaHQgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzLiRwYWRkaW5nO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFJlZ2lvbiA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy4kcGFkZGluZyB8fCB0aGlzLiRjb21wdXRlUGFkZGluZygpO1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHBvaW50LnggPCBwYWRkaW5nLmxlZnQgKyByZWN0LmxlZnQpXG4gICAgICAgICAgICByZXR1cm4gXCJtYXJrZXJzXCI7XG4gICAgICAgIGlmICh0aGlzLiRzaG93Rm9sZFdpZGdldHMgJiYgcG9pbnQueCA+IHJlY3QucmlnaHQgLSBwYWRkaW5nLnJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIFwiZm9sZFdpZGdldHNcIjtcbiAgICB9O1xuXG59KS5jYWxsKEd1dHRlci5wcm90b3R5cGUpO1xuXG5leHBvcnRzLkd1dHRlciA9IEd1dHRlcjtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvbWFya2VyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIixcImFjZS9saWIvZG9tXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBkb20gPSBhY2VxdWlyZShcIi4uL2xpYi9kb21cIik7XG5cbnZhciBNYXJrZXIgPSBmdW5jdGlvbihwYXJlbnRFbCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcImFjZV9sYXllciBhY2VfbWFya2VyLWxheWVyXCI7XG4gICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbn07XG5cbihmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuJHBhZGRpbmcgPSAwO1xuXG4gICAgdGhpcy5zZXRQYWRkaW5nID0gZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gcGFkZGluZztcbiAgICB9O1xuICAgIHRoaXMuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0TWFya2VycyA9IGZ1bmN0aW9uKG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGNvbmZpZyB8fCB0aGlzLmNvbmZpZztcbiAgICAgICAgaWYgKCFjb25maWcpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cblxuICAgICAgICB2YXIgaHRtbCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5tYXJrZXJzKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5tYXJrZXJzW2tleV07XG5cbiAgICAgICAgICAgIGlmICghbWFya2VyLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnVwZGF0ZShodG1sLCB0aGlzLCB0aGlzLnNlc3Npb24sIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IG1hcmtlci5yYW5nZS5jbGlwUm93cyhjb25maWcuZmlyc3RSb3csIGNvbmZpZy5sYXN0Um93KTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICByYW5nZSA9IHJhbmdlLnRvU2NyZWVuUmFuZ2UodGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuJHBhZGRpbmcgKyByYW5nZS5zdGFydC5jb2x1bW4gKiBjb25maWcuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcmVyKGh0bWwsIHJhbmdlLCBsZWZ0LCB0b3AsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hcmtlci50eXBlID09IFwiZnVsbExpbmVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Z1bGxMaW5lTWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenosIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hcmtlci50eXBlID09IFwic2NyZWVuTGluZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2NyZWVuTGluZU1hcmtlcihodG1sLCByYW5nZSwgbWFya2VyLmNsYXp6LCBjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5pc011bHRpTGluZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci50eXBlID09IFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdUZXh0TWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenosIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdNdWx0aUxpbmVNYXJrZXIoaHRtbCwgcmFuZ2UsIG1hcmtlci5jbGF6eiwgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2luZ2xlTGluZU1hcmtlcihodG1sLCByYW5nZSwgbWFya2VyLmNsYXp6ICsgXCIgYWNlX3N0YXJ0XCIsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IGh0bWwuam9pbihcIlwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kZ2V0VG9wID0gZnVuY3Rpb24ocm93LCBsYXllckNvbmZpZykge1xuICAgICAgICByZXR1cm4gKHJvdyAtIGxheWVyQ29uZmlnLmZpcnN0Um93U2NyZWVuKSAqIGxheWVyQ29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgfTtcbiAgICB0aGlzLmRyYXdUZXh0TWFya2VyID0gZnVuY3Rpb24oc3RyaW5nQnVpbGRlciwgcmFuZ2UsIGNsYXp6LCBsYXllckNvbmZpZywgZXh0cmFTdHlsZSkge1xuICAgICAgICB2YXIgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xuXG4gICAgICAgIHZhciBsaW5lUmFuZ2UgPSBuZXcgUmFuZ2UoXG4gICAgICAgICAgICByb3csIHJhbmdlLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgIHJvdywgdGhpcy5zZXNzaW9uLmdldFNjcmVlbkxhc3RSb3dDb2x1bW4ocm93KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmRyYXdTaW5nbGVMaW5lTWFya2VyKHN0cmluZ0J1aWxkZXIsIGxpbmVSYW5nZSwgY2xhenogKyBcIiBhY2Vfc3RhcnRcIiwgbGF5ZXJDb25maWcsIDEsIGV4dHJhU3R5bGUpO1xuICAgICAgICByb3cgPSByYW5nZS5lbmQucm93O1xuICAgICAgICBsaW5lUmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCAwLCByb3csIHJhbmdlLmVuZC5jb2x1bW4pO1xuICAgICAgICB0aGlzLmRyYXdTaW5nbGVMaW5lTWFya2VyKHN0cmluZ0J1aWxkZXIsIGxpbmVSYW5nZSwgY2xhenosIGxheWVyQ29uZmlnLCAwLCBleHRyYVN0eWxlKTtcblxuICAgICAgICBmb3IgKHJvdyA9IHJhbmdlLnN0YXJ0LnJvdyArIDE7IHJvdyA8IHJhbmdlLmVuZC5yb3c7IHJvdysrKSB7XG4gICAgICAgICAgICBsaW5lUmFuZ2Uuc3RhcnQucm93ID0gcm93O1xuICAgICAgICAgICAgbGluZVJhbmdlLmVuZC5yb3cgPSByb3c7XG4gICAgICAgICAgICBsaW5lUmFuZ2UuZW5kLmNvbHVtbiA9IHRoaXMuc2Vzc2lvbi5nZXRTY3JlZW5MYXN0Um93Q29sdW1uKHJvdyk7XG4gICAgICAgICAgICB0aGlzLmRyYXdTaW5nbGVMaW5lTWFya2VyKHN0cmluZ0J1aWxkZXIsIGxpbmVSYW5nZSwgY2xhenosIGxheWVyQ29uZmlnLCAxLCBleHRyYVN0eWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kcmF3TXVsdGlMaW5lTWFya2VyID0gZnVuY3Rpb24oc3RyaW5nQnVpbGRlciwgcmFuZ2UsIGNsYXp6LCBjb25maWcsIGV4dHJhU3R5bGUpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLiRwYWRkaW5nO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2Uuc3RhcnQucm93LCBjb25maWcpO1xuICAgICAgICB2YXIgbGVmdCA9IHBhZGRpbmcgKyByYW5nZS5zdGFydC5jb2x1bW4gKiBjb25maWcuY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgIGV4dHJhU3R5bGUgPSBleHRyYVN0eWxlIHx8IFwiXCI7XG5cbiAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdcIiwgY2xhenosIFwiIGFjZV9zdGFydCcgc3R5bGU9J1wiLFxuICAgICAgICAgICAgXCJoZWlnaHQ6XCIsIGhlaWdodCwgXCJweDtcIixcbiAgICAgICAgICAgIFwicmlnaHQ6MDtcIixcbiAgICAgICAgICAgIFwidG9wOlwiLCB0b3AsIFwicHg7XCIsXG4gICAgICAgICAgICBcImxlZnQ6XCIsIGxlZnQsIFwicHg7XCIsIGV4dHJhU3R5bGUsIFwiJz48L2Rpdj5cIlxuICAgICAgICApO1xuICAgICAgICB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2UuZW5kLnJvdywgY29uZmlnKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcmFuZ2UuZW5kLmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcblxuICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J1wiLCBjbGF6eiwgXCInIHN0eWxlPSdcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0OlwiLCBoZWlnaHQsIFwicHg7XCIsXG4gICAgICAgICAgICBcIndpZHRoOlwiLCB3aWR0aCwgXCJweDtcIixcbiAgICAgICAgICAgIFwidG9wOlwiLCB0b3AsIFwicHg7XCIsXG4gICAgICAgICAgICBcImxlZnQ6XCIsIHBhZGRpbmcsIFwicHg7XCIsIGV4dHJhU3R5bGUsIFwiJz48L2Rpdj5cIlxuICAgICAgICApO1xuICAgICAgICBoZWlnaHQgPSAocmFuZ2UuZW5kLnJvdyAtIHJhbmdlLnN0YXJ0LnJvdyAtIDEpICogY29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIGlmIChoZWlnaHQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2Uuc3RhcnQucm93ICsgMSwgY29uZmlnKTtcblxuICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J1wiLCBjbGF6eiwgXCInIHN0eWxlPSdcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0OlwiLCBoZWlnaHQsIFwicHg7XCIsXG4gICAgICAgICAgICBcInJpZ2h0OjA7XCIsXG4gICAgICAgICAgICBcInRvcDpcIiwgdG9wLCBcInB4O1wiLFxuICAgICAgICAgICAgXCJsZWZ0OlwiLCBwYWRkaW5nLCBcInB4O1wiLCBleHRyYVN0eWxlLCBcIic+PC9kaXY+XCJcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuZHJhd1NpbmdsZUxpbmVNYXJrZXIgPSBmdW5jdGlvbihzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFMZW5ndGgsIGV4dHJhU3R5bGUpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSAocmFuZ2UuZW5kLmNvbHVtbiArIChleHRyYUxlbmd0aCB8fCAwKSAtIHJhbmdlLnN0YXJ0LmNvbHVtbikgKiBjb25maWcuY2hhcmFjdGVyV2lkdGg7XG5cbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy4kcGFkZGluZyArIHJhbmdlLnN0YXJ0LmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcblxuICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J1wiLCBjbGF6eiwgXCInIHN0eWxlPSdcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0OlwiLCBoZWlnaHQsIFwicHg7XCIsXG4gICAgICAgICAgICBcIndpZHRoOlwiLCB3aWR0aCwgXCJweDtcIixcbiAgICAgICAgICAgIFwidG9wOlwiLCB0b3AsIFwicHg7XCIsXG4gICAgICAgICAgICBcImxlZnQ6XCIsIGxlZnQsIFwicHg7XCIsIGV4dHJhU3R5bGUgfHwgXCJcIiwgXCInPjwvZGl2PlwiXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHRoaXMuZHJhd0Z1bGxMaW5lTWFya2VyID0gZnVuY3Rpb24oc3RyaW5nQnVpbGRlciwgcmFuZ2UsIGNsYXp6LCBjb25maWcsIGV4dHJhU3R5bGUpIHtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyAhPSByYW5nZS5lbmQucm93KVxuICAgICAgICAgICAgaGVpZ2h0ICs9IHRoaXMuJGdldFRvcChyYW5nZS5lbmQucm93LCBjb25maWcpIC0gdG9wO1xuXG4gICAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nXCIsIGNsYXp6LCBcIicgc3R5bGU9J1wiLFxuICAgICAgICAgICAgXCJoZWlnaHQ6XCIsIGhlaWdodCwgXCJweDtcIixcbiAgICAgICAgICAgIFwidG9wOlwiLCB0b3AsIFwicHg7XCIsXG4gICAgICAgICAgICBcImxlZnQ6MDtyaWdodDowO1wiLCBleHRyYVN0eWxlIHx8IFwiXCIsIFwiJz48L2Rpdj5cIlxuICAgICAgICApO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5kcmF3U2NyZWVuTGluZU1hcmtlciA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgY29uZmlnLCBleHRyYVN0eWxlKSB7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2Uuc3RhcnQucm93LCBjb25maWcpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQ7XG5cbiAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdcIiwgY2xhenosIFwiJyBzdHlsZT0nXCIsXG4gICAgICAgICAgICBcImhlaWdodDpcIiwgaGVpZ2h0LCBcInB4O1wiLFxuICAgICAgICAgICAgXCJ0b3A6XCIsIHRvcCwgXCJweDtcIixcbiAgICAgICAgICAgIFwibGVmdDowO3JpZ2h0OjA7XCIsIGV4dHJhU3R5bGUgfHwgXCJcIiwgXCInPjwvZGl2PlwiXG4gICAgICAgICk7XG4gICAgfTtcblxufSkuY2FsbChNYXJrZXIucHJvdG90eXBlKTtcblxuZXhwb3J0cy5NYXJrZXIgPSBNYXJrZXI7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2xheWVyL3RleHRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBkb20gPSBhY2VxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgbGFuZyA9IGFjZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFwiLi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xuXG52YXIgVGV4dCA9IGZ1bmN0aW9uKHBhcmVudEVsKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX2xheWVyIGFjZV90ZXh0LWxheWVyXCI7XG4gICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLiR1cGRhdGVFb2xDaGFyID0gdGhpcy4kdXBkYXRlRW9sQ2hhci5iaW5kKHRoaXMpO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuXG4gICAgdGhpcy5FT0ZfQ0hBUiA9IFwiXFx4QjZcIjtcbiAgICB0aGlzLkVPTF9DSEFSX0xGID0gXCJcXHhBQ1wiO1xuICAgIHRoaXMuRU9MX0NIQVJfQ1JMRiA9IFwiXFx4YTRcIjtcbiAgICB0aGlzLkVPTF9DSEFSID0gdGhpcy5FT0xfQ0hBUl9MRjtcbiAgICB0aGlzLlRBQl9DSEFSID0gXCJcXHUyMTkyXCI7IC8vXCJcXHUyMUU1XCI7XG4gICAgdGhpcy5TUEFDRV9DSEFSID0gXCJcXHhCN1wiO1xuICAgIHRoaXMuJHBhZGRpbmcgPSAwO1xuXG4gICAgdGhpcy4kdXBkYXRlRW9sQ2hhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgRU9MX0NIQVIgPSB0aGlzLnNlc3Npb24uZG9jLmdldE5ld0xpbmVDaGFyYWN0ZXIoKSA9PSBcIlxcblwiXG4gICAgICAgICAgID8gdGhpcy5FT0xfQ0hBUl9MRlxuICAgICAgICAgICA6IHRoaXMuRU9MX0NIQVJfQ1JMRjtcbiAgICAgICAgaWYgKHRoaXMuRU9MX0NIQVIgIT0gRU9MX0NIQVIpIHtcbiAgICAgICAgICAgIHRoaXMuRU9MX0NIQVIgPSBFT0xfQ0hBUjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRQYWRkaW5nID0gZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICB0aGlzLiRwYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjAgXCIgKyBwYWRkaW5nICsgXCJweFwiO1xuICAgIH07XG5cbiAgICB0aGlzLmdldExpbmVIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZvbnRNZXRyaWNzLiRjaGFyYWN0ZXJTaXplLmhlaWdodCB8fCAwO1xuICAgIH07XG5cbiAgICB0aGlzLmdldENoYXJhY3RlcldpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmb250TWV0cmljcy4kY2hhcmFjdGVyU2l6ZS53aWR0aCB8fCAwO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy4kc2V0Rm9udE1ldHJpY3MgPSBmdW5jdGlvbihtZWFzdXJlKSB7XG4gICAgICAgIHRoaXMuJGZvbnRNZXRyaWNzID0gbWVhc3VyZTtcbiAgICAgICAgdGhpcy4kZm9udE1ldHJpY3Mub24oXCJjaGFuZ2VDaGFyYWN0ZXJTaXplXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcImNoYW5nZUNoYXJhY3RlclNpemVcIiwgZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuJHBvbGxTaXplQ2hhbmdlcygpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tGb3JTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRmb250TWV0cmljcy5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG4gICAgfTtcbiAgICB0aGlzLiRwb2xsU2l6ZUNoYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyID0gdGhpcy4kZm9udE1ldHJpY3MuJHBvbGxTaXplQ2hhbmdlcygpO1xuICAgIH07XG4gICAgdGhpcy5zZXRTZXNzaW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbilcbiAgICAgICAgICAgIHRoaXMuJGNvbXB1dGVUYWJTdHJpbmcoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaG93SW52aXNpYmxlcyA9IGZhbHNlO1xuICAgIHRoaXMuc2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbihzaG93SW52aXNpYmxlcykge1xuICAgICAgICBpZiAodGhpcy5zaG93SW52aXNpYmxlcyA9PSBzaG93SW52aXNpYmxlcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB0aGlzLnNob3dJbnZpc2libGVzID0gc2hvd0ludmlzaWJsZXM7XG4gICAgICAgIHRoaXMuJGNvbXB1dGVUYWJTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHRoaXMuZGlzcGxheUluZGVudEd1aWRlcyA9IHRydWU7XG4gICAgdGhpcy5zZXREaXNwbGF5SW5kZW50R3VpZGVzID0gZnVuY3Rpb24oZGlzcGxheSkge1xuICAgICAgICBpZiAodGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzID09IGRpc3BsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5kaXNwbGF5SW5kZW50R3VpZGVzID0gZGlzcGxheTtcbiAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy4kdGFiU3RyaW5ncyA9IFtdO1xuICAgIHRoaXMub25DaGFuZ2VUYWJTaXplID1cbiAgICB0aGlzLiRjb21wdXRlVGFiU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5zZXNzaW9uLmdldFRhYlNpemUoKTtcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTtcbiAgICAgICAgdmFyIHRhYlN0ciA9IHRoaXMuJHRhYlN0cmluZ3MgPSBbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGFiU2l6ZSArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0YWJTdHIucHVzaChcIjxzcGFuIGNsYXNzPSdhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfdGFiJz5cIlxuICAgICAgICAgICAgICAgICAgICArIHRoaXMuVEFCX0NIQVJcbiAgICAgICAgICAgICAgICAgICAgKyBsYW5nLnN0cmluZ1JlcGVhdChcIiBcIiwgaSAtIDEpXG4gICAgICAgICAgICAgICAgICAgICsgXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWJTdHIucHVzaChsYW5nLnN0cmluZ1JlcGVhdChcIiBcIiwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMpIHtcbiAgICAgICAgICAgIHRoaXMuJGluZGVudEd1aWRlUmUgPSAgL1xcc1xcU3wgXFx0fFxcdCB8XFxzJC87XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJhY2VfaW5kZW50LWd1aWRlXCI7XG4gICAgICAgICAgICB2YXIgc3BhY2VDbGFzcyA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgdGFiQ2xhc3MgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gXCIgYWNlX2ludmlzaWJsZVwiO1xuICAgICAgICAgICAgICAgIHNwYWNlQ2xhc3MgPSBcIiBhY2VfaW52aXNpYmxlX3NwYWNlXCI7XG4gICAgICAgICAgICAgICAgdGFiQ2xhc3MgPSBcIiBhY2VfaW52aXNpYmxlX3RhYlwiO1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZUNvbnRlbnQgPSBsYW5nLnN0cmluZ1JlcGVhdCh0aGlzLlNQQUNFX0NIQVIsIHRoaXMudGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHRhYkNvbnRlbnQgPSB0aGlzLlRBQl9DSEFSICsgbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIHRoaXMudGFiU2l6ZSAtIDEpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZUNvbnRlbnQgPSBsYW5nLnN0cmluZ1JlcGVhdChcIiBcIiwgdGhpcy50YWJTaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFiQ29udGVudCA9IHNwYWNlQ29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kdGFiU3RyaW5nc1tcIiBcIl0gPSBcIjxzcGFuIGNsYXNzPSdcIiArIGNsYXNzTmFtZSArIHNwYWNlQ2xhc3MgKyBcIic+XCIgKyBzcGFjZUNvbnRlbnQgKyBcIjwvc3Bhbj5cIjtcbiAgICAgICAgICAgIHRoaXMuJHRhYlN0cmluZ3NbXCJcXHRcIl0gPSBcIjxzcGFuIGNsYXNzPSdcIiArIGNsYXNzTmFtZSArIHRhYkNsYXNzICsgXCInPlwiICsgdGFiQ29udGVudCArIFwiPC9zcGFuPlwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlTGluZXMgPSBmdW5jdGlvbihjb25maWcsIGZpcnN0Um93LCBsYXN0Um93KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5sYXN0Um93ICE9IGNvbmZpZy5sYXN0Um93IHx8XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5maXJzdFJvdyAhPSBjb25maWcuZmlyc3RSb3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGluZXMoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1heChmaXJzdFJvdywgY29uZmlnLmZpcnN0Um93KTtcbiAgICAgICAgdmFyIGxhc3QgPSBNYXRoLm1pbihsYXN0Um93LCBjb25maWcubGFzdFJvdyk7XG5cbiAgICAgICAgdmFyIGxpbmVFbGVtZW50cyA9IHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgbGluZUVsZW1lbnRzSWR4ID0gMDtcblxuICAgICAgICBmb3IgKHZhciByb3cgPSBjb25maWcuZmlyc3RSb3c7IHJvdyA8IGZpcnN0OyByb3crKykge1xuICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldEZvbGRMaW5lKHJvdyk7XG4gICAgICAgICAgICBpZiAoZm9sZExpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUuY29udGFpbnNSb3coZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZm9sZExpbmUuc3RhcnQucm93O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVFbGVtZW50c0lkeCArKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3cgPSBmaXJzdDtcbiAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3cpO1xuICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGRTdGFydCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IGZvbGRMaW5lLmVuZC5yb3crMTtcbiAgICAgICAgICAgICAgICBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93LCBmb2xkTGluZSk7XG4gICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOkluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdyA+IGxhc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIHZhciBsaW5lRWxlbWVudCA9IGxpbmVFbGVtZW50c1tsaW5lRWxlbWVudHNJZHgrK107XG4gICAgICAgICAgICBpZiAobGluZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlbmRlckxpbmUoXG4gICAgICAgICAgICAgICAgICAgIGh0bWwsIHJvdywgIXRoaXMuJHVzZUxpbmVHcm91cHMoKSwgcm93ID09IGZvbGRTdGFydCA/IGZvbGRMaW5lIDogZmFsc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxpbmVFbGVtZW50LnN0eWxlLmhlaWdodCA9IGNvbmZpZy5saW5lSGVpZ2h0ICogdGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGxpbmVFbGVtZW50LmlubmVySFRNTCA9IGh0bWwuam9pbihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2Nyb2xsTGluZXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIG9sZENvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICBpZiAoIW9sZENvbmZpZyB8fCBvbGRDb25maWcubGFzdFJvdyA8IGNvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuXG4gICAgICAgIGlmIChjb25maWcubGFzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xuXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgaWYgKG9sZENvbmZpZy5maXJzdFJvdyA8IGNvbmZpZy5maXJzdFJvdylcbiAgICAgICAgICAgIGZvciAodmFyIHJvdz10aGlzLnNlc3Npb24uZ2V0Rm9sZGVkUm93Q291bnQob2xkQ29uZmlnLmZpcnN0Um93LCBjb25maWcuZmlyc3RSb3cgLSAxKTsgcm93PjA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgIGlmIChvbGRDb25maWcubGFzdFJvdyA+IGNvbmZpZy5sYXN0Um93KVxuICAgICAgICAgICAgZm9yICh2YXIgcm93PXRoaXMuc2Vzc2lvbi5nZXRGb2xkZWRSb3dDb3VudChjb25maWcubGFzdFJvdyArIDEsIG9sZENvbmZpZy5sYXN0Um93KTsgcm93PjA7IHJvdy0tKVxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmxhc3RDaGlsZCk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5maXJzdFJvdyA8IG9sZENvbmZpZy5maXJzdFJvdykge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy4kcmVuZGVyTGluZXNGcmFnbWVudChjb25maWcsIGNvbmZpZy5maXJzdFJvdywgb2xkQ29uZmlnLmZpcnN0Um93IC0gMSk7XG4gICAgICAgICAgICBpZiAoZWwuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIGVsLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcubGFzdFJvdyA+IG9sZENvbmZpZy5sYXN0Um93KSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLiRyZW5kZXJMaW5lc0ZyYWdtZW50KGNvbmZpZywgb2xkQ29uZmlnLmxhc3RSb3cgKyAxLCBjb25maWcubGFzdFJvdyk7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kcmVuZGVyTGluZXNGcmFnbWVudCA9IGZ1bmN0aW9uKGNvbmZpZywgZmlyc3RSb3csIGxhc3RSb3cpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB2YXIgcm93ID0gZmlyc3RSb3c7XG4gICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93KTtcbiAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPiBmb2xkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93KzE7XG4gICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdywgZm9sZExpbmUpO1xuICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93ID4gbGFzdFJvdylcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICB2YXIgaHRtbCA9IFtdO1xuICAgICAgICAgICAgdGhpcy4kcmVuZGVyTGluZShodG1sLCByb3csIGZhbHNlLCByb3cgPT0gZm9sZFN0YXJ0ID8gZm9sZExpbmUgOiBmYWxzZSk7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbC5qb2luKFwiXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHVzZUxpbmVHcm91cHMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAnYWNlX2xpbmVfZ3JvdXAnO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGNvbmZpZy5saW5lSGVpZ2h0ICogdGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpICsgXCJweFwiO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlKGNvbnRhaW5lci5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgdmFyIGh0bWwgPSBbXTtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gY29uZmlnLmZpcnN0Um93LCBsYXN0Um93ID0gY29uZmlnLmxhc3RSb3c7XG5cbiAgICAgICAgdmFyIHJvdyA9IGZpcnN0Um93O1xuICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAocm93ID4gZm9sZFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcm93ID0gZm9sZExpbmUuZW5kLnJvdysxO1xuICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3csIGZvbGRMaW5lKTtcbiAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6SW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93ID4gbGFzdFJvdylcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgaWYgKHRoaXMuJHVzZUxpbmVHcm91cHMoKSlcbiAgICAgICAgICAgICAgICBodG1sLnB1c2goXCI8ZGl2IGNsYXNzPSdhY2VfbGluZV9ncm91cCcgc3R5bGU9J2hlaWdodDpcIiwgY29uZmlnLmxpbmVIZWlnaHQqdGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpLCBcInB4Jz5cIilcblxuICAgICAgICAgICAgdGhpcy4kcmVuZGVyTGluZShodG1sLCByb3csIGZhbHNlLCByb3cgPT0gZm9sZFN0YXJ0ID8gZm9sZExpbmUgOiBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLiR1c2VMaW5lR3JvdXBzKCkpXG4gICAgICAgICAgICAgICAgaHRtbC5wdXNoKFwiPC9kaXY+XCIpOyAvLyBlbmQgdGhlIGxpbmUgZ3JvdXBcblxuICAgICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IGh0bWwuam9pbihcIlwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kdGV4dFRva2VuID0ge1xuICAgICAgICBcInRleHRcIjogdHJ1ZSxcbiAgICAgICAgXCJycGFyZW5cIjogdHJ1ZSxcbiAgICAgICAgXCJscGFyZW5cIjogdHJ1ZVxuICAgIH07XG5cbiAgICB0aGlzLiRyZW5kZXJUb2tlbiA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJlcGxhY2VSZWcgPSAvXFx0fCZ8PHwoICspfChbXFx4MDAtXFx4MWZcXHg4MC1cXHhhMFxceGFkXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdUZFRkZdKXxbXFx1MTEwMC1cXHUxMTVGXFx1MTFBMy1cXHUxMUE3XFx1MTFGQS1cXHUxMUZGXFx1MjMyOS1cXHUyMzJBXFx1MkU4MC1cXHUyRTk5XFx1MkU5Qi1cXHUyRUYzXFx1MkYwMC1cXHUyRkQ1XFx1MkZGMC1cXHUyRkZCXFx1MzAwMC1cXHUzMDNFXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzE5MC1cXHUzMUJBXFx1MzFDMC1cXHUzMUUzXFx1MzFGMC1cXHUzMjFFXFx1MzIyMC1cXHUzMjQ3XFx1MzI1MC1cXHUzMkZFXFx1MzMwMC1cXHU0REJGXFx1NEUwMC1cXHVBNDhDXFx1QTQ5MC1cXHVBNEM2XFx1QTk2MC1cXHVBOTdDXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQUZGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTY2XFx1RkU2OC1cXHVGRTZCXFx1RkYwMS1cXHVGRjYwXFx1RkZFMC1cXHVGRkU2XS9nO1xuICAgICAgICB2YXIgcmVwbGFjZUZ1bmMgPSBmdW5jdGlvbihjLCBhLCBiLCB0YWJJZHgsIGlkeDQpIHtcbiAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2hvd0ludmlzaWJsZXNcbiAgICAgICAgICAgICAgICAgICAgPyBcIjxzcGFuIGNsYXNzPSdhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2UnPlwiICsgbGFuZy5zdHJpbmdSZXBlYXQoc2VsZi5TUEFDRV9DSEFSLCBjLmxlbmd0aCkgKyBcIjwvc3Bhbj5cIlxuICAgICAgICAgICAgICAgICAgICA6IGM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCImIzM4O1wiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09IFwiPFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJiM2MDtcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PSBcIlxcdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhYlNpemUgPSBzZWxmLnNlc3Npb24uZ2V0U2NyZWVuVGFiU2l6ZShzY3JlZW5Db2x1bW4gKyB0YWJJZHgpO1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSB0YWJTaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi4kdGFiU3RyaW5nc1t0YWJTaXplXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PSBcIlxcdTMwMDBcIikge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc1RvVXNlID0gc2VsZi5zaG93SW52aXNpYmxlcyA/IFwiYWNlX2NqayBhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2VcIiA6IFwiYWNlX2Nqa1wiO1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IHNlbGYuc2hvd0ludmlzaWJsZXMgPyBzZWxmLlNQQUNFX0NIQVIgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIGNsYXNzPSdcIiArIGNsYXNzVG9Vc2UgKyBcIicgc3R5bGU9J3dpZHRoOlwiICtcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLmNoYXJhY3RlcldpZHRoICogMikgK1xuICAgICAgICAgICAgICAgICAgICBcInB4Jz5cIiArIHNwYWNlICsgXCI8L3NwYW4+XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3BhbiBjbGFzcz0nYWNlX2ludmlzaWJsZSBhY2VfaW52aXNpYmxlX3NwYWNlIGFjZV9pbnZhbGlkJz5cIiArIHNlbGYuU1BBQ0VfQ0hBUiArIFwiPC9zcGFuPlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3BhbiBjbGFzcz0nYWNlX2Nqaycgc3R5bGU9J3dpZHRoOlwiICtcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLmNoYXJhY3RlcldpZHRoICogMikgK1xuICAgICAgICAgICAgICAgICAgICBcInB4Jz5cIiArIGMgKyBcIjwvc3Bhbj5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb3V0cHV0ID0gdmFsdWUucmVwbGFjZShyZXBsYWNlUmVnLCByZXBsYWNlRnVuYyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLiR0ZXh0VG9rZW5bdG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gXCJhY2VfXCIgKyB0b2tlbi50eXBlLnJlcGxhY2UoL1xcLi9nLCBcIiBhY2VfXCIpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09IFwiZm9sZFwiKVxuICAgICAgICAgICAgICAgIHN0eWxlID0gXCIgc3R5bGU9J3dpZHRoOlwiICsgKHRva2VuLnZhbHVlLmxlbmd0aCAqIHRoaXMuY29uZmlnLmNoYXJhY3RlcldpZHRoKSArIFwicHg7JyBcIjtcbiAgICAgICAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChcIjxzcGFuIGNsYXNzPSdcIiwgY2xhc3NlcywgXCInXCIsIHN0eWxlLCBcIj5cIiwgb3V0cHV0LCBcIjwvc3Bhbj5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2gob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NyZWVuQ29sdW1uICsgdmFsdWUubGVuZ3RoO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbmRlckluZGVudEd1aWRlID0gZnVuY3Rpb24oc3RyaW5nQnVpbGRlciwgdmFsdWUsIG1heCkge1xuICAgICAgICB2YXIgY29scyA9IHZhbHVlLnNlYXJjaCh0aGlzLiRpbmRlbnRHdWlkZVJlKTtcbiAgICAgICAgaWYgKGNvbHMgPD0gMCB8fCBjb2xzID49IG1heClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlWzBdID09IFwiIFwiKSB7XG4gICAgICAgICAgICBjb2xzIC09IGNvbHMgJSB0aGlzLnRhYlNpemU7XG4gICAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2gobGFuZy5zdHJpbmdSZXBlYXQodGhpcy4kdGFiU3RyaW5nc1tcIiBcIl0sIGNvbHMvdGhpcy50YWJTaXplKSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGNvbHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlWzBdID09IFwiXFx0XCIpIHtcbiAgICAgICAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChsYW5nLnN0cmluZ1JlcGVhdCh0aGlzLiR0YWJTdHJpbmdzW1wiXFx0XCJdLCBjb2xzKSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGNvbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy4kcmVuZGVyV3JhcHBlZExpbmUgPSBmdW5jdGlvbihzdHJpbmdCdWlsZGVyLCB0b2tlbnMsIHNwbGl0cywgb25seUNvbnRlbnRzKSB7XG4gICAgICAgIHZhciBjaGFycyA9IDA7XG4gICAgICAgIHZhciBzcGxpdCA9IDA7XG4gICAgICAgIHZhciBzcGxpdENoYXJzID0gc3BsaXRzWzBdO1xuICAgICAgICB2YXIgc2NyZWVuQ29sdW1uID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICBpZiAoaSA9PSAwICYmIHRoaXMuZGlzcGxheUluZGVudEd1aWRlcykge1xuICAgICAgICAgICAgICAgIGNoYXJzID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZW5kZXJJbmRlbnRHdWlkZShzdHJpbmdCdWlsZGVyLCB2YWx1ZSwgc3BsaXRDaGFycyk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2hhcnMgLT0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhcnMgKyB2YWx1ZS5sZW5ndGggPCBzcGxpdENoYXJzKSB7XG4gICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uID0gdGhpcy4kcmVuZGVyVG9rZW4oc3RyaW5nQnVpbGRlciwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNoYXJzICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJzICsgdmFsdWUubGVuZ3RoID49IHNwbGl0Q2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uID0gdGhpcy4kcmVuZGVyVG9rZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLCBzY3JlZW5Db2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiwgdmFsdWUuc3Vic3RyaW5nKDAsIHNwbGl0Q2hhcnMgLSBjaGFycylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3BsaXRDaGFycyAtIGNoYXJzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBzcGxpdENoYXJzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb25seUNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2FjZV9saW5lJyBzdHlsZT0naGVpZ2h0OlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpbmVIZWlnaHQsIFwicHgnPlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgKys7XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0Q2hhcnMgPSBzcGxpdHNbc3BsaXRdIHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFycyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IHRoaXMuJHJlbmRlclRva2VuKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nQnVpbGRlciwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kcmVuZGVyU2ltcGxlTGluZSA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHRva2Vucykge1xuICAgICAgICB2YXIgc2NyZWVuQ29sdW1uID0gMDtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zWzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheUluZGVudEd1aWRlcylcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZW5kZXJJbmRlbnRHdWlkZShzdHJpbmdCdWlsZGVyLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IHRoaXMuJHJlbmRlclRva2VuKHN0cmluZ0J1aWxkZXIsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IHRoaXMuJHJlbmRlclRva2VuKHN0cmluZ0J1aWxkZXIsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy4kcmVuZGVyTGluZSA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHJvdywgb25seUNvbnRlbnRzLCBmb2xkTGluZSkge1xuICAgICAgICBpZiAoIWZvbGRMaW5lICYmIGZvbGRMaW5lICE9IGZhbHNlKVxuICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZExpbmUocm93KTtcblxuICAgICAgICBpZiAoZm9sZExpbmUpXG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy4kZ2V0Rm9sZExpbmVUb2tlbnMocm93LCBmb2xkTGluZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnNlc3Npb24uZ2V0VG9rZW5zKHJvdyk7XG5cblxuICAgICAgICBpZiAoIW9ubHlDb250ZW50cykge1xuICAgICAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nYWNlX2xpbmUnIHN0eWxlPSdoZWlnaHQ6XCIsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5saW5lSGVpZ2h0ICogKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdXNlTGluZUdyb3VwcygpID8gMSA6dGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpXG4gICAgICAgICAgICAgICAgICAgICksIFwicHgnPlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdHMgPSB0aGlzLnNlc3Npb24uZ2V0Um93U3BsaXREYXRhKHJvdyk7XG4gICAgICAgICAgICBpZiAoc3BsaXRzICYmIHNwbGl0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy4kcmVuZGVyV3JhcHBlZExpbmUoc3RyaW5nQnVpbGRlciwgdG9rZW5zLCBzcGxpdHMsIG9ubHlDb250ZW50cyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy4kcmVuZGVyU2ltcGxlTGluZShzdHJpbmdCdWlsZGVyLCB0b2tlbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgICAgIGlmIChmb2xkTGluZSlcbiAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93XG5cbiAgICAgICAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChcbiAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfZW9sJz5cIixcbiAgICAgICAgICAgICAgICByb3cgPT0gdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpIC0gMSA/IHRoaXMuRU9GX0NIQVIgOiB0aGlzLkVPTF9DSEFSLFxuICAgICAgICAgICAgICAgIFwiPC9zcGFuPlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb25seUNvbnRlbnRzKVxuICAgICAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFwiPC9kaXY+XCIpO1xuICAgIH07XG5cbiAgICB0aGlzLiRnZXRGb2xkTGluZVRva2VucyA9IGZ1bmN0aW9uKHJvdywgZm9sZExpbmUpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciByZW5kZXJUb2tlbnMgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRUb2tlbnModG9rZW5zLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgdmFyIGlkeCA9IDAsIGNvbCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoKGNvbCArIHRva2Vuc1tpZHhdLnZhbHVlLmxlbmd0aCkgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgY29sICs9IHRva2Vuc1tpZHhdLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZHgrKztcblxuICAgICAgICAgICAgICAgIGlmIChpZHggPT0gdG9rZW5zLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbCAhPSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdG9rZW5zW2lkeF0udmFsdWUuc3Vic3RyaW5nKGZyb20gLSBjb2wpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAodG8gLSBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdG8gLSBmcm9tKTtcblxuICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW5zW2lkeF0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb2wgPSBmcm9tICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoY29sIDwgdG8gJiYgaWR4IDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva2Vuc1tpZHhdLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggKyBjb2wgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJUb2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbnNbaWR4XS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnN1YnN0cmluZygwLCB0byAtIGNvbClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHRva2Vuc1tpZHhdKTtcbiAgICAgICAgICAgICAgICBjb2wgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VucyA9IHNlc3Npb24uZ2V0VG9rZW5zKHJvdyk7XG4gICAgICAgIGZvbGRMaW5lLndhbGsoZnVuY3Rpb24ocGxhY2Vob2xkZXIsIHJvdywgY29sdW1uLCBsYXN0Q29sdW1uLCBpc05ld1Jvdykge1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUb2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZm9sZFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3Um93KVxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFkZFRva2Vucyh0b2tlbnMsIGxhc3RDb2x1bW4sIGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZvbGRMaW5lLmVuZC5yb3csIHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGZvbGRMaW5lLmVuZC5yb3cpLmxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlclRva2VucztcbiAgICB9O1xuXG4gICAgdGhpcy4kdXNlTGluZUdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldFVzZVdyYXBNb2RlKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuJG1lYXN1cmVOb2RlKVxuICAgICAgICAgICAgdGhpcy4kbWVhc3VyZU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLiRtZWFzdXJlTm9kZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLiRtZWFzdXJlTm9kZTtcbiAgICB9O1xuXG59KS5jYWxsKFRleHQucHJvdG90eXBlKTtcblxuZXhwb3J0cy5UZXh0ID0gVGV4dDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbGF5ZXIvY3Vyc29yXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2RvbVwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkb20gPSBhY2VxdWlyZShcIi4uL2xpYi9kb21cIik7XG52YXIgSUU4O1xuXG52YXIgQ3Vyc29yID0gZnVuY3Rpb24ocGFyZW50RWwpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXCJhY2VfbGF5ZXIgYWNlX2N1cnNvci1sYXllclwiO1xuICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgXG4gICAgaWYgKElFOCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBJRTggPSBcIm9wYWNpdHlcIiBpbiB0aGlzLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNCbGlua2luZyA9IHRydWU7XG4gICAgdGhpcy5ibGlua0ludGVydmFsID0gMTAwMDtcbiAgICB0aGlzLnNtb290aEJsaW5raW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmN1cnNvcnMgPSBbXTtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMuYWRkQ3Vyc29yKCk7XG4gICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2VfaGlkZGVuLWN1cnNvcnNcIik7XG4gICAgdGhpcy4kdXBkYXRlQ3Vyc29ycyA9IHRoaXMuJHVwZGF0ZVZpc2liaWxpdHkuYmluZCh0aGlzKTtcbn07XG5cbihmdW5jdGlvbigpIHtcbiAgICBcbiAgICB0aGlzLiR1cGRhdGVWaXNpYmlsaXR5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciBjdXJzb3JzID0gdGhpcy5jdXJzb3JzO1xuICAgICAgICBmb3IgKHZhciBpID0gY3Vyc29ycy5sZW5ndGg7IGktLTsgKVxuICAgICAgICAgICAgY3Vyc29yc1tpXS5zdHlsZS52aXNpYmlsaXR5ID0gdmFsID8gXCJcIiA6IFwiaGlkZGVuXCI7XG4gICAgfTtcbiAgICB0aGlzLiR1cGRhdGVPcGFjaXR5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciBjdXJzb3JzID0gdGhpcy5jdXJzb3JzO1xuICAgICAgICBmb3IgKHZhciBpID0gY3Vyc29ycy5sZW5ndGg7IGktLTsgKVxuICAgICAgICAgICAgY3Vyc29yc1tpXS5zdHlsZS5vcGFjaXR5ID0gdmFsID8gXCJcIiA6IFwiMFwiO1xuICAgIH07XG4gICAgXG5cbiAgICB0aGlzLiRwYWRkaW5nID0gMDtcbiAgICB0aGlzLnNldFBhZGRpbmcgPSBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgIHRoaXMuJHBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QmxpbmtpbmcgPSBmdW5jdGlvbihibGlua2luZykge1xuICAgICAgICBpZiAoYmxpbmtpbmcgIT0gdGhpcy5pc0JsaW5raW5nKXtcbiAgICAgICAgICAgIHRoaXMuaXNCbGlua2luZyA9IGJsaW5raW5nO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnNldEJsaW5rSW50ZXJ2YWwgPSBmdW5jdGlvbihibGlua0ludGVydmFsKSB7XG4gICAgICAgIGlmIChibGlua0ludGVydmFsICE9IHRoaXMuYmxpbmtJbnRlcnZhbCl7XG4gICAgICAgICAgICB0aGlzLmJsaW5rSW50ZXJ2YWwgPSBibGlua0ludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnNldFNtb290aEJsaW5raW5nID0gZnVuY3Rpb24oc21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgaWYgKHNtb290aEJsaW5raW5nICE9IHRoaXMuc21vb3RoQmxpbmtpbmcgJiYgIUlFOCkge1xuICAgICAgICAgICAgdGhpcy5zbW9vdGhCbGlua2luZyA9IHNtb290aEJsaW5raW5nO1xuICAgICAgICAgICAgZG9tLnNldENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2Vfc21vb3RoLWJsaW5raW5nXCIsIHNtb290aEJsaW5raW5nKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUN1cnNvcnModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVDdXJzb3JzID0gKHNtb290aEJsaW5raW5nIFxuICAgICAgICAgICAgICAgID8gdGhpcy4kdXBkYXRlT3BhY2l0eVxuICAgICAgICAgICAgICAgIDogdGhpcy4kdXBkYXRlVmlzaWJpbGl0eSkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hZGRDdXJzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiYWNlX2N1cnNvclwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB0aGlzLmN1cnNvcnMucHVzaChlbCk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVDdXJzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmN1cnNvcnMucG9wKCk7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmhpZGVDdXJzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2VfaGlkZGVuLWN1cnNvcnNcIik7XG4gICAgICAgIHRoaXMucmVzdGFydFRpbWVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2hvd0N1cnNvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX2hpZGRlbi1jdXJzb3JzXCIpO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc3RhcnRUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBkYXRlID0gdGhpcy4kdXBkYXRlQ3Vyc29ycztcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICBpZiAodGhpcy5zbW9vdGhCbGlua2luZykge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNzc0NsYXNzKHRoaXMuZWxlbWVudCwgXCJhY2Vfc21vb3RoLWJsaW5raW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB1cGRhdGUodHJ1ZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQmxpbmtpbmcgfHwgIXRoaXMuYmxpbmtJbnRlcnZhbCB8fCAhdGhpcy5pc1Zpc2libGUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuc21vb3RoQmxpbmtpbmcpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5lbGVtZW50LCBcImFjZV9zbW9vdGgtYmxpbmtpbmdcIik7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgYmxpbmsgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZShmYWxzZSk7XG4gICAgICAgICAgICB9LCAwLjYgKiB0aGlzLmJsaW5rSW50ZXJ2YWwpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1cGRhdGUodHJ1ZSk7XG4gICAgICAgICAgICBibGluaygpO1xuICAgICAgICB9LCB0aGlzLmJsaW5rSW50ZXJ2YWwpO1xuXG4gICAgICAgIGJsaW5rKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGl4ZWxQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBvblNjcmVlbikge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnIHx8ICF0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4ge2xlZnQgOiAwLCB0b3AgOiAwfTtcblxuICAgICAgICBpZiAoIXBvc2l0aW9uKVxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHZhciBjdXJzb3JMZWZ0ID0gdGhpcy4kcGFkZGluZyArIHBvcy5jb2x1bW4gKiB0aGlzLmNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGN1cnNvclRvcCA9IChwb3Mucm93IC0gKG9uU2NyZWVuID8gdGhpcy5jb25maWcuZmlyc3RSb3dTY3JlZW4gOiAwKSkgKlxuICAgICAgICAgICAgdGhpcy5jb25maWcubGluZUhlaWdodDtcblxuICAgICAgICByZXR1cm4ge2xlZnQgOiBjdXJzb3JMZWZ0LCB0b3AgOiBjdXJzb3JUb3B9O1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VycztcbiAgICAgICAgdmFyIGkgPSAwLCBjdXJzb3JJbmRleCA9IDA7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gW3tjdXJzb3I6IG51bGx9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc2VsZWN0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaXhlbFBvcyA9IHRoaXMuZ2V0UGl4ZWxQb3NpdGlvbihzZWxlY3Rpb25zW2ldLmN1cnNvciwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoKHBpeGVsUG9zLnRvcCA+IGNvbmZpZy5oZWlnaHQgKyBjb25maWcub2Zmc2V0IHx8XG4gICAgICAgICAgICAgICAgIHBpeGVsUG9zLnRvcCA8IDApICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9ICh0aGlzLmN1cnNvcnNbY3Vyc29ySW5kZXgrK10gfHwgdGhpcy5hZGRDdXJzb3IoKSkuc3R5bGU7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5kcmF3Q3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IHBpeGVsUG9zLmxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gcGl4ZWxQb3MudG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gY29uZmlnLmNoYXJhY3RlcldpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGNvbmZpZy5saW5lSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdDdXJzb3Ioc3R5bGUsIHBpeGVsUG9zLCBjb25maWcsIHNlbGVjdGlvbnNbaV0sIHRoaXMuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuY3Vyc29ycy5sZW5ndGggPiBjdXJzb3JJbmRleClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ3Vyc29yKCk7XG5cbiAgICAgICAgdmFyIG92ZXJ3cml0ZSA9IHRoaXMuc2Vzc2lvbi5nZXRPdmVyd3JpdGUoKTtcbiAgICAgICAgdGhpcy4kc2V0T3ZlcndyaXRlKG92ZXJ3cml0ZSk7XG4gICAgICAgIHRoaXMuJHBpeGVsUG9zID0gcGl4ZWxQb3M7XG4gICAgICAgIHRoaXMucmVzdGFydFRpbWVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZHJhd0N1cnNvciA9IG51bGw7XG5cbiAgICB0aGlzLiRzZXRPdmVyd3JpdGUgPSBmdW5jdGlvbihvdmVyd3JpdGUpIHtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSAhPSB0aGlzLm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgdGhpcy5vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX292ZXJ3cml0ZS1jdXJzb3JzXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFwiYWNlX292ZXJ3cml0ZS1jdXJzb3JzXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgfTtcblxufSkuY2FsbChDdXJzb3IucHJvdG90eXBlKTtcblxuZXhwb3J0cy5DdXJzb3IgPSBDdXJzb3I7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3Njcm9sbGJhclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gYWNlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgZXZlbnQgPSBhY2VxdWlyZShcIi4vbGliL2V2ZW50XCIpO1xudmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgU2Nyb2xsQmFyID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFwiYWNlX3Njcm9sbGJhciBhY2Vfc2Nyb2xsYmFyXCIgKyB0aGlzLmNsYXNzU3VmZml4O1xuXG4gICAgdGhpcy5pbm5lciA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuaW5uZXIuY2xhc3NOYW1lID0gXCJhY2Vfc2Nyb2xsYmFyLWlubmVyXCI7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW5uZXIpO1xuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG5cbiAgICB0aGlzLnNldFZpc2libGUoZmFsc2UpO1xuICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XG5cbiAgICBldmVudC5hZGRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5lbGVtZW50LCBcIm1vdXNlZG93blwiLCBldmVudC5wcmV2ZW50RGVmYXVsdCk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuXG4gICAgdGhpcy5zZXRWaXNpYmxlID0gZnVuY3Rpb24oaXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaXNWaXNpYmxlID8gXCJcIiA6IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB9O1xufSkuY2FsbChTY3JvbGxCYXIucHJvdG90eXBlKTtcbnZhciBWU2Nyb2xsQmFyID0gZnVuY3Rpb24ocGFyZW50LCByZW5kZXJlcikge1xuICAgIFNjcm9sbEJhci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSAwO1xuICAgIHJlbmRlcmVyLiRzY3JvbGxiYXJXaWR0aCA9IFxuICAgIHRoaXMud2lkdGggPSBkb20uc2Nyb2xsYmFyV2lkdGgocGFyZW50Lm93bmVyRG9jdW1lbnQpO1xuICAgIHRoaXMuaW5uZXIuc3R5bGUud2lkdGggPVxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIHx8IDE1KSArIDUgKyBcInB4XCI7XG59O1xuXG5vb3AuaW5oZXJpdHMoVlNjcm9sbEJhciwgU2Nyb2xsQmFyKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5jbGFzc1N1ZmZpeCA9ICctdic7XG4gICAgdGhpcy5vblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2tpcEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KFwic2Nyb2xsXCIsIHtkYXRhOiB0aGlzLnNjcm9sbFRvcH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmlzaWJsZSA/IHRoaXMud2lkdGggOiAwO1xuICAgIH07XG4gICAgdGhpcy5zZXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIHRoaXMuc2V0SW5uZXJIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5pbm5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgfTtcbiAgICB0aGlzLnNldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIHRoaXMuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24oc2Nyb2xsVG9wKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5lbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pLmNhbGwoVlNjcm9sbEJhci5wcm90b3R5cGUpO1xudmFyIEhTY3JvbGxCYXIgPSBmdW5jdGlvbihwYXJlbnQsIHJlbmRlcmVyKSB7XG4gICAgU2Nyb2xsQmFyLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICB0aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gcmVuZGVyZXIuJHNjcm9sbGJhcldpZHRoO1xuICAgIHRoaXMuaW5uZXIuc3R5bGUuaGVpZ2h0ID1cbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IHx8IDE1KSArIDUgKyBcInB4XCI7XG59O1xuXG5vb3AuaW5oZXJpdHMoSFNjcm9sbEJhciwgU2Nyb2xsQmFyKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5jbGFzc1N1ZmZpeCA9ICctaCc7XG4gICAgdGhpcy5vblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2tpcEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoXCJzY3JvbGxcIiwge2RhdGE6IHRoaXMuc2Nyb2xsTGVmdH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPyB0aGlzLmhlaWdodCA6IDA7XG4gICAgfTtcbiAgICB0aGlzLnNldFdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgfTtcbiAgICB0aGlzLnNldElubmVyV2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB0aGlzLmlubmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgfTtcbiAgICB0aGlzLnNldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgdGhpcy5pbm5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH07XG4gICAgdGhpcy5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24oc2Nyb2xsTGVmdCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxMZWZ0ICE9IHNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pLmNhbGwoSFNjcm9sbEJhci5wcm90b3R5cGUpO1xuXG5cbmV4cG9ydHMuU2Nyb2xsQmFyID0gVlNjcm9sbEJhcjsgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0cy5TY3JvbGxCYXJWID0gVlNjcm9sbEJhcjsgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0cy5TY3JvbGxCYXJIID0gSFNjcm9sbEJhcjsgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5leHBvcnRzLlZTY3JvbGxCYXIgPSBWU2Nyb2xsQmFyO1xuZXhwb3J0cy5IU2Nyb2xsQmFyID0gSFNjcm9sbEJhcjtcbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL3JlbmRlcmxvb3BcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvZXZlbnRcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgZXZlbnQgPSBhY2VxdWlyZShcIi4vbGliL2V2ZW50XCIpO1xuXG5cbnZhciBSZW5kZXJMb29wID0gZnVuY3Rpb24ob25SZW5kZXIsIHdpbikge1xuICAgIHRoaXMub25SZW5kZXIgPSBvblJlbmRlcjtcbiAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNoYW5nZXMgPSAwO1xuICAgIHRoaXMud2luZG93ID0gd2luIHx8IHdpbmRvdztcbn07XG5cbihmdW5jdGlvbigpIHtcblxuXG4gICAgdGhpcy5zY2hlZHVsZSA9IGZ1bmN0aW9uKGNoYW5nZSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLmNoYW5nZXMgfCBjaGFuZ2U7XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nICYmIHRoaXMuY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBldmVudC5uZXh0RnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX3NlbGYucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGFuZ2VzID0gX3NlbGYuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICBfc2VsZi5jaGFuZ2VzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX3NlbGYub25SZW5kZXIoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy53aW5kb3cpO1xuICAgICAgICB9XG4gICAgfTtcblxufSkuY2FsbChSZW5kZXJMb29wLnByb3RvdHlwZSk7XG5cbmV4cG9ydHMuUmVuZGVyTG9vcCA9IFJlbmRlckxvb3A7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9sYXllci9mb250X21ldHJpY3NcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbnZhciBvb3AgPSBhY2VxdWlyZShcIi4uL2xpYi9vb3BcIik7XG52YXIgZG9tID0gYWNlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIGxhbmcgPSBhY2VxdWlyZShcIi4uL2xpYi9sYW5nXCIpO1xudmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFwiLi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcIi4uL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcblxudmFyIENIQVJfQ09VTlQgPSAwO1xuXG52YXIgRm9udE1ldHJpY3MgPSBleHBvcnRzLkZvbnRNZXRyaWNzID0gZnVuY3Rpb24ocGFyZW50RWwsIGludGVydmFsKSB7XG4gICAgdGhpcy5lbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuJHNldE1lYXN1cmVOb2RlU3R5bGVzKHRoaXMuZWwuc3R5bGUsIHRydWUpO1xuICAgIFxuICAgIHRoaXMuJG1haW4gPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyh0aGlzLiRtYWluLnN0eWxlKTtcbiAgICBcbiAgICB0aGlzLiRtZWFzdXJlTm9kZSA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuJHNldE1lYXN1cmVOb2RlU3R5bGVzKHRoaXMuJG1lYXN1cmVOb2RlLnN0eWxlKTtcbiAgICBcbiAgICBcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuJG1haW4pO1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy4kbWVhc3VyZU5vZGUpO1xuICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgIFxuICAgIGlmICghQ0hBUl9DT1VOVClcbiAgICAgICAgdGhpcy4kdGVzdEZyYWN0aW9uYWxSZWN0KCk7XG4gICAgdGhpcy4kbWVhc3VyZU5vZGUuaW5uZXJIVE1MID0gbGFuZy5zdHJpbmdSZXBlYXQoXCJYXCIsIENIQVJfQ09VTlQpO1xuICAgIFxuICAgIHRoaXMuJGNoYXJhY3RlclNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG4gICAgdGhpcy5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XG4gICAgICAgIFxuICAgIHRoaXMuJGNoYXJhY3RlclNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG4gICAgXG4gICAgdGhpcy4kdGVzdEZyYWN0aW9uYWxSZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyhlbC5zdHlsZSk7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gXCIwLjJweFwiO1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB2YXIgdyA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBpZiAodyA+IDAgJiYgdyA8IDEpXG4gICAgICAgICAgICBDSEFSX0NPVU5UID0gNTA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIENIQVJfQ09VTlQgPSAxMDA7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy4kc2V0TWVhc3VyZU5vZGVTdHlsZXMgPSBmdW5jdGlvbihzdHlsZSwgaXNSb290KSB7XG4gICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSBcInByZVwiO1xuXG4gICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSA8IDgpIHtcbiAgICAgICAgICAgIHN0eWxlW1wiZm9udC1mYW1pbHlcIl0gPSBcImluaGVyaXRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBcImluaGVyaXRcIjtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IGlzUm9vdCA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICB9O1xuXG4gICAgdGhpcy5jaGVja0ZvclNpemVDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy4kbWVhc3VyZVNpemVzKCk7XG4gICAgICAgIGlmIChzaXplICYmICh0aGlzLiRjaGFyYWN0ZXJTaXplLndpZHRoICE9PSBzaXplLndpZHRoIHx8IHRoaXMuJGNoYXJhY3RlclNpemUuaGVpZ2h0ICE9PSBzaXplLmhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuJG1lYXN1cmVOb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICAgICAgICAgIHZhciBib2xkU2l6ZSA9IHRoaXMuJG1lYXN1cmVTaXplcygpO1xuICAgICAgICAgICAgdGhpcy4kbWVhc3VyZU5vZGUuc3R5bGUuZm9udFdlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLiRjaGFyYWN0ZXJTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhclNpemVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dCb2xkRm9udHMgPSBib2xkU2l6ZSAmJiBib2xkU2l6ZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiBib2xkU2l6ZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZUNoYXJhY3RlclNpemVcIiwge2RhdGE6IHNpemV9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLiRwb2xsU2l6ZUNoYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLiRwb2xsU2l6ZUNoYW5nZXNUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldFBvbGxpbmcgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgdGhpcy4kcG9sbFNpemVDaGFuZ2VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kbWVhc3VyZVNpemVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChDSEFSX0NPVU5UID09PSA1MCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHsgXG4gICAgICAgICAgICAgICByZWN0ID0gdGhpcy4kbWVhc3VyZU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgIHJlY3QgPSB7d2lkdGg6IDAsIGhlaWdodDowIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNpemUgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIENIQVJfQ09VTlRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuJG1lYXN1cmVOb2RlLmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy4kbWVhc3VyZU5vZGUuY2xpZW50V2lkdGggLyBDSEFSX0NPVU5UXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplLndpZHRoID09PSAwIHx8IHNpemUuaGVpZ2h0ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG5cbiAgICB0aGlzLiRtZWFzdXJlQ2hhcldpZHRoID0gZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgdGhpcy4kbWFpbi5pbm5lckhUTUwgPSBsYW5nLnN0cmluZ1JlcGVhdChjaCwgQ0hBUl9DT1VOVCk7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy4kbWFpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHJlY3Qud2lkdGggLyBDSEFSX0NPVU5UO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRDaGFyYWN0ZXJXaWR0aCA9IGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy5jaGFyU2l6ZXNbY2hdO1xuICAgICAgICBpZiAodyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJTaXplc1tjaF0gPSB0aGlzLiRtZWFzdXJlQ2hhcldpZHRoKGNoKSAvIHRoaXMuJGNoYXJhY3RlclNpemUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgdGhpcy5lbC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH07XG5cbn0pLmNhbGwoRm9udE1ldHJpY3MucHJvdG90eXBlKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvY29uZmlnXCIsXCJhY2UvbGliL3VzZXJhZ2VudFwiLFwiYWNlL2xheWVyL2d1dHRlclwiLFwiYWNlL2xheWVyL21hcmtlclwiLFwiYWNlL2xheWVyL3RleHRcIixcImFjZS9sYXllci9jdXJzb3JcIixcImFjZS9zY3JvbGxiYXJcIixcImFjZS9zY3JvbGxiYXJcIixcImFjZS9yZW5kZXJsb29wXCIsXCJhY2UvbGF5ZXIvZm9udF9tZXRyaWNzXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgZG9tID0gYWNlcXVpcmUoXCIuL2xpYi9kb21cIik7XG52YXIgY29uZmlnID0gYWNlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbnZhciB1c2VyYWdlbnQgPSBhY2VxdWlyZShcIi4vbGliL3VzZXJhZ2VudFwiKTtcbnZhciBHdXR0ZXJMYXllciA9IGFjZXF1aXJlKFwiLi9sYXllci9ndXR0ZXJcIikuR3V0dGVyO1xudmFyIE1hcmtlckxheWVyID0gYWNlcXVpcmUoXCIuL2xheWVyL21hcmtlclwiKS5NYXJrZXI7XG52YXIgVGV4dExheWVyID0gYWNlcXVpcmUoXCIuL2xheWVyL3RleHRcIikuVGV4dDtcbnZhciBDdXJzb3JMYXllciA9IGFjZXF1aXJlKFwiLi9sYXllci9jdXJzb3JcIikuQ3Vyc29yO1xudmFyIEhTY3JvbGxCYXIgPSBhY2VxdWlyZShcIi4vc2Nyb2xsYmFyXCIpLkhTY3JvbGxCYXI7XG52YXIgVlNjcm9sbEJhciA9IGFjZXF1aXJlKFwiLi9zY3JvbGxiYXJcIikuVlNjcm9sbEJhcjtcbnZhciBSZW5kZXJMb29wID0gYWNlcXVpcmUoXCIuL3JlbmRlcmxvb3BcIikuUmVuZGVyTG9vcDtcbnZhciBGb250TWV0cmljcyA9IGFjZXF1aXJlKFwiLi9sYXllci9mb250X21ldHJpY3NcIikuRm9udE1ldHJpY3M7XG52YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXCIuL2xpYi9ldmVudF9lbWl0dGVyXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBlZGl0b3JDc3MgPSBcIi5hY2VfZWRpdG9yIHtcXFxucG9zaXRpb246IHJlbGF0aXZlO1xcXG5vdmVyZmxvdzogaGlkZGVuO1xcXG5mb250OiAxMnB4L25vcm1hbCAnTW9uYWNvJywgJ01lbmxvJywgJ1VidW50dSBNb25vJywgJ0NvbnNvbGFzJywgJ3NvdXJjZS1jb2RlLXBybycsIG1vbm9zcGFjZTtcXFxuZGlyZWN0aW9uOiBsdHI7XFxcbn1cXFxuLmFjZV9zY3JvbGxlciB7XFxcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxub3ZlcmZsb3c6IGhpZGRlbjtcXFxudG9wOiAwO1xcXG5ib3R0b206IDA7XFxcbmJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxcbi1tcy11c2VyLXNlbGVjdDogbm9uZTtcXFxuLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXFxuLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXFxudXNlci1zZWxlY3Q6IG5vbmU7XFxcbmN1cnNvcjogdGV4dDtcXFxufVxcXG4uYWNlX2NvbnRlbnQge1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbi1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxuLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG5taW4td2lkdGg6IDEwMCU7XFxcbn1cXFxuLmFjZV9kcmFnZ2luZyAuYWNlX3Njcm9sbGVyOmJlZm9yZXtcXFxucG9zaXRpb246IGFic29sdXRlO1xcXG50b3A6IDA7XFxcbmxlZnQ6IDA7XFxcbnJpZ2h0OiAwO1xcXG5ib3R0b206IDA7XFxcbmNvbnRlbnQ6ICcnO1xcXG5iYWNrZ3JvdW5kOiByZ2JhKDI1MCwgMjUwLCAyNTAsIDAuMDEpO1xcXG56LWluZGV4OiAxMDAwO1xcXG59XFxcbi5hY2VfZHJhZ2dpbmcuYWNlX2RhcmsgLmFjZV9zY3JvbGxlcjpiZWZvcmV7XFxcbmJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wMSk7XFxcbn1cXFxuLmFjZV9zZWxlY3RpbmcsIC5hY2Vfc2VsZWN0aW5nICoge1xcXG5jdXJzb3I6IHRleHQgIWltcG9ydGFudDtcXFxufVxcXG4uYWNlX2d1dHRlciB7XFxcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxub3ZlcmZsb3cgOiBoaWRkZW47XFxcbndpZHRoOiBhdXRvO1xcXG50b3A6IDA7XFxcbmJvdHRvbTogMDtcXFxubGVmdDogMDtcXFxuY3Vyc29yOiBkZWZhdWx0O1xcXG56LWluZGV4OiA0O1xcXG4tbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxcbi1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxcbi13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxcbnVzZXItc2VsZWN0OiBub25lO1xcXG59XFxcbi5hY2VfZ3V0dGVyLWFjdGl2ZS1saW5lIHtcXFxucG9zaXRpb246IGFic29sdXRlO1xcXG5sZWZ0OiAwO1xcXG5yaWdodDogMDtcXFxufVxcXG4uYWNlX3Njcm9sbGVyLmFjZV9zY3JvbGwtbGVmdCB7XFxcbmJveC1zaGFkb3c6IDE3cHggMCAxNnB4IC0xNnB4IHJnYmEoMCwgMCwgMCwgMC40KSBpbnNldDtcXFxufVxcXG4uYWNlX2d1dHRlci1jZWxsIHtcXFxucGFkZGluZy1sZWZ0OiAxOXB4O1xcXG5wYWRkaW5nLXJpZ2h0OiA2cHg7XFxcbmJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxcbn1cXFxuLmFjZV9ndXR0ZXItY2VsbC5hY2VfZXJyb3Ige1xcXG5iYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBTUFBQUFvTFE5VEFBQUJPRkJNVkVYLy8vLy8vLy8vUVJzd0ZBYi9VaTR3RkFZd0ZBWXdGQWFXR0FmRFJ5bXpPU0gvUHhzd0ZBYi9TaVV3RkFZd0ZBYlVQUnZqUWlEbGxvZzVIaEhkUnlic1RpMy9UeXY5VGlyK1N5ai9VQzMvLy8vWHVyZWJNQkl3RkFiL1JTSGJQeC9nVXpmZHdMM2t6TWl2S0JBd0ZBYmJ2Ym5oUHg2Nk5ob3dGQVl3RkFhWkpnOHdGQWF4S0JEWnVyZi9SQjZtTXhiL1NDTXdGQVl3RkFieFFCMytSQjR3RkFiL1FoeTRPaCs0UWlmYk5SY3dGQVl3RkFZd0ZBYi9RUnpkTmhnd0ZBWXdGQWJhdjd2L1V5N29hRTY4TUJLNUx4TGV3ci9yMk5YZXdMc3dGQWF4Snc0d0ZBYmtQUnkyUHlZd0ZBYXhLaExtMXRNd0ZBYXpQaVF3RkFhVUdBYi9RQnJmT3gzYnZydi9WQy9tYUU0d0ZBYlJQQnE2TVJPOFF5bmV3OERwMnRqZndiMHdGQWJ4NmVqdTUrYnk2dW5zNHVIOS9mMzYrdnIvR2tIakFBQUFZblJTVGxNQUd0KzY0cm5XdS9ibzhlQUE0SW5IMytEd29ON2o0ZUxpNHhQOTlOZmc0K2IrL3U5Qi9lRHMxTUQxbU83KzRQSGcyTVhhMzQ3Zzd2RGl6TUxONGVHK1B2N2k1ZXZzL3Y3OXl1N1MzL0RWNy80OThZdjI0ZUgrNHVmUTNPenUvdjcreTEzc1Jxd0FBQURMU1VSQlZIamFaYy9YRHNGZ0dJQmh0RHJzaGxpdG1rMklyYkhGcUwycHZYZi8rNzhEUG9rajcrRno5cXBVLzlVWEpJbGhtUGFUYVE2UVBhejBtbSs1Z3drZ292Y1Y2R1p6ZDVKdENRd2dzeG9IT3ZKTzE1a2xlUkxBbk1nSEZJRVNVRVBtYXdCOW5nbWVsVHRpcHd3ZkFTaWx4T0x5aVY1VVZVeVZBZmJHMGNDUEhpZytHQmt6QUVOSFMwQXN0VkY2YmFjWklPemdMbXhzSGJ0Mk9lY05nSkM4M0pFUm1lUFVZcThBUkdrSng2WHRGc2RkZEJRZ1pFMm5QUjZDSUNaaGF3akE0RmIvY2h2KzM5OWtmUitNTU1ER09RQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxcbmJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxcbmJhY2tncm91bmQtcG9zaXRpb246IDJweCBjZW50ZXI7XFxcbn1cXFxuLmFjZV9ndXR0ZXItY2VsbC5hY2Vfd2FybmluZyB7XFxcbmJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FNQUFBQW9MUTlUQUFBQW1WQk1WRVgvLy84QUFBRC8vLzhBQUFBQUFBQlBTemIvNXNBQUFBQi9ibEgvNzN6L3Vsa0FBQUFBQUFEODVwa0FBQUFBQUFBQ0FnUC92R3ovcmtEZXJHYkdyVjcvcGtRSUNBZi8vLy9lMElzQUFBRC9vRUQvcVR2aHJuVUFBQUQveUhEL25qY0FBQUR1djJyL256Ly9vVGovcDA2NG9HZi96SEFBQUFBOU5pci90RklBQUFEL3RsVGl1V2YvdGtJQUFBQ3luWEVBQUFBQUFBQXRJUlc3ekJwQkFBQUFNM1JTVGxNQUFCUjFtN1JYTzhMbjMxWjM2elQrbmVYZTVPem9vUkRmbitUWjRwM2gyaFRmNHQzazN1Y3lyTjFLNStYYWtzNTJTZnM5Q1hnckFBQUFqa2xFUVZSNDJvM1BiUStDSUJRRllFd2JvUGhTWWdvWXVuSXFxTG42L3o4dVlkSDhWbWRudTl2ejRXd1hnTi94VFBSRDIrc2dPY1pqc2dlL3doWFpnVWFZWXZUOFFudUphVXJqckhVUXJlR2N6dUVhZlFDTy9TSlR1ZlRicm9Xc1Bnc2xsVmhxM3dKRWsyalVTelgzQ1VFREpDODQ3MDdkalJjNU1UQVF4b0xndXBXUndXNlVCNWZTKytOVjhBYk9aZ25zQzdCcEVBQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxcbmJhY2tncm91bmQtcG9zaXRpb246IDJweCBjZW50ZXI7XFxcbn1cXFxuLmFjZV9ndXR0ZXItY2VsbC5hY2VfaW5mbyB7XFxcbmJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FBQUFBQTZtS0M5QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFBSjBVazVUQUFCMms4MDRBQUFBUGtsRVFWUVkwMk5nSUI2OFF1TzN0aUx6bmpBd3BLVGdOeURiTWVnd2lzQ0haVUVUVVpWMFpxT3F1QnBYajJydG5wU0pUMUFFbm5SbUwyT2dHZ0FBSUtrUlFhcDJodGdBQUFBQVNVVk9SSzVDWUlJPVxcXCIpO1xcXG5iYWNrZ3JvdW5kLXBvc2l0aW9uOiAycHggY2VudGVyO1xcXG59XFxcbi5hY2VfZGFyayAuYWNlX2d1dHRlci1jZWxsLmFjZV9pbmZvIHtcXFxuYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFCQU1BQUFEdDNlSlNBQUFBSkZCTVZFVUFBQUNob2FHQWdJQXFLaXErdnI2dHJhMVpXVm1VbEpTYm01czhQRHh1Ym01NmVucmRnemczQUFBQUFYUlNUbE1BUU9iWVpnQUFBQ2xKUkVGVWVOcGpZTUFQZHNNWUhlZ3lKWkZRQmxzVWxNRlZDV1VZS2tBWk14WkFHZHhsRE1RQkFHK1RCUDRCNlJ5SkFBQUFBRWxGVGtTdVFtQ0NcXFwiKTtcXFxufVxcXG4uYWNlX3Njcm9sbGJhciB7XFxcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxucmlnaHQ6IDA7XFxcbmJvdHRvbTogMDtcXFxuei1pbmRleDogNjtcXFxufVxcXG4uYWNlX3Njcm9sbGJhci1pbm5lciB7XFxcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxuY3Vyc29yOiB0ZXh0O1xcXG5sZWZ0OiAwO1xcXG50b3A6IDA7XFxcbn1cXFxuLmFjZV9zY3JvbGxiYXItdntcXFxub3ZlcmZsb3cteDogaGlkZGVuO1xcXG5vdmVyZmxvdy15OiBzY3JvbGw7XFxcbnRvcDogMDtcXFxufVxcXG4uYWNlX3Njcm9sbGJhci1oIHtcXFxub3ZlcmZsb3cteDogc2Nyb2xsO1xcXG5vdmVyZmxvdy15OiBoaWRkZW47XFxcbmxlZnQ6IDA7XFxcbn1cXFxuLmFjZV9wcmludC1tYXJnaW4ge1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbmhlaWdodDogMTAwJTtcXFxufVxcXG4uYWNlX3RleHQtaW5wdXQge1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbnotaW5kZXg6IDA7XFxcbndpZHRoOiAwLjVlbTtcXFxuaGVpZ2h0OiAxZW07XFxcbm9wYWNpdHk6IDA7XFxcbmJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcXG4tbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxcbmFwcGVhcmFuY2U6IG5vbmU7XFxcbmJvcmRlcjogbm9uZTtcXFxucmVzaXplOiBub25lO1xcXG5vdXRsaW5lOiBub25lO1xcXG5vdmVyZmxvdzogaGlkZGVuO1xcXG5mb250OiBpbmhlcml0O1xcXG5wYWRkaW5nOiAwIDFweDtcXFxubWFyZ2luOiAwIC0xcHg7XFxcbnRleHQtaW5kZW50OiAtMWVtO1xcXG4tbXMtdXNlci1zZWxlY3Q6IHRleHQ7XFxcbi1tb3otdXNlci1zZWxlY3Q6IHRleHQ7XFxcbi13ZWJraXQtdXNlci1zZWxlY3Q6IHRleHQ7XFxcbnVzZXItc2VsZWN0OiB0ZXh0O1xcXG59XFxcbi5hY2VfdGV4dC1pbnB1dC5hY2VfY29tcG9zaXRpb24ge1xcXG5iYWNrZ3JvdW5kOiBpbmhlcml0O1xcXG5jb2xvcjogaW5oZXJpdDtcXFxuei1pbmRleDogMTAwMDtcXFxub3BhY2l0eTogMTtcXFxudGV4dC1pbmRlbnQ6IDA7XFxcbn1cXFxuLmFjZV9sYXllciB7XFxcbnotaW5kZXg6IDE7XFxcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxub3ZlcmZsb3c6IGhpZGRlbjtcXFxud29yZC13cmFwOiBub3JtYWw7XFxcbndoaXRlLXNwYWNlOiBwcmU7XFxcbmhlaWdodDogMTAwJTtcXFxud2lkdGg6IDEwMCU7XFxcbi1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxuLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG5wb2ludGVyLWV2ZW50czogbm9uZTtcXFxufVxcXG4uYWNlX2d1dHRlci1sYXllciB7XFxcbnBvc2l0aW9uOiByZWxhdGl2ZTtcXFxud2lkdGg6IGF1dG87XFxcbnRleHQtYWxpZ246IHJpZ2h0O1xcXG5wb2ludGVyLWV2ZW50czogYXV0bztcXFxufVxcXG4uYWNlX3RleHQtbGF5ZXIge1xcXG5mb250OiBpbmhlcml0ICFpbXBvcnRhbnQ7XFxcbn1cXFxuLmFjZV9jamsge1xcXG5kaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcbnRleHQtYWxpZ246IGNlbnRlcjtcXFxufVxcXG4uYWNlX2N1cnNvci1sYXllciB7XFxcbnotaW5kZXg6IDQ7XFxcbn1cXFxuLmFjZV9jdXJzb3Ige1xcXG56LWluZGV4OiA0O1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbi1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxuLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG5ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG5ib3JkZXItbGVmdDogMnB4IHNvbGlkXFxcbn1cXFxuLmFjZV9zbGltLWN1cnNvcnMgLmFjZV9jdXJzb3Ige1xcXG5ib3JkZXItbGVmdC13aWR0aDogMXB4O1xcXG59XFxcbi5hY2Vfb3ZlcndyaXRlLWN1cnNvcnMgLmFjZV9jdXJzb3Ige1xcXG5ib3JkZXItbGVmdC13aWR0aDogMDtcXFxuYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkO1xcXG59XFxcbi5hY2VfaGlkZGVuLWN1cnNvcnMgLmFjZV9jdXJzb3Ige1xcXG5vcGFjaXR5OiAwLjI7XFxcbn1cXFxuLmFjZV9zbW9vdGgtYmxpbmtpbmcgLmFjZV9jdXJzb3Ige1xcXG4td2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4xOHM7XFxcbnRyYW5zaXRpb246IG9wYWNpdHkgMC4xOHM7XFxcbn1cXFxuLmFjZV9lZGl0b3IuYWNlX211bHRpc2VsZWN0IC5hY2VfY3Vyc29yIHtcXFxuYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXFxufVxcXG4uYWNlX21hcmtlci1sYXllciAuYWNlX3N0ZXAsIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc3RhY2sge1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbnotaW5kZXg6IDM7XFxcbn1cXFxuLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zZWxlY3Rpb24ge1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbnotaW5kZXg6IDU7XFxcbn1cXFxuLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9icmFja2V0IHtcXFxucG9zaXRpb246IGFic29sdXRlO1xcXG56LWluZGV4OiA2O1xcXG59XFxcbi5hY2VfbWFya2VyLWxheWVyIC5hY2VfYWN0aXZlLWxpbmUge1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbnotaW5kZXg6IDI7XFxcbn1cXFxuLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zZWxlY3RlZC13b3JkIHtcXFxucG9zaXRpb246IGFic29sdXRlO1xcXG56LWluZGV4OiA0O1xcXG4tbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcbi13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxuYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxufVxcXG4uYWNlX2xpbmUgLmFjZV9mb2xkIHtcXFxuLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG4td2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcbmRpc3BsYXk6IGlubGluZS1ibG9jaztcXFxuaGVpZ2h0OiAxMXB4O1xcXG5tYXJnaW4tdG9wOiAtMnB4O1xcXG52ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcXG5iYWNrZ3JvdW5kLWltYWdlOlxcXG51cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkVBQUFBSkNBWUFBQURVNk1jTUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBSnBKUkVGVWVOcGkvUC8vUHdPbGdBWEdZR1JrbEFWU29rRDhHbWp3WTF3YXNLbGpRcFlBQ3RwQ0ZlQURjSFZRZlF5TVFBd3p3QVpJM3dKS3ZDTGtmS0JhTVNDbEJsUjdCT1Fpa0NGR1FFRXJJSDBWcWthYmlHQ0Fxd1VhZEF6WkpSeFFyLzBnd2lYSWFsOHpRUVBuTlZUZ0oxVGRhd0wwVDVnQklQMU1VSk5oQnYySEtvUUhIanFOckE0V080elkwZ2x5TktMVDJLSWZJTUFBUXNkZ0dpWHZnbllBQUFBQVNVVk9SSzVDWUlJPVxcXCIpLFxcXG51cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBM0NBWUFBQUROTmlBNUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBQ0pKUkVGVWVOcGkrUC8vZnhnVEF3UERCeER4RDA3OFJTWCtZZUV5REZNQ0lNQUFJM0lObVhpd2YyWUFBQUFBU1VWT1JLNUNZSUk9XFxcIik7XFxcbmJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQsIHJlcGVhdC14O1xcXG5iYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyLCB0b3AgbGVmdDtcXFxuY29sb3I6IHRyYW5zcGFyZW50O1xcXG5ib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXFxuYm9yZGVyLXJhZGl1czogMnB4O1xcXG5jdXJzb3I6IHBvaW50ZXI7XFxcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xcXG59XFxcbi5hY2VfZGFyayAuYWNlX2ZvbGQge1xcXG59XFxcbi5hY2VfZm9sZDpob3ZlcntcXFxuYmFja2dyb3VuZC1pbWFnZTpcXFxudXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJFQUFBQUpDQVlBQUFEVTZNY01BQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUpwSlJFRlVlTnBpL1AvL1B3T2xnQVhHWUdSa2xBVlNva0Q4R21qd1kxd2FzS2xqUXBZQUN0cENGZUFEY0hWUWZReU1RQXd6d0FaSTN3Skt2Q0xrZktCYU1TQ2xCbFI3Qk9RaWtDRkdRRUVySUgwVnFrYWJpR0NBcXdVYWRBelpKUnhRci8wZ3dpWElhbDh6UVFQbk5WVGdKMVRkYXdMMFQ1Z0JJUDFNVUpOaEJ2MkhLb1FISGpxTnJBNFdPNHpZMGdseU5LTFQyS0lmSU1BQVFzZGdHaVh2Z25ZQUFBQUFTVVZPUks1Q1lJST1cXFwiKSxcXFxudXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQTNDQVlBQUFETk5pQTVBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUNCSlJFRlVlTnBpK1AvL2Z6NFRBd1BEWnhEeEQ1WDRpNWZMTUV3SmdBQURBRVBWRGJqTnc4N1pBQUFBQUVsRlRrU3VRbUNDXFxcIik7XFxcbn1cXFxuLmFjZV90b29sdGlwIHtcXFxuYmFja2dyb3VuZC1jb2xvcjogI0ZGRjtcXFxuYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCB0cmFuc3BhcmVudCwgcmdiYSgwLCAwLCAwLCAwLjEpKTtcXFxuYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgdHJhbnNwYXJlbnQsIHJnYmEoMCwgMCwgMCwgMC4xKSk7XFxcbmJvcmRlcjogMXB4IHNvbGlkIGdyYXk7XFxcbmJvcmRlci1yYWRpdXM6IDFweDtcXFxuYm94LXNoYWRvdzogMCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcXFxuY29sb3I6IGJsYWNrO1xcXG5tYXgtd2lkdGg6IDEwMCU7XFxcbnBhZGRpbmc6IDNweCA0cHg7XFxcbnBvc2l0aW9uOiBmaXhlZDtcXFxuei1pbmRleDogOTk5OTk5O1xcXG4tbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcbi13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxuYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxuY3Vyc29yOiBkZWZhdWx0O1xcXG53aGl0ZS1zcGFjZTogcHJlO1xcXG53b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxcbmxpbmUtaGVpZ2h0OiBub3JtYWw7XFxcbmZvbnQtc3R5bGU6IG5vcm1hbDtcXFxuZm9udC13ZWlnaHQ6IG5vcm1hbDtcXFxubGV0dGVyLXNwYWNpbmc6IG5vcm1hbDtcXFxucG9pbnRlci1ldmVudHM6IG5vbmU7XFxcbn1cXFxuLmFjZV9mb2xkaW5nLWVuYWJsZWQgPiAuYWNlX2d1dHRlci1jZWxsIHtcXFxucGFkZGluZy1yaWdodDogMTNweDtcXFxufVxcXG4uYWNlX2ZvbGQtd2lkZ2V0IHtcXFxuLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG4td2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcbm1hcmdpbjogMCAtMTJweCAwIDFweDtcXFxuZGlzcGxheTogbm9uZTtcXFxud2lkdGg6IDExcHg7XFxcbnZlcnRpY2FsLWFsaWduOiB0b3A7XFxcbmJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQU5FbEVRVlI0Mm1XS3NRMEFNQXpDOGl4TGxyelFqem1CaUVqcDBBNld3QkNTUGdLQVhvTGtxU290N25OM3lNd1I3cFozMk56cEtrVm9EQlV4S0FBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKTtcXFxuYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXFxuYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcXG5ib3JkZXItcmFkaXVzOiAzcHg7XFxcbmJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcXG5jdXJzb3I6IHBvaW50ZXI7XFxcbn1cXFxuLmFjZV9mb2xkaW5nLWVuYWJsZWQgLmFjZV9mb2xkLXdpZGdldCB7XFxcbmRpc3BsYXk6IGlubGluZS1ibG9jazsgICBcXFxufVxcXG4uYWNlX2ZvbGQtd2lkZ2V0LmFjZV9lbmQge1xcXG5iYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFORWxFUVZSNDJtM0h3UWtBTUFoRDBZenNSY2hGS0k3c0Fpa2VXa3J4d1NjRUIwbmg1ZTdLVFBXaW1aa2k0dFlmVmJYK01ObDRweVpYZWpVTzFRQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxcbn1cXFxuLmFjZV9mb2xkLXdpZGdldC5hY2VfY2xvc2VkIHtcXFxuYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFNQUFBQUdDQVlBQUFBRzVTUU1BQUFBT1VsRVFWUjQyalhLd1FrQU1BZ0R3S3dxS0Q0RXdRMjZzU09rVldqZ0lJSEF6UGlDZ2FxaXFuSkhabktJQ0JFUkhOMTk0TzViOXZiTHVBVlJMK2wwWVduWkFBQUFBRWxGVGtTdVFtQ0NYQT09XFxcIik7XFxcbn1cXFxuLmFjZV9mb2xkLXdpZGdldDpob3ZlciB7XFxcbmJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtcXFxuYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcXG5ib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcXG59XFxcbi5hY2VfZm9sZC13aWRnZXQ6YWN0aXZlIHtcXFxuYm9yZGVyOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQpO1xcXG5iYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcXG5ib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xcXG59XFxcbi5hY2VfZGFyayAuYWNlX2ZvbGQtd2lkZ2V0IHtcXFxuYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBSGtsRVFWUUlXMlA0Ly84L0F6b0dFUTdvR0NhTExBaFdpU3dCMTQ2QkFRQ1NUUFlvY3FUMEFBQUFBRWxGVGtTdVFtQ0NcXFwiKTtcXFxufVxcXG4uYWNlX2RhcmsgLmFjZV9mb2xkLXdpZGdldC5hY2VfZW5kIHtcXFxuYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBSDBsRVFWUUlXMlA0Ly84L0F4UTd3TmpJQWpETWdDNEF4akNWS0JpcklBQUYwa3oycmxoeHBBQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxcbn1cXFxuLmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQuYWNlX2Nsb3NlZCB7XFxcbmJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBTUFBQUFGQ0FZQUFBQ0FjVmFpQUFBQUhFbEVRVlFJVzJQNC8vKy9BeEF6Z0RBRGxPT0F6bkhBS2dQV0F3QVJqaThVSURUZlFRQUFBQUJKUlU1RXJrSmdnZz09XFxcIik7XFxcbn1cXFxuLmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQ6aG92ZXIge1xcXG5ib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcXG5iYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XFxcbn1cXFxuLmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQ6YWN0aXZlIHtcXFxuYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXFxufVxcXG4uYWNlX2ZvbGQtd2lkZ2V0LmFjZV9pbnZhbGlkIHtcXFxuYmFja2dyb3VuZC1jb2xvcjogI0ZGQjRCNDtcXFxuYm9yZGVyLWNvbG9yOiAjREU1NTU1O1xcXG59XFxcbi5hY2VfZmFkZS1mb2xkLXdpZGdldHMgLmFjZV9mb2xkLXdpZGdldCB7XFxcbi13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjRzIGVhc2UgMC4wNXM7XFxcbnRyYW5zaXRpb246IG9wYWNpdHkgMC40cyBlYXNlIDAuMDVzO1xcXG5vcGFjaXR5OiAwO1xcXG59XFxcbi5hY2VfZmFkZS1mb2xkLXdpZGdldHM6aG92ZXIgLmFjZV9mb2xkLXdpZGdldCB7XFxcbi13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjA1cyBlYXNlIDAuMDVzO1xcXG50cmFuc2l0aW9uOiBvcGFjaXR5IDAuMDVzIGVhc2UgMC4wNXM7XFxcbm9wYWNpdHk6MTtcXFxufVxcXG4uYWNlX3VuZGVybGluZSB7XFxcbnRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcXG59XFxcbi5hY2VfYm9sZCB7XFxcbmZvbnQtd2VpZ2h0OiBib2xkO1xcXG59XFxcbi5hY2Vfbm9ib2xkIC5hY2VfYm9sZCB7XFxcbmZvbnQtd2VpZ2h0OiBub3JtYWw7XFxcbn1cXFxuLmFjZV9pdGFsaWMge1xcXG5mb250LXN0eWxlOiBpdGFsaWM7XFxcbn1cXFxuLmFjZV9lcnJvci1tYXJrZXIge1xcXG5iYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMCwgMCwwLjIpO1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbnotaW5kZXg6IDk7XFxcbn1cXFxuLmFjZV9oaWdobGlnaHQtbWFya2VyIHtcXFxuYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMCwwLjIpO1xcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxcbnotaW5kZXg6IDg7XFxcbn1cXFxuXCI7XG5cbmRvbS5pbXBvcnRDc3NTdHJpbmcoZWRpdG9yQ3NzLCBcImFjZV9lZGl0b3IuY3NzXCIpO1xuXG52YXIgVmlydHVhbFJlbmRlcmVyID0gZnVuY3Rpb24oY29udGFpbmVyLCB0aGVtZSkge1xuICAgIHZhciBfc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiRrZWVwVGV4dEFyZWFBdEN1cnNvciA9ICF1c2VyYWdlbnQuaXNPbGRJRTtcblxuICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJhY2VfZWRpdG9yXCIpO1xuXG4gICAgdGhpcy5zZXRUaGVtZSh0aGVtZSk7XG5cbiAgICB0aGlzLiRndXR0ZXIgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiRndXR0ZXIuY2xhc3NOYW1lID0gXCJhY2VfZ3V0dGVyXCI7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kZ3V0dGVyKTtcblxuICAgIHRoaXMuc2Nyb2xsZXIgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLnNjcm9sbGVyLmNsYXNzTmFtZSA9IFwiYWNlX3Njcm9sbGVyXCI7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxlcik7XG5cbiAgICB0aGlzLmNvbnRlbnQgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gXCJhY2VfY29udGVudFwiO1xuICAgIHRoaXMuc2Nyb2xsZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcblxuICAgIHRoaXMuJGd1dHRlckxheWVyID0gbmV3IEd1dHRlckxheWVyKHRoaXMuJGd1dHRlcik7XG4gICAgdGhpcy4kZ3V0dGVyTGF5ZXIub24oXCJjaGFuZ2VHdXR0ZXJXaWR0aFwiLCB0aGlzLm9uR3V0dGVyUmVzaXplLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy4kbWFya2VyQmFjayA9IG5ldyBNYXJrZXJMYXllcih0aGlzLmNvbnRlbnQpO1xuXG4gICAgdmFyIHRleHRMYXllciA9IHRoaXMuJHRleHRMYXllciA9IG5ldyBUZXh0TGF5ZXIodGhpcy5jb250ZW50KTtcbiAgICB0aGlzLmNhbnZhcyA9IHRleHRMYXllci5lbGVtZW50O1xuXG4gICAgdGhpcy4kbWFya2VyRnJvbnQgPSBuZXcgTWFya2VyTGF5ZXIodGhpcy5jb250ZW50KTtcblxuICAgIHRoaXMuJGN1cnNvckxheWVyID0gbmV3IEN1cnNvckxheWVyKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy4kaG9yaXpTY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLiR2U2Nyb2xsID0gZmFsc2U7XG5cbiAgICB0aGlzLnNjcm9sbEJhciA9IFxuICAgIHRoaXMuc2Nyb2xsQmFyViA9IG5ldyBWU2Nyb2xsQmFyKHRoaXMuY29udGFpbmVyLCB0aGlzKTtcbiAgICB0aGlzLnNjcm9sbEJhckggPSBuZXcgSFNjcm9sbEJhcih0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgdGhpcy5zY3JvbGxCYXJWLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIV9zZWxmLiRzY3JvbGxBbmltYXRpb24pXG4gICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcChlLmRhdGEgLSBfc2VsZi5zY3JvbGxNYXJnaW4udG9wKTtcbiAgICB9KTtcbiAgICB0aGlzLnNjcm9sbEJhckguYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcbiAgICAgICAgICAgIF9zZWxmLnNlc3Npb24uc2V0U2Nyb2xsTGVmdChlLmRhdGEgLSBfc2VsZi5zY3JvbGxNYXJnaW4ubGVmdCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNjcm9sbFRvcCA9IDA7XG4gICAgdGhpcy5zY3JvbGxMZWZ0ID0gMDtcblxuICAgIHRoaXMuY3Vyc29yUG9zID0ge1xuICAgICAgICByb3cgOiAwLFxuICAgICAgICBjb2x1bW4gOiAwXG4gICAgfTtcblxuICAgIHRoaXMuJGZvbnRNZXRyaWNzID0gbmV3IEZvbnRNZXRyaWNzKHRoaXMuY29udGFpbmVyLCA1MDApO1xuICAgIHRoaXMuJHRleHRMYXllci4kc2V0Rm9udE1ldHJpY3ModGhpcy4kZm9udE1ldHJpY3MpO1xuICAgIHRoaXMuJHRleHRMYXllci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlQ2hhcmFjdGVyU2l6ZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIF9zZWxmLnVwZGF0ZUNoYXJhY3RlclNpemUoKTtcbiAgICAgICAgX3NlbGYub25SZXNpemUodHJ1ZSwgX3NlbGYuZ3V0dGVyV2lkdGgsIF9zZWxmLiRzaXplLndpZHRoLCBfc2VsZi4kc2l6ZS5oZWlnaHQpO1xuICAgICAgICBfc2VsZi5fc2lnbmFsKFwiY2hhbmdlQ2hhcmFjdGVyU2l6ZVwiLCBlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHNpemUgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHNjcm9sbGVySGVpZ2h0OiAwLFxuICAgICAgICBzY3JvbGxlcldpZHRoOiAwLFxuICAgICAgICAkZGlydHk6IHRydWVcbiAgICB9O1xuXG4gICAgdGhpcy5sYXllckNvbmZpZyA9IHtcbiAgICAgICAgd2lkdGggOiAxLFxuICAgICAgICBwYWRkaW5nIDogMCxcbiAgICAgICAgZmlyc3RSb3cgOiAwLFxuICAgICAgICBmaXJzdFJvd1NjcmVlbjogMCxcbiAgICAgICAgbGFzdFJvdyA6IDAsXG4gICAgICAgIGxpbmVIZWlnaHQgOiAwLFxuICAgICAgICBjaGFyYWN0ZXJXaWR0aCA6IDAsXG4gICAgICAgIG1pbkhlaWdodCA6IDEsXG4gICAgICAgIG1heEhlaWdodCA6IDEsXG4gICAgICAgIG9mZnNldCA6IDAsXG4gICAgICAgIGhlaWdodCA6IDEsXG4gICAgICAgIGd1dHRlck9mZnNldDogMVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5zY3JvbGxNYXJnaW4gPSB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgdjogMCxcbiAgICAgICAgaDogMFxuICAgIH07XG5cbiAgICB0aGlzLiRsb29wID0gbmV3IFJlbmRlckxvb3AoXG4gICAgICAgIHRoaXMuJHJlbmRlckNoYW5nZXMuYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5jb250YWluZXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld1xuICAgICk7XG4gICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcblxuICAgIHRoaXMudXBkYXRlQ2hhcmFjdGVyU2l6ZSgpO1xuICAgIHRoaXMuc2V0UGFkZGluZyg0KTtcbiAgICBjb25maWcucmVzZXRPcHRpb25zKHRoaXMpO1xuICAgIGNvbmZpZy5fZW1pdChcInJlbmRlcmVyXCIsIHRoaXMpO1xufTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5DSEFOR0VfQ1VSU09SID0gMTtcbiAgICB0aGlzLkNIQU5HRV9NQVJLRVIgPSAyO1xuICAgIHRoaXMuQ0hBTkdFX0dVVFRFUiA9IDQ7XG4gICAgdGhpcy5DSEFOR0VfU0NST0xMID0gODtcbiAgICB0aGlzLkNIQU5HRV9MSU5FUyA9IDE2O1xuICAgIHRoaXMuQ0hBTkdFX1RFWFQgPSAzMjtcbiAgICB0aGlzLkNIQU5HRV9TSVpFID0gNjQ7XG4gICAgdGhpcy5DSEFOR0VfTUFSS0VSX0JBQ0sgPSAxMjg7XG4gICAgdGhpcy5DSEFOR0VfTUFSS0VSX0ZST05UID0gMjU2O1xuICAgIHRoaXMuQ0hBTkdFX0ZVTEwgPSA1MTI7XG4gICAgdGhpcy5DSEFOR0VfSF9TQ1JPTEwgPSAxMDI0O1xuXG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuXG4gICAgdGhpcy51cGRhdGVDaGFyYWN0ZXJTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIuYWxsb3dCb2xkRm9udHMgIT0gdGhpcy4kYWxsb3dCb2xkRm9udHMpIHtcbiAgICAgICAgICAgIHRoaXMuJGFsbG93Qm9sZEZvbnRzID0gdGhpcy4kdGV4dExheWVyLmFsbG93Qm9sZEZvbnRzO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZShcImFjZV9ub2JvbGRcIiwgIXRoaXMuJGFsbG93Qm9sZEZvbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGF5ZXJDb25maWcuY2hhcmFjdGVyV2lkdGggPVxuICAgICAgICB0aGlzLmNoYXJhY3RlcldpZHRoID0gdGhpcy4kdGV4dExheWVyLmdldENoYXJhY3RlcldpZHRoKCk7XG4gICAgICAgIHRoaXMubGF5ZXJDb25maWcubGluZUhlaWdodCA9XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IHRoaXMuJHRleHRMYXllci5nZXRMaW5lSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuJHVwZGF0ZVByaW50TWFyZ2luKCk7XG4gICAgfTtcbiAgICB0aGlzLnNldFNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24pXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uZG9jLm9mZihcImNoYW5nZU5ld0xpbmVNb2RlXCIsIHRoaXMub25DaGFuZ2VOZXdMaW5lTW9kZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24gJiYgdGhpcy5zY3JvbGxNYXJnaW4udG9wICYmIHNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgPD0gMClcbiAgICAgICAgICAgIHNlc3Npb24uc2V0U2Nyb2xsVG9wKC10aGlzLnNjcm9sbE1hcmdpbi50b3ApO1xuXG4gICAgICAgIHRoaXMuJGN1cnNvckxheWVyLnNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuJG1hcmtlckJhY2suc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgdGhpcy4kdGV4dExheWVyLnNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfRlVMTCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi4kc2V0Rm9udE1ldHJpY3ModGhpcy4kZm9udE1ldHJpY3MpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlID0gdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DaGFuZ2VOZXdMaW5lTW9kZSgpXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5kb2Mub24oXCJjaGFuZ2VOZXdMaW5lTW9kZVwiLCB0aGlzLm9uQ2hhbmdlTmV3TGluZU1vZGUpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVMaW5lcyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93LCBmb3JjZSkge1xuICAgICAgICBpZiAobGFzdFJvdyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbGFzdFJvdyA9IEluZmluaXR5O1xuXG4gICAgICAgIGlmICghdGhpcy4kY2hhbmdlZExpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMgPSB7XG4gICAgICAgICAgICAgICAgZmlyc3RSb3c6IGZpcnN0Um93LFxuICAgICAgICAgICAgICAgIGxhc3RSb3c6IGxhc3RSb3dcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kY2hhbmdlZExpbmVzLmZpcnN0Um93ID4gZmlyc3RSb3cpXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzLmZpcnN0Um93ID0gZmlyc3RSb3c7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA8IGxhc3RSb3cpXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3cgPSBsYXN0Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA8IHRoaXMubGF5ZXJDb25maWcuZmlyc3RSb3cpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSlcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA9IHRoaXMubGF5ZXJDb25maWcubGFzdFJvdztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGNoYW5nZWRMaW5lcy5maXJzdFJvdyA+IHRoaXMubGF5ZXJDb25maWcubGFzdFJvdylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9MSU5FUyk7XG4gICAgfTtcblxuICAgIHRoaXMub25DaGFuZ2VOZXdMaW5lTW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1RFWFQpO1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuJHVwZGF0ZUVvbENoYXIoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMub25DaGFuZ2VUYWJTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCB8IHRoaXMuQ0hBTkdFX01BUktFUik7XG4gICAgICAgIHRoaXMuJHRleHRMYXllci5vbkNoYW5nZVRhYlNpemUoKTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1RFWFQpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVGdWxsID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgaWYgKGZvcmNlKVxuICAgICAgICAgICAgdGhpcy4kcmVuZGVyQ2hhbmdlcyh0aGlzLkNIQU5HRV9GVUxMLCB0cnVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlRm9udFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kdGV4dExheWVyLmNoZWNrRm9yU2l6ZUNoYW5nZXMoKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kY2hhbmdlcyA9IDA7XG4gICAgdGhpcy4kdXBkYXRlU2l6ZUFzeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLiRsb29wLnBlbmRpbmcpXG4gICAgICAgICAgICB0aGlzLiRzaXplLiRkaXJ0eSA9IHRydWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB9O1xuICAgIHRoaXMub25SZXNpemUgPSBmdW5jdGlvbihmb3JjZSwgZ3V0dGVyV2lkdGgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXppbmcgPiAyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnJlc2l6aW5nID4gMClcbiAgICAgICAgICAgIHRoaXMucmVzaXppbmcrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5yZXNpemluZyA9IGZvcmNlID8gMSA6IDA7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAoIWhlaWdodClcbiAgICAgICAgICAgIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodCB8fCBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIGlmICghd2lkdGgpXG4gICAgICAgICAgICB3aWR0aCA9IGVsLmNsaWVudFdpZHRoIHx8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuJHVwZGF0ZUNhY2hlZFNpemUoZm9yY2UsIGd1dHRlcldpZHRoLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBcbiAgICAgICAgaWYgKCF0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0IHx8ICghd2lkdGggJiYgIWhlaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNpemluZyA9IDA7XG5cbiAgICAgICAgaWYgKGZvcmNlKVxuICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuJHBhZGRpbmcgPSBudWxsO1xuXG4gICAgICAgIGlmIChmb3JjZSlcbiAgICAgICAgICAgIHRoaXMuJHJlbmRlckNoYW5nZXMoY2hhbmdlcyB8IHRoaXMuJGNoYW5nZXMsIHRydWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKGNoYW5nZXMgfCB0aGlzLiRjaGFuZ2VzKTtcblxuICAgICAgICBpZiAodGhpcy5yZXNpemluZylcbiAgICAgICAgICAgIHRoaXMucmVzaXppbmcgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQmFyVi5zY3JvbGxUb3AgPSBudWxsO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZSA9IGZ1bmN0aW9uKGZvcmNlLCBndXR0ZXJXaWR0aCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBoZWlnaHQgLT0gKHRoaXMuJGV4dHJhSGVpZ2h0IHx8IDApO1xuICAgICAgICB2YXIgY2hhbmdlcyA9IDA7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy4kc2l6ZTtcbiAgICAgICAgdmFyIG9sZFNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxlckhlaWdodDogc2l6ZS5zY3JvbGxlckhlaWdodCxcbiAgICAgICAgICAgIHNjcm9sbGVyV2lkdGg6IHNpemUuc2Nyb2xsZXJXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVpZ2h0ICYmIChmb3JjZSB8fCBzaXplLmhlaWdodCAhPSBoZWlnaHQpKSB7XG4gICAgICAgICAgICBzaXplLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy5DSEFOR0VfU0laRTtcblxuICAgICAgICAgICAgc2l6ZS5zY3JvbGxlckhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHRoaXMuJGhvcml6U2Nyb2xsKVxuICAgICAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJIZWlnaHQgLT0gdGhpcy5zY3JvbGxCYXJILmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLmVsZW1lbnQuc3R5bGUuYm90dG9tID0gdGhpcy5zY3JvbGxCYXJILmdldEhlaWdodCgpICsgXCJweFwiO1xuXG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcyB8IHRoaXMuQ0hBTkdFX1NDUk9MTDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aWR0aCAmJiAoZm9yY2UgfHwgc2l6ZS53aWR0aCAhPSB3aWR0aCkpIHtcbiAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy5DSEFOR0VfU0laRTtcbiAgICAgICAgICAgIHNpemUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGd1dHRlcldpZHRoID09IG51bGwpXG4gICAgICAgICAgICAgICAgZ3V0dGVyV2lkdGggPSB0aGlzLiRzaG93R3V0dGVyID8gdGhpcy4kZ3V0dGVyLm9mZnNldFdpZHRoIDogMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5ndXR0ZXJXaWR0aCA9IGd1dHRlcldpZHRoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhckguZWxlbWVudC5zdHlsZS5sZWZ0ID0gXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLmxlZnQgPSBndXR0ZXJXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJXaWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gZ3V0dGVyV2lkdGggLSB0aGlzLnNjcm9sbEJhclYuZ2V0V2lkdGgoKSk7ICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJILmVsZW1lbnQuc3R5bGUucmlnaHQgPSBcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUucmlnaHQgPSB0aGlzLnNjcm9sbEJhclYuZ2V0V2lkdGgoKSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUuYm90dG9tID0gdGhpcy5zY3JvbGxCYXJILmdldEhlaWdodCgpICsgXCJweFwiO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi5nZXRVc2VXcmFwTW9kZSgpICYmIHRoaXMuYWRqdXN0V3JhcExpbWl0KCkgfHwgZm9yY2UpXG4gICAgICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLkNIQU5HRV9GVUxMO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzaXplLiRkaXJ0eSA9ICF3aWR0aCB8fCAhaGVpZ2h0O1xuXG4gICAgICAgIGlmIChjaGFuZ2VzKVxuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwicmVzaXplXCIsIG9sZFNpemUpO1xuXG4gICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH07XG5cbiAgICB0aGlzLm9uR3V0dGVyUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBndXR0ZXJXaWR0aCA9IHRoaXMuJHNob3dHdXR0ZXIgPyB0aGlzLiRndXR0ZXIub2Zmc2V0V2lkdGggOiAwO1xuICAgICAgICBpZiAoZ3V0dGVyV2lkdGggIT0gdGhpcy5ndXR0ZXJXaWR0aClcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgfD0gdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZSh0cnVlLCBndXR0ZXJXaWR0aCwgdGhpcy4kc2l6ZS53aWR0aCwgdGhpcy4kc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKSAmJiB0aGlzLmFkanVzdFdyYXBMaW1pdCgpKSB7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuJHNpemUuJGRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kY29tcHV0ZUxheWVyQ29uZmlnKCk7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX01BUktFUik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRqdXN0V3JhcExpbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aCAtIHRoaXMuJHBhZGRpbmcgKiAyO1xuICAgICAgICB2YXIgbGltaXQgPSBNYXRoLmZsb29yKGF2YWlsYWJsZVdpZHRoIC8gdGhpcy5jaGFyYWN0ZXJXaWR0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uYWRqdXN0V3JhcExpbWl0KGxpbWl0LCB0aGlzLiRzaG93UHJpbnRNYXJnaW4gJiYgdGhpcy4kcHJpbnRNYXJnaW5Db2x1bW4pO1xuICAgIH07XG4gICAgdGhpcy5zZXRBbmltYXRlZFNjcm9sbCA9IGZ1bmN0aW9uKHNob3VsZEFuaW1hdGUpe1xuICAgICAgICB0aGlzLnNldE9wdGlvbihcImFuaW1hdGVkU2Nyb2xsXCIsIHNob3VsZEFuaW1hdGUpO1xuICAgIH07XG4gICAgdGhpcy5nZXRBbmltYXRlZFNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kYW5pbWF0ZWRTY3JvbGw7XG4gICAgfTtcbiAgICB0aGlzLnNldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24oc2hvd0ludmlzaWJsZXMpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJzaG93SW52aXNpYmxlc1wiLCBzaG93SW52aXNpYmxlcyk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dJbnZpc2libGVzXCIpO1xuICAgIH07XG4gICAgdGhpcy5nZXREaXNwbGF5SW5kZW50R3VpZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcImRpc3BsYXlJbmRlbnRHdWlkZXNcIik7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uKGRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJkaXNwbGF5SW5kZW50R3VpZGVzXCIsIGRpc3BsYXkpO1xuICAgIH07XG4gICAgdGhpcy5zZXRTaG93UHJpbnRNYXJnaW4gPSBmdW5jdGlvbihzaG93UHJpbnRNYXJnaW4pIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJzaG93UHJpbnRNYXJnaW5cIiwgc2hvd1ByaW50TWFyZ2luKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2hvd1ByaW50TWFyZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dQcmludE1hcmdpblwiKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbihzaG93UHJpbnRNYXJnaW4pIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJwcmludE1hcmdpbkNvbHVtblwiLCBzaG93UHJpbnRNYXJnaW4pO1xuICAgIH07XG4gICAgdGhpcy5nZXRQcmludE1hcmdpbkNvbHVtbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJwcmludE1hcmdpbkNvbHVtblwiKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0U2hvd0d1dHRlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcInNob3dHdXR0ZXJcIik7XG4gICAgfTtcbiAgICB0aGlzLnNldFNob3dHdXR0ZXIgPSBmdW5jdGlvbihzaG93KXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0T3B0aW9uKFwic2hvd0d1dHRlclwiLCBzaG93KTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGYWRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJmYWRlRm9sZFdpZGdldHNcIilcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRGYWRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbihzaG93KSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiZmFkZUZvbGRXaWRnZXRzXCIsIHNob3cpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEhpZ2hsaWdodEd1dHRlckxpbmUgPSBmdW5jdGlvbihzaG91bGRIaWdobGlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oXCJoaWdobGlnaHRHdXR0ZXJMaW5lXCIsIHNob3VsZEhpZ2hsaWdodCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0SGlnaGxpZ2h0R3V0dGVyTGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXCJoaWdobGlnaHRHdXR0ZXJMaW5lXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLiR1cGRhdGVHdXR0ZXJMaW5lSGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLiRjdXJzb3JMYXllci4kcGl4ZWxQb3M7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmxheWVyQ29uZmlnLmxpbmVIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKSkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICBjdXJzb3IuY29sdW1uID0gMDtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oY3Vyc29yLCB0cnVlKTtcbiAgICAgICAgICAgIGhlaWdodCAqPSB0aGlzLnNlc3Npb24uZ2V0Um93TGVuZ3RoKGN1cnNvci5yb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGd1dHRlckxpbmVIaWdobGlnaHQuc3R5bGUudG9wID0gcG9zLnRvcCAtIHRoaXMubGF5ZXJDb25maWcub2Zmc2V0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLiRndXR0ZXJMaW5lSGlnaGxpZ2h0LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuXG4gICAgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRzaG93UHJpbnRNYXJnaW4gJiYgIXRoaXMuJHByaW50TWFyZ2luRWwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLiRwcmludE1hcmdpbkVsKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWwgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmNsYXNzTmFtZSA9IFwiYWNlX2xheWVyIGFjZV9wcmludC1tYXJnaW4tbGF5ZXJcIjtcbiAgICAgICAgICAgIHRoaXMuJHByaW50TWFyZ2luRWwgPSBkb20uY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuJHByaW50TWFyZ2luRWwuY2xhc3NOYW1lID0gXCJhY2VfcHJpbnQtbWFyZ2luXCI7XG4gICAgICAgICAgICBjb250YWluZXJFbC5hcHBlbmRDaGlsZCh0aGlzLiRwcmludE1hcmdpbkVsKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5pbnNlcnRCZWZvcmUoY29udGFpbmVyRWwsIHRoaXMuY29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuJHByaW50TWFyZ2luRWwuc3R5bGU7XG4gICAgICAgIHN0eWxlLmxlZnQgPSAoKHRoaXMuY2hhcmFjdGVyV2lkdGggKiB0aGlzLiRwcmludE1hcmdpbkNvbHVtbikgKyB0aGlzLiRwYWRkaW5nKSArIFwicHhcIjtcbiAgICAgICAgc3R5bGUudmlzaWJpbGl0eSA9IHRoaXMuJHNob3dQcmludE1hcmdpbiA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLiR3cmFwID09IC0xKVxuICAgICAgICAgICAgdGhpcy5hZGp1c3RXcmFwTGltaXQoKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Q29udGFpbmVyRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfTtcbiAgICB0aGlzLmdldE1vdXNlRXZlbnRUYXJnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VGV4dEFyZWFDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH07XG4gICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRrZWVwVGV4dEFyZWFBdEN1cnNvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XG4gICAgICAgIHZhciBwb3NUb3AgPSB0aGlzLiRjdXJzb3JMYXllci4kcGl4ZWxQb3MudG9wO1xuICAgICAgICB2YXIgcG9zTGVmdCA9IHRoaXMuJGN1cnNvckxheWVyLiRwaXhlbFBvcy5sZWZ0O1xuICAgICAgICBwb3NUb3AgLT0gY29uZmlnLm9mZnNldDtcblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnRleHRhcmVhLnN0eWxlO1xuICAgICAgICB2YXIgaCA9IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgaWYgKHBvc1RvcCA8IDAgfHwgcG9zVG9wID4gY29uZmlnLmhlaWdodCAtIGgpIHtcbiAgICAgICAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3ID0gdGhpcy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMuJGNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy50ZXh0YXJlYS52YWx1ZS5yZXBsYWNlKC9eXFx4MDErLywgXCJcIik7XG4gICAgICAgICAgICB3ICo9ICh0aGlzLnNlc3Npb24uJGdldFN0cmluZ1NjcmVlbldpZHRoKHZhbClbMF0rMik7XG4gICAgICAgICAgICBoICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zTGVmdCAtPSB0aGlzLnNjcm9sbExlZnQ7XG4gICAgICAgIGlmIChwb3NMZWZ0ID4gdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoIC0gdylcbiAgICAgICAgICAgIHBvc0xlZnQgPSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB3O1xuXG4gICAgICAgIHBvc0xlZnQgKz0gdGhpcy5ndXR0ZXJXaWR0aDtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gaCArIFwicHhcIjtcbiAgICAgICAgc3R5bGUud2lkdGggPSB3ICsgXCJweFwiO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gTWF0aC5taW4ocG9zTGVmdCwgdGhpcy4kc2l6ZS5zY3JvbGxlcldpZHRoIC0gdykgKyBcInB4XCI7XG4gICAgICAgIHN0eWxlLnRvcCA9IE1hdGgubWluKHBvc1RvcCwgdGhpcy4kc2l6ZS5oZWlnaHQgLSBoKSArIFwicHhcIjtcbiAgICB9O1xuICAgIHRoaXMuZ2V0Rmlyc3RWaXNpYmxlUm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93O1xuICAgIH07XG4gICAgdGhpcy5nZXRGaXJzdEZ1bGx5VmlzaWJsZVJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdyArICh0aGlzLmxheWVyQ29uZmlnLm9mZnNldCA9PT0gMCA/IDAgOiAxKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0TGFzdEZ1bGx5VmlzaWJsZVJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmxpbnQgPSBNYXRoLmZsb29yKCh0aGlzLmxheWVyQ29uZmlnLmhlaWdodCArIHRoaXMubGF5ZXJDb25maWcub2Zmc2V0KSAvIHRoaXMubGF5ZXJDb25maWcubGluZUhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93IC0gMSArIGZsaW50O1xuICAgIH07XG4gICAgdGhpcy5nZXRMYXN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllckNvbmZpZy5sYXN0Um93O1xuICAgIH07XG5cbiAgICB0aGlzLiRwYWRkaW5nID0gbnVsbDtcbiAgICB0aGlzLnNldFBhZGRpbmcgPSBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgIHRoaXMuJHBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgICAgdGhpcy4kbWFya2VyQmFjay5zZXRQYWRkaW5nKHBhZGRpbmcpO1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xuICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRTY3JvbGxNYXJnaW4gPSBmdW5jdGlvbih0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIHNtID0gdGhpcy5zY3JvbGxNYXJnaW47XG4gICAgICAgIHNtLnRvcCA9IHRvcHwwO1xuICAgICAgICBzbS5ib3R0b20gPSBib3R0b218MDtcbiAgICAgICAgc20ucmlnaHQgPSByaWdodHwwO1xuICAgICAgICBzbS5sZWZ0ID0gbGVmdHwwO1xuICAgICAgICBzbS52ID0gc20udG9wICsgc20uYm90dG9tO1xuICAgICAgICBzbS5oID0gc20ubGVmdCArIHNtLnJpZ2h0O1xuICAgICAgICBpZiAoc20udG9wICYmIHRoaXMuc2Nyb2xsVG9wIDw9IDAgJiYgdGhpcy5zZXNzaW9uKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcCgtc20udG9wKTtcbiAgICAgICAgdGhpcy51cGRhdGVGdWxsKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldEhTY3JvbGxCYXJBbHdheXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRoU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZTtcbiAgICB9O1xuICAgIHRoaXMuc2V0SFNjcm9sbEJhckFsd2F5c1Zpc2libGUgPSBmdW5jdGlvbihhbHdheXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwiaFNjcm9sbEJhckFsd2F5c1Zpc2libGVcIiwgYWx3YXlzVmlzaWJsZSk7XG4gICAgfTtcbiAgICB0aGlzLmdldFZTY3JvbGxCYXJBbHdheXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZTtcbiAgICB9O1xuICAgIHRoaXMuc2V0VlNjcm9sbEJhckFsd2F5c1Zpc2libGUgPSBmdW5jdGlvbihhbHdheXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uKFwidlNjcm9sbEJhckFsd2F5c1Zpc2libGVcIiwgYWx3YXlzVmlzaWJsZSk7XG4gICAgfTtcblxuICAgIHRoaXMuJHVwZGF0ZVNjcm9sbEJhclYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMubGF5ZXJDb25maWcubWF4SGVpZ2h0O1xuICAgICAgICB2YXIgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0O1xuICAgICAgICBpZiAoIXRoaXMuJG1heExpbmVzICYmIHRoaXMuJHNjcm9sbFBhc3RFbmQpIHtcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCAtPSAoc2Nyb2xsZXJIZWlnaHQgLSB0aGlzLmxpbmVIZWlnaHQpICogdGhpcy4kc2Nyb2xsUGFzdEVuZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCA+IHNjcm9sbEhlaWdodCAtIHNjcm9sbGVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5zY3JvbGxUb3AgKyBzY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2Nyb2xsVG9wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0U2Nyb2xsSGVpZ2h0KHNjcm9sbEhlaWdodCArIHRoaXMuc2Nyb2xsTWFyZ2luLnYpO1xuICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0U2Nyb2xsVG9wKHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5zY3JvbGxNYXJnaW4udG9wKTtcbiAgICB9O1xuICAgIHRoaXMuJHVwZGF0ZVNjcm9sbEJhckggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxCYXJILnNldFNjcm9sbFdpZHRoKHRoaXMubGF5ZXJDb25maWcud2lkdGggKyAyICogdGhpcy4kcGFkZGluZyArIHRoaXMuc2Nyb2xsTWFyZ2luLmgpO1xuICAgICAgICB0aGlzLnNjcm9sbEJhckguc2V0U2Nyb2xsTGVmdCh0aGlzLnNjcm9sbExlZnQgKyB0aGlzLnNjcm9sbE1hcmdpbi5sZWZ0KTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuJGZyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGZyb3plbiA9IHRydWU7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnVuZnJlZXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGZyb3plbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLiRyZW5kZXJDaGFuZ2VzID0gZnVuY3Rpb24oY2hhbmdlcywgZm9yY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuJGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy4kY2hhbmdlcztcbiAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXRoaXMuc2Vzc2lvbiB8fCAhdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggfHwgdGhpcy4kZnJvemVuKSB8fCAoIWNoYW5nZXMgJiYgIWZvcmNlKSkge1xuICAgICAgICAgICAgdGhpcy4kY2hhbmdlcyB8PSBjaGFuZ2VzO1xuICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgfSBcbiAgICAgICAgaWYgKHRoaXMuJHNpemUuJGRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLiRjaGFuZ2VzIHw9IGNoYW5nZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vblJlc2l6ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubGluZUhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLmNoZWNrRm9yU2l6ZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwiYmVmb3JlUmVuZGVyXCIpO1xuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcbiAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9GVUxMIHx8XG4gICAgICAgICAgICBjaGFuZ2VzICYgdGhpcy5DSEFOR0VfU0laRSB8fFxuICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQgfHxcbiAgICAgICAgICAgIGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9MSU5FUyB8fFxuICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1NDUk9MTCB8fFxuICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0hfU0NST0xMXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLiRjb21wdXRlTGF5ZXJDb25maWcoKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuZmlyc3RSb3cgIT0gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdyAmJiBjb25maWcuZmlyc3RSb3dTY3JlZW4gPT0gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvd1NjcmVlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXMuc2Nyb2xsVG9wICsgKGNvbmZpZy5maXJzdFJvdyAtIHRoaXMubGF5ZXJDb25maWcuZmlyc3RSb3cpICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBzdDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMgfCB0aGlzLkNIQU5HRV9TQ1JPTEw7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy4kY29tcHV0ZUxheWVyQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVNjcm9sbEJhclYoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfSF9TQ1JPTEwpXG4gICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlU2Nyb2xsQmFySCgpO1xuICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuZWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAoLWNvbmZpZy5vZmZzZXQpICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLm1hcmdpblRvcCA9ICgtY29uZmlnLm9mZnNldCkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUud2lkdGggPSBjb25maWcud2lkdGggKyAyICogdGhpcy4kcGFkZGluZyArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBjb25maWcubWluSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfSF9TQ1JPTEwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gLXRoaXMuc2Nyb2xsTGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xhc3NOYW1lID0gdGhpcy5zY3JvbGxMZWZ0IDw9IDAgPyBcImFjZV9zY3JvbGxlclwiIDogXCJhY2Vfc2Nyb2xsZXIgYWNlX3Njcm9sbC1sZWZ0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9GVUxMKSB7XG4gICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2hvd0d1dHRlcilcbiAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJG1hcmtlckJhY2sudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJGN1cnNvckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcbiAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodEd1dHRlckxpbmUgJiYgdGhpcy4kdXBkYXRlR3V0dGVyTGluZUhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9TQ1JPTEwpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfVEVYVCB8fCBjaGFuZ2VzICYgdGhpcy5DSEFOR0VfTElORVMpXG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dExheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci5zY3JvbGxMaW5lcyhjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy4kc2hvd0d1dHRlcilcbiAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJG1hcmtlckJhY2sudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJGN1cnNvckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICAgICAgdGhpcy4kaGlnaGxpZ2h0R3V0dGVyTGluZSAmJiB0aGlzLiR1cGRhdGVHdXR0ZXJMaW5lSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzaG93R3V0dGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9MSU5FUykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHVwZGF0ZUxpbmVzKCkgfHwgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9HVVRURVIpICYmIHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQgfHwgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0dVVFRFUikge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0NVUlNPUikge1xuICAgICAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIudXBkYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgICAgICAgICAgdGhpcy4kaGlnaGxpZ2h0R3V0dGVyTGluZSAmJiB0aGlzLiR1cGRhdGVHdXR0ZXJMaW5lSGlnaGxpZ2h0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcyAmICh0aGlzLkNIQU5HRV9NQVJLRVIgfCB0aGlzLkNIQU5HRV9NQVJLRVJfRlJPTlQpKSB7XG4gICAgICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzICYgKHRoaXMuQ0hBTkdFX01BUktFUiB8IHRoaXMuQ0hBTkdFX01BUktFUl9CQUNLKSkge1xuICAgICAgICAgICAgdGhpcy4kbWFya2VyQmFjay51cGRhdGUoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NpZ25hbChcImFmdGVyUmVuZGVyXCIpO1xuICAgIH07XG5cbiAgICBcbiAgICB0aGlzLiRhdXRvc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbkxlbmd0aCgpICogdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy4kbWF4TGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBkZXNpcmVkSGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAodGhpcy4kbWluTGluZXN8fDEpICogdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgTWF0aC5taW4obWF4SGVpZ2h0LCBoZWlnaHQpXG4gICAgICAgICkgKyB0aGlzLnNjcm9sbE1hcmdpbi52ICsgKHRoaXMuJGV4dHJhSGVpZ2h0IHx8IDApO1xuICAgICAgICB2YXIgdlNjcm9sbCA9IGhlaWdodCA+IG1heEhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIGlmIChkZXNpcmVkSGVpZ2h0ICE9IHRoaXMuZGVzaXJlZEhlaWdodCB8fFxuICAgICAgICAgICAgdGhpcy4kc2l6ZS5oZWlnaHQgIT0gdGhpcy5kZXNpcmVkSGVpZ2h0IHx8IHZTY3JvbGwgIT0gdGhpcy4kdlNjcm9sbCkge1xuICAgICAgICAgICAgaWYgKHZTY3JvbGwgIT0gdGhpcy4kdlNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHZTY3JvbGwgPSB2U2Nyb2xsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRWaXNpYmxlKHZTY3JvbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdyA9IHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gZGVzaXJlZEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUNhY2hlZFNpemUodHJ1ZSwgdGhpcy4kZ3V0dGVyV2lkdGgsIHcsIGRlc2lyZWRIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5kZXNpcmVkSGVpZ2h0ID0gZGVzaXJlZEhlaWdodDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwiYXV0b3NpemVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRoaXMuJGNvbXB1dGVMYXllckNvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy4kbWF4TGluZXMgJiYgdGhpcy5saW5lSGVpZ2h0ID4gMSlcbiAgICAgICAgICAgIHRoaXMuJGF1dG9zaXplKCk7XG5cbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzaXplID0gdGhpcy4kc2l6ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBoaWRlU2Nyb2xsYmFycyA9IHNpemUuaGVpZ2h0IDw9IDIgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBzY3JlZW5MaW5lcyA9IHRoaXMuc2Vzc2lvbi5nZXRTY3JlZW5MZW5ndGgoKTtcbiAgICAgICAgdmFyIG1heEhlaWdodCA9IHNjcmVlbkxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnNjcm9sbFRvcCAlIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgdmFyIG1pbkhlaWdodCA9IHNpemUuc2Nyb2xsZXJIZWlnaHQgKyB0aGlzLmxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxvbmdlc3RMaW5lID0gdGhpcy4kZ2V0TG9uZ2VzdExpbmUoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBob3JpelNjcm9sbCA9ICFoaWRlU2Nyb2xsYmFycyAmJiAodGhpcy4kaFNjcm9sbEJhckFsd2F5c1Zpc2libGUgfHxcbiAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJXaWR0aCAtIGxvbmdlc3RMaW5lIC0gMiAqIHRoaXMuJHBhZGRpbmcgPCAwKTtcblxuICAgICAgICB2YXIgaFNjcm9sbENoYW5nZWQgPSB0aGlzLiRob3JpelNjcm9sbCAhPT0gaG9yaXpTY3JvbGw7XG4gICAgICAgIGlmIChoU2Nyb2xsQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy4kaG9yaXpTY3JvbGwgPSBob3JpelNjcm9sbDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFySC5zZXRWaXNpYmxlKGhvcml6U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHNjcm9sbFBhc3RFbmQgPSAhdGhpcy4kbWF4TGluZXMgJiYgdGhpcy4kc2Nyb2xsUGFzdEVuZFxuICAgICAgICAgICAgPyAoc2l6ZS5zY3JvbGxlckhlaWdodCAtIHRoaXMubGluZUhlaWdodCkgKiB0aGlzLiRzY3JvbGxQYXN0RW5kXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIG1heEhlaWdodCArPSBzY3JvbGxQYXN0RW5kO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoTWF0aC5tYXgoLXRoaXMuc2Nyb2xsTWFyZ2luLnRvcCxcbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMuc2Nyb2xsVG9wLCBtYXhIZWlnaHQgLSBzaXplLnNjcm9sbGVySGVpZ2h0ICsgdGhpcy5zY3JvbGxNYXJnaW4uYm90dG9tKSkpO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KE1hdGgubWF4KC10aGlzLnNjcm9sbE1hcmdpbi5sZWZ0LCBNYXRoLm1pbih0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBsb25nZXN0TGluZSArIDIgKiB0aGlzLiRwYWRkaW5nIC0gc2l6ZS5zY3JvbGxlcldpZHRoICsgdGhpcy5zY3JvbGxNYXJnaW4ucmlnaHQpKSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgdlNjcm9sbCA9ICFoaWRlU2Nyb2xsYmFycyAmJiAodGhpcy4kdlNjcm9sbEJhckFsd2F5c1Zpc2libGUgfHxcbiAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJIZWlnaHQgLSBtYXhIZWlnaHQgKyBzY3JvbGxQYXN0RW5kIDwgMCB8fCB0aGlzLnNjcm9sbFRvcCk7XG4gICAgICAgIHZhciB2U2Nyb2xsQ2hhbmdlZCA9IHRoaXMuJHZTY3JvbGwgIT09IHZTY3JvbGw7XG4gICAgICAgIGlmICh2U2Nyb2xsQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy4kdlNjcm9sbCA9IHZTY3JvbGw7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0VmlzaWJsZSh2U2Nyb2xsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lQ291bnQgPSBNYXRoLmNlaWwobWluSGVpZ2h0IC8gdGhpcy5saW5lSGVpZ2h0KSAtIDE7XG4gICAgICAgIHZhciBmaXJzdFJvdyA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoKHRoaXMuc2Nyb2xsVG9wIC0gb2Zmc2V0KSAvIHRoaXMubGluZUhlaWdodCkpO1xuICAgICAgICB2YXIgbGFzdFJvdyA9IGZpcnN0Um93ICsgbGluZUNvdW50O1xuICAgICAgICB2YXIgZmlyc3RSb3dTY3JlZW4sIGZpcnN0Um93SGVpZ2h0O1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgZmlyc3RSb3cgPSBzZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRSb3coZmlyc3RSb3csIDApO1xuICAgICAgICB2YXIgZm9sZExpbmUgPSBzZXNzaW9uLmdldEZvbGRMaW5lKGZpcnN0Um93KTtcbiAgICAgICAgaWYgKGZvbGRMaW5lKSB7XG4gICAgICAgICAgICBmaXJzdFJvdyA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcnN0Um93U2NyZWVuID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUm93KGZpcnN0Um93LCAwKTtcbiAgICAgICAgZmlyc3RSb3dIZWlnaHQgPSBzZXNzaW9uLmdldFJvd0xlbmd0aChmaXJzdFJvdykgKiBsaW5lSGVpZ2h0O1xuXG4gICAgICAgIGxhc3RSb3cgPSBNYXRoLm1pbihzZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRSb3cobGFzdFJvdywgMCksIHNlc3Npb24uZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgbWluSGVpZ2h0ID0gc2l6ZS5zY3JvbGxlckhlaWdodCArIHNlc3Npb24uZ2V0Um93TGVuZ3RoKGxhc3RSb3cpICogbGluZUhlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJvd0hlaWdodDtcblxuICAgICAgICBvZmZzZXQgPSB0aGlzLnNjcm9sbFRvcCAtIGZpcnN0Um93U2NyZWVuICogbGluZUhlaWdodDtcblxuICAgICAgICB2YXIgY2hhbmdlcyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxheWVyQ29uZmlnLndpZHRoICE9IGxvbmdlc3RMaW5lKSBcbiAgICAgICAgICAgIGNoYW5nZXMgPSB0aGlzLkNIQU5HRV9IX1NDUk9MTDtcbiAgICAgICAgaWYgKGhTY3JvbGxDaGFuZ2VkIHx8IHZTY3JvbGxDaGFuZ2VkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzID0gdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZSh0cnVlLCB0aGlzLmd1dHRlcldpZHRoLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJzY3JvbGxiYXJWaXNpYmlsaXR5Q2hhbmdlZFwiKTtcbiAgICAgICAgICAgIGlmICh2U2Nyb2xsQ2hhbmdlZClcbiAgICAgICAgICAgICAgICBsb25nZXN0TGluZSA9IHRoaXMuJGdldExvbmdlc3RMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMubGF5ZXJDb25maWcgPSB7XG4gICAgICAgICAgICB3aWR0aCA6IGxvbmdlc3RMaW5lLFxuICAgICAgICAgICAgcGFkZGluZyA6IHRoaXMuJHBhZGRpbmcsXG4gICAgICAgICAgICBmaXJzdFJvdyA6IGZpcnN0Um93LFxuICAgICAgICAgICAgZmlyc3RSb3dTY3JlZW46IGZpcnN0Um93U2NyZWVuLFxuICAgICAgICAgICAgbGFzdFJvdyA6IGxhc3RSb3csXG4gICAgICAgICAgICBsaW5lSGVpZ2h0IDogbGluZUhlaWdodCxcbiAgICAgICAgICAgIGNoYXJhY3RlcldpZHRoIDogdGhpcy5jaGFyYWN0ZXJXaWR0aCxcbiAgICAgICAgICAgIG1pbkhlaWdodCA6IG1pbkhlaWdodCxcbiAgICAgICAgICAgIG1heEhlaWdodCA6IG1heEhlaWdodCxcbiAgICAgICAgICAgIG9mZnNldCA6IG9mZnNldCxcbiAgICAgICAgICAgIGd1dHRlck9mZnNldCA6IE1hdGgubWF4KDAsIE1hdGguY2VpbCgob2Zmc2V0ICsgc2l6ZS5oZWlnaHQgLSBzaXplLnNjcm9sbGVySGVpZ2h0KSAvIGxpbmVIZWlnaHQpKSxcbiAgICAgICAgICAgIGhlaWdodCA6IHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9O1xuXG4gICAgdGhpcy4kdXBkYXRlTGluZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gdGhpcy4kY2hhbmdlZExpbmVzLmZpcnN0Um93O1xuICAgICAgICB2YXIgbGFzdFJvdyA9IHRoaXMuJGNoYW5nZWRMaW5lcy5sYXN0Um93O1xuICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMgPSBudWxsO1xuXG4gICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XG5cbiAgICAgICAgaWYgKGZpcnN0Um93ID4gbGF5ZXJDb25maWcubGFzdFJvdyArIDEpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChsYXN0Um93IDwgbGF5ZXJDb25maWcuZmlyc3RSb3cpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmIChsYXN0Um93ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGxheWVyQ29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUobGF5ZXJDb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGVMaW5lcyhsYXllckNvbmZpZywgZmlyc3RSb3csIGxhc3RSb3cpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy4kZ2V0TG9uZ2VzdExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYXJDb3VudCA9IHRoaXMuc2Vzc2lvbi5nZXRTY3JlZW5XaWR0aCgpO1xuICAgICAgICBpZiAodGhpcy5zaG93SW52aXNpYmxlcyAmJiAhdGhpcy5zZXNzaW9uLiR1c2VXcmFwTW9kZSlcbiAgICAgICAgICAgIGNoYXJDb3VudCArPSAxO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSAyICogdGhpcy4kcGFkZGluZywgTWF0aC5yb3VuZChjaGFyQ291bnQgKiB0aGlzLmNoYXJhY3RlcldpZHRoKSk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUZyb250TWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC5zZXRNYXJrZXJzKHRoaXMuc2Vzc2lvbi5nZXRNYXJrZXJzKHRydWUpKTtcbiAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9NQVJLRVJfRlJPTlQpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVCYWNrTWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRtYXJrZXJCYWNrLnNldE1hcmtlcnModGhpcy5zZXNzaW9uLmdldE1hcmtlcnMoKSk7XG4gICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfTUFSS0VSX0JBQ0spO1xuICAgIH07XG4gICAgdGhpcy5hZGRHdXR0ZXJEZWNvcmF0aW9uID0gZnVuY3Rpb24ocm93LCBjbGFzc05hbWUpe1xuICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5hZGRHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uKHJvdywgY2xhc3NOYW1lKXtcbiAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbihyb3csIGNsYXNzTmFtZSk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUJyZWFrcG9pbnRzID0gZnVuY3Rpb24ocm93cykge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XG4gICAgfTtcbiAgICB0aGlzLnNldEFubm90YXRpb25zID0gZnVuY3Rpb24oYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuc2V0QW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUN1cnNvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0NVUlNPUik7XG4gICAgfTtcbiAgICB0aGlzLmhpZGVDdXJzb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuaGlkZUN1cnNvcigpO1xuICAgIH07XG4gICAgdGhpcy5zaG93Q3Vyc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGN1cnNvckxheWVyLnNob3dDdXJzb3IoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IGZ1bmN0aW9uKGFuY2hvciwgbGVhZCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoYW5jaG9yLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnNjcm9sbEN1cnNvckludG9WaWV3KGxlYWQsIG9mZnNldCk7XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbEN1cnNvckludG9WaWV3ID0gZnVuY3Rpb24oY3Vyc29yLCBvZmZzZXQsICR2aWV3TWFyZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKGN1cnNvcik7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBwb3MubGVmdDtcbiAgICAgICAgdmFyIHRvcCA9IHBvcy50b3A7XG4gICAgICAgIFxuICAgICAgICB2YXIgdG9wTWFyZ2luID0gJHZpZXdNYXJnaW4gJiYgJHZpZXdNYXJnaW4udG9wIHx8IDA7XG4gICAgICAgIHZhciBib3R0b21NYXJnaW4gPSAkdmlld01hcmdpbiAmJiAkdmlld01hcmdpbi5ib3R0b20gfHwgMDtcbiAgICAgICAgXG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLiRzY3JvbGxBbmltYXRpb24gPyB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgOiB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgXG4gICAgICAgIGlmIChzY3JvbGxUb3AgKyB0b3BNYXJnaW4gPiB0b3ApIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICAgICAgdG9wIC09IG9mZnNldCAqIHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQ7XG4gICAgICAgICAgICBpZiAodG9wID09PSAwKVxuICAgICAgICAgICAgICAgIHRvcCA9IC10aGlzLnNjcm9sbE1hcmdpbi50b3A7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsVG9wICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCAtIGJvdHRvbU1hcmdpbiA8IHRvcCArIHRoaXMubGluZUhlaWdodCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldClcbiAgICAgICAgICAgICAgICB0b3AgKz0gb2Zmc2V0ICogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AodG9wICsgdGhpcy5saW5lSGVpZ2h0IC0gdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcblxuICAgICAgICBpZiAoc2Nyb2xsTGVmdCA+IGxlZnQpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0IDwgdGhpcy4kcGFkZGluZyArIDIgKiB0aGlzLmxheWVyQ29uZmlnLmNoYXJhY3RlcldpZHRoKVxuICAgICAgICAgICAgICAgIGxlZnQgPSAtdGhpcy5zY3JvbGxNYXJnaW4ubGVmdDtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KGxlZnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbExlZnQgKyB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggPCBsZWZ0ICsgdGhpcy5jaGFyYWN0ZXJXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbExlZnQoTWF0aC5yb3VuZChsZWZ0ICsgdGhpcy5jaGFyYWN0ZXJXaWR0aCAtIHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbExlZnQgPD0gdGhpcy4kcGFkZGluZyAmJiBsZWZ0IC0gc2Nyb2xsTGVmdCA8IHRoaXMuY2hhcmFjdGVyV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpO1xuICAgIH07XG4gICAgdGhpcy5nZXRTY3JvbGxUb3BSb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9wIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgIH07XG4gICAgdGhpcy5nZXRTY3JvbGxCb3R0b21Sb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGguZmxvb3IoKHRoaXMuc2Nyb2xsVG9wICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCkgLyB0aGlzLmxpbmVIZWlnaHQpIC0gMSk7XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvUm93ID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aocm93ICogdGhpcy5saW5lSGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5hbGlnbkN1cnNvciA9IGZ1bmN0aW9uKGN1cnNvciwgYWxpZ25tZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3Vyc29yID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBjdXJzb3IgPSB7cm93OiBjdXJzb3IsIGNvbHVtbjogMH07XG5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oY3Vyc29yKTtcbiAgICAgICAgdmFyIGggPSB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0IC0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcG9zLnRvcCAtIGggKiAoYWxpZ25tZW50IHx8IDApO1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9O1xuXG4gICAgdGhpcy5TVEVQUyA9IDg7XG4gICAgdGhpcy4kY2FsY1N0ZXBzID0gZnVuY3Rpb24oZnJvbVZhbHVlLCB0b1ZhbHVlKXtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbCA9IHRoaXMuU1RFUFM7XG4gICAgICAgIHZhciBzdGVwcyA9IFtdO1xuXG4gICAgICAgIHZhciBmdW5jICA9IGZ1bmN0aW9uKHQsIHhfbWluLCBkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGR4ICogKE1hdGgucG93KHQgLSAxLCAzKSArIDEpICsgeF9taW47XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSlcbiAgICAgICAgICAgIHN0ZXBzLnB1c2goZnVuYyhpIC8gdGhpcy5TVEVQUywgZnJvbVZhbHVlLCB0b1ZhbHVlIC0gZnJvbVZhbHVlKSk7XG5cbiAgICAgICAgcmV0dXJuIHN0ZXBzO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb0xpbmUgPSBmdW5jdGlvbihsaW5lLCBjZW50ZXIsIGFuaW1hdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKHtyb3c6IGxpbmUsIGNvbHVtbjogMH0pO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcG9zLnRvcDtcbiAgICAgICAgaWYgKGNlbnRlcilcbiAgICAgICAgICAgIG9mZnNldCAtPSB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgaW5pdGlhbFNjcm9sbCA9IHRoaXMuc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKG9mZnNldCk7XG4gICAgICAgIGlmIChhbmltYXRlICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVNjcm9sbGluZyhpbml0aWFsU2Nyb2xsLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHRoaXMuYW5pbWF0ZVNjcm9sbGluZyA9IGZ1bmN0aW9uKGZyb21WYWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRvVmFsdWUgPSB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKCF0aGlzLiRhbmltYXRlZFNjcm9sbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIGlmIChmcm9tVmFsdWUgPT0gdG9WYWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLiRzY3JvbGxBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBvbGRTdGVwcyA9IHRoaXMuJHNjcm9sbEFuaW1hdGlvbi5zdGVwcztcbiAgICAgICAgICAgIGlmIChvbGRTdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmcm9tVmFsdWUgPSBvbGRTdGVwc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbVZhbHVlID09IHRvVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHN0ZXBzID0gX3NlbGYuJGNhbGNTdGVwcyhmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICAgICAgICB0aGlzLiRzY3JvbGxBbmltYXRpb24gPSB7ZnJvbTogZnJvbVZhbHVlLCB0bzogdG9WYWx1ZSwgc3RlcHM6IHN0ZXBzfTtcblxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuJHRpbWVyKTtcblxuICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcChzdGVwcy5zaGlmdCgpKTtcbiAgICAgICAgX3NlbGYuc2Vzc2lvbi4kc2Nyb2xsVG9wID0gdG9WYWx1ZTtcbiAgICAgICAgdGhpcy4kdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcChzdGVwcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLiRzY3JvbGxUb3AgPSB0b1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLiRzY3JvbGxUb3AgPSAtMTtcbiAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcCh0b1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0b1ZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3NlbGYuJHRpbWVyID0gY2xlYXJJbnRlcnZhbChfc2VsZi4kdGltZXIpO1xuICAgICAgICAgICAgICAgIF9zZWxmLiRzY3JvbGxBbmltYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwKTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsVG9ZID0gZnVuY3Rpb24oc2Nyb2xsVG9wKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb1ggPSBmdW5jdGlvbihzY3JvbGxMZWZ0KSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnQgIT09IHNjcm9sbExlZnQpXG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0hfU0NST0xMKTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoeSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KHkpO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxCeSA9IGZ1bmN0aW9uKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgICAgIGRlbHRhWSAmJiB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxUb3AoKSArIGRlbHRhWSk7XG4gICAgICAgIGRlbHRhWCAmJiB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdCh0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpICsgZGVsdGFYKTtcbiAgICB9O1xuICAgIHRoaXMuaXNTY3JvbGxhYmxlQnkgPSBmdW5jdGlvbihkZWx0YVgsIGRlbHRhWSkge1xuICAgICAgICBpZiAoZGVsdGFZIDwgMCAmJiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgPj0gMSAtIHRoaXMuc2Nyb2xsTWFyZ2luLnRvcClcbiAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChkZWx0YVkgPiAwICYmIHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxUb3AoKSArIHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHRcbiAgICAgICAgICAgIC0gdGhpcy5sYXllckNvbmZpZy5tYXhIZWlnaHQgPCAtMSArIHRoaXMuc2Nyb2xsTWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChkZWx0YVggPCAwICYmIHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxMZWZ0KCkgPj0gMSAtIHRoaXMuc2Nyb2xsTWFyZ2luLmxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRlbHRhWCA+IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbExlZnQoKSArIHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aFxuICAgICAgICAgICAgLSB0aGlzLmxheWVyQ29uZmlnLndpZHRoIDwgLTEgKyB0aGlzLnNjcm9sbE1hcmdpbi5yaWdodClcbiAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHRoaXMucGl4ZWxUb1NjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gKHggKyB0aGlzLnNjcm9sbExlZnQgLSBjYW52YXNQb3MubGVmdCAtIHRoaXMuJHBhZGRpbmcpIC8gdGhpcy5jaGFyYWN0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoKHkgKyB0aGlzLnNjcm9sbFRvcCAtIGNhbnZhc1Bvcy50b3ApIC8gdGhpcy5saW5lSGVpZ2h0KTtcbiAgICAgICAgdmFyIGNvbCA9IE1hdGgucm91bmQob2Zmc2V0KTtcblxuICAgICAgICByZXR1cm4ge3Jvdzogcm93LCBjb2x1bW46IGNvbCwgc2lkZTogb2Zmc2V0IC0gY29sID4gMCA/IDEgOiAtMX07XG4gICAgfTtcblxuICAgIHRoaXMuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHZhciBjb2wgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgKHggKyB0aGlzLnNjcm9sbExlZnQgLSBjYW52YXNQb3MubGVmdCAtIHRoaXMuJHBhZGRpbmcpIC8gdGhpcy5jaGFyYWN0ZXJXaWR0aFxuICAgICAgICApO1xuXG4gICAgICAgIHZhciByb3cgPSAoeSArIHRoaXMuc2Nyb2xsVG9wIC0gY2FudmFzUG9zLnRvcCkgLyB0aGlzLmxpbmVIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24ocm93LCBNYXRoLm1heChjb2wsIDApKTtcbiAgICB9O1xuICAgIHRoaXMudGV4dFRvU2NyZWVuQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24ocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy4kcGFkZGluZyArIE1hdGgucm91bmQocG9zLmNvbHVtbiAqIHRoaXMuY2hhcmFjdGVyV2lkdGgpO1xuICAgICAgICB2YXIgeSA9IHBvcy5yb3cgKiB0aGlzLmxpbmVIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZ2VYOiBjYW52YXNQb3MubGVmdCArIHggLSB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBwYWdlWTogY2FudmFzUG9zLnRvcCArIHkgLSB0aGlzLnNjcm9sbFRvcFxuICAgICAgICB9O1xuICAgIH07XG4gICAgdGhpcy52aXN1YWxpemVGb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIFwiYWNlX2ZvY3VzXCIpO1xuICAgIH07XG4gICAgdGhpcy52aXN1YWxpemVCbHVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgXCJhY2VfZm9jdXNcIik7XG4gICAgfTtcbiAgICB0aGlzLnNob3dDb21wb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kY29tcG9zaXRpb24pXG4gICAgICAgICAgICB0aGlzLiRjb21wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBrZWVwVGV4dEFyZWFBdEN1cnNvcjogdGhpcy4ka2VlcFRleHRBcmVhQXRDdXJzb3IsXG4gICAgICAgICAgICAgICAgY3NzVGV4dDogdGhpcy50ZXh0YXJlYS5zdHlsZS5jc3NUZXh0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMudGV4dGFyZWEsIFwiYWNlX2NvbXBvc2l0aW9uXCIpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xuICAgIH07XG4gICAgdGhpcy5zZXRDb21wb3NpdGlvblRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHRoaXMuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XG4gICAgfTtcbiAgICB0aGlzLmhpZGVDb21wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGNvbXBvc2l0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLnRleHRhcmVhLCBcImFjZV9jb21wb3NpdGlvblwiKTtcbiAgICAgICAgdGhpcy4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSB0aGlzLiRjb21wb3NpdGlvbi5rZWVwVGV4dEFyZWFBdEN1cnNvcjtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5zdHlsZS5jc3NUZXh0ID0gdGhpcy4kY29tcG9zaXRpb24uY3NzVGV4dDtcbiAgICAgICAgdGhpcy4kY29tcG9zaXRpb24gPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5zZXRUaGVtZSA9IGZ1bmN0aW9uKHRoZW1lLCBjYikge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLiR0aGVtZUlkID0gdGhlbWU7XG4gICAgICAgIF9zZWxmLl9kaXNwYXRjaEV2ZW50KCd0aGVtZUNoYW5nZScse3RoZW1lOnRoZW1lfSk7XG5cbiAgICAgICAgaWYgKCF0aGVtZSB8fCB0eXBlb2YgdGhlbWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIG1vZHVsZU5hbWUgPSB0aGVtZSB8fCB0aGlzLiRvcHRpb25zLnRoZW1lLmluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFtcInRoZW1lXCIsIG1vZHVsZU5hbWVdLCBhZnRlckxvYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWZ0ZXJMb2FkKHRoZW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyTG9hZChtb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChfc2VsZi4kdGhlbWVJZCAhPSB0aGVtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIGlmICghbW9kdWxlLmNzc0NsYXNzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRvbS5pbXBvcnRDc3NTdHJpbmcoXG4gICAgICAgICAgICAgICAgbW9kdWxlLmNzc1RleHQsXG4gICAgICAgICAgICAgICAgbW9kdWxlLmNzc0NsYXNzLFxuICAgICAgICAgICAgICAgIF9zZWxmLmNvbnRhaW5lci5vd25lckRvY3VtZW50XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoX3NlbGYudGhlbWUpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNzc0NsYXNzKF9zZWxmLmNvbnRhaW5lciwgX3NlbGYudGhlbWUuY3NzQ2xhc3MpO1xuXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IFwicGFkZGluZ1wiIGluIG1vZHVsZSA/IG1vZHVsZS5wYWRkaW5nIFxuICAgICAgICAgICAgICAgIDogXCJwYWRkaW5nXCIgaW4gKF9zZWxmLnRoZW1lIHx8IHt9KSA/IDQgOiBfc2VsZi4kcGFkZGluZztcbiAgICAgICAgICAgIGlmIChfc2VsZi4kcGFkZGluZyAmJiBwYWRkaW5nICE9IF9zZWxmLiRwYWRkaW5nKVxuICAgICAgICAgICAgICAgIF9zZWxmLnNldFBhZGRpbmcocGFkZGluZyk7XG4gICAgICAgICAgICBfc2VsZi4kdGhlbWUgPSBtb2R1bGUuY3NzQ2xhc3M7XG5cbiAgICAgICAgICAgIF9zZWxmLnRoZW1lID0gbW9kdWxlO1xuICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKF9zZWxmLmNvbnRhaW5lciwgbW9kdWxlLmNzc0NsYXNzKTtcbiAgICAgICAgICAgIGRvbS5zZXRDc3NDbGFzcyhfc2VsZi5jb250YWluZXIsIFwiYWNlX2RhcmtcIiwgbW9kdWxlLmlzRGFyayk7XG4gICAgICAgICAgICBpZiAoX3NlbGYuJHNpemUpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi4kc2l6ZS53aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgX3NlbGYuJHVwZGF0ZVNpemVBc3luYygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2VsZi5fZGlzcGF0Y2hFdmVudCgndGhlbWVMb2FkZWQnLCB7dGhlbWU6bW9kdWxlfSk7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldFRoZW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0aGVtZUlkO1xuICAgIH07XG4gICAgdGhpcy5zZXRTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlLCBpbmNsdWRlKSB7XG4gICAgICAgIGRvbS5zZXRDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgc3R5bGUsIGluY2x1ZGUgIT09IGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMudW5zZXRTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgc3R5bGUpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRDdXJzb3JTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGVyLnN0eWxlLmN1cnNvciAhPSBzdHlsZSlcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUuY3Vyc29yID0gc3R5bGU7XG4gICAgfTtcbiAgICB0aGlzLnNldE1vdXNlQ3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxlci5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZTtcbiAgICB9O1xuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRjdXJzb3JMYXllci5kZXN0cm95KCk7XG4gICAgfTtcblxufSkuY2FsbChWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlKTtcblxuXG5jb25maWcuZGVmaW5lT3B0aW9ucyhWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHtcbiAgICBhbmltYXRlZFNjcm9sbDoge2luaXRpYWxWYWx1ZTogZmFsc2V9LFxuICAgIHNob3dJbnZpc2libGVzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR0ZXh0TGF5ZXIuc2V0U2hvd0ludmlzaWJsZXModmFsdWUpKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHNob3dQcmludE1hcmdpbjoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkgeyB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHByaW50TWFyZ2luQ29sdW1uOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oKSB7IHRoaXMuJHVwZGF0ZVByaW50TWFyZ2luKCk7IH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogODBcbiAgICB9LFxuICAgIHByaW50TWFyZ2luOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRoaXMuJHByaW50TWFyZ2luQ29sdW1uID0gdmFsO1xuICAgICAgICAgICAgdGhpcy4kc2hvd1ByaW50TWFyZ2luID0gISF2YWw7XG4gICAgICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNob3dQcmludE1hcmdpbiAmJiB0aGlzLiRwcmludE1hcmdpbkNvbHVtbjsgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNob3dHdXR0ZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihzaG93KXtcbiAgICAgICAgICAgIHRoaXMuJGd1dHRlci5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcbiAgICAgICAgICAgIHRoaXMub25HdXR0ZXJSZXNpemUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBmYWRlRm9sZFdpZGdldHM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihzaG93KSB7XG4gICAgICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy4kZ3V0dGVyLCBcImFjZV9mYWRlLWZvbGQtd2lkZ2V0c1wiLCBzaG93KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd0ZvbGRXaWRnZXRzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oc2hvdykge3RoaXMuJGd1dHRlckxheWVyLnNldFNob3dGb2xkV2lkZ2V0cyhzaG93KX0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgc2hvd0xpbmVOdW1iZXJzOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oc2hvdykge1xuICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuc2V0U2hvd0xpbmVOdW1iZXJzKHNob3cpO1xuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9HVVRURVIpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGRpc3BsYXlJbmRlbnRHdWlkZXM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihzaG93KSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdGV4dExheWVyLnNldERpc3BsYXlJbmRlbnRHdWlkZXMoc2hvdykpXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9URVhUKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBoaWdobGlnaHRHdXR0ZXJMaW5lOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGd1dHRlckxpbmVIaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXJMaW5lSGlnaGxpZ2h0ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGluZUhpZ2hsaWdodC5jbGFzc05hbWUgPSBcImFjZV9ndXR0ZXItYWN0aXZlLWxpbmVcIjtcbiAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXIuYXBwZW5kQ2hpbGQodGhpcy4kZ3V0dGVyTGluZUhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRndXR0ZXJMaW5lSGlnaGxpZ2h0LnN0eWxlLmRpc3BsYXkgPSBzaG91bGRIaWdobGlnaHQgPyBcIlwiIDogXCJub25lXCI7XG4gICAgICAgICAgICBpZiAodGhpcy4kY3Vyc29yTGF5ZXIuJHBpeGVsUG9zKVxuICAgICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUd1dHRlckxpbmVIaWdobGlnaHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICB9LFxuICAgIGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlIHx8ICF0aGlzLiRob3JpelNjcm9sbClcbiAgICAgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX1NDUk9MTCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcbiAgICB9LFxuICAgIHZTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJHZTY3JvbGxCYXJBbHdheXNWaXNpYmxlIHx8ICF0aGlzLiR2U2Nyb2xsKVxuICAgICAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfU0NST0xMKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgZm9udFNpemU6ICB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzaXplID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5mb250U2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvbnRTaXplKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogMTJcbiAgICB9LFxuICAgIGZvbnRGYW1pbHk6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5mb250RmFtaWx5ID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9udFNpemUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWF4TGluZXM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnVsbCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtaW5MaW5lczoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGdWxsKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNjcm9sbFBhc3RFbmQ6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHZhbCA9ICt2YWwgfHwgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzY3JvbGxQYXN0RW5kID09IHZhbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLiRzY3JvbGxQYXN0RW5kID0gdmFsO1xuICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9TQ1JPTEwpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IDAsXG4gICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcbiAgICB9LFxuICAgIGZpeGVkV2lkdGhHdXR0ZXI6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLiRmaXhlZFdpZHRoID0gISF2YWw7XG4gICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRoZW1lOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7IHRoaXMuc2V0VGhlbWUodmFsKSB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy4kdGhlbWVJZCB8fCB0aGlzLnRoZW1lOyB9LFxuICAgICAgICBpbml0aWFsVmFsdWU6IFwiLi90aGVtZS90ZXh0bWF0ZVwiLFxuICAgICAgICBoYW5kbGVzU2V0OiB0cnVlXG4gICAgfVxufSk7XG5cbmV4cG9ydHMuVmlydHVhbFJlbmRlcmVyID0gVmlydHVhbFJlbmRlcmVyO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2Uvd29ya2VyL3dvcmtlcl9jbGllbnRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL25ldFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvY29uZmlnXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBuZXQgPSBhY2VxdWlyZShcIi4uL2xpYi9uZXRcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXCIuLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgY29uZmlnID0gYWNlcXVpcmUoXCIuLi9jb25maWdcIik7XG5cbnZhciBXb3JrZXJDbGllbnQgPSBmdW5jdGlvbih0b3BMZXZlbE5hbWVzcGFjZXMsIG1vZCwgY2xhc3NuYW1lLCB3b3JrZXJVcmwpIHtcbiAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IHRoaXMuJHNlbmREZWx0YVF1ZXVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IHRoaXMuY2hhbmdlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgaWYgKGFjZXF1aXJlLm5hbWVUb1VybCAmJiAhYWNlcXVpcmUudG9VcmwpXG4gICAgICAgIGFjZXF1aXJlLnRvVXJsID0gYWNlcXVpcmUubmFtZVRvVXJsO1xuICAgIFxuICAgIGlmIChjb25maWcuZ2V0KFwicGFja2FnZWRcIikgfHwgIWFjZXF1aXJlLnRvVXJsKSB7XG4gICAgICAgIHdvcmtlclVybCA9IHdvcmtlclVybCB8fCBjb25maWcubW9kdWxlVXJsKG1vZC5pZCwgXCJ3b3JrZXJcIilcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm9ybWFsaXplUGF0aCA9IHRoaXMuJG5vcm1hbGl6ZVBhdGg7XG4gICAgICAgIHdvcmtlclVybCA9IHdvcmtlclVybCB8fCBub3JtYWxpemVQYXRoKGFjZXF1aXJlLnRvVXJsKFwiYWNlL3dvcmtlci93b3JrZXIuanNcIiwgbnVsbCwgXCJfXCIpKTtcblxuICAgICAgICB2YXIgdGxucyA9IHt9O1xuICAgICAgICB0b3BMZXZlbE5hbWVzcGFjZXMuZm9yRWFjaChmdW5jdGlvbihucykge1xuICAgICAgICAgICAgdGxuc1tuc10gPSBub3JtYWxpemVQYXRoKGFjZXF1aXJlLnRvVXJsKG5zLCBudWxsLCBcIl9cIikucmVwbGFjZSgvKFxcLmpzKT8oXFw/LiopPyQvLCBcIlwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgd29ya2VyU3JjID0gbW9kLnNyYztcbiAgICB2YXIgQmxvYiA9IHJlcXVpcmUoJ3czYy1ibG9iJyk7XG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbIHdvcmtlclNyYyBdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICB2YXIgYmxvYlVybCA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuICAgIHRoaXMuJHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG5cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiB3aW5kb3cuRE9NRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICB2YXIgYmxvYiA9IHRoaXMuJHdvcmtlckJsb2Iod29ya2VyVXJsKTtcbiAgICAgICAgICAgIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICAgICAgICB2YXIgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cbiAgICAgICAgICAgIHRoaXMuJHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiR3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpbml0IDogdHJ1ZSxcbiAgICAgICAgdGxucyA6IHRsbnMsXG4gICAgICAgIG1vZHVsZSA6IG1vZC5pZCxcbiAgICAgICAgY2xhc3NuYW1lIDogY2xhc3NuYW1lXG4gICAgfSk7XG5cbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG5cbiAgICB0aGlzLiR3b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2U7XG59O1xuXG4oZnVuY3Rpb24oKXtcblxuICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuICAgIHRoaXMub25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgbXNnID0gZS5kYXRhO1xuICAgICAgICBzd2l0Y2gobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbChtc2cubmFtZSwge2RhdGE6IG1zZy5kYXRhfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW21zZy5pZF07XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW21zZy5pZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihtc2cuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibG9nXCI6XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cgJiYgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgbXNnLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfTtcblxuICAgIHRoaXMuJG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBuZXQucXVhbGlmeVVSTChwYXRoKTtcbiAgICB9O1xuXG4gICAgdGhpcy50ZXJtaW5hdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2lnbmFsKFwidGVybWluYXRlXCIsIHt9KTtcbiAgICAgICAgdGhpcy5kZWx0YVF1ZXVlID0gbnVsbDtcbiAgICAgICAgdGhpcy4kd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLiR3b3JrZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy4kZG9jKVxuICAgICAgICAgICAgdGhpcy4kZG9jLm9mZihcImNoYW5nZVwiLCB0aGlzLmNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy4kZG9jID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5zZW5kID0gZnVuY3Rpb24oY21kLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuJHdvcmtlci5wb3N0TWVzc2FnZSh7Y29tbWFuZDogY21kLCBhcmdzOiBhcmdzfSk7XG4gICAgfTtcblxuICAgIHRoaXMuY2FsbCA9IGZ1bmN0aW9uKGNtZCwgYXJncywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2lkXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgYXJncy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmQoY21kLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5lbWl0ID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuJHdvcmtlci5wb3N0TWVzc2FnZSh7ZXZlbnQ6IGV2ZW50LCBkYXRhOiB7ZGF0YTogZGF0YS5kYXRhfX0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGV4LnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmF0dGFjaFRvRG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYodGhpcy4kZG9jKVxuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcblxuICAgICAgICB0aGlzLiRkb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuY2FsbChcInNldFZhbHVlXCIsIFtkb2MuZ2V0VmFsdWUoKV0pO1xuICAgICAgICBkb2Mub24oXCJjaGFuZ2VcIiwgdGhpcy5jaGFuZ2VMaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWx0YVF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbHRhUXVldWUgPSBbZS5kYXRhXTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy4kc2VuZERlbHRhUXVldWUsIDApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRoaXMuZGVsdGFRdWV1ZS5wdXNoKGUuZGF0YSk7XG4gICAgfTtcblxuICAgIHRoaXMuJHNlbmREZWx0YVF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBxID0gdGhpcy5kZWx0YVF1ZXVlO1xuICAgICAgICBpZiAoIXEpIHJldHVybjtcbiAgICAgICAgdGhpcy5kZWx0YVF1ZXVlID0gbnVsbDtcbiAgICAgICAgaWYgKHEubGVuZ3RoID4gMjAgJiYgcS5sZW5ndGggPiB0aGlzLiRkb2MuZ2V0TGVuZ3RoKCkgPj4gMSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKFwic2V0VmFsdWVcIiwgW3RoaXMuJGRvYy5nZXRWYWx1ZSgpXSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHtkYXRhOiBxfSk7XG4gICAgfTtcblxuICAgIHRoaXMuJHdvcmtlckJsb2IgPSBmdW5jdGlvbih3b3JrZXJVcmwpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IFwiaW1wb3J0U2NyaXB0cygnXCIgKyBuZXQucXVhbGlmeVVSTCh3b3JrZXJVcmwpICsgXCInKTtcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbc2NyaXB0XSwge1widHlwZVwiOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIn0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgICAgICB2YXIgQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBibG9iQnVpbGRlciA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICAgICAgYmxvYkJ1aWxkZXIuYXBwZW5kKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gYmxvYkJ1aWxkZXIuZ2V0QmxvYihcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KS5jYWxsKFdvcmtlckNsaWVudC5wcm90b3R5cGUpO1xuXG5cbnZhciBVSVdvcmtlckNsaWVudCA9IGZ1bmN0aW9uKHRvcExldmVsTmFtZXNwYWNlcywgbW9kLCBjbGFzc25hbWUpIHtcbiAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IHRoaXMuJHNlbmREZWx0YVF1ZXVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IHRoaXMuY2hhbmdlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG5cbiAgICB2YXIgbWFpbiA9IG51bGw7XG4gICAgdmFyIGVtaXRTeW5jID0gZmFsc2U7XG4gICAgdmFyIHNlbmRlciA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyKTtcbiAgICB2YXIgX3NlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy4kd29ya2VyID0ge307XG4gICAgdGhpcy4kd29ya2VyLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy4kd29ya2VyLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBfc2VsZi5tZXNzYWdlQnVmZmVyLnB1c2goZSk7XG4gICAgICAgIGlmIChtYWluKSB7XG4gICAgICAgICAgICBpZiAoZW1pdFN5bmMpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChwcm9jZXNzTmV4dCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZXRFbWl0U3luYyA9IGZ1bmN0aW9uKHZhbCkgeyBlbWl0U3luYyA9IHZhbCB9O1xuXG4gICAgdmFyIHByb2Nlc3NOZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBfc2VsZi5tZXNzYWdlQnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgIGlmIChtc2cuY29tbWFuZClcbiAgICAgICAgICAgIG1haW5bbXNnLmNvbW1hbmRdLmFwcGx5KG1haW4sIG1zZy5hcmdzKTtcbiAgICAgICAgZWxzZSBpZiAobXNnLmV2ZW50KVxuICAgICAgICAgICAgc2VuZGVyLl9zaWduYWwobXNnLmV2ZW50LCBtc2cuZGF0YSk7XG4gICAgfTtcblxuICAgIHNlbmRlci5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICBfc2VsZi5vbk1lc3NhZ2Uoe2RhdGE6IG1zZ30pO1xuICAgIH07XG4gICAgc2VuZGVyLmNhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2tJZCkge1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiBcImNhbGxcIiwgaWQ6IGNhbGxiYWNrSWQsIGRhdGE6IGRhdGF9KTtcbiAgICB9O1xuICAgIHNlbmRlci5lbWl0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiBcImV2ZW50XCIsIG5hbWU6IG5hbWUsIGRhdGE6IGRhdGF9KTtcbiAgICB9O1xuXG4gICAgY29uZmlnLmxvYWRNb2R1bGUoW1wid29ya2VyXCIsIG1vZF0sIGZ1bmN0aW9uKE1haW4pIHtcbiAgICAgICAgbWFpbiA9IG5ldyBNYWluW2NsYXNzbmFtZV0oc2VuZGVyKTtcbiAgICAgICAgd2hpbGUgKF9zZWxmLm1lc3NhZ2VCdWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICB9KTtcbn07XG5cblVJV29ya2VyQ2xpZW50LnByb3RvdHlwZSA9IFdvcmtlckNsaWVudC5wcm90b3R5cGU7XG5cbmV4cG9ydHMuVUlXb3JrZXJDbGllbnQgPSBVSVdvcmtlckNsaWVudDtcbmV4cG9ydHMuV29ya2VyQ2xpZW50ID0gV29ya2VyQ2xpZW50O1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9wbGFjZWhvbGRlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlXCIsXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcIixcImFjZS9saWIvb29wXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFwiLi9saWIvZXZlbnRfZW1pdHRlclwiKS5FdmVudEVtaXR0ZXI7XG52YXIgb29wID0gYWNlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG5cbnZhciBQbGFjZUhvbGRlciA9IGZ1bmN0aW9uKHNlc3Npb24sIGxlbmd0aCwgcG9zLCBvdGhlcnMsIG1haW5DbGFzcywgb3RoZXJzQ2xhc3MpIHtcbiAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgdGhpcy5kb2MgPSBzZXNzaW9uLmdldERvY3VtZW50KCk7XG4gICAgdGhpcy5tYWluQ2xhc3MgPSBtYWluQ2xhc3M7XG4gICAgdGhpcy5vdGhlcnNDbGFzcyA9IG90aGVyc0NsYXNzO1xuICAgIHRoaXMuJG9uVXBkYXRlID0gdGhpcy5vblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZG9jLm9uKFwiY2hhbmdlXCIsIHRoaXMuJG9uVXBkYXRlKTtcbiAgICB0aGlzLiRvdGhlcnMgPSBvdGhlcnM7XG4gICAgXG4gICAgdGhpcy4kb25DdXJzb3JDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9zZWxmLm9uQ3Vyc29yQ2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy4kcG9zID0gcG9zO1xuICAgIHZhciB1bmRvU3RhY2sgPSBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuJHVuZG9TdGFjayB8fCBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuJHVuZG9zdGFjayB8fCB7bGVuZ3RoOiAtMX07XG4gICAgdGhpcy4kdW5kb1N0YWNrRGVwdGggPSAgdW5kb1N0YWNrLmxlbmd0aDtcbiAgICB0aGlzLnNldHVwKCk7XG5cbiAgICBzZXNzaW9uLnNlbGVjdGlvbi5vbihcImNoYW5nZUN1cnNvclwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XG4gICAgdGhpcy5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2M7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgcG9zID0gdGhpcy4kcG9zO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25CZWZvcmUgPSBzZXNzaW9uLnNlbGVjdGlvbi50b0pTT04oKTtcbiAgICAgICAgaWYgKHNlc3Npb24uc2VsZWN0aW9uLmluTXVsdGlTZWxlY3RNb2RlKVxuICAgICAgICAgICAgc2Vzc2lvbi5zZWxlY3Rpb24udG9TaW5nbGVSYW5nZSgpO1xuXG4gICAgICAgIHRoaXMucG9zID0gZG9jLmNyZWF0ZUFuY2hvcihwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgdGhpcy5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uLCBwb3Mucm93LCBwb3MuY29sdW1uICsgdGhpcy5sZW5ndGgpLCB0aGlzLm1haW5DbGFzcywgbnVsbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnBvcy5vbihcImNoYW5nZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIoX3NlbGYubWFya2VySWQpO1xuICAgICAgICAgICAgX3NlbGYubWFya2VySWQgPSBzZXNzaW9uLmFkZE1hcmtlcihuZXcgUmFuZ2UoZXZlbnQudmFsdWUucm93LCBldmVudC52YWx1ZS5jb2x1bW4sIGV2ZW50LnZhbHVlLnJvdywgZXZlbnQudmFsdWUuY29sdW1uK19zZWxmLmxlbmd0aCksIF9zZWxmLm1haW5DbGFzcywgbnVsbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vdGhlcnMgPSBbXTtcbiAgICAgICAgdGhpcy4kb3RoZXJzLmZvckVhY2goZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBkb2MuY3JlYXRlQW5jaG9yKG90aGVyLnJvdywgb3RoZXIuY29sdW1uKTtcbiAgICAgICAgICAgIF9zZWxmLm90aGVycy5wdXNoKGFuY2hvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uLnNldFVuZG9TZWxlY3QoZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5zaG93T3RoZXJNYXJrZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMub3RoZXJzQWN0aXZlKSByZXR1cm47XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm90aGVyc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub3RoZXJzLmZvckVhY2goZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICAgICAgICBhbmNob3IubWFya2VySWQgPSBzZXNzaW9uLmFkZE1hcmtlcihuZXcgUmFuZ2UoYW5jaG9yLnJvdywgYW5jaG9yLmNvbHVtbiwgYW5jaG9yLnJvdywgYW5jaG9yLmNvbHVtbitfc2VsZi5sZW5ndGgpLCBfc2VsZi5vdGhlcnNDbGFzcywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgYW5jaG9yLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIoYW5jaG9yLm1hcmtlcklkKTtcbiAgICAgICAgICAgICAgICBhbmNob3IubWFya2VySWQgPSBzZXNzaW9uLmFkZE1hcmtlcihuZXcgUmFuZ2UoZXZlbnQudmFsdWUucm93LCBldmVudC52YWx1ZS5jb2x1bW4sIGV2ZW50LnZhbHVlLnJvdywgZXZlbnQudmFsdWUuY29sdW1uK19zZWxmLmxlbmd0aCksIF9zZWxmLm90aGVyc0NsYXNzLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmhpZGVPdGhlck1hcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoIXRoaXMub3RoZXJzQWN0aXZlKSByZXR1cm47XG4gICAgICAgIHRoaXMub3RoZXJzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdGhlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVNYXJrZXIodGhpcy5vdGhlcnNbaV0ubWFya2VySWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uVXBkYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgdmFyIHJhbmdlID0gZGVsdGEucmFuZ2U7XG4gICAgICAgIGlmKHJhbmdlLnN0YXJ0LnJvdyAhPT0gcmFuZ2UuZW5kLnJvdykgcmV0dXJuO1xuICAgICAgICBpZihyYW5nZS5zdGFydC5yb3cgIT09IHRoaXMucG9zLnJvdykgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kdXBkYXRpbmcpIHJldHVybjtcbiAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgbGVuZ3RoRGlmZiA9IGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRUZXh0XCIgPyByYW5nZS5lbmQuY29sdW1uIC0gcmFuZ2Uuc3RhcnQuY29sdW1uIDogcmFuZ2Uuc3RhcnQuY29sdW1uIC0gcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICAgICAgXG4gICAgICAgIGlmKHJhbmdlLnN0YXJ0LmNvbHVtbiA+PSB0aGlzLnBvcy5jb2x1bW4gJiYgcmFuZ2Uuc3RhcnQuY29sdW1uIDw9IHRoaXMucG9zLmNvbHVtbiArIHRoaXMubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbVN0YXJ0ID0gcmFuZ2Uuc3RhcnQuY29sdW1uIC0gdGhpcy5wb3MuY29sdW1uO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gbGVuZ3RoRGlmZjtcbiAgICAgICAgICAgIGlmKCF0aGlzLnNlc3Npb24uJGZyb21VbmRvKSB7XG4gICAgICAgICAgICAgICAgaWYoZGVsdGEuYWN0aW9uID09PSBcImluc2VydFRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5vdGhlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlclBvcyA9IHRoaXMub3RoZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHtyb3c6IG90aGVyUG9zLnJvdywgY29sdW1uOiBvdGhlclBvcy5jb2x1bW4gKyBkaXN0YW5jZUZyb21TdGFydH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihvdGhlclBvcy5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPCBvdGhlclBvcy5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zLmNvbHVtbiArPSBsZW5ndGhEaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MuaW5zZXJ0KG5ld1BvcywgZGVsdGEudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZGVsdGEuYWN0aW9uID09PSBcInJlbW92ZVRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5vdGhlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlclBvcyA9IHRoaXMub3RoZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHtyb3c6IG90aGVyUG9zLnJvdywgY29sdW1uOiBvdGhlclBvcy5jb2x1bW4gKyBkaXN0YW5jZUZyb21TdGFydH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihvdGhlclBvcy5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPCBvdGhlclBvcy5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zLmNvbHVtbiArPSBsZW5ndGhEaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MucmVtb3ZlKG5ldyBSYW5nZShuZXdQb3Mucm93LCBuZXdQb3MuY29sdW1uLCBuZXdQb3Mucm93LCBuZXdQb3MuY29sdW1uIC0gbGVuZ3RoRGlmZikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHJhbmdlLnN0YXJ0LmNvbHVtbiA9PT0gdGhpcy5wb3MuY29sdW1uICYmIGRlbHRhLmFjdGlvbiA9PT0gXCJpbnNlcnRUZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zLnNldFBvc2l0aW9uKHRoaXMucG9zLnJvdywgdGhpcy5wb3MuY29sdW1uIC0gbGVuZ3RoRGlmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3RoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5vdGhlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BvcyA9IHtyb3c6IG90aGVyLnJvdywgY29sdW1uOiBvdGhlci5jb2x1bW4gLSBsZW5ndGhEaWZmfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvdGhlci5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPCBvdGhlci5jb2x1bW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvcy5jb2x1bW4gKz0gbGVuZ3RoRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5zZXRQb3NpdGlvbihuZXdQb3Mucm93LCBuZXdQb3MuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihyYW5nZS5zdGFydC5jb2x1bW4gPT09IHRoaXMucG9zLmNvbHVtbiAmJiBkZWx0YS5hY3Rpb24gPT09IFwicmVtb3ZlVGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3RoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5vdGhlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3RoZXIucm93ID09PSByYW5nZS5zdGFydC5yb3cgJiYgcmFuZ2Uuc3RhcnQuY29sdW1uIDwgb3RoZXIuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLnNldFBvc2l0aW9uKG90aGVyLnJvdywgb3RoZXIuY29sdW1uIC0gbGVuZ3RoRGlmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zLl9lbWl0KFwiY2hhbmdlXCIsIHt2YWx1ZTogdGhpcy5wb3N9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdGhlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLm90aGVyc1tpXS5fZW1pdChcImNoYW5nZVwiLCB7dmFsdWU6IHRoaXMub3RoZXJzW2ldfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kdXBkYXRpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkN1cnNvckNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLiR1cGRhdGluZyB8fCAhdGhpcy5zZXNzaW9uKSByZXR1cm47XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmdldEN1cnNvcigpO1xuICAgICAgICBpZiAocG9zLnJvdyA9PT0gdGhpcy5wb3Mucm93ICYmIHBvcy5jb2x1bW4gPj0gdGhpcy5wb3MuY29sdW1uICYmIHBvcy5jb2x1bW4gPD0gdGhpcy5wb3MuY29sdW1uICsgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd090aGVyTWFya2VycygpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImN1cnNvckVudGVyXCIsIGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZU90aGVyTWFya2VycygpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdChcImN1cnNvckxlYXZlXCIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07ICAgIFxuICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVNYXJrZXIodGhpcy5tYXJrZXJJZCk7XG4gICAgICAgIHRoaXMuaGlkZU90aGVyTWFya2VycygpO1xuICAgICAgICB0aGlzLmRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuJG9uVXBkYXRlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlQ3Vyc29yXCIsIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5wb3MuZGV0YWNoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vdGhlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMub3RoZXJzW2ldLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRVbmRvU2VsZWN0KHRydWUpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy4kdW5kb1N0YWNrRGVwdGggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5jZWxpbmcgcGxhY2Vob2xkZXJzIG9ubHkgc3VwcG9ydGVkIHdpdGggdW5kbyBtYW5hZ2VyIGF0dGFjaGVkIHRvIHNlc3Npb24uXCIpO1xuICAgICAgICB2YXIgdW5kb01hbmFnZXIgPSB0aGlzLnNlc3Npb24uZ2V0VW5kb01hbmFnZXIoKTtcbiAgICAgICAgdmFyIHVuZG9zUmVxdWlyZWQgPSAodW5kb01hbmFnZXIuJHVuZG9TdGFjayB8fCB1bmRvTWFuYWdlci4kdW5kb3N0YWNrKS5sZW5ndGggLSB0aGlzLiR1bmRvU3RhY2tEZXB0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmRvc1JlcXVpcmVkOyBpKyspIHtcbiAgICAgICAgICAgIHVuZG9NYW5hZ2VyLnVuZG8odHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uQmVmb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbi5mcm9tSlNPTih0aGlzLnNlbGVjdGlvbkJlZm9yZSk7XG4gICAgfTtcbn0pLmNhbGwoUGxhY2VIb2xkZXIucHJvdG90eXBlKTtcblxuXG5leHBvcnRzLlBsYWNlSG9sZGVyID0gUGxhY2VIb2xkZXI7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb3VzZS9tdWx0aV9zZWxlY3RfaGFuZGxlclwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2xpYi91c2VyYWdlbnRcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxudmFyIGV2ZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvZXZlbnRcIik7XG52YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXCIuLi9saWIvdXNlcmFnZW50XCIpO1xuZnVuY3Rpb24gaXNTYW1lUG9pbnQocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyA9PSBwMi5yb3cgJiYgcDEuY29sdW1uID09IHAyLmNvbHVtbjtcbn1cblxuZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgIHZhciBldiA9IGUuZG9tRXZlbnQ7XG4gICAgdmFyIGFsdCA9IGV2LmFsdEtleTtcbiAgICB2YXIgc2hpZnQgPSBldi5zaGlmdEtleTtcbiAgICB2YXIgY3RybCA9IGV2LmN0cmxLZXk7XG4gICAgdmFyIGFjY2VsID0gZS5nZXRBY2NlbEtleSgpO1xuICAgIHZhciBidXR0b24gPSBlLmdldEJ1dHRvbigpO1xuICAgIFxuICAgIGlmIChjdHJsICYmIHVzZXJhZ2VudC5pc01hYylcbiAgICAgICAgYnV0dG9uID0gZXYuYnV0dG9uO1xuXG4gICAgaWYgKGUuZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlICYmIGJ1dHRvbiA9PSAyKSB7XG4gICAgICAgIGUuZWRpdG9yLnRleHRJbnB1dC5vbkNvbnRleHRNZW51KGUuZG9tRXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICghY3RybCAmJiAhYWx0ICYmICFhY2NlbCkge1xuICAgICAgICBpZiAoYnV0dG9uID09PSAwICYmIGUuZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlKVxuICAgICAgICAgICAgZS5lZGl0b3IuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmIChidXR0b24gIT09IDApXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBlZGl0b3IgPSBlLmVkaXRvcjtcbiAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgaXNNdWx0aVNlbGVjdCA9IGVkaXRvci5pbk11bHRpU2VsZWN0TW9kZTtcbiAgICB2YXIgcG9zID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgdmFyIGN1cnNvciA9IHNlbGVjdGlvbi5nZXRDdXJzb3IoKTtcbiAgICB2YXIgaW5TZWxlY3Rpb24gPSBlLmluU2VsZWN0aW9uKCkgfHwgKHNlbGVjdGlvbi5pc0VtcHR5KCkgJiYgaXNTYW1lUG9pbnQocG9zLCBjdXJzb3IpKTtcblxuICAgIHZhciBtb3VzZVggPSBlLngsIG1vdXNlWSA9IGUueTtcbiAgICB2YXIgb25Nb3VzZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbW91c2VYID0gZS5jbGllbnRYO1xuICAgICAgICBtb3VzZVkgPSBlLmNsaWVudFk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgIHZhciBzY3JlZW5BbmNob3IgPSBlZGl0b3IucmVuZGVyZXIucGl4ZWxUb1NjcmVlbkNvb3JkaW5hdGVzKG1vdXNlWCwgbW91c2VZKTtcbiAgICB2YXIgc2NyZWVuQ3Vyc29yID0gc2NyZWVuQW5jaG9yO1xuICAgIFxuICAgIHZhciBzZWxlY3Rpb25Nb2RlO1xuICAgIGlmIChlZGl0b3IuJG1vdXNlSGFuZGxlci4kZW5hYmxlSnVtcFRvRGVmKSB7XG4gICAgICAgIGlmIChjdHJsICYmIGFsdCB8fCBhY2NlbCAmJiBhbHQpXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlID0gXCJhZGRcIjtcbiAgICAgICAgZWxzZSBpZiAoYWx0KVxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZSA9IFwiYmxvY2tcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYWNjZWwgJiYgIWFsdCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZSA9IFwiYWRkXCI7XG4gICAgICAgICAgICBpZiAoIWlzTXVsdGlTZWxlY3QgJiYgc2hpZnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGFsdCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoc2VsZWN0aW9uTW9kZSAmJiB1c2VyYWdlbnQuaXNNYWMgJiYgZXYuY3RybEtleSkge1xuICAgICAgICBlZGl0b3IuJG1vdXNlSGFuZGxlci5jYW5jZWxDb250ZXh0TWVudSgpO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3Rpb25Nb2RlID09IFwiYWRkXCIpIHtcbiAgICAgICAgaWYgKCFpc011bHRpU2VsZWN0ICYmIGluU2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBkcmFnZ2luZ1xuXG4gICAgICAgIGlmICghaXNNdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuICAgICAgICAgICAgZWRpdG9yLmFkZFNlbGVjdGlvbk1hcmtlcihyYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkUmFuZ2UgPSBzZWxlY3Rpb24ucmFuZ2VMaXN0LnJhbmdlQXRQb2ludChwb3MpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmcrKztcbiAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNoaWZ0KSB7XG4gICAgICAgICAgICBvbGRSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICByYW5nZSA9IHNlbGVjdGlvbi5yYW5nZXNbMF07XG4gICAgICAgICAgICBlZGl0b3IucmVtb3ZlU2VsZWN0aW9uTWFya2VyKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iub25jZShcIm1vdXNldXBcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdG1wU2VsID0gc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xuXG4gICAgICAgICAgICBpZiAob2xkUmFuZ2UgJiYgdG1wU2VsLmlzRW1wdHkoKSAmJiBpc1NhbWVQb2ludChvbGRSYW5nZS5jdXJzb3IsIHRtcFNlbC5jdXJzb3IpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zdWJzdHJhY3RQb2ludCh0bXBTZWwuY3Vyc29yKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzaGlmdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc3Vic3RyYWN0UG9pbnQocmFuZ2UuY3Vyc29yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXIocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UodG1wU2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmctLTtcbiAgICAgICAgICAgIGVkaXRvci5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb25Nb2RlID09IFwiYmxvY2tcIikge1xuICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlOyAgICAgICAgXG4gICAgICAgIHZhciBpbml0aWFsUmFuZ2U7XG4gICAgICAgIHZhciByZWN0U2VsID0gW107XG4gICAgICAgIHZhciBibG9ja1NlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5ld0N1cnNvciA9IGVkaXRvci5yZW5kZXJlci5waXhlbFRvU2NyZWVuQ29vcmRpbmF0ZXMobW91c2VYLCBtb3VzZVkpO1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKG5ld0N1cnNvci5yb3csIG5ld0N1cnNvci5jb2x1bW4pO1xuXG4gICAgICAgICAgICBpZiAoaXNTYW1lUG9pbnQoc2NyZWVuQ3Vyc29yLCBuZXdDdXJzb3IpICYmIGlzU2FtZVBvaW50KGN1cnNvciwgc2VsZWN0aW9uLmxlYWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNjcmVlbkN1cnNvciA9IG5ld0N1cnNvcjtcblxuICAgICAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZysrO1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihjdXJzb3IpO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG5cbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXJzKHJlY3RTZWwpO1xuICAgICAgICAgICAgcmVjdFNlbCA9IHNlbGVjdGlvbi5yZWN0YW5ndWxhclJhbmdlQmxvY2soc2NyZWVuQ3Vyc29yLCBzY3JlZW5BbmNob3IpO1xuICAgICAgICAgICAgaWYgKGVkaXRvci4kbW91c2VIYW5kbGVyLiRjbGlja1NlbGVjdGlvbiAmJiByZWN0U2VsLmxlbmd0aCA9PSAxICYmIHJlY3RTZWxbMF0uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIHJlY3RTZWxbMF0gPSBlZGl0b3IuJG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIHJlY3RTZWwuZm9yRWFjaChlZGl0b3IuYWRkU2VsZWN0aW9uTWFya2VyLCBlZGl0b3IpO1xuICAgICAgICAgICAgZWRpdG9yLnVwZGF0ZVNlbGVjdGlvbk1hcmtlcnMoKTtcbiAgICAgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmctLTtcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZysrO1xuICAgICAgICBpZiAoaXNNdWx0aVNlbGVjdCAmJiAhYWNjZWwpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi50b1NpbmdsZVJhbmdlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTXVsdGlTZWxlY3QgJiYgYWNjZWwpIHtcbiAgICAgICAgICAgIGluaXRpYWxSYW5nZSA9IHNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcbiAgICAgICAgICAgIGVkaXRvci5hZGRTZWxlY3Rpb25NYXJrZXIoaW5pdGlhbFJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHNoaWZ0KVxuICAgICAgICAgICAgc2NyZWVuQW5jaG9yID0gc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24oc2VsZWN0aW9uLmxlYWQpOyAgICAgICAgICAgIFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcbiAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZy0tO1xuICAgICAgICBcbiAgICAgICAgc2NyZWVuQ3Vyc29yID0ge3JvdzogLTEsIGNvbHVtbjogLTF9O1xuXG4gICAgICAgIHZhciBvbk1vdXNlU2VsZWN0aW9uRW5kID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXJzKHJlY3RTZWwpO1xuICAgICAgICAgICAgaWYgKCFyZWN0U2VsLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZWN0U2VsID0gW3NlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKV07XG4gICAgICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nKys7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVNlbGVjdGlvbk1hcmtlcihpbml0aWFsUmFuZ2UpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi50b1NpbmdsZVJhbmdlKGluaXRpYWxSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY3RTZWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJlY3RTZWxbaV0pO1xuICAgICAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGVkaXRvci4kbW91c2VIYW5kbGVyLiRjbGlja1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nLS07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uU2VsZWN0aW9uSW50ZXJ2YWwgPSBibG9ja1NlbGVjdDtcblxuICAgICAgICBldmVudC5jYXB0dXJlKGVkaXRvci5jb250YWluZXIsIG9uTW91c2VTZWxlY3Rpb24sIG9uTW91c2VTZWxlY3Rpb25FbmQpO1xuICAgICAgICB2YXIgdGltZXJJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge29uU2VsZWN0aW9uSW50ZXJ2YWwoKTt9LCAyMCk7XG5cbiAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cblxuZXhwb3J0cy5vbk1vdXNlRG93biA9IG9uTW91c2VEb3duO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbmV4cG9ydHMuZGVmYXVsdENvbW1hbmRzID0gW3tcbiAgICBuYW1lOiBcImFkZEN1cnNvckFib3ZlXCIsXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlTGluZXMoLTEpOyB9LFxuICAgIGJpbmRLZXk6IHt3aW46IFwiQ3RybC1BbHQtVXBcIiwgbWFjOiBcIkN0cmwtQWx0LVVwXCJ9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRvbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJhZGRDdXJzb3JCZWxvd1wiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZUxpbmVzKDEpOyB9LFxuICAgIGJpbmRLZXk6IHt3aW46IFwiQ3RybC1BbHQtRG93blwiLCBtYWM6IFwiQ3RybC1BbHQtRG93blwifSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkb25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiYWRkQ3Vyc29yQWJvdmVTa2lwQ3VycmVudFwiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZUxpbmVzKC0xLCB0cnVlKTsgfSxcbiAgICBiaW5kS2V5OiB7d2luOiBcIkN0cmwtQWx0LVNoaWZ0LVVwXCIsIG1hYzogXCJDdHJsLUFsdC1TaGlmdC1VcFwifSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkb25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwiYWRkQ3Vyc29yQmVsb3dTa2lwQ3VycmVudFwiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZUxpbmVzKDEsIHRydWUpOyB9LFxuICAgIGJpbmRLZXk6IHt3aW46IFwiQ3RybC1BbHQtU2hpZnQtRG93blwiLCBtYWM6IFwiQ3RybC1BbHQtU2hpZnQtRG93blwifSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkb25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwic2VsZWN0TW9yZUJlZm9yZVwiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZSgtMSk7IH0sXG4gICAgYmluZEtleToge3dpbjogXCJDdHJsLUFsdC1MZWZ0XCIsIG1hYzogXCJDdHJsLUFsdC1MZWZ0XCJ9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRvbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzZWxlY3RNb3JlQWZ0ZXJcIixcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmUoMSk7IH0sXG4gICAgYmluZEtleToge3dpbjogXCJDdHJsLUFsdC1SaWdodFwiLCBtYWM6IFwiQ3RybC1BbHQtUmlnaHRcIn0sXG4gICAgc2Nyb2xsSW50b1ZpZXc6IFwiY3Vyc29yXCIsXG4gICAgcmVhZG9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcInNlbGVjdE5leHRCZWZvcmVcIixcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmUoLTEsIHRydWUpOyB9LFxuICAgIGJpbmRLZXk6IHt3aW46IFwiQ3RybC1BbHQtU2hpZnQtTGVmdFwiLCBtYWM6IFwiQ3RybC1BbHQtU2hpZnQtTGVmdFwifSxcbiAgICBzY3JvbGxJbnRvVmlldzogXCJjdXJzb3JcIixcbiAgICByZWFkb25seTogdHJ1ZVxufSwge1xuICAgIG5hbWU6IFwic2VsZWN0TmV4dEFmdGVyXCIsXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlKDEsIHRydWUpOyB9LFxuICAgIGJpbmRLZXk6IHt3aW46IFwiQ3RybC1BbHQtU2hpZnQtUmlnaHRcIiwgbWFjOiBcIkN0cmwtQWx0LVNoaWZ0LVJpZ2h0XCJ9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRvbmx5OiB0cnVlXG59LCB7XG4gICAgbmFtZTogXCJzcGxpdEludG9MaW5lc1wiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubXVsdGlTZWxlY3Quc3BsaXRJbnRvTGluZXMoKTsgfSxcbiAgICBiaW5kS2V5OiB7d2luOiBcIkN0cmwtQWx0LUxcIiwgbWFjOiBcIkN0cmwtQWx0LUxcIn0sXG4gICAgcmVhZG9ubHk6IHRydWVcbn0sIHtcbiAgICBuYW1lOiBcImFsaWduQ3Vyc29yc1wiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuYWxpZ25DdXJzb3JzKCk7IH0sXG4gICAgYmluZEtleToge3dpbjogXCJDdHJsLUFsdC1BXCIsIG1hYzogXCJDdHJsLUFsdC1BXCJ9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiXG59LCB7XG4gICAgbmFtZTogXCJmaW5kQWxsXCIsXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5maW5kQWxsKCk7IH0sXG4gICAgYmluZEtleToge3dpbjogXCJDdHJsLUFsdC1LXCIsIG1hYzogXCJDdHJsLUFsdC1HXCJ9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRvbmx5OiB0cnVlXG59XTtcbmV4cG9ydHMubXVsdGlTZWxlY3RDb21tYW5kcyA9IFt7XG4gICAgbmFtZTogXCJzaW5nbGVTZWxlY3Rpb25cIixcbiAgICBiaW5kS2V5OiBcImVzY1wiLFxuICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZXhpdE11bHRpU2VsZWN0TW9kZSgpOyB9LFxuICAgIHNjcm9sbEludG9WaWV3OiBcImN1cnNvclwiLFxuICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgIGlzQXZhaWxhYmxlOiBmdW5jdGlvbihlZGl0b3IpIHtyZXR1cm4gZWRpdG9yICYmIGVkaXRvci5pbk11bHRpU2VsZWN0TW9kZX1cbn1dO1xuXG52YXIgSGFzaEhhbmRsZXIgPSBhY2VxdWlyZShcIi4uL2tleWJvYXJkL2hhc2hfaGFuZGxlclwiKS5IYXNoSGFuZGxlcjtcbmV4cG9ydHMua2V5Ym9hcmRIYW5kbGVyID0gbmV3IEhhc2hIYW5kbGVyKGV4cG9ydHMubXVsdGlTZWxlY3RDb21tYW5kcyk7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL211bHRpX3NlbGVjdFwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL3JhbmdlX2xpc3RcIixcImFjZS9yYW5nZVwiLFwiYWNlL3NlbGVjdGlvblwiLFwiYWNlL21vdXNlL211bHRpX3NlbGVjdF9oYW5kbGVyXCIsXCJhY2UvbGliL2V2ZW50XCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcIixcImFjZS9zZWFyY2hcIixcImFjZS9lZGl0X3Nlc3Npb25cIixcImFjZS9lZGl0b3JcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxudmFyIFJhbmdlTGlzdCA9IGFjZXF1aXJlKFwiLi9yYW5nZV9saXN0XCIpLlJhbmdlTGlzdDtcbnZhciBSYW5nZSA9IGFjZXF1aXJlKFwiLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBTZWxlY3Rpb24gPSBhY2VxdWlyZShcIi4vc2VsZWN0aW9uXCIpLlNlbGVjdGlvbjtcbnZhciBvbk1vdXNlRG93biA9IGFjZXF1aXJlKFwiLi9tb3VzZS9tdWx0aV9zZWxlY3RfaGFuZGxlclwiKS5vbk1vdXNlRG93bjtcbnZhciBldmVudCA9IGFjZXF1aXJlKFwiLi9saWIvZXZlbnRcIik7XG52YXIgbGFuZyA9IGFjZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBjb21tYW5kcyA9IGFjZXF1aXJlKFwiLi9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcIik7XG5leHBvcnRzLmNvbW1hbmRzID0gY29tbWFuZHMuZGVmYXVsdENvbW1hbmRzLmNvbmNhdChjb21tYW5kcy5tdWx0aVNlbGVjdENvbW1hbmRzKTtcbnZhciBTZWFyY2ggPSBhY2VxdWlyZShcIi4vc2VhcmNoXCIpLlNlYXJjaDtcbnZhciBzZWFyY2ggPSBuZXcgU2VhcmNoKCk7XG5cbmZ1bmN0aW9uIGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpIHtcbiAgICBzZWFyY2guJG9wdGlvbnMud3JhcCA9IHRydWU7XG4gICAgc2VhcmNoLiRvcHRpb25zLm5lZWRsZSA9IG5lZWRsZTtcbiAgICBzZWFyY2guJG9wdGlvbnMuYmFja3dhcmRzID0gZGlyID09IC0xO1xuICAgIHJldHVybiBzZWFyY2guZmluZChzZXNzaW9uKTtcbn1cbnZhciBFZGl0U2Vzc2lvbiA9IGFjZXF1aXJlKFwiLi9lZGl0X3Nlc3Npb25cIikuRWRpdFNlc3Npb247XG4oZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXRTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZWxlY3Rpb25NYXJrZXJzO1xuICAgIH07XG59KS5jYWxsKEVkaXRTZXNzaW9uLnByb3RvdHlwZSk7XG4oZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yYW5nZXMgPSBudWxsO1xuICAgIHRoaXMucmFuZ2VMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmFkZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UsICRibG9ja0NoYW5nZUV2ZW50cykge1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICghdGhpcy5pbk11bHRpU2VsZWN0TW9kZSAmJiB0aGlzLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBvbGRSYW5nZSA9IHRoaXMudG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlTGlzdC5hZGQob2xkUmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlTGlzdC5yYW5nZXMubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlTGlzdC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGJsb2NrQ2hhbmdlRXZlbnRzIHx8IHRoaXMuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlTGlzdC5hZGQob2xkUmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy4kb25BZGRSYW5nZShvbGRSYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJhbmdlLmN1cnNvcilcbiAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHJhbmdlLmVuZDtcblxuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LmFkZChyYW5nZSk7XG5cbiAgICAgICAgdGhpcy4kb25BZGRSYW5nZShyYW5nZSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy4kb25SZW1vdmVSYW5nZShyZW1vdmVkKTtcblxuICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID4gMSAmJiAhdGhpcy5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFwibXVsdGlTZWxlY3RcIik7XG4gICAgICAgICAgICB0aGlzLmluTXVsdGlTZWxlY3RNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kdW5kb1NlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYXR0YWNoKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGJsb2NrQ2hhbmdlRXZlbnRzIHx8IHRoaXMuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgIH07XG5cbiAgICB0aGlzLnRvU2luZ2xlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByYW5nZSA9IHJhbmdlIHx8IHRoaXMucmFuZ2VzWzBdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LnJlbW92ZUFsbCgpO1xuICAgICAgICBpZiAocmVtb3ZlZC5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLiRvblJlbW92ZVJhbmdlKHJlbW92ZWQpO1xuXG4gICAgICAgIHJhbmdlICYmIHRoaXMuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzdHJhY3RQb2ludCA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LnN1YnN0cmFjdFBvaW50KHBvcyk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLiRvblJlbW92ZVJhbmdlKHJlbW92ZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWRbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubWVyZ2VPdmVybGFwcGluZ1JhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0Lm1lcmdlKCk7XG4gICAgICAgIGlmIChyZW1vdmVkLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UocmVtb3ZlZCk7XG4gICAgICAgIGVsc2UgaWYodGhpcy5yYW5nZXNbMF0pXG4gICAgICAgICAgICB0aGlzLmZyb21PcmllbnRlZFJhbmdlKHRoaXMucmFuZ2VzWzBdKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kb25BZGRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMucmFuZ2VMaXN0LnJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMucmFuZ2VzLnVuc2hpZnQocmFuZ2UpO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJhZGRSYW5nZVwiLCB7cmFuZ2U6IHJhbmdlfSk7XG4gICAgfTtcblxuICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbihyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMucmFuZ2VMaXN0LnJhbmdlcy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQgPT0gMSAmJiB0aGlzLmluTXVsdGlTZWxlY3RNb2RlKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gdGhpcy5yYW5nZUxpc3QucmFuZ2VzLnBvcCgpO1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGxhc3RSYW5nZSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHJlbW92ZWQubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5yYW5nZXMuaW5kZXhPZihyZW1vdmVkW2ldKTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaWduYWwoXCJyZW1vdmVSYW5nZVwiLCB7cmFuZ2VzOiByZW1vdmVkfSk7XG5cbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA9PT0gMCAmJiB0aGlzLmluTXVsdGlTZWxlY3RNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmluTXVsdGlTZWxlY3RNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWwoXCJzaW5nbGVTZWxlY3RcIik7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uJHVuZG9TZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuZGV0YWNoKHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UmFuZ2UgPSBsYXN0UmFuZ2UgfHwgdGhpcy5yYW5nZXNbMF07XG4gICAgICAgIGlmIChsYXN0UmFuZ2UgJiYgIWxhc3RSYW5nZS5pc0VxdWFsKHRoaXMuZ2V0UmFuZ2UoKSkpXG4gICAgICAgICAgICB0aGlzLmZyb21PcmllbnRlZFJhbmdlKGxhc3RSYW5nZSk7XG4gICAgfTtcbiAgICB0aGlzLiRpbml0UmFuZ2VMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlTGlzdClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLnJhbmdlTGlzdCA9IG5ldyBSYW5nZUxpc3QoKTtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gMDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0QWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlQ291bnQgPyB0aGlzLnJhbmdlTGlzdC5yYW5nZXMuY29uY2F0KCkgOiBbdGhpcy5nZXRSYW5nZSgpXTtcbiAgICB9O1xuXG4gICAgdGhpcy5zcGxpdEludG9MaW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlTGlzdC5yYW5nZXM7XG4gICAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2VzWzBdLnN0YXJ0LCBsYXN0UmFuZ2UuZW5kKTtcblxuICAgICAgICAgICAgdGhpcy50b1NpbmdsZVJhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlLCBsYXN0UmFuZ2UuY3Vyc29yID09IGxhc3RSYW5nZS5zdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgaXNCYWNrd2FyZHMgPSB0aGlzLmlzQmFja3dhcmRzKCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSByYW5nZS5zdGFydC5yb3c7XG4gICAgICAgICAgICB2YXIgZW5kUm93ID0gcmFuZ2UuZW5kLnJvdztcbiAgICAgICAgICAgIGlmIChzdGFydFJvdyA9PSBlbmRSb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCYWNrd2FyZHMpXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLmVuZCwgZW5kID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmFuZ2UoUmFuZ2UuZnJvbVBvaW50cyhlbmQsIGVuZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmFuZ2UoUmFuZ2UuZnJvbVBvaW50cyhzdGFydCwgc3RhcnQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWN0U2VsID0gW107XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuZ2V0TGluZVJhbmdlKHN0YXJ0Um93LCB0cnVlKTtcbiAgICAgICAgICAgIHIuc3RhcnQuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICAgICAgcmVjdFNlbC5wdXNoKHIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRSb3cgKyAxOyBpIDwgZW5kUm93OyBpKyspXG4gICAgICAgICAgICAgICAgcmVjdFNlbC5wdXNoKHRoaXMuZ2V0TGluZVJhbmdlKGksIHRydWUpKTtcblxuICAgICAgICAgICAgciA9IHRoaXMuZ2V0TGluZVJhbmdlKGVuZFJvdywgdHJ1ZSk7XG4gICAgICAgICAgICByLmVuZC5jb2x1bW4gPSByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICAgICAgcmVjdFNlbC5wdXNoKHIpO1xuXG4gICAgICAgICAgICByZWN0U2VsLmZvckVhY2godGhpcy5hZGRSYW5nZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudG9nZ2xlQmxvY2tTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZUxpc3QucmFuZ2VzO1xuICAgICAgICAgICAgdmFyIGxhc3RSYW5nZSA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlc1swXS5zdGFydCwgbGFzdFJhbmdlLmVuZCk7XG5cbiAgICAgICAgICAgIHRoaXMudG9TaW5nbGVSYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgbGFzdFJhbmdlLmN1cnNvciA9PSBsYXN0UmFuZ2Uuc3RhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5zZWxlY3Rpb25MZWFkKTtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uQW5jaG9yKTtcblxuICAgICAgICAgICAgdmFyIHJlY3RTZWwgPSB0aGlzLnJlY3Rhbmd1bGFyUmFuZ2VCbG9jayhjdXJzb3IsIGFuY2hvcik7XG4gICAgICAgICAgICByZWN0U2VsLmZvckVhY2godGhpcy5hZGRSYW5nZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVjdGFuZ3VsYXJSYW5nZUJsb2NrID0gZnVuY3Rpb24oc2NyZWVuQ3Vyc29yLCBzY3JlZW5BbmNob3IsIGluY2x1ZGVFbXB0eUxpbmVzKSB7XG4gICAgICAgIHZhciByZWN0U2VsID0gW107XG5cbiAgICAgICAgdmFyIHhCYWNrd2FyZHMgPSBzY3JlZW5DdXJzb3IuY29sdW1uIDwgc2NyZWVuQW5jaG9yLmNvbHVtbjtcbiAgICAgICAgaWYgKHhCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFydENvbHVtbiA9IHNjcmVlbkN1cnNvci5jb2x1bW47XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2NyZWVuQW5jaG9yLmNvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydENvbHVtbiA9IHNjcmVlbkFuY2hvci5jb2x1bW47XG4gICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gc2NyZWVuQ3Vyc29yLmNvbHVtbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB5QmFja3dhcmRzID0gc2NyZWVuQ3Vyc29yLnJvdyA8IHNjcmVlbkFuY2hvci5yb3c7XG4gICAgICAgIGlmICh5QmFja3dhcmRzKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSBzY3JlZW5DdXJzb3Iucm93O1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHNjcmVlbkFuY2hvci5yb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSBzY3JlZW5BbmNob3Iucm93O1xuICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHNjcmVlbkN1cnNvci5yb3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPCAwKVxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSAwO1xuICAgICAgICBpZiAoc3RhcnRSb3cgPCAwKVxuICAgICAgICAgICAgc3RhcnRSb3cgPSAwO1xuXG4gICAgICAgIGlmIChzdGFydFJvdyA9PSBlbmRSb3cpXG4gICAgICAgICAgICBpbmNsdWRlRW1wdHlMaW5lcyA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgcm93ID0gc3RhcnRSb3c7IHJvdyA8PSBlbmRSb3c7IHJvdysrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKFxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24ocm93LCBzdGFydENvbHVtbiksXG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihyb3csIGVuZENvbHVtbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY0VuZCAmJiBpc1NhbWVQb2ludChyYW5nZS5lbmQsIGRvY0VuZCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHZhciBkb2NFbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZS5jdXJzb3IgPSB4QmFja3dhcmRzID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7XG4gICAgICAgICAgICByZWN0U2VsLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlCYWNrd2FyZHMpXG4gICAgICAgICAgICByZWN0U2VsLnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoIWluY2x1ZGVFbXB0eUxpbmVzKSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gcmVjdFNlbC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKHJlY3RTZWxbZW5kXS5pc0VtcHR5KCkgJiYgZW5kID4gMClcbiAgICAgICAgICAgICAgICBlbmQtLTtcbiAgICAgICAgICAgIGlmIChlbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVjdFNlbFtzdGFydF0uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVuZDsgaSA+PSBzdGFydDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RTZWxbaV0uaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgICAgICByZWN0U2VsLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0U2VsO1xuICAgIH07XG59KS5jYWxsKFNlbGVjdGlvbi5wcm90b3R5cGUpO1xudmFyIEVkaXRvciA9IGFjZXF1aXJlKFwiLi9lZGl0b3JcIikuRWRpdG9yO1xuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uTWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZFNlbGVjdGlvbk1hcmtlciA9IGZ1bmN0aW9uKG9yaWVudGVkUmFuZ2UpIHtcbiAgICAgICAgaWYgKCFvcmllbnRlZFJhbmdlLmN1cnNvcilcbiAgICAgICAgICAgIG9yaWVudGVkUmFuZ2UuY3Vyc29yID0gb3JpZW50ZWRSYW5nZS5lbmQ7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZSgpO1xuICAgICAgICBvcmllbnRlZFJhbmdlLm1hcmtlciA9IHRoaXMuc2Vzc2lvbi5hZGRNYXJrZXIob3JpZW50ZWRSYW5nZSwgXCJhY2Vfc2VsZWN0aW9uXCIsIHN0eWxlKTtcblxuICAgICAgICB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMucHVzaChvcmllbnRlZFJhbmdlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbk1hcmtlckNvdW50ID0gdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG9yaWVudGVkUmFuZ2U7XG4gICAgfTtcbiAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbk1hcmtlciA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2UubWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlTWFya2VyKHJhbmdlLm1hcmtlcik7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2Vycy5pbmRleE9mKHJhbmdlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb25NYXJrZXJDb3VudCA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2Vycy5sZW5ndGg7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlU2VsZWN0aW9uTWFya2VycyA9IGZ1bmN0aW9uKHJhbmdlcykge1xuICAgICAgICB2YXIgbWFya2VyTGlzdCA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VycztcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAoIXJhbmdlLm1hcmtlcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVNYXJrZXIocmFuZ2UubWFya2VyKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG1hcmtlckxpc3QuaW5kZXhPZihyYW5nZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpXG4gICAgICAgICAgICAgICAgbWFya2VyTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb25NYXJrZXJDb3VudCA9IG1hcmtlckxpc3QubGVuZ3RoO1xuICAgIH07XG5cbiAgICB0aGlzLiRvbkFkZFJhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmFkZFNlbGVjdGlvbk1hcmtlcihlLnJhbmdlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xuICAgIH07XG5cbiAgICB0aGlzLiRvblJlbW92ZVJhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbk1hcmtlcnMoZS5yYW5nZXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgfTtcblxuICAgIHRoaXMuJG9uTXVsdGlTZWxlY3QgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmluTXVsdGlTZWxlY3RNb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmluTXVsdGlTZWxlY3RNb2RlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnNldFN0eWxlKFwiYWNlX211bHRpc2VsZWN0XCIpO1xuICAgICAgICB0aGlzLmtleUJpbmRpbmcuYWRkS2V5Ym9hcmRIYW5kbGVyKGNvbW1hbmRzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuc2V0RGVmYXVsdEhhbmRsZXIoXCJleGVjXCIsIHRoaXMuJG9uTXVsdGlTZWxlY3RFeGVjKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgfTtcblxuICAgIHRoaXMuJG9uU2luZ2xlU2VsZWN0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLm11bHRpU2VsZWN0LmluVmlydHVhbE1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnVuc2V0U3R5bGUoXCJhY2VfbXVsdGlzZWxlY3RcIik7XG4gICAgICAgIHRoaXMua2V5QmluZGluZy5yZW1vdmVLZXlib2FyZEhhbmRsZXIoY29tbWFuZHMua2V5Ym9hcmRIYW5kbGVyKTtcblxuICAgICAgICB0aGlzLmNvbW1hbmRzLnJlbW92ZURlZmF1bHRIYW5kbGVyKFwiZXhlY1wiLCB0aGlzLiRvbk11bHRpU2VsZWN0RXhlYyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcbiAgICAgICAgdGhpcy5fZW1pdChcImNoYW5nZVNlbGVjdGlvblwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kb25NdWx0aVNlbGVjdEV4ZWMgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBjb21tYW5kID0gZS5jb21tYW5kO1xuICAgICAgICB2YXIgZWRpdG9yID0gZS5lZGl0b3I7XG4gICAgICAgIGlmICghZWRpdG9yLm11bHRpU2VsZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb21tYW5kLmV4ZWMoZWRpdG9yLCBlLmFyZ3MgfHwge30pO1xuICAgICAgICAgICAgZWRpdG9yLm11bHRpU2VsZWN0LmFkZFJhbmdlKGVkaXRvci5tdWx0aVNlbGVjdC50b09yaWVudGVkUmFuZ2UoKSk7XG4gICAgICAgICAgICBlZGl0b3IubXVsdGlTZWxlY3QubWVyZ2VPdmVybGFwcGluZ1JhbmdlcygpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24gPT0gXCJmb3JFYWNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVkaXRvci5mb3JFYWNoU2VsZWN0aW9uKGNvbW1hbmQsIGUuYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC5tdWx0aVNlbGVjdEFjdGlvbiA9PSBcImZvckVhY2hMaW5lXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVkaXRvci5mb3JFYWNoU2VsZWN0aW9uKGNvbW1hbmQsIGUuYXJncywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC5tdWx0aVNlbGVjdEFjdGlvbiA9PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICBlZGl0b3IuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tbWFuZC5leGVjKGVkaXRvciwgZS5hcmdzIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24oZWRpdG9yLCBlLmFyZ3MgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTsgXG4gICAgdGhpcy5mb3JFYWNoU2VsZWN0aW9uID0gZnVuY3Rpb24oY21kLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBrZWVwT3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMua2VlcE9yZGVyO1xuICAgICAgICB2YXIgJGJ5TGluZXMgPSBvcHRpb25zID09IHRydWUgfHwgb3B0aW9ucyAmJiBvcHRpb25zLiRieUxpbmVzXG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIHZhciByYW5nZUxpc3QgPSBzZWxlY3Rpb24ucmFuZ2VMaXN0O1xuICAgICAgICB2YXIgcmFuZ2VzID0gKGtlZXBPcmRlciA/IHNlbGVjdGlvbiA6IHJhbmdlTGlzdCkucmFuZ2VzO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGNtZC5leGVjID8gY21kLmV4ZWModGhpcywgYXJncyB8fCB7fSkgOiBjbWQodGhpcywgYXJncyB8fCB7fSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVnID0gc2VsZWN0aW9uLl9ldmVudFJlZ2lzdHJ5O1xuICAgICAgICBzZWxlY3Rpb24uX2V2ZW50UmVnaXN0cnkgPSB7fTtcblxuICAgICAgICB2YXIgdG1wU2VsID0gbmV3IFNlbGVjdGlvbihzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGlmICgkYnlMaW5lcykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiByYW5nZXNbaV0uc3RhcnQucm93ID09IHJhbmdlc1tpIC0gMV0uZW5kLnJvdylcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG1wU2VsLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlc1tpXSk7XG4gICAgICAgICAgICB0bXBTZWwuaW5kZXggPSBpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZXNzaW9uLnNlbGVjdGlvbiA9IHRtcFNlbDtcbiAgICAgICAgICAgIHZhciBjbWRSZXN1bHQgPSBjbWQuZXhlYyA/IGNtZC5leGVjKHRoaXMsIGFyZ3MgfHwge30pIDogY21kKHRoaXMsIGFyZ3MgfHwge30pO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgY21kUmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY21kUmVzdWx0O1xuICAgICAgICAgICAgdG1wU2VsLnRvT3JpZW50ZWRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRtcFNlbC5kZXRhY2goKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlc3Npb24uc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgICAgc2VsZWN0aW9uLl9ldmVudFJlZ2lzdHJ5ID0gcmVnO1xuICAgICAgICBzZWxlY3Rpb24ubWVyZ2VPdmVybGFwcGluZ1JhbmdlcygpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGFuaW0gPSB0aGlzLnJlbmRlcmVyLiRzY3JvbGxBbmltYXRpb247XG4gICAgICAgIHRoaXMub25DdXJzb3JDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICBpZiAoYW5pbSAmJiBhbmltLmZyb20gPT0gYW5pbS50bylcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYW5pbWF0ZVNjcm9sbGluZyhhbmltLmZyb20pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHRoaXMuZXhpdE11bHRpU2VsZWN0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgfHwgdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm11bHRpU2VsZWN0LnRvU2luZ2xlUmFuZ2UoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5pbk11bHRpU2VsZWN0TW9kZSAmJiAhdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5tdWx0aVNlbGVjdC5yYW5nZUxpc3QucmFuZ2VzO1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWYucHVzaCh0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5sID0gdGhpcy5zZXNzaW9uLmdldERvY3VtZW50KCkuZ2V0TmV3TGluZUNoYXJhY3RlcigpO1xuICAgICAgICAgICAgdGV4dCA9IGJ1Zi5qb2luKG5sKTtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAoYnVmLmxlbmd0aCAtIDEpICogbmwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRleHQgPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLiRjaGVja011bHRpc2VsZWN0Q2hhbmdlID0gZnVuY3Rpb24oZSwgYW5jaG9yKSB7XG4gICAgICAgIGlmICh0aGlzLmluTXVsdGlTZWxlY3RNb2RlICYmICF0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMubXVsdGlTZWxlY3QucmFuZ2VzWzBdO1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QuaXNFbXB0eSgpICYmIGFuY2hvciA9PSB0aGlzLm11bHRpU2VsZWN0LmFuY2hvcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcG9zID0gYW5jaG9yID09IHRoaXMubXVsdGlTZWxlY3QuYW5jaG9yXG4gICAgICAgICAgICAgICAgPyByYW5nZS5jdXJzb3IgPT0gcmFuZ2Uuc3RhcnQgPyByYW5nZS5lbmQgOiByYW5nZS5zdGFydFxuICAgICAgICAgICAgICAgIDogcmFuZ2UuY3Vyc29yO1xuICAgICAgICAgICAgaWYgKHBvcy5yb3cgIT0gYW5jaG9yLnJvd1xuICAgICAgICAgICAgICAgIHx8IHRoaXMuc2Vzc2lvbi4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudChwb3Mucm93LCBwb3MuY29sdW1uKS5jb2x1bW4gIT0gYW5jaG9yLmNvbHVtbilcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0LnRvU2luZ2xlUmFuZ2UodGhpcy5tdWx0aVNlbGVjdC50b09yaWVudGVkUmFuZ2UoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZmluZEFsbCA9IGZ1bmN0aW9uKG5lZWRsZSwgb3B0aW9ucywgYWRkaXRpdmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMubmVlZGxlID0gbmVlZGxlIHx8IG9wdGlvbnMubmVlZGxlO1xuICAgICAgICBpZiAob3B0aW9ucy5uZWVkbGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KClcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2VsZWN0aW9uLmdldFdvcmRSYW5nZSgpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgb3B0aW9ucy5uZWVkbGUgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfSAgICBcbiAgICAgICAgdGhpcy4kc2VhcmNoLnNldChvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLiRzZWFyY2guZmluZEFsbCh0aGlzLnNlc3Npb24pO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyArPSAxO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5tdWx0aVNlbGVjdDtcblxuICAgICAgICBpZiAoIWFkZGl0aXZlKVxuICAgICAgICAgICAgc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UocmFuZ2VzWzBdKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOyApXG4gICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2VzW2ldLCB0cnVlKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIHNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VBdFBvaW50KHJhbmdlLnN0YXJ0KSlcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSwgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyAtPSAxO1xuXG4gICAgICAgIHJldHVybiByYW5nZXMubGVuZ3RoO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RNb3JlTGluZXMgPSBmdW5jdGlvbihkaXIsIHNraXApIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XG4gICAgICAgIHZhciBpc0JhY2t3YXJkcyA9IHJhbmdlLmN1cnNvciA9PSByYW5nZS5lbmQ7XG5cbiAgICAgICAgdmFyIHNjcmVlbkxlYWQgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHJhbmdlLmN1cnNvcik7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi4kZGVzaXJlZENvbHVtbilcbiAgICAgICAgICAgIHNjcmVlbkxlYWQuY29sdW1uID0gdGhpcy5zZWxlY3Rpb24uJGRlc2lyZWRDb2x1bW47XG5cbiAgICAgICAgdmFyIGxlYWQgPSB0aGlzLnNlc3Npb24uc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlbkxlYWQucm93ICsgZGlyLCBzY3JlZW5MZWFkLmNvbHVtbik7XG5cbiAgICAgICAgaWYgKCFyYW5nZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBzY3JlZW5BbmNob3IgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKGlzQmFja3dhcmRzID8gcmFuZ2UuZW5kIDogcmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuQW5jaG9yLnJvdyArIGRpciwgc2NyZWVuQW5jaG9yLmNvbHVtbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gbGVhZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgdmFyIG5ld1JhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhsZWFkLCBhbmNob3IpO1xuICAgICAgICAgICAgbmV3UmFuZ2UuY3Vyc29yID0gbmV3UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3UmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGFuY2hvciwgbGVhZCk7XG4gICAgICAgICAgICBuZXdSYW5nZS5jdXJzb3IgPSBuZXdSYW5nZS5lbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdSYW5nZS5kZXNpcmVkQ29sdW1uID0gc2NyZWVuTGVhZC5jb2x1bW47XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaW5NdWx0aVNlbGVjdE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9IHJhbmdlLmN1cnNvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgICAgICAgaWYgKHRvUmVtb3ZlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3Vic3RyYWN0UG9pbnQodG9SZW1vdmUpO1xuICAgIH07XG4gICAgdGhpcy50cmFuc3Bvc2VTZWxlY3Rpb25zID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB2YXIgc2VsID0gc2Vzc2lvbi5tdWx0aVNlbGVjdDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbC5yYW5nZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBhbGxbaV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IHNlc3Npb24uZ2V0V29yZFJhbmdlKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5yb3cgPSB0bXAuc3RhcnQucm93O1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHRtcC5zdGFydC5jb2x1bW47XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IHRtcC5lbmQucm93O1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSB0bXAuZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWwubWVyZ2VPdmVybGFwcGluZ1JhbmdlcygpO1xuXG4gICAgICAgIHZhciB3b3JkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gYWxsLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFsbFtpXTtcbiAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQoc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgd29yZHMudW5zaGlmdCh3b3Jkcy5wb3AoKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdvcmRzLnB1c2god29yZHMuc2hpZnQoKSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBhbGxbaV07XG4gICAgICAgICAgICB2YXIgdG1wID0gcmFuZ2UuY2xvbmUoKTtcbiAgICAgICAgICAgIHNlc3Npb24ucmVwbGFjZShyYW5nZSwgd29yZHNbaV0pO1xuICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gdG1wLnN0YXJ0LnJvdztcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHRtcC5zdGFydC5jb2x1bW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0TW9yZSA9IGZ1bmN0aW9uKGRpciwgc2tpcCwgc3RvcEF0Rmlyc3QpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWwgPSBzZXNzaW9uLm11bHRpU2VsZWN0O1xuXG4gICAgICAgIHZhciByYW5nZSA9IHNlbC50b09yaWVudGVkUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmFuZ2UgPSBzZXNzaW9uLmdldFdvcmRSYW5nZShyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XG4gICAgICAgICAgICByYW5nZS5jdXJzb3IgPSBkaXIgPT0gLTEgPyByYW5nZS5zdGFydCA6IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3QuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgaWYgKHN0b3BBdEZpcnN0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVlZGxlID0gc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgIHZhciBuZXdSYW5nZSA9IGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpO1xuICAgICAgICBpZiAobmV3UmFuZ2UpIHtcbiAgICAgICAgICAgIG5ld1JhbmdlLmN1cnNvciA9IGRpciA9PSAtMSA/IG5ld1JhbmdlLnN0YXJ0IDogbmV3UmFuZ2UuZW5kO1xuICAgICAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi51bmZvbGQobmV3UmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5hZGRSYW5nZShuZXdSYW5nZSk7XG4gICAgICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyAtPSAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhudWxsLCAwLjUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwKVxuICAgICAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5zdWJzdHJhY3RQb2ludChyYW5nZS5jdXJzb3IpO1xuICAgIH07XG4gICAgdGhpcy5hbGlnbkN1cnNvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgICAgIHZhciBzZWwgPSBzZXNzaW9uLm11bHRpU2VsZWN0O1xuICAgICAgICB2YXIgcmFuZ2VzID0gc2VsLnJhbmdlcztcbiAgICAgICAgdmFyIHJvdyA9IC0xO1xuICAgICAgICB2YXIgc2FtZVJvd1JhbmdlcyA9IHJhbmdlcy5maWx0ZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKHIuY3Vyc29yLnJvdyA9PSByb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByb3cgPSByLmN1cnNvci5yb3c7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoIHx8IHNhbWVSb3dSYW5nZXMubGVuZ3RoID09IHJhbmdlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgdmFyIGZyID0gcmFuZ2Uuc3RhcnQucm93LCBsciA9IHJhbmdlLmVuZC5yb3c7XG4gICAgICAgICAgICB2YXIgZ3Vlc3NSYW5nZSA9IGZyID09IGxyO1xuICAgICAgICAgICAgaWYgKGd1ZXNzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGxyKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgvWz06XS8udGVzdChsaW5lKSAmJiArK2xyIDwgbWF4KTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TGluZShmcik7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoL1s9Ol0vLnRlc3QobGluZSkgJiYgLS1mciA+IDApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChmciA8IDApIGZyID0gMDtcbiAgICAgICAgICAgICAgICBpZiAobHIgPj0gbWF4KSBsciA9IG1heCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLnNlc3Npb24uZG9jLnJlbW92ZUxpbmVzKGZyLCBscik7XG4gICAgICAgICAgICBsaW5lcyA9IHRoaXMuJHJlQWxpZ25UZXh0KGxpbmVzLCBndWVzc1JhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kb2MuaW5zZXJ0KHtyb3c6IGZyLCBjb2x1bW46IDB9LCBsaW5lcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoIWd1ZXNzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYW1lUm93UmFuZ2VzLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHNlbC5zdWJzdHJhY3RQb2ludChyLmN1cnNvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG1heENvbCA9IDA7XG4gICAgICAgICAgICB2YXIgbWluU3BhY2UgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHZhciBzcGFjZU9mZnNldHMgPSByYW5nZXMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHIuY3Vyc29yO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHAucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VPZmZzZXQgPSBsaW5lLnN1YnN0cihwLmNvbHVtbikuc2VhcmNoKC9cXFMvZyk7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzcGFjZU9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAocC5jb2x1bW4gPiBtYXhDb2wpXG4gICAgICAgICAgICAgICAgICAgIG1heENvbCA9IHAuY29sdW1uO1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZU9mZnNldCA8IG1pblNwYWNlKVxuICAgICAgICAgICAgICAgICAgICBtaW5TcGFjZSA9IHNwYWNlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGFjZU9mZnNldDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24ociwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gci5jdXJzb3I7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBtYXhDb2wgLSBwLmNvbHVtbjtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHNwYWNlT2Zmc2V0c1tpXSAtIG1pblNwYWNlO1xuICAgICAgICAgICAgICAgIGlmIChsID4gZClcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5pbnNlcnQocCwgbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIGwgLSBkKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZShuZXcgUmFuZ2UocC5yb3csIHAuY29sdW1uLCBwLnJvdywgcC5jb2x1bW4gLSBsICsgZCkpO1xuXG4gICAgICAgICAgICAgICAgci5zdGFydC5jb2x1bW4gPSByLmVuZC5jb2x1bW4gPSBtYXhDb2w7XG4gICAgICAgICAgICAgICAgci5zdGFydC5yb3cgPSByLmVuZC5yb3cgPSBwLnJvdztcbiAgICAgICAgICAgICAgICByLmN1cnNvciA9IHIuZW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWwuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2VzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy4kcmVBbGlnblRleHQgPSBmdW5jdGlvbihsaW5lcywgZm9yY2VMZWZ0KSB7XG4gICAgICAgIHZhciBpc0xlZnRBbGlnbmVkID0gdHJ1ZSwgaXNSaWdodEFsaWduZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc3RhcnRXLCB0ZXh0VywgZW5kVztcblxuICAgICAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvKFxccyopKC4qPykoXFxzKikoWz06XS4qKS8pO1xuICAgICAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgICAgIHJldHVybiBbbGluZV07XG5cbiAgICAgICAgICAgIGlmIChzdGFydFcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VyA9IG1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRleHRXID0gbVsyXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZW5kVyA9IG1bM10ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhcnRXICsgdGV4dFcgKyBlbmRXICE9IG1bMV0ubGVuZ3RoICsgbVsyXS5sZW5ndGggKyBtWzNdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpc1JpZ2h0QWxpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0VyAhPSBtWzFdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBpc0xlZnRBbGlnbmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChzdGFydFcgPiBtWzFdLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzdGFydFcgPSBtWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0ZXh0VyA8IG1bMl0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRleHRXID0gbVsyXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kVyA+IG1bM10ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVuZFcgPSBtWzNdLmxlbmd0aDtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0pLm1hcChmb3JjZUxlZnQgPyBhbGlnbkxlZnQgOlxuICAgICAgICAgICAgaXNMZWZ0QWxpZ25lZCA/IGlzUmlnaHRBbGlnbmVkID8gYWxpZ25SaWdodCA6IGFsaWduTGVmdCA6IHVuQWxpZ24pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNwYWNlcyhuKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZy5zdHJpbmdSZXBlYXQoXCIgXCIsIG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWxpZ25MZWZ0KG0pIHtcbiAgICAgICAgICAgIHJldHVybiAhbVsyXSA/IG1bMF0gOiBzcGFjZXMoc3RhcnRXKSArIG1bMl1cbiAgICAgICAgICAgICAgICArIHNwYWNlcyh0ZXh0VyAtIG1bMl0ubGVuZ3RoICsgZW5kVylcbiAgICAgICAgICAgICAgICArIG1bNF0ucmVwbGFjZSgvXihbPTpdKVxccysvLCBcIiQxIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbGlnblJpZ2h0KG0pIHtcbiAgICAgICAgICAgIHJldHVybiAhbVsyXSA/IG1bMF0gOiBzcGFjZXMoc3RhcnRXICsgdGV4dFcgLSBtWzJdLmxlbmd0aCkgKyBtWzJdXG4gICAgICAgICAgICAgICAgKyBzcGFjZXMoZW5kVywgXCIgXCIpXG4gICAgICAgICAgICAgICAgKyBtWzRdLnJlcGxhY2UoL14oWz06XSlcXHMrLywgXCIkMSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdW5BbGlnbihtKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1bMl0gPyBtWzBdIDogc3BhY2VzKHN0YXJ0VykgKyBtWzJdXG4gICAgICAgICAgICAgICAgKyBzcGFjZXMoZW5kVylcbiAgICAgICAgICAgICAgICArIG1bNF0ucmVwbGFjZSgvXihbPTpdKVxccysvLCBcIiQxIFwiKTtcbiAgICAgICAgfVxuICAgIH07XG59KS5jYWxsKEVkaXRvci5wcm90b3R5cGUpO1xuXG5cbmZ1bmN0aW9uIGlzU2FtZVBvaW50KHAxLCBwMikge1xuICAgIHJldHVybiBwMS5yb3cgPT0gcDIucm93ICYmIHAxLmNvbHVtbiA9PSBwMi5jb2x1bW47XG59XG5leHBvcnRzLm9uU2Vzc2lvbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IGUuc2Vzc2lvbjtcbiAgICBpZiAoc2Vzc2lvbiAmJiAhc2Vzc2lvbi5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzID0gW107XG4gICAgICAgIHNlc3Npb24uc2VsZWN0aW9uLiRpbml0UmFuZ2VMaXN0KCk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QgPSBzZXNzaW9uLnNlbGVjdGlvbjtcbiAgICB9XG4gICAgdGhpcy5tdWx0aVNlbGVjdCA9IHNlc3Npb24gJiYgc2Vzc2lvbi5tdWx0aVNlbGVjdDtcblxuICAgIHZhciBvbGRTZXNzaW9uID0gZS5vbGRTZXNzaW9uO1xuICAgIGlmIChvbGRTZXNzaW9uKSB7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3Qub2ZmKFwiYWRkUmFuZ2VcIiwgdGhpcy4kb25BZGRSYW5nZSk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3Qub2ZmKFwicmVtb3ZlUmFuZ2VcIiwgdGhpcy4kb25SZW1vdmVSYW5nZSk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3Qub2ZmKFwibXVsdGlTZWxlY3RcIiwgdGhpcy4kb25NdWx0aVNlbGVjdCk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3Qub2ZmKFwic2luZ2xlU2VsZWN0XCIsIHRoaXMuJG9uU2luZ2xlU2VsZWN0KTtcbiAgICAgICAgb2xkU2Vzc2lvbi5tdWx0aVNlbGVjdC5sZWFkLm9mZihcImNoYW5nZVwiLCAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XG4gICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3QuYW5jaG9yLm9mZihcImNoYW5nZVwiLCAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcImFkZFJhbmdlXCIsIHRoaXMuJG9uQWRkUmFuZ2UpO1xuICAgICAgICBzZXNzaW9uLm11bHRpU2VsZWN0Lm9uKFwicmVtb3ZlUmFuZ2VcIiwgdGhpcy4kb25SZW1vdmVSYW5nZSk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3Qub24oXCJtdWx0aVNlbGVjdFwiLCB0aGlzLiRvbk11bHRpU2VsZWN0KTtcbiAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcInNpbmdsZVNlbGVjdFwiLCB0aGlzLiRvblNpbmdsZVNlbGVjdCk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QubGVhZC5vbihcImNoYW5nZVwiLCAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XG4gICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QuYW5jaG9yLm9uKFwiY2hhbmdlXCIsICB0aGlzLiRjaGVja011bHRpc2VsZWN0Q2hhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbiAmJiB0aGlzLmluTXVsdGlTZWxlY3RNb2RlICE9IHNlc3Npb24uc2VsZWN0aW9uLmluTXVsdGlTZWxlY3RNb2RlKSB7XG4gICAgICAgIGlmIChzZXNzaW9uLnNlbGVjdGlvbi5pbk11bHRpU2VsZWN0TW9kZSlcbiAgICAgICAgICAgIHRoaXMuJG9uTXVsdGlTZWxlY3QoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4kb25TaW5nbGVTZWxlY3QoKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gTXVsdGlTZWxlY3QoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci4kbXVsdGlzZWxlY3RPblNlc3Npb25DaGFuZ2UpXG4gICAgICAgIHJldHVybjtcbiAgICBlZGl0b3IuJG9uQWRkUmFuZ2UgPSBlZGl0b3IuJG9uQWRkUmFuZ2UuYmluZChlZGl0b3IpO1xuICAgIGVkaXRvci4kb25SZW1vdmVSYW5nZSA9IGVkaXRvci4kb25SZW1vdmVSYW5nZS5iaW5kKGVkaXRvcik7XG4gICAgZWRpdG9yLiRvbk11bHRpU2VsZWN0ID0gZWRpdG9yLiRvbk11bHRpU2VsZWN0LmJpbmQoZWRpdG9yKTtcbiAgICBlZGl0b3IuJG9uU2luZ2xlU2VsZWN0ID0gZWRpdG9yLiRvblNpbmdsZVNlbGVjdC5iaW5kKGVkaXRvcik7XG4gICAgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSA9IGV4cG9ydHMub25TZXNzaW9uQ2hhbmdlLmJpbmQoZWRpdG9yKTtcbiAgICBlZGl0b3IuJGNoZWNrTXVsdGlzZWxlY3RDaGFuZ2UgPSBlZGl0b3IuJGNoZWNrTXVsdGlzZWxlY3RDaGFuZ2UuYmluZChlZGl0b3IpO1xuXG4gICAgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZShlZGl0b3IpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVNlc3Npb25cIiwgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSk7XG5cbiAgICBlZGl0b3Iub24oXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24pO1xuICAgIGVkaXRvci5jb21tYW5kcy5hZGRDb21tYW5kcyhjb21tYW5kcy5kZWZhdWx0Q29tbWFuZHMpO1xuXG4gICAgYWRkQWx0Q3Vyc29yTGlzdGVuZXJzKGVkaXRvcik7XG59XG5cbmZ1bmN0aW9uIGFkZEFsdEN1cnNvckxpc3RlbmVycyhlZGl0b3Ipe1xuICAgIHZhciBlbCA9IGVkaXRvci50ZXh0SW5wdXQuZ2V0RWxlbWVudCgpO1xuICAgIHZhciBhbHRDdXJzb3IgPSBmYWxzZTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcihlbCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxOCAmJiAhKGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgICAgICAgIGlmICghYWx0Q3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNldE1vdXNlQ3Vyc29yKFwiY3Jvc3NoYWlyXCIpO1xuICAgICAgICAgICAgICAgIGFsdEN1cnNvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWx0Q3Vyc29yKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBldmVudC5hZGRMaXN0ZW5lcihlbCwgXCJrZXl1cFwiLCByZXNldCk7XG4gICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFwiYmx1clwiLCByZXNldCk7XG4gICAgZnVuY3Rpb24gcmVzZXQoZSkge1xuICAgICAgICBpZiAoYWx0Q3Vyc29yKSB7XG4gICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2V0TW91c2VDdXJzb3IoXCJcIik7XG4gICAgICAgICAgICBhbHRDdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5NdWx0aVNlbGVjdCA9IE11bHRpU2VsZWN0O1xuXG5cbmFjZXF1aXJlKFwiLi9jb25maWdcIikuZGVmaW5lT3B0aW9ucyhFZGl0b3IucHJvdG90eXBlLCBcImVkaXRvclwiLCB7XG4gICAgZW5hYmxlTXVsdGlzZWxlY3Q6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIE11bHRpU2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMub24oXCJjaGFuZ2VTZXNzaW9uXCIsIHRoaXMuJG11bHRpc2VsZWN0T25TZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJjaGFuZ2VTZXNzaW9uXCIsIHRoaXMuJG11bHRpc2VsZWN0T25TZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfVxufSk7XG5cblxuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb2RlL2ZvbGRpbmcvZm9sZF9tb2RlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmFuZ2UgPSBhY2VxdWlyZShcIi4uLy4uL3JhbmdlXCIpLlJhbmdlO1xuXG52YXIgRm9sZE1vZGUgPSBleHBvcnRzLkZvbGRNb2RlID0gZnVuY3Rpb24oKSB7fTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5mb2xkaW5nU3RhcnRNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMuZ2V0Rm9sZFdpZGdldCA9IGZ1bmN0aW9uKHNlc3Npb24sIGZvbGRTdHlsZSwgcm93KSB7XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgIGlmICh0aGlzLmZvbGRpbmdTdGFydE1hcmtlci50ZXN0KGxpbmUpKVxuICAgICAgICAgICAgcmV0dXJuIFwic3RhcnRcIjtcbiAgICAgICAgaWYgKGZvbGRTdHlsZSA9PSBcIm1hcmtiZWdpbmVuZFwiXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5mb2xkaW5nU3RvcE1hcmtlclxuICAgICAgICAgICAgICAgICYmIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIudGVzdChsaW5lKSlcbiAgICAgICAgICAgIHJldHVybiBcImVuZFwiO1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2UgPSBmdW5jdGlvbihzZXNzaW9uLCBmb2xkU3R5bGUsIHJvdykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5pbmRlbnRhdGlvbkJsb2NrID0gZnVuY3Rpb24oc2Vzc2lvbiwgcm93LCBjb2x1bW4pIHtcbiAgICAgICAgdmFyIHJlID0gL1xcUy87XG4gICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBzdGFydExldmVsID0gbGluZS5zZWFyY2gocmUpO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBjb2x1bW4gfHwgbGluZS5sZW5ndGg7XG4gICAgICAgIHZhciBtYXhSb3cgPSBzZXNzaW9uLmdldExlbmd0aCgpO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSByb3c7XG4gICAgICAgIHZhciBlbmRSb3cgPSByb3c7XG5cbiAgICAgICAgd2hpbGUgKCsrcm93IDwgbWF4Um93KSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBzZXNzaW9uLmdldExpbmUocm93KS5zZWFyY2gocmUpO1xuXG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gLTEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChsZXZlbCA8PSBzdGFydExldmVsKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBlbmRSb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kUm93ID4gc3RhcnRSb3cpIHtcbiAgICAgICAgICAgIHZhciBlbmRDb2x1bW4gPSBzZXNzaW9uLmdldExpbmUoZW5kUm93KS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0Um93LCBzdGFydENvbHVtbiwgZW5kUm93LCBlbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub3BlbmluZ0JyYWNrZXRCbG9jayA9IGZ1bmN0aW9uKHNlc3Npb24sIGJyYWNrZXQsIHJvdywgY29sdW1uLCB0eXBlUmUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0ge3Jvdzogcm93LCBjb2x1bW46IGNvbHVtbiArIDF9O1xuICAgICAgICB2YXIgZW5kID0gc2Vzc2lvbi4kZmluZENsb3NpbmdCcmFja2V0KGJyYWNrZXQsIHN0YXJ0LCB0eXBlUmUpO1xuICAgICAgICBpZiAoIWVuZClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgZncgPSBzZXNzaW9uLmZvbGRXaWRnZXRzW2VuZC5yb3ddO1xuICAgICAgICBpZiAoZncgPT0gbnVsbClcbiAgICAgICAgICAgIGZ3ID0gc2Vzc2lvbi5nZXRGb2xkV2lkZ2V0KGVuZC5yb3cpO1xuXG4gICAgICAgIGlmIChmdyA9PSBcInN0YXJ0XCIgJiYgZW5kLnJvdyA+IHN0YXJ0LnJvdykge1xuICAgICAgICAgICAgZW5kLnJvdyAtLTtcbiAgICAgICAgICAgIGVuZC5jb2x1bW4gPSBzZXNzaW9uLmdldExpbmUoZW5kLnJvdykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0LCBlbmQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsb3NpbmdCcmFja2V0QmxvY2sgPSBmdW5jdGlvbihzZXNzaW9uLCBicmFja2V0LCByb3csIGNvbHVtbiwgdHlwZVJlKSB7XG4gICAgICAgIHZhciBlbmQgPSB7cm93OiByb3csIGNvbHVtbjogY29sdW1ufTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KGJyYWNrZXQsIGVuZCk7XG5cbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBzdGFydC5jb2x1bW4rKztcbiAgICAgICAgZW5kLmNvbHVtbi0tO1xuXG4gICAgICAgIHJldHVybiAgUmFuZ2UuZnJvbVBvaW50cyhzdGFydCwgZW5kKTtcbiAgICB9O1xufSkuY2FsbChGb2xkTW9kZS5wcm90b3R5cGUpO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS90aGVtZS90ZXh0bWF0ZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kb21cIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLmlzRGFyayA9IGZhbHNlO1xuZXhwb3J0cy5jc3NDbGFzcyA9IFwiYWNlLXRtXCI7XG5leHBvcnRzLmNzc1RleHQgPSBcIi5hY2UtdG0gLmFjZV9ndXR0ZXIge1xcXG5iYWNrZ3JvdW5kOiAjZjBmMGYwO1xcXG5jb2xvcjogIzMzMztcXFxufVxcXG4uYWNlLXRtIC5hY2VfcHJpbnQtbWFyZ2luIHtcXFxud2lkdGg6IDFweDtcXFxuYmFja2dyb3VuZDogI2U4ZThlODtcXFxufVxcXG4uYWNlLXRtIC5hY2VfZm9sZCB7XFxcbmJhY2tncm91bmQtY29sb3I6ICM2QjcyRTY7XFxcbn1cXFxuLmFjZS10bSB7XFxcbmJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxcbmNvbG9yOiBibGFjaztcXFxufVxcXG4uYWNlLXRtIC5hY2VfY3Vyc29yIHtcXFxuY29sb3I6IGJsYWNrO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9pbnZpc2libGUge1xcXG5jb2xvcjogcmdiKDE5MSwgMTkxLCAxOTEpO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9zdG9yYWdlLFxcXG4uYWNlLXRtIC5hY2Vfa2V5d29yZCB7XFxcbmNvbG9yOiBibHVlO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9jb25zdGFudCB7XFxcbmNvbG9yOiByZ2IoMTk3LCA2LCAxMSk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2NvbnN0YW50LmFjZV9idWlsZGluIHtcXFxuY29sb3I6IHJnYig4OCwgNzIsIDI0Nik7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2NvbnN0YW50LmFjZV9sYW5ndWFnZSB7XFxcbmNvbG9yOiByZ2IoODgsIDkyLCAyNDYpO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9jb25zdGFudC5hY2VfbGlicmFyeSB7XFxcbmNvbG9yOiByZ2IoNiwgMTUwLCAxNCk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2ludmFsaWQge1xcXG5iYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMCwgMCwgMC4xKTtcXFxuY29sb3I6IHJlZDtcXFxufVxcXG4uYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfZnVuY3Rpb24ge1xcXG5jb2xvcjogcmdiKDYwLCA3NiwgMTE0KTtcXFxufVxcXG4uYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfY29uc3RhbnQge1xcXG5jb2xvcjogcmdiKDYsIDE1MCwgMTQpO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9zdXBwb3J0LmFjZV90eXBlLFxcXG4uYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfY2xhc3Mge1xcXG5jb2xvcjogcmdiKDEwOSwgMTIxLCAyMjIpO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9rZXl3b3JkLmFjZV9vcGVyYXRvciB7XFxcbmNvbG9yOiByZ2IoMTA0LCAxMTgsIDEzNSk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX3N0cmluZyB7XFxcbmNvbG9yOiByZ2IoMywgMTA2LCA3KTtcXFxufVxcXG4uYWNlLXRtIC5hY2VfY29tbWVudCB7XFxcbmNvbG9yOiByZ2IoNzYsIDEzNiwgMTA3KTtcXFxufVxcXG4uYWNlLXRtIC5hY2VfY29tbWVudC5hY2VfZG9jIHtcXFxuY29sb3I6IHJnYigwLCAxMDIsIDI1NSk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2NvbW1lbnQuYWNlX2RvYy5hY2VfdGFnIHtcXFxuY29sb3I6IHJnYigxMjgsIDE1OSwgMTkxKTtcXFxufVxcXG4uYWNlLXRtIC5hY2VfY29uc3RhbnQuYWNlX251bWVyaWMge1xcXG5jb2xvcjogcmdiKDAsIDAsIDIwNSk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX3ZhcmlhYmxlIHtcXFxuY29sb3I6IHJnYig0OSwgMTMyLCAxNDkpO1xcXG59XFxcbi5hY2UtdG0gLmFjZV94bWwtcGUge1xcXG5jb2xvcjogcmdiKDEwNCwgMTA0LCA5MSk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2VudGl0eS5hY2VfbmFtZS5hY2VfZnVuY3Rpb24ge1xcXG5jb2xvcjogIzAwMDBBMjtcXFxufVxcXG4uYWNlLXRtIC5hY2VfaGVhZGluZyB7XFxcbmNvbG9yOiByZ2IoMTIsIDcsIDI1NSk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2xpc3Qge1xcXG5jb2xvcjpyZ2IoMTg1LCA2LCAxNDQpO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9tZXRhLmFjZV90YWcge1xcXG5jb2xvcjpyZ2IoMCwgMjIsIDE0Mik7XFxcbn1cXFxuLmFjZS10bSAuYWNlX3N0cmluZy5hY2VfcmVnZXgge1xcXG5jb2xvcjogcmdiKDI1NSwgMCwgMClcXFxufVxcXG4uYWNlLXRtIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0aW9uIHtcXFxuYmFja2dyb3VuZDogcmdiKDE4MSwgMjEzLCAyNTUpO1xcXG59XFxcbi5hY2UtdG0uYWNlX211bHRpc2VsZWN0IC5hY2Vfc2VsZWN0aW9uLmFjZV9zdGFydCB7XFxcbmJveC1zaGFkb3c6IDAgMCAzcHggMHB4IHdoaXRlO1xcXG5ib3JkZXItcmFkaXVzOiAycHg7XFxcbn1cXFxuLmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX3N0ZXAge1xcXG5iYWNrZ3JvdW5kOiByZ2IoMjUyLCAyNTUsIDApO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zdGFjayB7XFxcbmJhY2tncm91bmQ6IHJnYigxNjQsIDIyOSwgMTAxKTtcXFxufVxcXG4uYWNlLXRtIC5hY2VfbWFya2VyLWxheWVyIC5hY2VfYnJhY2tldCB7XFxcbm1hcmdpbjogLTFweCAwIDAgLTFweDtcXFxuYm9yZGVyOiAxcHggc29saWQgcmdiKDE5MiwgMTkyLCAxOTIpO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9hY3RpdmUtbGluZSB7XFxcbmJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNyk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2d1dHRlci1hY3RpdmUtbGluZSB7XFxcbmJhY2tncm91bmQtY29sb3IgOiAjZGNkY2RjO1xcXG59XFxcbi5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zZWxlY3RlZC13b3JkIHtcXFxuYmFja2dyb3VuZDogcmdiKDI1MCwgMjUwLCAyNTUpO1xcXG5ib3JkZXI6IDFweCBzb2xpZCByZ2IoMjAwLCAyMDAsIDI1MCk7XFxcbn1cXFxuLmFjZS10bSAuYWNlX2luZGVudC1ndWlkZSB7XFxcbmJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFDQ0FZQUFBQ1pnYlluQUFBQUUwbEVRVlFJbVdQNC8vLy9mNGJMbHkvL0J3QW1WZ2QxL3cxMS9nQUFBQUJKUlU1RXJrSmdnZz09XFxcIikgcmlnaHQgcmVwZWF0LXk7XFxcbn1cXFxuXCI7XG5cbnZhciBkb20gPSBhY2VxdWlyZShcIi4uL2xpYi9kb21cIik7XG5kb20uaW1wb3J0Q3NzU3RyaW5nKGV4cG9ydHMuY3NzVGV4dCwgZXhwb3J0cy5jc3NDbGFzcyk7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9saW5lX3dpZGdldHNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL3JhbmdlXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi9saWIvb29wXCIpO1xudmFyIGRvbSA9IGFjZXF1aXJlKFwiLi9saWIvZG9tXCIpO1xudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xuXG5cbmZ1bmN0aW9uIExpbmVXaWRnZXRzKHNlc3Npb24pIHtcbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuc2Vzc2lvbi53aWRnZXRNYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLnNlc3Npb24uZ2V0Um93TGVuZ3RoID0gdGhpcy5nZXRSb3dMZW5ndGg7XG4gICAgdGhpcy5zZXNzaW9uLiRnZXRXaWRnZXRTY3JlZW5MZW5ndGggPSB0aGlzLiRnZXRXaWRnZXRTY3JlZW5MZW5ndGg7XG4gICAgdGhpcy51cGRhdGVPbkNoYW5nZSA9IHRoaXMudXBkYXRlT25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbmRlcldpZGdldHMgPSB0aGlzLnJlbmRlcldpZGdldHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1lYXN1cmVXaWRnZXRzID0gdGhpcy5tZWFzdXJlV2lkZ2V0cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHMgPSBbXTtcbiAgICB0aGlzLiRvbkNoYW5nZUVkaXRvciA9IHRoaXMuJG9uQ2hhbmdlRWRpdG9yLmJpbmQodGhpcyk7XG4gICAgXG4gICAgdGhpcy5zZXNzaW9uLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlT25DaGFuZ2UpO1xuICAgIHRoaXMuc2Vzc2lvbi5vbihcImNoYW5nZUVkaXRvclwiLCB0aGlzLiRvbkNoYW5nZUVkaXRvcik7XG59XG5cbihmdW5jdGlvbigpIHtcbiAgICB0aGlzLmdldFJvd0xlbmd0aCA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHMpXG4gICAgICAgICAgICBoID0gdGhpcy5saW5lV2lkZ2V0c1tyb3ddICYmIHRoaXMubGluZVdpZGdldHNbcm93XS5yb3dDb3VudCB8fCAwO1xuICAgICAgICBlbHNlIFxuICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgIGlmICghdGhpcy4kdXNlV3JhcE1vZGUgfHwgIXRoaXMuJHdyYXBEYXRhW3Jvd10pIHtcbiAgICAgICAgICAgIHJldHVybiAxICsgaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiR3cmFwRGF0YVtyb3ddLmxlbmd0aCArIDEgKyBoO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuJGdldFdpZGdldFNjcmVlbkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NyZWVuUm93cyA9IDA7XG4gICAgICAgIHRoaXMubGluZVdpZGdldHMuZm9yRWFjaChmdW5jdGlvbih3KXtcbiAgICAgICAgICAgIGlmICh3ICYmIHcucm93Q291bnQpXG4gICAgICAgICAgICAgICAgc2NyZWVuUm93cyArPXcucm93Q291bnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2NyZWVuUm93cztcbiAgICB9OyAgICBcbiAgICBcbiAgICB0aGlzLiRvbkNoYW5nZUVkaXRvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5hdHRhY2goZS5lZGl0b3IpO1xuICAgIH07XG5cbiAgICB0aGlzLmF0dGFjaCA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICBpZiAoZWRpdG9yICAmJiBlZGl0b3Iud2lkZ2V0TWFuYWdlciAmJiBlZGl0b3Iud2lkZ2V0TWFuYWdlciAhPSB0aGlzKVxuICAgICAgICAgICAgZWRpdG9yLndpZGdldE1hbmFnZXIuZGV0YWNoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yID09IGVkaXRvcilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgXG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci53aWRnZXRNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5vbihcImJlZm9yZVJlbmRlclwiLCB0aGlzLm1lYXN1cmVXaWRnZXRzKTtcbiAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5vbihcImFmdGVyUmVuZGVyXCIsIHRoaXMucmVuZGVyV2lkZ2V0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGlmICghZWRpdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBudWxsO1xuICAgICAgICBlZGl0b3Iud2lkZ2V0TWFuYWdlciA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICBlZGl0b3IucmVuZGVyZXIub2ZmKFwiYmVmb3JlUmVuZGVyXCIsIHRoaXMubWVhc3VyZVdpZGdldHMpO1xuICAgICAgICBlZGl0b3IucmVuZGVyZXIub2ZmKFwiYWZ0ZXJSZW5kZXJcIiwgdGhpcy5yZW5kZXJXaWRnZXRzKTtcbiAgICAgICAgdmFyIGxpbmVXaWRnZXRzID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzO1xuICAgICAgICBsaW5lV2lkZ2V0cyAmJiBsaW5lV2lkZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgIGlmICh3ICYmIHcuZWwgJiYgdy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdy5faW5Eb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHcuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3LmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlT25DaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBsaW5lV2lkZ2V0cyA9IHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cztcbiAgICAgICAgaWYgKCFsaW5lV2lkZ2V0cykgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgIHZhciBkZWx0YSA9IGUuZGF0YTtcbiAgICAgICAgdmFyIHJhbmdlID0gZGVsdGEucmFuZ2U7XG4gICAgICAgIHZhciBzdGFydFJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcbiAgICAgICAgdmFyIGxlbiA9IHJhbmdlLmVuZC5yb3cgLSBzdGFydFJvdztcblxuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFwicmVtb3ZlVGV4dFwiIHx8IGRlbHRhLmFjdGlvbiA9PSBcInJlbW92ZUxpbmVzXCIpIHtcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gbGluZVdpZGdldHMuc3BsaWNlKHN0YXJ0Um93ICsgMSwgbGVuKTtcbiAgICAgICAgICAgIHJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICAgICAgICAgICAgdyAmJiB0aGlzLnJlbW92ZUxpbmVXaWRnZXQodyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd3MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoc3RhcnRSb3csIDApO1xuICAgICAgICAgICAgbGluZVdpZGdldHMuc3BsaWNlLmFwcGx5KGxpbmVXaWRnZXRzLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd3MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy4kdXBkYXRlUm93cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XG4gICAgICAgIGlmICghbGluZVdpZGdldHMpIHJldHVybjtcbiAgICAgICAgdmFyIG5vV2lkZ2V0cyA9IHRydWU7XG4gICAgICAgIGxpbmVXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24odywgaSkge1xuICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICBub1dpZGdldHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3LnJvdyA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9XaWRnZXRzKVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRMaW5lV2lkZ2V0ID0gZnVuY3Rpb24odykge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cylcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cyA9IG5ldyBBcnJheSh0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCkpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW3cucm93XSA9IHc7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmVkaXRvci5yZW5kZXJlcjtcbiAgICAgICAgaWYgKHcuaHRtbCAmJiAhdy5lbCkge1xuICAgICAgICAgICAgdy5lbCA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdy5lbC5pbm5lckhUTUwgPSB3Lmh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcuZWwpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh3LmVsLCBcImFjZV9saW5lV2lkZ2V0Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgdy5lbC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIHcuZWwuc3R5bGUuekluZGV4ID0gNTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh3LmVsKTtcbiAgICAgICAgICAgIHcuX2luRG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXcuY292ZXJHdXR0ZXIpIHtcbiAgICAgICAgICAgIHcuZWwuc3R5bGUuekluZGV4ID0gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXcucGl4ZWxIZWlnaHQpIHtcbiAgICAgICAgICAgIHcucGl4ZWxIZWlnaHQgPSB3LmVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAody5yb3dDb3VudCA9PSBudWxsKVxuICAgICAgICAgICAgdy5yb3dDb3VudCA9IHcucGl4ZWxIZWlnaHQgLyByZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlRm9sZFwiLCB7ZGF0YTp7c3RhcnQ6e3Jvdzogdy5yb3d9fX0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy4kdXBkYXRlUm93cygpO1xuICAgICAgICB0aGlzLnJlbmRlcldpZGdldHMobnVsbCwgcmVuZGVyZXIpO1xuICAgICAgICByZXR1cm4gdztcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVtb3ZlTGluZVdpZGdldCA9IGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgdy5faW5Eb2N1bWVudCA9IGZhbHNlO1xuICAgICAgICBpZiAody5lbCAmJiB3LmVsLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3LmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQody5lbCk7XG4gICAgICAgIGlmICh3LmVkaXRvciAmJiB3LmVkaXRvci5kZXN0cm95KSB0cnkge1xuICAgICAgICAgICAgdy5lZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICB9IGNhdGNoKGUpe31cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cylcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0c1t3LnJvd10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5fZW1pdChcImNoYW5nZUZvbGRcIiwge2RhdGE6e3N0YXJ0Ontyb3c6IHcucm93fX19KTtcbiAgICAgICAgdGhpcy4kdXBkYXRlUm93cygpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5vbldpZGdldENoYW5nZWQgPSBmdW5jdGlvbih3KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHMucHVzaCh3KTtcbiAgICAgICAgdGhpcy5lZGl0b3IgJiYgdGhpcy5lZGl0b3IucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5tZWFzdXJlV2lkZ2V0cyA9IGZ1bmN0aW9uKGUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkV2lkZ2V0cyA9IHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHM7XG4gICAgICAgIHZhciBjb25maWcgPSByZW5kZXJlci5sYXllckNvbmZpZztcbiAgICAgICAgXG4gICAgICAgIGlmICghY2hhbmdlZFdpZGdldHMgfHwgIWNoYW5nZWRXaWRnZXRzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlZFdpZGdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gY2hhbmdlZFdpZGdldHNbaV07XG4gICAgICAgICAgICBpZiAoIXcuX2luRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB3Ll9pbkRvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jb250YWluZXIuYXBwZW5kQ2hpbGQody5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHcuaCA9IHcuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXcuZml4ZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHcudyA9IHcuZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdy5zY3JlZW5XaWR0aCA9IE1hdGguY2VpbCh3LncgLyBjb25maWcuY2hhcmFjdGVyV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSB3LmggLyBjb25maWcubGluZUhlaWdodDtcbiAgICAgICAgICAgIGlmICh3LmNvdmVyTGluZSkge1xuICAgICAgICAgICAgICAgIHJvd0NvdW50IC09IHRoaXMuc2Vzc2lvbi5nZXRSb3dMaW5lQ291bnQody5yb3cpO1xuICAgICAgICAgICAgICAgIGlmIChyb3dDb3VudCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3LnJvd0NvdW50ICE9IHJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdy5yb3dDb3VudCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgICAgIGlmICh3LnJvdyA8IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdy5yb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAhPSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlRm9sZFwiLCB7ZGF0YTp7c3RhcnQ6e3JvdzogbWlufX19KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0V2lkdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHMgPSBbXTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVuZGVyV2lkZ2V0cyA9IGZ1bmN0aW9uKGUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBjb25maWcgPSByZW5kZXJlci5sYXllckNvbmZpZztcbiAgICAgICAgdmFyIGxpbmVXaWRnZXRzID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzO1xuICAgICAgICBpZiAoIWxpbmVXaWRnZXRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1pbih0aGlzLmZpcnN0Um93LCBjb25maWcuZmlyc3RSb3cpO1xuICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWF4KHRoaXMubGFzdFJvdywgY29uZmlnLmxhc3RSb3csIGxpbmVXaWRnZXRzLmxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICB3aGlsZSAoZmlyc3QgPiAwICYmICFsaW5lV2lkZ2V0c1tmaXJzdF0pXG4gICAgICAgICAgICBmaXJzdC0tO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5maXJzdFJvdyA9IGNvbmZpZy5maXJzdFJvdztcbiAgICAgICAgdGhpcy5sYXN0Um93ID0gY29uZmlnLmxhc3RSb3c7XG5cbiAgICAgICAgcmVuZGVyZXIuJGN1cnNvckxheWVyLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdmFyIHcgPSBsaW5lV2lkZ2V0c1tpXTtcbiAgICAgICAgICAgIGlmICghdyB8fCAhdy5lbCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICghdy5faW5Eb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHcuX2luRG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh3LmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3AgPSByZW5kZXJlci4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbih7cm93OiBpLCBjb2x1bW46MH0sIHRydWUpLnRvcDtcbiAgICAgICAgICAgIGlmICghdy5jb3ZlckxpbmUpXG4gICAgICAgICAgICAgICAgdG9wICs9IGNvbmZpZy5saW5lSGVpZ2h0ICogdGhpcy5zZXNzaW9uLmdldFJvd0xpbmVDb3VudCh3LnJvdyk7XG4gICAgICAgICAgICB3LmVsLnN0eWxlLnRvcCA9IHRvcCAtIGNvbmZpZy5vZmZzZXQgKyBcInB4XCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdy5jb3Zlckd1dHRlciA/IDAgOiByZW5kZXJlci5ndXR0ZXJXaWR0aDtcbiAgICAgICAgICAgIGlmICghdy5maXhlZFdpZHRoKVxuICAgICAgICAgICAgICAgIGxlZnQgLT0gcmVuZGVyZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHcuZWwuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG5cbiAgICAgICAgICAgIGlmICh3LmZpeGVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3LmVsLnN0eWxlLnJpZ2h0ID0gcmVuZGVyZXIuc2Nyb2xsQmFyLmdldFdpZHRoKCkgKyBcInB4XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcuZWwuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbn0pLmNhbGwoTGluZVdpZGdldHMucHJvdG90eXBlKTtcblxuXG5leHBvcnRzLkxpbmVXaWRnZXRzID0gTGluZVdpZGdldHM7XG5cbn0pO1xuXG5hY2UuZGVmaW5lKFwiYWNlL2V4dC9lcnJvcl9tYXJrZXJcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saW5lX3dpZGdldHNcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xudmFyIExpbmVXaWRnZXRzID0gYWNlcXVpcmUoXCIuLi9saW5lX3dpZGdldHNcIikuTGluZVdpZGdldHM7XG52YXIgZG9tID0gYWNlcXVpcmUoXCIuLi9saWIvZG9tXCIpO1xudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcblxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFycmF5LCBuZWVkbGUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgZmlyc3QgPSAwO1xuICAgIHZhciBsYXN0ID0gYXJyYXkubGVuZ3RoIC0gMTtcblxuICAgIHdoaWxlIChmaXJzdCA8PSBsYXN0KSB7XG4gICAgICAgIHZhciBtaWQgPSAoZmlyc3QgKyBsYXN0KSA+PiAxO1xuICAgICAgICB2YXIgYyA9IGNvbXBhcmF0b3IobmVlZGxlLCBhcnJheVttaWRdKTtcbiAgICAgICAgaWYgKGMgPiAwKVxuICAgICAgICAgICAgZmlyc3QgPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGlmIChjIDwgMClcbiAgICAgICAgICAgIGxhc3QgPSBtaWQgLSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gLShmaXJzdCArIDEpO1xufVxuXG5mdW5jdGlvbiBmaW5kQW5ub3RhdGlvbnMoc2Vzc2lvbiwgcm93LCBkaXIpIHtcbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBzZXNzaW9uLmdldEFubm90YXRpb25zKCkuc29ydChSYW5nZS5jb21wYXJlUG9pbnRzKTtcbiAgICBpZiAoIWFubm90YXRpb25zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIHZhciBpID0gYmluYXJ5U2VhcmNoKGFubm90YXRpb25zLCB7cm93OiByb3csIGNvbHVtbjogLTF9LCBSYW5nZS5jb21wYXJlUG9pbnRzKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICAgIGkgPSAtaSAtIDE7XG4gICAgXG4gICAgaWYgKGkgPj0gYW5ub3RhdGlvbnMubGVuZ3RoKVxuICAgICAgICBpID0gZGlyID4gMCA/IDAgOiBhbm5vdGF0aW9ucy5sZW5ndGggLSAxO1xuICAgIGVsc2UgaWYgKGkgPT09IDAgJiYgZGlyIDwgMClcbiAgICAgICAgaSA9IGFubm90YXRpb25zLmxlbmd0aCAtIDE7XG4gICAgXG4gICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tpXTtcbiAgICBpZiAoIWFubm90YXRpb24gfHwgIWRpcilcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGFubm90YXRpb24ucm93ID09PSByb3cpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2kgKz0gZGlyXTtcbiAgICAgICAgfSB3aGlsZSAoYW5ub3RhdGlvbiAmJiBhbm5vdGF0aW9uLnJvdyA9PT0gcm93KTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zLnNsaWNlKCk7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIHZhciBtYXRjaGVkID0gW107XG4gICAgcm93ID0gYW5ub3RhdGlvbi5yb3c7XG4gICAgZG8ge1xuICAgICAgICBtYXRjaGVkW2RpciA8IDAgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiXShhbm5vdGF0aW9uKTtcbiAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2kgKz0gZGlyXTtcbiAgICB9IHdoaWxlIChhbm5vdGF0aW9uICYmIGFubm90YXRpb24ucm93ID09IHJvdyk7XG4gICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoICYmIG1hdGNoZWQ7XG59XG5cbmV4cG9ydHMuc2hvd0Vycm9yTWFya2VyID0gZnVuY3Rpb24oZWRpdG9yLCBkaXIpIHtcbiAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xuICAgIGlmICghc2Vzc2lvbi53aWRnZXRNYW5hZ2VyKSB7XG4gICAgICAgIHNlc3Npb24ud2lkZ2V0TWFuYWdlciA9IG5ldyBMaW5lV2lkZ2V0cyhzZXNzaW9uKTtcbiAgICAgICAgc2Vzc2lvbi53aWRnZXRNYW5hZ2VyLmF0dGFjaChlZGl0b3IpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcG9zID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgdmFyIHJvdyA9IHBvcy5yb3c7XG4gICAgdmFyIG9sZFdpZGdldCA9IHNlc3Npb24ubGluZVdpZGdldHMgJiYgc2Vzc2lvbi5saW5lV2lkZ2V0c1tyb3ddO1xuICAgIGlmIChvbGRXaWRnZXQpIHtcbiAgICAgICAgb2xkV2lkZ2V0LmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3cgLT0gZGlyO1xuICAgIH1cbiAgICB2YXIgYW5ub3RhdGlvbnMgPSBmaW5kQW5ub3RhdGlvbnMoc2Vzc2lvbiwgcm93LCBkaXIpO1xuICAgIHZhciBndXR0ZXJBbm5vO1xuICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zWzBdO1xuICAgICAgICBwb3MuY29sdW1uID0gKGFubm90YXRpb24ucG9zICYmIHR5cGVvZiBhbm5vdGF0aW9uLmNvbHVtbiAhPSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IGFubm90YXRpb24ucG9zLnNjXG4gICAgICAgICAgICA6IGFubm90YXRpb24uY29sdW1uKSB8fCAwO1xuICAgICAgICBwb3Mucm93ID0gYW5ub3RhdGlvbi5yb3c7XG4gICAgICAgIGd1dHRlckFubm8gPSBlZGl0b3IucmVuZGVyZXIuJGd1dHRlckxheWVyLiRhbm5vdGF0aW9uc1twb3Mucm93XTtcbiAgICB9IGVsc2UgaWYgKG9sZFdpZGdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ3V0dGVyQW5ubyA9IHtcbiAgICAgICAgICAgIHRleHQ6IFtcIkxvb2tzIGdvb2QhXCJdLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImFjZV9va1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVkaXRvci5zZXNzaW9uLnVuZm9sZChwb3Mucm93KTtcbiAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHBvcyk7XG4gICAgXG4gICAgdmFyIHcgPSB7XG4gICAgICAgIHJvdzogcG9zLnJvdywgXG4gICAgICAgIGZpeGVkV2lkdGg6IHRydWUsXG4gICAgICAgIGNvdmVyR3V0dGVyOiB0cnVlLFxuICAgICAgICBlbDogZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICB9O1xuICAgIHZhciBlbCA9IHcuZWwuYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIHZhciBhcnJvdyA9IHcuZWwuYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIGFycm93LmNsYXNzTmFtZSA9IFwiZXJyb3Jfd2lkZ2V0X2Fycm93IFwiICsgZ3V0dGVyQW5uby5jbGFzc05hbWU7XG4gICAgXG4gICAgdmFyIGxlZnQgPSBlZGl0b3IucmVuZGVyZXIuJGN1cnNvckxheWVyXG4gICAgICAgIC5nZXRQaXhlbFBvc2l0aW9uKHBvcykubGVmdDtcbiAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gbGVmdCArIGVkaXRvci5yZW5kZXJlci5ndXR0ZXJXaWR0aCAtIDUgKyBcInB4XCI7XG4gICAgXG4gICAgdy5lbC5jbGFzc05hbWUgPSBcImVycm9yX3dpZGdldF93cmFwcGVyXCI7XG4gICAgZWwuY2xhc3NOYW1lID0gXCJlcnJvcl93aWRnZXQgXCIgKyBndXR0ZXJBbm5vLmNsYXNzTmFtZTtcbiAgICBlbC5pbm5lckhUTUwgPSBndXR0ZXJBbm5vLnRleHQuam9pbihcIjxicj5cIik7XG4gICAgXG4gICAgZWwuYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgIFxuICAgIHZhciBrYiA9IGZ1bmN0aW9uKF8sIGhhc2hJZCwga2V5U3RyaW5nKSB7XG4gICAgICAgIGlmIChoYXNoSWQgPT09IDAgJiYgKGtleVN0cmluZyA9PT0gXCJlc2NcIiB8fCBrZXlTdHJpbmcgPT09IFwicmV0dXJuXCIpKSB7XG4gICAgICAgICAgICB3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiB7Y29tbWFuZDogXCJudWxsXCJ9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB3LmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGVkaXRvci4kbW91c2VIYW5kbGVyLmlzTW91c2VQcmVzc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlZGl0b3Iua2V5QmluZGluZy5yZW1vdmVLZXlib2FyZEhhbmRsZXIoa2IpO1xuICAgICAgICBzZXNzaW9uLndpZGdldE1hbmFnZXIucmVtb3ZlTGluZVdpZGdldCh3KTtcbiAgICAgICAgZWRpdG9yLm9mZihcImNoYW5nZVNlbGVjdGlvblwiLCB3LmRlc3Ryb3kpO1xuICAgICAgICBlZGl0b3Iub2ZmKFwiY2hhbmdlU2Vzc2lvblwiLCB3LmRlc3Ryb3kpO1xuICAgICAgICBlZGl0b3Iub2ZmKFwibW91c2V1cFwiLCB3LmRlc3Ryb3kpO1xuICAgICAgICBlZGl0b3Iub2ZmKFwiY2hhbmdlXCIsIHcuZGVzdHJveSk7XG4gICAgfTtcbiAgICBcbiAgICBlZGl0b3Iua2V5QmluZGluZy5hZGRLZXlib2FyZEhhbmRsZXIoa2IpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVNlbGVjdGlvblwiLCB3LmRlc3Ryb3kpO1xuICAgIGVkaXRvci5vbihcImNoYW5nZVNlc3Npb25cIiwgdy5kZXN0cm95KTtcbiAgICBlZGl0b3Iub24oXCJtb3VzZXVwXCIsIHcuZGVzdHJveSk7XG4gICAgZWRpdG9yLm9uKFwiY2hhbmdlXCIsIHcuZGVzdHJveSk7XG4gICAgXG4gICAgZWRpdG9yLnNlc3Npb24ud2lkZ2V0TWFuYWdlci5hZGRMaW5lV2lkZ2V0KHcpO1xuICAgIFxuICAgIHcuZWwub25tb3VzZWRvd24gPSBlZGl0b3IuZm9jdXMuYmluZChlZGl0b3IpO1xuICAgIFxuICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhudWxsLCAwLjUsIHtib3R0b206IHcuZWwub2Zmc2V0SGVpZ2h0fSk7XG59O1xuXG5cbmRvbS5pbXBvcnRDc3NTdHJpbmcoXCJcXFxuICAgIC5lcnJvcl93aWRnZXRfd3JhcHBlciB7XFxcbiAgICAgICAgYmFja2dyb3VuZDogaW5oZXJpdDtcXFxuICAgICAgICBjb2xvcjogaW5oZXJpdDtcXFxuICAgICAgICBib3JkZXI6bm9uZVxcXG4gICAgfVxcXG4gICAgLmVycm9yX3dpZGdldCB7XFxcbiAgICAgICAgYm9yZGVyLXRvcDogc29saWQgMnB4O1xcXG4gICAgICAgIGJvcmRlci1ib3R0b206IHNvbGlkIDJweDtcXFxuICAgICAgICBtYXJnaW46IDVweCAwO1xcXG4gICAgICAgIHBhZGRpbmc6IDEwcHggNDBweDtcXFxuICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxcbiAgICB9XFxcbiAgICAuZXJyb3Jfd2lkZ2V0LmFjZV9lcnJvciwgLmVycm9yX3dpZGdldF9hcnJvdy5hY2VfZXJyb3J7XFxcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjZmY1YTVhXFxcbiAgICB9XFxcbiAgICAuZXJyb3Jfd2lkZ2V0LmFjZV93YXJuaW5nLCAuZXJyb3Jfd2lkZ2V0X2Fycm93LmFjZV93YXJuaW5ne1xcXG4gICAgICAgIGJvcmRlci1jb2xvcjogI0YxRDgxN1xcXG4gICAgfVxcXG4gICAgLmVycm9yX3dpZGdldC5hY2VfaW5mbywgLmVycm9yX3dpZGdldF9hcnJvdy5hY2VfaW5mb3tcXFxuICAgICAgICBib3JkZXItY29sb3I6ICM1YTVhNWFcXFxuICAgIH1cXFxuICAgIC5lcnJvcl93aWRnZXQuYWNlX29rLCAuZXJyb3Jfd2lkZ2V0X2Fycm93LmFjZV9va3tcXFxuICAgICAgICBib3JkZXItY29sb3I6ICM1YWFhNWFcXFxuICAgIH1cXFxuICAgIC5lcnJvcl93aWRnZXRfYXJyb3cge1xcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxuICAgICAgICBib3JkZXI6IHNvbGlkIDVweDtcXFxuICAgICAgICBib3JkZXItdG9wLWNvbG9yOiB0cmFuc3BhcmVudCFpbXBvcnRhbnQ7XFxcbiAgICAgICAgYm9yZGVyLXJpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudCFpbXBvcnRhbnQ7XFxcbiAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6IHRyYW5zcGFyZW50IWltcG9ydGFudDtcXFxuICAgICAgICB0b3A6IC01cHg7XFxcbiAgICB9XFxcblwiLCBcIlwiKTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYWNlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL2ZpeG9sZGJyb3dzZXJzXCIsXCJhY2UvbGliL2RvbVwiLFwiYWNlL2xpYi9ldmVudFwiLFwiYWNlL2VkaXRvclwiLFwiYWNlL2VkaXRfc2Vzc2lvblwiLFwiYWNlL3VuZG9tYW5hZ2VyXCIsXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiLFwiYWNlL3dvcmtlci93b3JrZXJfY2xpZW50XCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIsXCJhY2UvcGxhY2Vob2xkZXJcIixcImFjZS9tdWx0aV9zZWxlY3RcIixcImFjZS9tb2RlL2ZvbGRpbmcvZm9sZF9tb2RlXCIsXCJhY2UvdGhlbWUvdGV4dG1hdGVcIixcImFjZS9leHQvZXJyb3JfbWFya2VyXCIsXCJhY2UvY29uZmlnXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuYWNlcXVpcmUoXCIuL2xpYi9maXhvbGRicm93c2Vyc1wiKTtcblxudmFyIGRvbSA9IGFjZXF1aXJlKFwiLi9saWIvZG9tXCIpO1xudmFyIGV2ZW50ID0gYWNlcXVpcmUoXCIuL2xpYi9ldmVudFwiKTtcblxudmFyIEVkaXRvciA9IGFjZXF1aXJlKFwiLi9lZGl0b3JcIikuRWRpdG9yO1xudmFyIEVkaXRTZXNzaW9uID0gYWNlcXVpcmUoXCIuL2VkaXRfc2Vzc2lvblwiKS5FZGl0U2Vzc2lvbjtcbnZhciBVbmRvTWFuYWdlciA9IGFjZXF1aXJlKFwiLi91bmRvbWFuYWdlclwiKS5VbmRvTWFuYWdlcjtcbnZhciBSZW5kZXJlciA9IGFjZXF1aXJlKFwiLi92aXJ0dWFsX3JlbmRlcmVyXCIpLlZpcnR1YWxSZW5kZXJlcjtcbmFjZXF1aXJlKFwiLi93b3JrZXIvd29ya2VyX2NsaWVudFwiKTtcbmFjZXF1aXJlKFwiLi9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIik7XG5hY2VxdWlyZShcIi4vcGxhY2Vob2xkZXJcIik7XG5hY2VxdWlyZShcIi4vbXVsdGlfc2VsZWN0XCIpO1xuYWNlcXVpcmUoXCIuL21vZGUvZm9sZGluZy9mb2xkX21vZGVcIik7XG5hY2VxdWlyZShcIi4vdGhlbWUvdGV4dG1hdGVcIik7XG5hY2VxdWlyZShcIi4vZXh0L2Vycm9yX21hcmtlclwiKTtcblxuZXhwb3J0cy5jb25maWcgPSBhY2VxdWlyZShcIi4vY29uZmlnXCIpO1xuZXhwb3J0cy5hY2VxdWlyZSA9IGFjZXF1aXJlO1xuZXhwb3J0cy5lZGl0ID0gZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAodHlwZW9mKGVsKSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBfaWQgPSBlbDtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChfaWQpO1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWNlLmVkaXQgY2FuJ3QgZmluZCBkaXYgI1wiICsgX2lkKTtcbiAgICB9XG5cbiAgICBpZiAoZWwgJiYgZWwuZW52ICYmIGVsLmVudi5lZGl0b3IgaW5zdGFuY2VvZiBFZGl0b3IpXG4gICAgICAgIHJldHVybiBlbC5lbnYuZWRpdG9yO1xuXG4gICAgdmFyIHZhbHVlID0gXCJcIjtcbiAgICBpZiAoZWwgJiYgL2lucHV0fHRleHRhcmVhL2kudGVzdChlbC50YWdOYW1lKSkge1xuICAgICAgICB2YXIgb2xkTm9kZSA9IGVsO1xuICAgICAgICB2YWx1ZSA9IG9sZE5vZGUudmFsdWU7XG4gICAgICAgIGVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgIG9sZE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWwsIG9sZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZG9tLmdldElubmVyVGV4dChlbCk7XG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBleHBvcnRzLmNyZWF0ZUVkaXRTZXNzaW9uKHZhbHVlKTtcblxuICAgIHZhciBlZGl0b3IgPSBuZXcgRWRpdG9yKG5ldyBSZW5kZXJlcihlbCkpO1xuICAgIGVkaXRvci5zZXRTZXNzaW9uKGRvYyk7XG5cbiAgICB2YXIgZW52ID0ge1xuICAgICAgICBkb2N1bWVudDogZG9jLFxuICAgICAgICBlZGl0b3I6IGVkaXRvcixcbiAgICAgICAgb25SZXNpemU6IGVkaXRvci5yZXNpemUuYmluZChlZGl0b3IsIG51bGwpXG4gICAgfTtcbiAgICBpZiAob2xkTm9kZSkgZW52LnRleHRhcmVhID0gb2xkTm9kZTtcbiAgICBldmVudC5hZGRMaXN0ZW5lcih3aW5kb3csIFwicmVzaXplXCIsIGVudi5vblJlc2l6ZSk7XG4gICAgZWRpdG9yLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LCBcInJlc2l6ZVwiLCBlbnYub25SZXNpemUpO1xuICAgICAgICBlbnYuZWRpdG9yLmNvbnRhaW5lci5lbnYgPSBudWxsOyAvLyBwcmV2ZW50IG1lbW9yeSBsZWFrIG9uIG9sZCBpZVxuICAgIH0pO1xuICAgIGVkaXRvci5jb250YWluZXIuZW52ID0gZWRpdG9yLmVudiA9IGVudjtcbiAgICByZXR1cm4gZWRpdG9yO1xufTtcbmV4cG9ydHMuY3JlYXRlRWRpdFNlc3Npb24gPSBmdW5jdGlvbih0ZXh0LCBtb2RlKSB7XG4gICAgdmFyIGRvYyA9IG5ldyBFZGl0U2Vzc2lvbih0ZXh0LCBtb2RlKTtcbiAgICBkb2Muc2V0VW5kb01hbmFnZXIobmV3IFVuZG9NYW5hZ2VyKCkpO1xuICAgIHJldHVybiBkb2M7XG59XG5leHBvcnRzLkVkaXRTZXNzaW9uID0gRWRpdFNlc3Npb247XG5leHBvcnRzLlVuZG9NYW5hZ2VyID0gVW5kb01hbmFnZXI7XG59KTtcbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhY2UuYWNlcXVpcmUoW1wiYWNlL2FjZVwiXSwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICBhICYmIGEuY29uZmlnLmluaXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd2luZG93LmFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hY2UgPSBhO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkgaWYgKGEuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hY2Vba2V5XSA9IGFba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIFxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuYWNlLmFjZXF1aXJlKFwiYWNlL2FjZVwiKTsiLCJhY2UuZGVmaW5lKFwiYWNlL3RoZW1lL2Nocm9tZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9kb21cIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuZXhwb3J0cy5pc0RhcmsgPSBmYWxzZTtcbmV4cG9ydHMuY3NzQ2xhc3MgPSBcImFjZS1jaHJvbWVcIjtcbmV4cG9ydHMuY3NzVGV4dCA9IFwiLmFjZS1jaHJvbWUgLmFjZV9ndXR0ZXIge1xcXG5iYWNrZ3JvdW5kOiAjZWJlYmViO1xcXG5jb2xvcjogIzMzMztcXFxub3ZlcmZsb3cgOiBoaWRkZW47XFxcbn1cXFxuLmFjZS1jaHJvbWUgLmFjZV9wcmludC1tYXJnaW4ge1xcXG53aWR0aDogMXB4O1xcXG5iYWNrZ3JvdW5kOiAjZThlOGU4O1xcXG59XFxcbi5hY2UtY2hyb21lIHtcXFxuYmFja2dyb3VuZC1jb2xvcjogI0ZGRkZGRjtcXFxuY29sb3I6IGJsYWNrO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfY3Vyc29yIHtcXFxuY29sb3I6IGJsYWNrO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfaW52aXNpYmxlIHtcXFxuY29sb3I6IHJnYigxOTEsIDE5MSwgMTkxKTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2NvbnN0YW50LmFjZV9idWlsZGluIHtcXFxuY29sb3I6IHJnYig4OCwgNzIsIDI0Nik7XFxcbn1cXFxuLmFjZS1jaHJvbWUgLmFjZV9jb25zdGFudC5hY2VfbGFuZ3VhZ2Uge1xcXG5jb2xvcjogcmdiKDg4LCA5MiwgMjQ2KTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2NvbnN0YW50LmFjZV9saWJyYXJ5IHtcXFxuY29sb3I6IHJnYig2LCAxNTAsIDE0KTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2ludmFsaWQge1xcXG5iYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTUzLCAwLCAwKTtcXFxuY29sb3I6IHdoaXRlO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfZm9sZCB7XFxcbn1cXFxuLmFjZS1jaHJvbWUgLmFjZV9zdXBwb3J0LmFjZV9mdW5jdGlvbiB7XFxcbmNvbG9yOiByZ2IoNjAsIDc2LCAxMTQpO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2Vfc3VwcG9ydC5hY2VfY29uc3RhbnQge1xcXG5jb2xvcjogcmdiKDYsIDE1MCwgMTQpO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2Vfc3VwcG9ydC5hY2VfdHlwZSxcXFxuLmFjZS1jaHJvbWUgLmFjZV9zdXBwb3J0LmFjZV9jbGFzc1xcXG4uYWNlLWNocm9tZSAuYWNlX3N1cHBvcnQuYWNlX290aGVyIHtcXFxuY29sb3I6IHJnYigxMDksIDEyMSwgMjIyKTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX3ZhcmlhYmxlLmFjZV9wYXJhbWV0ZXIge1xcXG5mb250LXN0eWxlOml0YWxpYztcXFxuY29sb3I6I0ZEOTcxRjtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2tleXdvcmQuYWNlX29wZXJhdG9yIHtcXFxuY29sb3I6IHJnYigxMDQsIDExOCwgMTM1KTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2NvbW1lbnQge1xcXG5jb2xvcjogIzIzNmUyNDtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2NvbW1lbnQuYWNlX2RvYyB7XFxcbmNvbG9yOiAjMjM2ZTI0O1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfY29tbWVudC5hY2VfZG9jLmFjZV90YWcge1xcXG5jb2xvcjogIzIzNmUyNDtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2NvbnN0YW50LmFjZV9udW1lcmljIHtcXFxuY29sb3I6IHJnYigwLCAwLCAyMDUpO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfdmFyaWFibGUge1xcXG5jb2xvcjogcmdiKDQ5LCAxMzIsIDE0OSk7XFxcbn1cXFxuLmFjZS1jaHJvbWUgLmFjZV94bWwtcGUge1xcXG5jb2xvcjogcmdiKDEwNCwgMTA0LCA5MSk7XFxcbn1cXFxuLmFjZS1jaHJvbWUgLmFjZV9lbnRpdHkuYWNlX25hbWUuYWNlX2Z1bmN0aW9uIHtcXFxuY29sb3I6ICMwMDAwQTI7XFxcbn1cXFxuLmFjZS1jaHJvbWUgLmFjZV9oZWFkaW5nIHtcXFxuY29sb3I6IHJnYigxMiwgNywgMjU1KTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2xpc3Qge1xcXG5jb2xvcjpyZ2IoMTg1LCA2LCAxNDQpO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0aW9uIHtcXFxuYmFja2dyb3VuZDogcmdiKDE4MSwgMjEzLCAyNTUpO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc3RlcCB7XFxcbmJhY2tncm91bmQ6IHJnYigyNTIsIDI1NSwgMCk7XFxcbn1cXFxuLmFjZS1jaHJvbWUgLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zdGFjayB7XFxcbmJhY2tncm91bmQ6IHJnYigxNjQsIDIyOSwgMTAxKTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX21hcmtlci1sYXllciAuYWNlX2JyYWNrZXQge1xcXG5tYXJnaW46IC0xcHggMCAwIC0xcHg7XFxcbmJvcmRlcjogMXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX21hcmtlci1sYXllciAuYWNlX2FjdGl2ZS1saW5lIHtcXFxuYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjA3KTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2d1dHRlci1hY3RpdmUtbGluZSB7XFxcbmJhY2tncm91bmQtY29sb3IgOiAjZGNkY2RjO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0ZWQtd29yZCB7XFxcbmJhY2tncm91bmQ6IHJnYigyNTAsIDI1MCwgMjU1KTtcXFxuYm9yZGVyOiAxcHggc29saWQgcmdiKDIwMCwgMjAwLCAyNTApO1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2Vfc3RvcmFnZSxcXFxuLmFjZS1jaHJvbWUgLmFjZV9rZXl3b3JkLFxcXG4uYWNlLWNocm9tZSAuYWNlX21ldGEuYWNlX3RhZyB7XFxcbmNvbG9yOiByZ2IoMTQ3LCAxNSwgMTI4KTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX3N0cmluZy5hY2VfcmVnZXgge1xcXG5jb2xvcjogcmdiKDI1NSwgMCwgMClcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX3N0cmluZyB7XFxcbmNvbG9yOiAjMUExQUE2O1xcXG59XFxcbi5hY2UtY2hyb21lIC5hY2VfZW50aXR5LmFjZV9vdGhlci5hY2VfYXR0cmlidXRlLW5hbWUge1xcXG5jb2xvcjogIzk5NDQwOTtcXFxufVxcXG4uYWNlLWNocm9tZSAuYWNlX2luZGVudC1ndWlkZSB7XFxcbmJhY2tncm91bmQ6IHVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFDQ0FZQUFBQ1pnYlluQUFBQUUwbEVRVlFJbVdQNC8vLy9mNGJMbHkvL0J3QW1WZ2QxL3cxMS9nQUFBQUJKUlU1RXJrSmdnZz09XFxcIikgcmlnaHQgcmVwZWF0LXk7XFxcbn1cXFxuXCI7XG5cbnZhciBkb20gPSBhY2VxdWlyZShcIi4uL2xpYi9kb21cIik7XG5kb20uaW1wb3J0Q3NzU3RyaW5nKGV4cG9ydHMuY3NzVGV4dCwgZXhwb3J0cy5jc3NDbGFzcyk7XG59KTtcbiIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgMilcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgsIHVuaXRTaXplKSB7XG4gIGlmICh1bml0U2l6ZSkgbGVuZ3RoIC09IGxlbmd0aCAlIHVuaXRTaXplO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGFyZyk7XG59XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbn0pLmNhbGwodGhpcyx7XCJpc0J1ZmZlclwiOnJlcXVpcmUoXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcIil9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWpiM0psTFhWMGFXd3RhWE12YkdsaUwzVjBhV3d1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4dklFTnZjSGx5YVdkb2RDQktiM2xsYm5Rc0lFbHVZeTRnWVc1a0lHOTBhR1Z5SUU1dlpHVWdZMjl1ZEhKcFluVjBiM0p6TGx4dUx5OWNiaTh2SUZCbGNtMXBjM05wYjI0Z2FYTWdhR1Z5WldKNUlHZHlZVzUwWldRc0lHWnlaV1VnYjJZZ1kyaGhjbWRsTENCMGJ5QmhibmtnY0dWeWMyOXVJRzlpZEdGcGJtbHVaeUJoWEc0dkx5QmpiM0I1SUc5bUlIUm9hWE1nYzI5bWRIZGhjbVVnWVc1a0lHRnpjMjlqYVdGMFpXUWdaRzlqZFcxbGJuUmhkR2x2YmlCbWFXeGxjeUFvZEdobFhHNHZMeUJjSWxOdlpuUjNZWEpsWENJcExDQjBieUJrWldGc0lHbHVJSFJvWlNCVGIyWjBkMkZ5WlNCM2FYUm9iM1YwSUhKbGMzUnlhV04wYVc5dUxDQnBibU5zZFdScGJtZGNiaTh2SUhkcGRHaHZkWFFnYkdsdGFYUmhkR2x2YmlCMGFHVWdjbWxuYUhSeklIUnZJSFZ6WlN3Z1kyOXdlU3dnYlc5a2FXWjVMQ0J0WlhKblpTd2djSFZpYkdsemFDeGNiaTh2SUdScGMzUnlhV0oxZEdVc0lITjFZbXhwWTJWdWMyVXNJR0Z1WkM5dmNpQnpaV3hzSUdOdmNHbGxjeUJ2WmlCMGFHVWdVMjltZEhkaGNtVXNJR0Z1WkNCMGJ5QndaWEp0YVhSY2JpOHZJSEJsY25OdmJuTWdkRzhnZDJodmJTQjBhR1VnVTI5bWRIZGhjbVVnYVhNZ1puVnlibWx6YUdWa0lIUnZJR1J2SUhOdkxDQnpkV0pxWldOMElIUnZJSFJvWlZ4dUx5OGdabTlzYkc5M2FXNW5JR052Ym1ScGRHbHZibk02WEc0dkwxeHVMeThnVkdobElHRmliM1psSUdOdmNIbHlhV2RvZENCdWIzUnBZMlVnWVc1a0lIUm9hWE1nY0dWeWJXbHpjMmx2YmlCdWIzUnBZMlVnYzJoaGJHd2dZbVVnYVc1amJIVmtaV1JjYmk4dklHbHVJR0ZzYkNCamIzQnBaWE1nYjNJZ2MzVmljM1JoYm5ScFlXd2djRzl5ZEdsdmJuTWdiMllnZEdobElGTnZablIzWVhKbExseHVMeTljYmk4dklGUklSU0JUVDBaVVYwRlNSU0JKVXlCUVVrOVdTVVJGUkNCY0lrRlRJRWxUWENJc0lGZEpWRWhQVlZRZ1YwRlNVa0ZPVkZrZ1QwWWdRVTVaSUV0SlRrUXNJRVZZVUZKRlUxTmNiaTh2SUU5U0lFbE5VRXhKUlVRc0lFbE9RMHhWUkVsT1J5QkNWVlFnVGs5VUlFeEpUVWxVUlVRZ1ZFOGdWRWhGSUZkQlVsSkJUbFJKUlZNZ1QwWmNiaTh2SUUxRlVrTklRVTVVUVVKSlRFbFVXU3dnUmtsVVRrVlRVeUJHVDFJZ1FTQlFRVkpVU1VOVlRFRlNJRkJWVWxCUFUwVWdRVTVFSUU1UFRrbE9SbEpKVGtkRlRVVk9WQzRnU1U1Y2JpOHZJRTVQSUVWV1JVNVVJRk5JUVV4TUlGUklSU0JCVlZSSVQxSlRJRTlTSUVOUFVGbFNTVWRJVkNCSVQweEVSVkpUSUVKRklFeEpRVUpNUlNCR1QxSWdRVTVaSUVOTVFVbE5MRnh1THk4Z1JFRk5RVWRGVXlCUFVpQlBWRWhGVWlCTVNVRkNTVXhKVkZrc0lGZElSVlJJUlZJZ1NVNGdRVTRnUVVOVVNVOU9JRTlHSUVOUFRsUlNRVU5VTENCVVQxSlVJRTlTWEc0dkx5QlBWRWhGVWxkSlUwVXNJRUZTU1ZOSlRrY2dSbEpQVFN3Z1QxVlVJRTlHSUU5U0lFbE9JRU5QVGs1RlExUkpUMDRnVjBsVVNDQlVTRVVnVTA5R1ZGZEJVa1VnVDFJZ1ZFaEZYRzR2THlCVlUwVWdUMUlnVDFSSVJWSWdSRVZCVEVsT1IxTWdTVTRnVkVoRklGTlBSbFJYUVZKRkxseHVYRzR2THlCT1QxUkZPaUJVYUdWelpTQjBlWEJsSUdOb1pXTnJhVzVuSUdaMWJtTjBhVzl1Y3lCcGJuUmxiblJwYjI1aGJHeDVJR1J2YmlkMElIVnpaU0JnYVc1emRHRnVZMlZ2Wm1CY2JpOHZJR0psWTJGMWMyVWdhWFFnYVhNZ1puSmhaMmxzWlNCaGJtUWdZMkZ1SUdKbElHVmhjMmxzZVNCbVlXdGxaQ0IzYVhSb0lHQlBZbXBsWTNRdVkzSmxZWFJsS0NsZ0xseHVablZ1WTNScGIyNGdhWE5CY25KaGVTaGhjaWtnZTF4dUlDQnlaWFIxY200Z1FYSnlZWGt1YVhOQmNuSmhlU2hoY2lrN1hHNTlYRzVsZUhCdmNuUnpMbWx6UVhKeVlYa2dQU0JwYzBGeWNtRjVPMXh1WEc1bWRXNWpkR2x2YmlCcGMwSnZiMnhsWVc0b1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnWVhKbklEMDlQU0FuWW05dmJHVmhiaWM3WEc1OVhHNWxlSEJ2Y25SekxtbHpRbTl2YkdWaGJpQTlJR2x6UW05dmJHVmhianRjYmx4dVpuVnVZM1JwYjI0Z2FYTk9kV3hzS0dGeVp5a2dlMXh1SUNCeVpYUjFjbTRnWVhKbklEMDlQU0J1ZFd4c08xeHVmVnh1Wlhod2IzSjBjeTVwYzA1MWJHd2dQU0JwYzA1MWJHdzdYRzVjYm1aMWJtTjBhVzl1SUdselRuVnNiRTl5Vlc1a1pXWnBibVZrS0dGeVp5a2dlMXh1SUNCeVpYUjFjbTRnWVhKbklEMDlJRzUxYkd3N1hHNTlYRzVsZUhCdmNuUnpMbWx6VG5Wc2JFOXlWVzVrWldacGJtVmtJRDBnYVhOT2RXeHNUM0pWYm1SbFptbHVaV1E3WEc1Y2JtWjFibU4wYVc5dUlHbHpUblZ0WW1WeUtHRnlaeWtnZTF4dUlDQnlaWFIxY200Z2RIbHdaVzltSUdGeVp5QTlQVDBnSjI1MWJXSmxjaWM3WEc1OVhHNWxlSEJ2Y25SekxtbHpUblZ0WW1WeUlEMGdhWE5PZFcxaVpYSTdYRzVjYm1aMWJtTjBhVzl1SUdselUzUnlhVzVuS0dGeVp5a2dlMXh1SUNCeVpYUjFjbTRnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKM04wY21sdVp5YzdYRzU5WEc1bGVIQnZjblJ6TG1selUzUnlhVzVuSUQwZ2FYTlRkSEpwYm1jN1hHNWNibVoxYm1OMGFXOXVJR2x6VTNsdFltOXNLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0ozTjViV0p2YkNjN1hHNTlYRzVsZUhCdmNuUnpMbWx6VTNsdFltOXNJRDBnYVhOVGVXMWliMnc3WEc1Y2JtWjFibU4wYVc5dUlHbHpWVzVrWldacGJtVmtLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdZWEpuSUQwOVBTQjJiMmxrSURBN1hHNTlYRzVsZUhCdmNuUnpMbWx6Vlc1a1pXWnBibVZrSUQwZ2FYTlZibVJsWm1sdVpXUTdYRzVjYm1aMWJtTjBhVzl1SUdselVtVm5SWGh3S0hKbEtTQjdYRzRnSUhKbGRIVnliaUJwYzA5aWFtVmpkQ2h5WlNrZ0ppWWdiMkpxWldOMFZHOVRkSEpwYm1jb2NtVXBJRDA5UFNBblcyOWlhbVZqZENCU1pXZEZlSEJkSnp0Y2JuMWNibVY0Y0c5eWRITXVhWE5TWldkRmVIQWdQU0JwYzFKbFowVjRjRHRjYmx4dVpuVnVZM1JwYjI0Z2FYTlBZbXBsWTNRb1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCMGVYQmxiMllnWVhKbklEMDlQU0FuYjJKcVpXTjBKeUFtSmlCaGNtY2dJVDA5SUc1MWJHdzdYRzU5WEc1bGVIQnZjblJ6TG1selQySnFaV04wSUQwZ2FYTlBZbXBsWTNRN1hHNWNibVoxYm1OMGFXOXVJR2x6UkdGMFpTaGtLU0I3WEc0Z0lISmxkSFZ5YmlCcGMwOWlhbVZqZENoa0tTQW1KaUJ2WW1wbFkzUlViMU4wY21sdVp5aGtLU0E5UFQwZ0oxdHZZbXBsWTNRZ1JHRjBaVjBuTzF4dWZWeHVaWGh3YjNKMGN5NXBjMFJoZEdVZ1BTQnBjMFJoZEdVN1hHNWNibVoxYm1OMGFXOXVJR2x6UlhKeWIzSW9aU2tnZTF4dUlDQnlaWFIxY200Z2FYTlBZbXBsWTNRb1pTa2dKaVpjYmlBZ0lDQWdJQ2h2WW1wbFkzUlViMU4wY21sdVp5aGxLU0E5UFQwZ0oxdHZZbXBsWTNRZ1JYSnliM0pkSnlCOGZDQmxJR2x1YzNSaGJtTmxiMllnUlhKeWIzSXBPMXh1ZlZ4dVpYaHdiM0owY3k1cGMwVnljbTl5SUQwZ2FYTkZjbkp2Y2p0Y2JseHVablZ1WTNScGIyNGdhWE5HZFc1amRHbHZiaWhoY21jcElIdGNiaUFnY21WMGRYSnVJSFI1Y0dWdlppQmhjbWNnUFQwOUlDZG1kVzVqZEdsdmJpYzdYRzU5WEc1bGVIQnZjblJ6TG1selJuVnVZM1JwYjI0Z1BTQnBjMFoxYm1OMGFXOXVPMXh1WEc1bWRXNWpkR2x2YmlCcGMxQnlhVzFwZEdsMlpTaGhjbWNwSUh0Y2JpQWdjbVYwZFhKdUlHRnlaeUE5UFQwZ2JuVnNiQ0I4ZkZ4dUlDQWdJQ0FnSUNBZ2RIbHdaVzltSUdGeVp5QTlQVDBnSjJKdmIyeGxZVzRuSUh4OFhHNGdJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmJuVnRZbVZ5SnlCOGZGeHVJQ0FnSUNBZ0lDQWdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0ozTjBjbWx1WnljZ2ZIeGNiaUFnSUNBZ0lDQWdJSFI1Y0dWdlppQmhjbWNnUFQwOUlDZHplVzFpYjJ3bklIeDhJQ0F2THlCRlV6WWdjM2x0WW05c1hHNGdJQ0FnSUNBZ0lDQjBlWEJsYjJZZ1lYSm5JRDA5UFNBbmRXNWtaV1pwYm1Wa0p6dGNibjFjYm1WNGNHOXlkSE11YVhOUWNtbHRhWFJwZG1VZ1BTQnBjMUJ5YVcxcGRHbDJaVHRjYmx4dVpuVnVZM1JwYjI0Z2FYTkNkV1ptWlhJb1lYSm5LU0I3WEc0Z0lISmxkSFZ5YmlCQ2RXWm1aWEl1YVhOQ2RXWm1aWElvWVhKbktUdGNibjFjYm1WNGNHOXlkSE11YVhOQ2RXWm1aWElnUFNCcGMwSjFabVpsY2p0Y2JseHVablZ1WTNScGIyNGdiMkpxWldOMFZHOVRkSEpwYm1jb2J5a2dlMXh1SUNCeVpYUjFjbTRnVDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaeTVqWVd4c0tHOHBPMXh1ZlNKZGZRPT0iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBTcHJheSA9IHJlcXVpcmUoJ3NwcmF5LXdydGMnKTtcbnZhciBDYXVzYWxCcm9hZGNhc3QgPSByZXF1aXJlKCdjYXVzYWwtYnJvYWRjYXN0LWRlZmluaXRpb24nKTtcbnZhciBWVndFID0gcmVxdWlyZSgndmVyc2lvbi12ZWN0b3Itd2l0aC1leGNlcHRpb25zJyk7XG52YXIgTFNFUVRyZWUgPSByZXF1aXJlKCdsc2VxdHJlZScpO1xudmFyIEdVSUQgPSByZXF1aXJlKCcuL2d1aWQuanMnKTtcblxudmFyIE1JbnNlcnRPcGVyYXRpb24gPSByZXF1aXJlKCcuL21lc3NhZ2VzLmpzJykuTUluc2VydE9wZXJhdGlvbjtcbnZhciBNQUVJbnNlcnRPcGVyYXRpb24gPSByZXF1aXJlKCcuL21lc3NhZ2VzLmpzJykuTUFFSW5zZXJ0T3BlcmF0aW9uO1xudmFyIE1SZW1vdmVPcGVyYXRpb24gPSByZXF1aXJlKCcuL21lc3NhZ2VzLmpzJykuTVJlbW92ZU9wZXJhdGlvbjtcbnZhciBNQ2FyZXRNb3ZlZE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vbWVzc2FnZXMuanMnKS5NQ2FyZXRNb3ZlZE9wZXJhdGlvbjtcblxudXRpbC5pbmhlcml0cyhDcmF0ZUNvcmUsIEV2ZW50RW1pdHRlcik7XG5cbi8qIVxuICogXFxicmllZiBsaW5rIHRvZ2V0aGVyIGFsbCBjb21wb25lbnRzIG9mIHRoZSBtb2RlbCBvZiB0aGUgQ1JBVEUgZWRpdG9yXG4gKiBcXHBhcmFtIGlkIHRoZSB1bmlxdWUgc2l0ZSBpZGVudGlmaWVyXG4gKiBcXHBhcmFtIG9wdGlvbnMgdGhlIHdlYnJ0YyBzcGVjaWZpYyBvcHRpb25zIFxuICovXG5mdW5jdGlvbiBDcmF0ZUNvcmUoaWQsIG9wdGlvbnMpe1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuaWQgPSBpZCB8fCBHVUlEKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmJyb2FkY2FzdCA9IG5ldyBDYXVzYWxCcm9hZGNhc3QobmV3IFNwcmF5KHRoaXMuaWQsIHRoaXMub3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWVndFKHRoaXMuaWQpKTtcbiAgICB0aGlzLnNlcXVlbmNlID0gbmV3IExTRVFUcmVlKHRoaXMuaWQpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vICNBIHJlZ3VsYXIgcmVjZWl2ZVxuICAgIHRoaXMuYnJvYWRjYXN0Lm9uKCdyZWNlaXZlJywgZnVuY3Rpb24ocmVjZWl2ZWRCcm9hZGNhc3RNZXNzYWdlKXtcbiAgICAgICAgc3dpdGNoIChyZWNlaXZlZEJyb2FkY2FzdE1lc3NhZ2UudHlwZSl7XG4gICAgICAgIGNhc2UgJ01SZW1vdmVPcGVyYXRpb24nOlxuICAgICAgICAgICAgc2VsZi5yZW1vdGVSZW1vdmUocmVjZWl2ZWRCcm9hZGNhc3RNZXNzYWdlLnJlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkQnJvYWRjYXN0TWVzc2FnZS5vcmlnaW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01JbnNlcnRPcGVyYXRpb24nOlxuICAgICAgICAgICAgc2VsZi5yZW1vdGVJbnNlcnQocmVjZWl2ZWRCcm9hZGNhc3RNZXNzYWdlLmluc2VydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkQnJvYWRjYXN0TWVzc2FnZS5vcmlnaW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01DYXJldE1vdmVkT3BlcmF0aW9uJzpcbiAgICAgICAgICAgIHNlbGYucmVtb3RlQ2FyZXRNb3ZlZChyZWNlaXZlZEJyb2FkY2FzdE1lc3NhZ2UucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWRCcm9hZGNhc3RNZXNzYWdlLm9yaWdpbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyAjQiBhbnRpLWVudHJvcHkgZm9yIHRoZSBtaXNzaW5nIG9wZXJhdGlvblxuICAgIHRoaXMuYnJvYWRjYXN0Lm9uKCdhbnRpRW50cm9weScsIGZ1bmN0aW9uKHNvY2tldCwgcmVtb3RlVlZ3RSwgbG9jYWxWVndFKXtcbiAgICAgICAgdmFyIHJlbW90ZVZWd0UgPSAobmV3IFZWd0UobnVsbCkpLmZyb21KU09OKHJlbW90ZVZWd0UpOyAvLyBjYXN0XG4gICAgICAgIHZhciB0b1NlYXJjaCA9IFtdO1xuICAgICAgICAvLyAjMSBmb3IgZWFjaCBlbnRyeSBvZiBvdXIgVlZ3RSwgbG9vayBpZiB0aGUgcmVtb3RlIFZWd0Uga25vd3MgbGVzc1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bG9jYWxWVndFLnZlY3Rvci5hcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIGxvY2FsRW50cnkgPSBsb2NhbFZWd0UudmVjdG9yLmFycltpXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHJlbW90ZVZWd0UudmVjdG9yLmluZGV4T2YobG9jYWxWVndFLnZlY3Rvci5hcnJbaV0pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICAgICAgICAgIC8vICNBIGNoZWNrIGlmIHRoZSBlbnRyeSBleGlzdHMgaW4gdGhlIHJlbW90ZSB2dndlXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0wKXsgc3RhcnQgPSByZW1vdGVWVndFLnZlY3Rvci5hcnJbaW5kZXhdLnYgKyAxOyB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaj1zdGFydDsgajw9bG9jYWxFbnRyeS52OyArK2ope1xuICAgICAgICAgICAgICAgIC8vICNCIGNoZWNrIGlmIG5vdCBvbmUgb2YgdGhlIGxvY2FsIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxFbnRyeS54LmluZGV4T2Yoaik8MCl7XG4gICAgICAgICAgICAgICAgICAgIHRvU2VhcmNoLnB1c2goe19lOiBsb2NhbEVudHJ5LmUsIF9jOiBqfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAjQyBoYW5kbGUgdGhlIGV4Y2VwdGlvbnMgb2YgdGhlIHJlbW90ZSB2ZWN0b3JcbiAgICAgICAgICAgIGlmIChpbmRleCA+PTApe1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxyZW1vdGVWVndFLnZlY3Rvci5hcnJbaW5kZXhdLngubGVuZ3RoOysrail7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGNlcHQgPSByZW1vdGVWVndFLnZlY3Rvci5hcnJbaW5kZXhdLnhbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEVudHJ5LnguaW5kZXhPZihleGNlcHQpPDAgJiYgZXhjZXB0PD1sb2NhbEVudHJ5LnYpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9TZWFyY2gucHVzaCh7X2U6IGxvY2FsRW50cnkuZSwgX2M6IGV4Y2VwdH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBzZWxmLmdldEVsZW1lbnRzKHRvU2VhcmNoKTtcbiAgICAgICAgLy92YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgLy8gIzIgc2VuZCBiYWNrIHRoZSBmb3VuZCBlbGVtZW50c1xuICAgICAgICBzZWxmLmJyb2FkY2FzdC5zZW5kQW50aUVudHJvcHlSZXNwb25zZShzb2NrZXQsIGxvY2FsVlZ3RSwgZWxlbWVudHMpO1xuICAgIH0pO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGNyZWF0ZSB0aGUgY29yZSBmcm9tIGFuIGV4aXN0aW5nIG9iamVjdFxuICogXFxwYXJhbSBvYmplY3QgdGhlIG9iamVjdCB0byBpbml0aWFsaXplIHRoZSBjb3JlIG1vZGVsIG9mIGNyYXRlIGNvbnRhaW5pbmcgYSBcbiAqIHNlcXVlbmNlIGFuZCBjYXVzYWxpdHkgdHJhY2tpbmcgbWV0YWRhdGFcbiAqL1xuQ3JhdGVDb3JlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICAvLyBpbXBvcnQgdGhlIHNlcXVlbmNlIGFuZCB2ZXJzaW9uIHZlY3RvciwgeWV0IGl0IGtlZXBzIHRoZSBpZGVudGlmaWVyIG9mXG4gICAgLy8gdGhpcyBpbnN0YW5jZSBvZiB0aGUgY29yZS5cbiAgICB2YXIgbG9jYWwgPSB0aGlzLmJyb2FkY2FzdC5jYXVzYWxpdHkubG9jYWw7XG4gICAgdGhpcy5icm9hZGNhc3QuY2F1c2FsaXR5LmZyb21KU09OKG9iamVjdC5jYXVzYWxpdHkpO1xuICAgIHRoaXMuYnJvYWRjYXN0LmNhdXNhbGl0eS5sb2NhbCA9IGxvY2FsO1xuICAgIHRoaXMuYnJvYWRjYXN0LmNhdXNhbGl0eS52ZWN0b3IuaW5zZXJ0KHRoaXMuYnJvYWRjYXN0LmNhdXNhbGl0eS5sb2NhbCk7XG4gICAgXG4gICAgdGhpcy5zZXF1ZW5jZS5mcm9tSlNPTihvYmplY3Quc2VxdWVuY2UpO1xuICAgIHRoaXMuc2VxdWVuY2UuX3MgPSBsb2NhbC5lO1xuICAgIHRoaXMuc2VxdWVuY2UuX2MgPSBsb2NhbC52O1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGxvY2FsIGluc2VydGlvbiBvZiBhIGNoYXJhY3RlciBpbnNpZGUgdGhlIHNlcXVlbmNlIHN0cnVjdHVyZS4gSXRcbiAqIGJyb2FkY2FzdHMgdGhlIG9wZXJhdGlvbiB0byB0aGUgcmVzdCBvZiB0aGUgbmV0d29yay5cbiAqIFxccGFyYW0gY2hhcmFjdGVyIHRoZSBjaGFyYWN0ZXIgdG8gaW5zZXJ0IGluIHRoZSBzZXF1ZW5jZVxuICogXFxwYXJhbSBpbmRleCB0aGUgaW5kZXggaW4gdGhlIHNlcXVlbmNlIHRvIGluc2VydFxuICogXFxyZXR1cm4gdGhlIGlkZW50aWZpZXIgZnJlc2hseSBhbGxvY2F0ZWRcbiAqL1xuQ3JhdGVDb3JlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihjaGFyYWN0ZXIsIGluZGV4KXtcbiAgICB2YXIgZWkgPSB0aGlzLnNlcXVlbmNlLmluc2VydChjaGFyYWN0ZXIsIGluZGV4KTtcbiAgICB2YXIgaWQgPSB7X2U6IGVpLl9pLl9zW2VpLl9pLl9zLmxlbmd0aC0xXSwgX2M6IGVpLl9pLl9jW2VpLl9pLl9jLmxlbmd0aC0xXX07XG4gICAgdGhpcy5icm9hZGNhc3Quc2VuZChuZXcgTUluc2VydE9wZXJhdGlvbihlaSwgaWQuX2UpLCBpZCwgbnVsbCk7XG4gICAgcmV0dXJuIGVpO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGxvY2FsIGRlbGV0aW9uIG9mIGEgY2hhcmFjdGVyIGZyb20gdGhlIHNlcXVlbmNlIHN0cnVjdHVyZS4gSXQgXG4gKiBicm9hZGNhc3RzIHRoZSBvcGVyYXRpb24gdG8gdGhlIHJlc3Qgb2YgdGhlIG5ldHdvcmsuXG4gKiBcXHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmVcbiAqIFxccmV0dXJuIHRoZSBpZGVudGlmaWVyIGZyZXNobHkgcmVtb3ZlZFxuICovXG5DcmF0ZUNvcmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGluZGV4KXtcbiAgICB2YXIgaSA9IHRoaXMuc2VxdWVuY2UucmVtb3ZlKGluZGV4KTtcbiAgICB2YXIgaXNSZWFkeSA9IHtfZTogaS5fc1tpLl9zLmxlbmd0aC0xXSwgX2M6IGkuX2NbaS5fYy5sZW5ndGgtMV19O1xuICAgIHRoaXMuc2VxdWVuY2UuX2MgKz0gMTtcbiAgICB2YXIgaWQgPSB7X2U6dGhpcy5zZXF1ZW5jZS5fcywgX2M6IHRoaXMuc2VxdWVuY2UuX2MgfSAvLyAoVE9ETykgZml4IHVnbHluZXNzXG4gICAgdGhpcy5icm9hZGNhc3Quc2VuZChuZXcgTVJlbW92ZU9wZXJhdGlvbihpLCBpZC5fZSksIGlkLCBpc1JlYWR5KTtcbiAgICByZXR1cm4gaTtcbn07XG5cbkNyYXRlQ29yZS5wcm90b3R5cGUuY2FyZXRNb3ZlZCA9IGZ1bmN0aW9uKHJhbmdlKXtcbiAgICB0aGlzLnNlcXVlbmNlLl9jICs9IDE7XG4gICAgdmFyIGlkID0ge19lOnRoaXMuc2VxdWVuY2UuX3MsIF9jOiB0aGlzLnNlcXVlbmNlLl9jIH0gLy8gKFRPRE8pIGZpeCB1Z2x5bmVzc1xuICAgIHRoaXMuYnJvYWRjYXN0LnNlbmQobmV3IE1DYXJldE1vdmVkT3BlcmF0aW9uKHJhbmdlLCBpZC5fZSksIGlkLCBudWxsKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgaW5zZXJ0aW9uIG9mIGFuIGVsZW1lbnQgZnJvbSBhIHJlbW90ZSBzaXRlLiBJdCBlbWl0cyAncmVtb3RlSW5zZXJ0JyBcbiAqIHdpdGggdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGluc2VydCwgLTEgaWYgYWxyZWFkeSBleGlzdGluZy5cbiAqIFxccGFyYW0gZWkgdGhlIHJlc3VsdCBvZiB0aGUgcmVtb3RlIGluc2VydCBvcGVyYXRpb25cbiAqIFxccGFyYW0gb3JpZ2luIHRoZSBvcmlnaW4gaWQgb2YgdGhlIGluc2VydCBvcGVyYXRpb25cbiAqL1xuQ3JhdGVDb3JlLnByb3RvdHlwZS5yZW1vdGVJbnNlcnQgPSBmdW5jdGlvbihlaSwgb3JpZ2luKXtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlcXVlbmNlLmFwcGx5SW5zZXJ0KGVpLl9lLCBlaS5faSwgZmFsc2UpO1xuICAgIHRoaXMuZW1pdCgncmVtb3RlSW5zZXJ0JywgZWkuX2UsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBvcmlnaW4pe1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW90ZUNhcmV0TW92ZWQnLCB7c3RhcnQ6IGluZGV4LCBlbmQ6IGluZGV4fSwgb3JpZ2luKTtcbiAgICB9O1xufTtcblxuLyohXG4gKiBcXGJyaWVmIHJlbW92YWwgb2YgYW4gZWxlbWVudCBmcm9tIGEgcmVtb3RlIHNpdGUuICBJdCBlbWl0cyAncmVtb3RlUmVtb3ZlJ1xuICogd2l0aCB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLCAtMSBpZiBkb2VzIG5vdCBleGlzdFxuICogXFxwYXJhbSBpZCB0aGUgcmVzdWx0IG9mIHRoZSByZW1vdGUgaW5zZXJ0IG9wZXJhdGlvblxuICogXFxwYXJhbSBvcmlnaW4gdGhlIG9yaWdpbiBpZCBvZiB0aGUgcmVtb3ZhbFxuICovXG5DcmF0ZUNvcmUucHJvdG90eXBlLnJlbW90ZVJlbW92ZSA9IGZ1bmN0aW9uKGlkLCBvcmlnaW4pe1xuICAgIHZhciBpbmRleCA9IHRoaXMuc2VxdWVuY2UuYXBwbHlSZW1vdmUoaWQpO1xuICAgIHRoaXMuZW1pdCgncmVtb3RlUmVtb3ZlJywgaW5kZXgpO1xuICAgIGlmIChpbmRleCA+PSAwICYmIG9yaWdpbil7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3RlQ2FyZXRNb3ZlZCcsIHtzdGFydDogaW5kZXgtMSwgZW5kOiBpbmRleC0xfSwgb3JpZ2luKTtcbiAgICB9O1xufTtcblxuQ3JhdGVDb3JlLnByb3RvdHlwZS5yZW1vdGVDYXJldE1vdmVkID0gZnVuY3Rpb24ocmFuZ2UsIG9yaWdpbil7XG4gICAgdGhpcy5lbWl0KCdyZW1vdGVDYXJldE1vdmVkJywgcmFuZ2UsIG9yaWdpbik7XG59O1xuXG5cbi8qIVxuICogXFxicmllZiBzZWFyY2ggYSBzZXQgb2YgZWxlbWVudHMgaW4gb3VyIHNlcXVlbmNlIGFuZCByZXR1cm4gdGhlbVxuICogXFxwYXJhbSB0b1NlYXJjaCB0aGUgYXJyYXkgb2YgZWxlbWVudHMge19lLCBfY30gdG8gc2VhcmNoXG4gKiBcXHJldHVybnMgYW4gYXJyYXkgb2Ygbm9kZXNcbiAqL1xuQ3JhdGVDb3JlLnByb3RvdHlwZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uKHRvU2VhcmNoKXtcbiAgICB2YXIgcmVzdWx0ID0gW10sIGZvdW5kLCBub2RlLCB0ZW1wTm9kZSwgaT10aGlzLnNlcXVlbmNlLmxlbmd0aCwgaj0wO1xuICAgIC8vIChUT0RPKSBpbXByb3ZlIHJlc2VhcmNoIGJ5IGV4cGxvaXRpbmcgdGhlIGZhY3QgdGhhdCBpZiBhIG5vZGUgaXNcbiAgICAvLyBtaXNzaW5nLCBhbGwgaXRzIGNoaWxkcmVuIGFyZSBtaXNzaW5nIHRvby5cbiAgICAvLyAoVE9ETykgaW1wcm92ZSB0aGUgcmV0dXJuZWQgcmVwcmVzZW50YXRpb246IGVpdGhlciBhIHRyZWUgdG8gZmFjdG9yaXplXG4gICAgLy8gY29tbW9uIHBhcnRzIG9mIHRoZSBzdHJ1Y3R1cmUgb3IgaWRlbnRpZmllcnMgdG8gZ2V0IHRoZSBwb2x5bG9nIHNpemVcbiAgICAvLyAoVE9ETykgaW1wcm92ZSB0aGUgc2VhcmNoIGJ5IHVzaW5nIHRoZSBmYWN0IHRoYXQgdG9TZWFyY2ggaXMgYSBzb3J0ZWRcbiAgICAvLyBhcnJheSwgcG9zc2libHkgcmVzdHJ1Y3R1cmUgdGhpcyBhcmd1bWVudCB0byBiZSBldmVuIG1vcmUgZWZmaWNpZW50XG4gICAgd2hpbGUgKHRvU2VhcmNoLmxlbmd0aCA+IDAgJiYgaTw9dGhpcy5zZXF1ZW5jZS5sZW5ndGggJiYgaT4wKXtcbiAgICAgICAgbm9kZSA9IHRoaXMuc2VxdWVuY2UuZ2V0KGkpO1xuICAgICAgICB0ZW1wTm9kZSA9IG5vZGU7XG4gICAgICAgIHdoaWxlKCB0ZW1wTm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH07XG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoaiA8IHRvU2VhcmNoLmxlbmd0aCAmJiAhZm91bmQpe1xuICAgICAgICAgICAgaWYgKHRlbXBOb2RlLnQucyA9PT0gdG9TZWFyY2hbal0uX2UgJiZcbiAgICAgICAgICAgICAgICB0ZW1wTm9kZS50LmMgPT09IHRvU2VhcmNoW2pdLl9jKXtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IE1BRUluc2VydE9wZXJhdGlvbih7X2U6IHRlbXBOb2RlLmUsIF9pOm5vZGV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge19lOiB0b1NlYXJjaFtqXS5fZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYzogdG9TZWFyY2hbal0uX2N9ICkpO1xuICAgICAgICAgICAgICAgIHRvU2VhcmNoLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvLyAgICAgICAgKytpO1xuICAgICAgICAtLWk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmF0ZUNvcmU7XG4iLCIvKiFcbiAqIFxcYnJpZWYgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGFuIGluc2VydCBvcGVyYXRpb25cbiAqIFxccGFyYW0gaW5zZXJ0IHRoZSByZXN1bHQgb2YgdGhlIGxvY2FsIGluc2VydCBvcGVyYXRpb25cbiAqIFxccGFyYW0gb3JpZ2luIHRoZSBvcmlnaW4gb2YgdGhlIGluc2VydGlvblxuICovXG5mdW5jdGlvbiBNSW5zZXJ0T3BlcmF0aW9uKGluc2VydCwgb3JpZ2luKXtcbiAgICB0aGlzLnR5cGUgPSBcIk1JbnNlcnRPcGVyYXRpb25cIjtcbiAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbn07XG5tb2R1bGUuZXhwb3J0cy5NSW5zZXJ0T3BlcmF0aW9uID0gTUluc2VydE9wZXJhdGlvbjtcblxuZnVuY3Rpb24gTUFFSW5zZXJ0T3BlcmF0aW9uKGluc2VydCwgaWQpe1xuICAgIHRoaXMudHlwZSA9IFwiTUFFSW5zZXJ0T3BlcmF0aW9uXCI7XG4gICAgdGhpcy5wYXlsb2FkID0gbmV3IE1JbnNlcnRPcGVyYXRpb24oaW5zZXJ0KTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5pc1JlYWR5ID0gbnVsbDtcbn07XG5tb2R1bGUuZXhwb3J0cy5NQUVJbnNlcnRPcGVyYXRpb24gPSBNQUVJbnNlcnRPcGVyYXRpb247XG5cbi8qIVxuICogXFxicmllZiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgYSBkZWxldGUgb3BlcmF0aW9uXG4gKiBcXHBhcmFtIHJlbW92ZSB0aGUgcmVzdWx0IG9mIHRoZSBsb2NhbCBkZWxldGUgb3BlcmF0aW9uXG4gKiBcXHBhcmFtIG9yaWdpbiB0aGUgb3JpZ2luIG9mIHRoZSByZW1vdmFsXG4gKi9cbmZ1bmN0aW9uIE1SZW1vdmVPcGVyYXRpb24ocmVtb3ZlLCBvcmlnaW4pe1xuICAgIHRoaXMudHlwZSA9IFwiTVJlbW92ZU9wZXJhdGlvblwiO1xuICAgIHRoaXMucmVtb3ZlID0gcmVtb3ZlO1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xufTtcbm1vZHVsZS5leHBvcnRzLk1SZW1vdmVPcGVyYXRpb24gPSBNUmVtb3ZlT3BlcmF0aW9uO1xuXG4vKiFcbiAqIFxcYnJpZWYgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGEgY2FyZXRNb3ZlZCBPcGVyYXRpb25cbiAqIFxccGFyYW0gcmFuZ2UgdGhlIHNlbGVjdGlvbiByYW5nZVxuICogXFxwYXJhbSBvcmlnaW4gdGhlIG9yaWdpbiBvZiB0aGUgc2VsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIE1DYXJldE1vdmVkT3BlcmF0aW9uKHJhbmdlLCBvcmlnaW4pe1xuICAgIHRoaXMudHlwZSA9IFwiTUNhcmV0TW92ZWRPcGVyYXRpb25cIjtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG59O1xubW9kdWxlLmV4cG9ydHMuTUNhcmV0TW92ZWRPcGVyYXRpb24gPSBNQ2FyZXRNb3ZlZE9wZXJhdGlvbjtcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBHVUlEID0gcmVxdWlyZSgnLi9ndWlkLmpzJyk7XG5cbnZhciBNQnJvYWRjYXN0ID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpLk1Ccm9hZGNhc3Q7XG52YXIgTUFudGlFbnRyb3B5UmVxdWVzdCA9IHJlcXVpcmUoJy4vbWVzc2FnZXMuanMnKS5NQW50aUVudHJvcHlSZXF1ZXN0O1xudmFyIE1BbnRpRW50cm9weVJlc3BvbnNlID0gcmVxdWlyZSgnLi9tZXNzYWdlcy5qcycpLk1BbnRpRW50cm9weVJlc3BvbnNlO1xuXG52YXIgVW5pY2FzdCA9IHJlcXVpcmUoJ3VuaWNhc3QtZGVmaW5pdGlvbicpO1xuXG51dGlsLmluaGVyaXRzKENhdXNhbEJyb2FkY2FzdCwgRXZlbnRFbWl0dGVyKTtcblxuLyohXG4gKiBJdCB0YWtlcyBhIHVuaXF1ZSB2YWx1ZSBmb3IgcGVlciBhbmQgYSBjb3VudGVyIHRvIGRpc3Rpbmd1aXNoIGEgbWVzc2FnZS4gSXRcbiAqIGVtaXRzICdyZWNlaXZlJyBldmVudCB3aGVuIHRoZSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgcmVhZHlcbiAqIFxccGFyYW0gc291cmNlIHRoZSBwcm90b2NvbCByZWNlaXZpbmcgdGhlIG1lc3NhZ2VzXG4gKiBcXHBhcmFtIGNhdXNhbGl0eSB0aGUgY2F1c2FsaXR5IHRyYWNraW5nIHN0cnVjdHVyZVxuICovXG5mdW5jdGlvbiBDYXVzYWxCcm9hZGNhc3Qoc291cmNlLCBjYXVzYWxpdHksIG5hbWUpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdjYXVzYWwnO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuY2F1c2FsaXR5ID0gY2F1c2FsaXR5O1xuICAgIHRoaXMuZGVsdGFBbnRpRW50cm9weSA9IDEwMDAqNjAqMS8yOyAvLyAoVE9ETykgY29uZmlndXJhYmxlIChjdXJyZW50bHkgMzBzKVxuICAgIHRoaXMudW5pY2FzdCA9IG5ldyBVbmljYXN0KHRoaXMuc291cmNlLCB0aGlzLm5hbWUrJy11bmljYXN0Jyk7XG5cbiAgICAvLyBidWZmZXIgb2Ygb3BlcmF0aW9uc1xuICAgIHRoaXMuYnVmZmVyID0gW107IFxuICAgIC8vIGJ1ZmZlciBvZiBhbnRpLWVudHJvcHkgbWVzc2FnZXMgKGNodW5raWZpZWQgYmVjYXVzZSBvZiBsYXJnZSBzaXplKVxuICAgIHRoaXMuYnVmZmVyQW50aUVudHJvcHkgPSBuZXcgTUFudGlFbnRyb3B5UmVzcG9uc2UoJ2luaXQnKTtcbiAgICBcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zb3VyY2Uub24oc2VsZi5uYW1lKyctYnJvYWRjYXN0LXJlY2VpdmUnLCBmdW5jdGlvbihzb2NrZXQsIG1lc3NhZ2Upe1xuICAgICAgICBzZWxmLnJlY2VpdmVCcm9hZGNhc3QobWVzc2FnZSk7XG4gICAgfSk7XG4gICAgdGhpcy51bmljYXN0Lm9uKCdyZWNlaXZlJywgZnVuY3Rpb24oc29ja2V0LCBtZXNzYWdlKXtcbiAgICAgICAgc2VsZi5yZWNlaXZlVW5pY2FzdChzb2NrZXQsIG1lc3NhZ2UpO1xuICAgIH0pO1xuICAgIHRoaXMuc291cmNlLm9uKCdzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKHN0YXRlKXtcbiAgICAgICAgaWYgKHN0YXRlPT09J2Nvbm5lY3QnKXtcbiAgICAgICAgICAgIHNlbGYudW5pY2FzdC5zZW5kKG5ldyBNQW50aUVudHJvcHlSZXF1ZXN0KHNlbGYuY2F1c2FsaXR5KSk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi51bmljYXN0LnNlbmQobmV3IE1BbnRpRW50cm9weVJlcXVlc3Qoc2VsZi5jYXVzYWxpdHkpKTtcbiAgICB9LCBzZWxmLmRlbHRhQW50aUVudHJvcHkpOyAgICBcbn07XG5cbi8qIVxuICogXFxicmllZiBicm9hZGNhc3QgdGhlIG1lc3NhZ2UgdG8gYWxsIHBhcnRpY2lwYW50c1xuICogXFxwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGJyb2FkY2FzdFxuICogXFxwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIG1lc3NhZ2VcbiAqIFxccGFyYW0gaXNSZWFkeSB0aGUgaWQocykgdGhhdCBtdXN0IGV4aXN0IHRvIGRlbGl2ZXIgdGhlIG1lc3NhZ2VcbiAqL1xuQ2F1c2FsQnJvYWRjYXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSwgaWQsIGlzUmVhZHkpe1xuICAgIC8vICMxIGdldCB0aGUgbmVpZ2hib3Job29kIGFuZCBjcmVhdGUgdGhlIG1lc3NhZ2VcbiAgICB2YXIgbGlua3MgPSB0aGlzLnNvdXJjZS5nZXRQZWVycyhOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB2YXIgbUJyb2FkY2FzdCA9IG5ldyBNQnJvYWRjYXN0KHRoaXMubmFtZSwgaWQgfHwgR1VJRCgpLCBpc1JlYWR5LCBtZXNzYWdlKTtcbiAgICAvLyAjMiByZWdpc3RlciB0aGUgbWVzc2FnZSBpbiB0aGUgc3RydWN0dXJlXG4gICAgdGhpcy5jYXVzYWxpdHkuaW5jcmVtZW50RnJvbShpZCk7XG4gICAgLy8gIzMgc2VuZCB0aGUgbWVzc2FnZSB0byB0aGUgbmVpZ2hib3Job29kXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7ICsraSl7XG4gICAgICAgIGlmIChsaW5rc1tpXS5jb25uZWN0ZWQgJiZcbiAgICAgICAgICAgIGxpbmtzW2ldLl9jaGFubmVsICYmIGxpbmtzW2ldLl9jaGFubmVsLnJlYWR5U3RhdGU9PT0nb3Blbicpe1xuICAgICAgICAgICAgbGlua3NbaV0uc2VuZChtQnJvYWRjYXN0KTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGFuc3dlcnMgdG8gYW4gYW50aWVudHJvcHkgcmVxdWVzdCBtZXNzYWdlIHdpdGggdGhlIG1pc3NpbmcgZWxlbWVudHNcbiAqIFxccGFyYW0gc29ja2V0IHRoZSBvcmlnaW4gb2YgdGhlIHJlcXVlc3RcbiAqIFxccGFyYW0gY2F1c2FsaXR5QXRSZWNlaXB0IHRoZSBsb2NhbCBjYXVzYWxpdHkgc3RydWN0dXJlIHdoZW4gdGhlIG1lc3NhZ2Ugd2FzXG4gKiByZWNlaXZlZFxuICogXFxwYXJhbSBtZXNzYWdlcyB0aGUgbWlzc2luZyBtZXNzYWdlc1xuICovIFxuQ2F1c2FsQnJvYWRjYXN0LnByb3RvdHlwZS5zZW5kQW50aUVudHJvcHlSZXNwb25zZSA9XG4gICAgZnVuY3Rpb24oc29ja2V0LCBjYXVzYWxpdHlBdFJlY2VpcHQsIG1lc3NhZ2VzKXtcbiAgICAgICAgdmFyIGlkID0gR1VJRCgpO1xuICAgICAgICAvLyAjMSBtZXRhZGF0YSBvZiB0aGUgYW50aWVudHJvcHkgcmVzcG9uc2VcbiAgICAgICAgdGhpcy51bmljYXN0LnNlbmQobmV3IE1BbnRpRW50cm9weVJlc3BvbnNlKGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2FsaXR5QXRSZWNlaXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMubGVuZ3RoKSwgc29ja2V0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB0aGlzLnVuaWNhc3Quc2VuZChuZXcgTUFudGlFbnRyb3B5UmVzcG9uc2UoaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNbaV0pLCAgc29ja2V0KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4vKiFcbiAqIFxcYnJpZWYgcmVjZWl2ZSBhIGJyb2FkY2FzdCBtZXNzYWdlXG4gKiBcXHBhcmFtIG1lc3NhZ2UgdGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqL1xuQ2F1c2FsQnJvYWRjYXN0LnByb3RvdHlwZS5yZWNlaXZlQnJvYWRjYXN0ID0gZnVuY3Rpb24obWVzc2FnZSl7XG4gICAgdmFyIGlkID0gbWVzc2FnZS5pZCxcbiAgICAgICAgaXNSZWFkeSA9IG1lc3NhZ2UuaXNSZWFkeTtcblxuICAgIGlmICghdGhpcy5zdG9wUHJvcGFnYXRpb24obWVzc2FnZSkpe1xuICAgICAgICAvLyAjMSByZWdpc3RlciB0aGUgb3BlcmF0aW9uXG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIC8vICMyIGRlbGl2ZXJcbiAgICAgICAgdGhpcy5yZXZpZXdCdWZmZXIoKTtcbiAgICAgICAgLy8gIzMgcmVicm9hZGNhc3RcbiAgICAgICAgdmFyIGxpbmtzID0gdGhpcy5zb3VyY2UuZ2V0UGVlcnMoTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYgKGxpbmtzW2ldLmNvbm5lY3RlZCAmJlxuICAgICAgICAgICAgICAgIGxpbmtzW2ldLl9jaGFubmVsICYmIGxpbmtzW2ldLl9jaGFubmVsLnJlYWR5U3RhdGU9PT0nb3Blbicpe1xuICAgICAgICAgICAgICAgIGxpbmtzW2ldLnNlbmQobWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH07XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgZ28gdGhyb3VnaCB0aGUgYnVmZmVyIG9mIG1lc3NhZ2VzIGFuZCBkZWxpdmVycyBhbGxcbiAqIHJlYWR5IG9wZXJhdGlvbnNcbiAqL1xuQ2F1c2FsQnJvYWRjYXN0LnByb3RvdHlwZS5yZXZpZXdCdWZmZXIgPSBmdW5jdGlvbigpe1xuICAgIHZhciBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBpID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMTtcbiAgICB3aGlsZShpPj0wKXtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgaWYgKHRoaXMuY2F1c2FsaXR5LmlzTG93ZXIobWVzc2FnZS5pZCkpe1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2F1c2FsaXR5LmlzUmVhZHkobWVzc2FnZS5pc1JlYWR5KSl7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2F1c2FsaXR5LmluY3JlbWVudEZyb20obWVzc2FnZS5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVjZWl2ZScsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAtLWk7XG4gICAgfTtcbiAgICBpZiAoZm91bmQpeyB0aGlzLnJldmlld0J1ZmZlcigpOyAgfTtcbn07XG5cbi8qIVxuICogXFxicmllZiByZWNlaXZlIGEgdW5pY2FzdCBtZXNzYWdlLCBpLmUuLCBlaXRoZXIgYW4gYW50aWVudHJvcHkgcmVxdWVzdCBvciBhblxuICogYW50aWVudHJvcHkgcmVzcG9uc2VcbiAqIFxcYnJpZWYgc29ja2V0IHRoZSBvcmlnaW4gb2YgdGhlIG1lc3NhZ2VcbiAqIFxcYnJpZWYgbWVzc2FnZSB0aGUgbWVzc2FnZSByZWNlaXZlZCBcbiAqL1xuQ2F1c2FsQnJvYWRjYXN0LnByb3RvdHlwZS5yZWNlaXZlVW5pY2FzdCA9IGZ1bmN0aW9uKHNvY2tldCwgbWVzc2FnZSl7XG4gICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpe1xuICAgIGNhc2UgJ01BbnRpRW50cm9weVJlcXVlc3QnOlxuICAgICAgICB0aGlzLmVtaXQoJ2FudGlFbnRyb3B5JyxcbiAgICAgICAgICAgICAgICAgIHNvY2tldCwgbWVzc2FnZS5jYXVzYWxpdHksIHRoaXMuY2F1c2FsaXR5LmNsb25lKCkpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdNQW50aUVudHJvcHlSZXNwb25zZSc6XG4gICAgICAgIC8vICNBIHJlcGxhY2UgdGhlIGJ1ZmZlcmVkIG1lc3NhZ2VcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyQW50aUVudHJvcHkuaWQgIT09IG1lc3NhZ2UuaWQpe1xuICAgICAgICAgICAgdGhpcy5idWZmZXJBbnRpRW50cm9weSA9IG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIC8vICNCIGFkZCB0aGUgbmV3IGVsZW1lbnQgdG8gdGhlIGJ1ZmZlciAgICAgICAgXG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1lbnQpe1xuICAgICAgICAgICAgdGhpcy5idWZmZXJBbnRpRW50cm9weS5lbGVtZW50cy5wdXNoKG1lc3NhZ2UuZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vICNDIGFkZCBjYXVzYWxpdHkgbWV0YWRhdGFcbiAgICAgICAgaWYgKG1lc3NhZ2UuY2F1c2FsaXR5KXtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyQW50aUVudHJvcHkuY2F1c2FsaXR5ID0gbWVzc2FnZS5jYXVzYWxpdHk7XG4gICAgICAgIH07XG4gICAgICAgIC8vICNEIHRoZSBidWZmZXJlZCBtZXNzYWdlIGlzIGZ1bGx5IGFycml2ZWQsIGRlbGl2ZXJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyQW50aUVudHJvcHkuZWxlbWVudHMubGVuZ3RoID09PVxuICAgICAgICAgICAgdGhpcy5idWZmZXJBbnRpRW50cm9weS5uYkVsZW1lbnRzKXtcbiAgICAgICAgICAgIC8vICMxIGNvbnNpZGVyZSBlYWNoIG1lc3NhZ2UgaW4gdGhlIHJlc3BvbnNlIGluZGVwZW5kYW50bHlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpPHRoaXMuYnVmZmVyQW50aUVudHJvcHkuZWxlbWVudHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5idWZmZXJBbnRpRW50cm9weS5lbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAvLyAjMiBvbmx5IGNoZWNrIGlmIHRoZSBtZXNzYWdlIGhhcyBub3QgYmVlbiByZWNlaXZlZCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RvcFByb3BhZ2F0aW9uKGVsZW1lbnQpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXVzYWxpdHkuaW5jcmVtZW50RnJvbShlbGVtZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWNlaXZlJywgZWxlbWVudC5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vICMzIG1lcmdlIGNhdXNhbGl0eSBzdHJ1Y3R1cmVzXG4gICAgICAgICAgICB0aGlzLmNhdXNhbGl0eS5tZXJnZSh0aGlzLmJ1ZmZlckFudGlFbnRyb3B5LmNhdXNhbGl0eSk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH07XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgZ2V0cyBjYWxsZWQgd2hlbiBhIGJyb2FkY2FzdCBtZXNzYWdlIHJlYWNoZXMgdGhpcyBub2RlLiAgdGhpc1xuICogZnVuY3Rpb24gZXZhbHVhdGVzIGlmIHRoZSBub2RlIHNob3VsZCBwcm9wYWdhdGUgdGhlIG1lc3NhZ2UgZnVydGhlciBvciBpZiBpdFxuICogc2hvdWxkIHN0b3Agc2VuZGluZyBpdC5cbiAqIFxccGFyYW0gbWVzc2FnZSBhIGJyb2FkY2FzdCBtZXNzYWdlXG4gKiBcXHJldHVybiB0cnVlIGlmIHRoZSBtZXNzYWdlIGlzIGFscmVhZHkga25vd24sIGZhbHNlIG90aGVyd2lzZVxuICovXG5DYXVzYWxCcm9hZGNhc3QucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2F1c2FsaXR5LmlzTG93ZXIobWVzc2FnZS5pZCkgfHxcbiAgICAgICAgdGhpcy5idWZmZXJJbmRleE9mKG1lc3NhZ2UuaWQpPj0wO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGdldCB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlciBvZiB0aGUgbWVzc2FnZSBpZGVudGlmaWVkIGJ5IGlkXG4gKiBcXHBhcmFtIGlkIHRoZSBpZGVudGlmaWVyIHRvIHNlYXJjaFxuICogXFxyZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtZXNzYWdlIGluIHRoZSBidWZmZXIsIC0xIGlmIG5vdCBmb3VuZFxuICovXG5DYXVzYWxCcm9hZGNhc3QucHJvdG90eXBlLmJ1ZmZlckluZGV4T2YgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGkgPSAwO1xuICAgIHdoaWxlICghZm91bmQgJiYgaTx0aGlzLmJ1ZmZlci5sZW5ndGgpe1xuICAgICAgICAvLyAoVE9ETykgZml4IHVnbHluZXNzXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLmJ1ZmZlcltpXS5pZCkgPT09IEpTT04uc3RyaW5naWZ5KGlkKSl7IFxuICAgICAgICAgICAgZm91bmQgPSB0cnVlOyBpbmRleCA9IGk7XG4gICAgICAgIH07XG4gICAgICAgICsraVxuICAgIH07XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXVzYWxCcm9hZGNhc3Q7XG4iLCJcbi8qIVxuICogXFxicmllZiBtZXNzYWdlIGNvbnRhaW5pbmcgZGF0YSB0byBicm9hZGNhc3RcbiAqIFxccGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgcHJvdG9jb2wsIGRlZmF1bHQgJ2NhdXNhbCdcbiAqIFxccGFyYW0gaWQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGJyb2FkY2FzdCBtZXNzYWdlXG4gKiBcXHBhcmFtIGlzUmVhZHkgdGhlIGlkZW50aWZpZXIocykgdGhhdCBtdXN0IGV4aXN0IHRvIGRlbGl2ZXIgdGhpcyBtZXNzYWdlXG4gKiBcXHBhcmFtIHBheWxvYWQgdGhlIGJyb2FkY2FzdGVkIGRhdGFcbiAqL1xuZnVuY3Rpb24gTUJyb2FkY2FzdChuYW1lLCBpZCwgaXNSZWFkeSwgcGF5bG9hZCl7XG4gICAgdGhpcy5wcm90b2NvbCA9IChuYW1lICYmIG5hbWUrJy1icm9hZGNhc3QnKSB8fCAnY2F1c2FsLWJyb2FkY2FzdCc7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuaXNSZWFkeSA9IGlzUmVhZHk7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbn07XG5tb2R1bGUuZXhwb3J0cy5NQnJvYWRjYXN0ID0gTUJyb2FkY2FzdDtcblxuLyohXG4gKiBcXGJyaWVmIG1lc3NhZ2UgdGhhdCByZXF1ZXN0IGFuIEFudGlFbnRyb3B5IFxuICogXFxwYXJhbSBjYXVzYWxpdHkgdGhlIGNhdXNhbGl0eSBzdHJ1Y3R1cmVcbiAqL1xuZnVuY3Rpb24gTUFudGlFbnRyb3B5UmVxdWVzdChjYXVzYWxpdHkpe1xuICAgIHRoaXMudHlwZSA9ICdNQW50aUVudHJvcHlSZXF1ZXN0JztcbiAgICB0aGlzLmNhdXNhbGl0eSA9IGNhdXNhbGl0eTtcbn07XG5tb2R1bGUuZXhwb3J0cy5NQW50aUVudHJvcHlSZXF1ZXN0ID0gTUFudGlFbnRyb3B5UmVxdWVzdDtcblxuLyohXG4gKiBcXGJyaWVmIG1lc3NhZ2UgcmVzcG9uZGluZyB0byB0aGUgQW50aUVudHJvcHkgcmVxdWVzdFxuICogXFxwYXJhbSBpZCB0aGUgaWRlbnRpZmllciBvZiB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogXFxwYXJhbSBjYXVzYWxpdHkgdGhlIGNhdXNhbGl0eSBzdHJ1Y3R1cmVcbiAqIFxccGFyYW0gbmJFbGVtZW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnQgdG8gc2VuZFxuICogXFxwYXJhbSBlbGVtZW50IGVhY2ggZWxlbWVudCB0byBzZW5kIFxuICovXG5mdW5jdGlvbiBNQW50aUVudHJvcHlSZXNwb25zZShpZCwgY2F1c2FsaXR5LCBuYkVsZW1lbnRzLCBlbGVtZW50KXtcbiAgICB0aGlzLnR5cGUgPSAnTUFudGlFbnRyb3B5UmVzcG9uc2UnO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNhdXNhbGl0eSA9IGNhdXNhbGl0eTtcbiAgICB0aGlzLm5iRWxlbWVudHMgPSBuYkVsZW1lbnRzO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xufTtcbm1vZHVsZS5leHBvcnRzLk1BbnRpRW50cm9weVJlc3BvbnNlID0gTUFudGlFbnRyb3B5UmVzcG9uc2U7XG5cbiIsIlxuLyohXG4gKiBcXGJyaWVmIG1lc3NhZ2UgY29udGFpbmluZyBkYXRhIHRvIHVuaWNhc3RcbiAqIFxccGFyYW0gbmFtZSB0aGUgcHJvdG9jb2wgbmFtZVxuICogXFxwYXJhbSBwYXlsb2FkIHRoZSBzZW50IGRhdGFcbiAqL1xuZnVuY3Rpb24gTVVuaWNhc3QobmFtZSwgcGF5bG9hZCl7XG4gICAgdGhpcy5wcm90b2NvbCA9IG5hbWUgfHwgJ3VuaWNhc3QnO1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG59O1xubW9kdWxlLmV4cG9ydHMuTVVuaWNhc3QgPSBNVW5pY2FzdDtcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIE1VbmljYXN0ID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpLk1VbmljYXN0O1xuXG51dGlsLmluaGVyaXRzKFVuaWNhc3QsIEV2ZW50RW1pdHRlcik7XG5cbi8qIVxuICogVW5pY2FzdCBjb21wb25lbnQgdGhhdCBzaW1wbHkgY2hvc2UgYSByYW5kb20gcGVlciBhbmQgc2VuZCBhIG1lc3NhZ2VcbiAqIFxccGFyYW0gc291cmNlIHRoZSBwcm90b2NvbCByZWNlaXZpbmcgdGhlIG1lc3NhZ2VzXG4gKiBcXHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIHByb3RvY29sLCBkZWZhdWx0IGlzICd1bmljYXN0J1xuICovXG5mdW5jdGlvbiBVbmljYXN0KHNvdXJjZSwgbWF4LCBuYW1lKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCAndW5pY2FzdCc7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc291cmNlLm9uKHNlbGYubmFtZSsnLXJlY2VpdmUnLCBmdW5jdGlvbihzb2NrZXQsIG1lc3NhZ2Upe1xuICAgICAgICBzZWxmLmVtaXQoJ3JlY2VpdmUnLCBzb2NrZXQsIG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgfSk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgc2VuZCB0aGUgbWVzc2FnZSB0byBvbmUgcmFuZG9tIHBhcnRpY2lwYW50XG4gKiBcXHBhcmFtIG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gc2VuZFxuICogXFxwYXJhbSBzb2NrZXQgb3B0aW9uYWwga25vd24gc29ja2V0XG4gKi9cblVuaWNhc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlLCBzb2NrZXQpe1xuICAgIC8vICMxIGdldCB0aGUgbmVpZ2hib3Job29kIGFuZCBjcmVhdGUgdGhlIG1lc3NhZ2VcbiAgICB2YXIgbGlua3MgPSAoc29ja2V0ICYmIFtzb2NrZXRdKSB8fCB0aGlzLnNvdXJjZS5nZXRQZWVycygxKTtcbiAgICB2YXIgbVVuaWNhc3QgPSBuZXcgTVVuaWNhc3QodGhpcy5uYW1lLCBtZXNzYWdlKTtcbiAgICAvLyAjMiBzZW5kIHRoZSBtZXNzYWdlXG4gICAgaWYgKGxpbmtzLmxlbmd0aD4wICYmIGxpbmtzWzBdLmNvbm5lY3RlZCl7XG4gICAgICAgIGxpbmtzWzBdLnNlbmQobVVuaWNhc3QpO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaWNhc3Q7XG4iLCJ2YXIgQkkgPSByZXF1aXJlKCdCaWdJbnQnKTtcblxuLyohXG4gKiBcXGNsYXNzIEJhc2VcbiAqIFxcYnJpZWYgcHJvdmlkZXMgYmFzaWMgZnVuY3Rpb24gdG8gYml0IG1hbmlwdWxhdGlvblxuICogXFxwYXJhbSBiIHRoZSBudW1iZXIgb2YgYml0cyBhdCBsZXZlbCAwIG9mIHRoZSBkZW5zZSBzcGFjZVxuICovXG5mdW5jdGlvbiBCYXNlKGIpeyAgICBcbiAgICB2YXIgREVGQVVMVF9CQVNFID0gMztcbiAgICB0aGlzLl9iID0gYiB8fCBERUZBVUxUX0JBU0U7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgUHJvY2VzcyB0aGUgbnVtYmVyIG9mIGJpdHMgdXNhZ2UgYXQgYSBjZXJ0YWluIGxldmVsIG9mIGRlbnNlIHNwYWNlXG4gKiBcXHBhcmFtIGxldmVsIHRoZSBsZXZlbCBpbiBkZW5zZSBzcGFjZSwgaS5lLiwgdGhlIG51bWJlciBvZiBjb25jYXRlbmF0aW9uXG4gKi9cbkJhc2UucHJvdG90eXBlLmdldEJpdEJhc2UgPSBmdW5jdGlvbihsZXZlbCl7XG4gICAgcmV0dXJuIHRoaXMuX2IgKyBsZXZlbDtcbn07XG5cbi8qIVxuICogXFxicmllZiBQcm9jZXNzIHRoZSB0b3RhbCBudW1iZXIgb2YgYml0cyB1c2FnZSB0byBnZXQgdG8gYSBjZXJ0YWluIGxldmVsXG4gKiBcXHBhcmFtIGxldmVsIHRoZSBsZXZlbCBpbiBkZW5zZSBzcGFjZVxuICovXG5CYXNlLnByb3RvdHlwZS5nZXRTdW1CaXQgPSBmdW5jdGlvbihsZXZlbCl7XG4gICAgdmFyIG4gPSB0aGlzLmdldEJpdEJhc2UobGV2ZWwpLFxuICAgICAgICBtID0gdGhpcy5fYi0xO1xuICAgIHJldHVybiAobiAqIChuICsgMSkpIC8gMiAtIChtICogKG0gKyAxKSAvIDIpO1xufTtcblxuLyohXG4gIFxcYnJpZWYgcHJvY2VzcyB0aGUgaW50ZXJ2YWwgYmV0d2VlbiB0d28gTFNFUU5vZGVcbiAgXFxwYXJhbSBwIHRoZSBwcmV2aW91cyBMU0VRTm9kZVxuICBcXHBhcmFtIHEgdGhlIG5leHQgTFNFUU5vZGVcbiAgXFxwYXJhbSBsZXZlbCB0aGUgZGVwdGggb2YgdGhlIHRyZWUgdG8gcHJvY2Vzc1xuICBcXHJldHVybiBhbiBpbnRlZ2VyIHdoaWNoIGlzIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSB0d28gbm9kZSBhdCB0aGUgZGVwdGhcbiovXG5CYXNlLnByb3RvdHlwZS5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKHAsIHEsIGxldmVsKXtcbiAgICB2YXIgc3VtID0gMCwgaSA9IDAsXG4gICAgICAgIHBJc0dyZWF0ZXIgPSBmYWxzZSwgY29tbW9uUm9vdCA9IHRydWUsXG4gICAgICAgIHByZXZWYWx1ZSA9IDAsIG5leHRWYWx1ZSA9IDA7XG4gICAgXG4gICAgd2hpbGUgKGk8PWxldmVsKXtcbiAgICAgICAgcHJldlZhbHVlID0gMDsgaWYgKHAgIT09IG51bGwpeyBwcmV2VmFsdWUgPSBwLnQucDsgfVxuICAgICAgICBuZXh0VmFsdWUgPSAwOyBpZiAocSAhPT0gbnVsbCl7IG5leHRWYWx1ZSA9IHEudC5wOyB9XG4gICAgICAgIGlmIChjb21tb25Sb290ICYmIHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKXtcbiAgICAgICAgICAgIGNvbW1vblJvb3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHBJc0dyZWF0ZXIgPSBwcmV2VmFsdWUgPiBuZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBJc0dyZWF0ZXIpeyBuZXh0VmFsdWUgPSBNYXRoLnBvdygyLHRoaXMuZ2V0Qml0QmFzZShpKSktMTsgfVxuICAgICAgICBpZiAoY29tbW9uUm9vdCB8fCBwSXNHcmVhdGVyIHx8IGkhPT1sZXZlbCl7XG4gICAgICAgICAgICBzdW0gKz0gbmV4dFZhbHVlIC0gcHJldlZhbHVlOyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1bSArPSBuZXh0VmFsdWUgLSBwcmV2VmFsdWUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIT09bGV2ZWwpe1xuICAgICAgICAgICAgc3VtICo9IE1hdGgucG93KDIsdGhpcy5nZXRCaXRCYXNlKGkrMSkpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocCE9PW51bGwgJiYgcC5jaGlsZHJlbi5sZW5ndGghPT0wKXtwPXAuY2hpbGRyZW5bMF07fSBlbHNle3A9bnVsbDt9O1xuICAgICAgICBpZiAocSE9PW51bGwgJiYgcS5jaGlsZHJlbi5sZW5ndGghPT0wKXtxPXEuY2hpbGRyZW5bMF07fSBlbHNle3E9bnVsbDt9O1xuICAgICAgICArK2k7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59O1xuXG5CYXNlLmluc3RhbmNlID0gbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcmdzKXtcbiAgICBpZiAoYXJncyl7XG4gICAgICAgIEJhc2UuaW5zdGFuY2UgPSBuZXcgQmFzZShhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQmFzZS5pbnN0YW5jZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICBCYXNlLmluc3RhbmNlID0gbmV3IEJhc2UoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlLmluc3RhbmNlO1xufTtcbiIsInZhciBCSSA9IHJlcXVpcmUoJ0JpZ0ludCcpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKSgpO1xudmFyIFRyaXBsZSA9IHJlcXVpcmUoJy4vdHJpcGxlLmpzJyk7XG52YXIgTFNFUU5vZGUgPSByZXF1aXJlKCcuL2xzZXFub2RlLmpzJyk7XG5cbi8qIVxuICogXFxjbGFzcyBJZGVudGlmaWVyXG4gKiBcXGJyaWVmIFVuaXF1ZSBhbmQgaW1tdXRhYmxlIGlkZW50aWZpZXIgY29tcG9zZWQgb2YgZGlnaXQsIHNvdXJjZXMsIGNvdW50ZXJzXG4gKiBcXHBhcmFtIGQgdGhlIGRpZ2l0IChwb3NpdGlvbiBpbiBkZW5zZSBzcGFjZSlcbiAqIFxccGFyYW0gcyB0aGUgbGlzdCBvZiBzb3VyY2VzXG4gKiBcXHBhcmFtIGMgdGhlIGxpc3Qgb2YgY291bnRlcnNcbiAqL1xuZnVuY3Rpb24gSWRlbnRpZmllcihkLCBzLCBjKXtcbiAgICB0aGlzLl9kID0gZDtcbiAgICB0aGlzLl9zID0gcztcbiAgICB0aGlzLl9jID0gYztcbn07XG5cbi8qIVxuICogXFxicmllZiBzZXQgdGhlIGQscyxjIHZhbHVlcyBhY2NvcmRpbmcgdG8gdGhlIG5vZGUgaW4gYXJndW1lbnRcbiAqIFxccGFyYW0gbm9kZSB0aGUgbHNlcW5vZGUgY29udGFpbmluZyB0aGUgcGF0aCBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmVcbiAqL1xuSWRlbnRpZmllci5wcm90b3R5cGUuZnJvbU5vZGUgPSBmdW5jdGlvbihub2RlKXtcbiAgICAvLyAjMSBwcm9jZXNzIHRoZSBsZW5ndGggb2YgdGhlIHBhdGhcbiAgICB2YXIgbGVuZ3RoID0gMSwgdGVtcE5vZGUgPSBub2RlLCBpID0gMDtcbiAgICBcbiAgICB3aGlsZSAodGVtcE5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKXtcblx0KytsZW5ndGg7XG4gICAgICAgIHRlbXBOb2RlID0gdGVtcE5vZGUuY2hpbGRyZW5bMF07XG4gICAgfTtcbiAgICAvLyAjMSBjb3B5IHRoZSB2YWx1ZXMgY29udGFpbmVkIGluIHRoZSBwYXRoXG4gICAgdGhpcy5fZCA9IEJJLmludDJiaWdJbnQoMCxCYXNlLmdldFN1bUJpdChsZW5ndGggLSAxKSk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggOyArK2kpe1xuICAgICAgICAvLyAjMWEgY29weSB0aGUgc2l0ZSBpZFxuICAgICAgICB0aGlzLl9zLnB1c2gobm9kZS50LnMpO1xuICAgICAgICAvLyAjMWIgY29weSB0aGUgY291bnRlclxuICAgICAgICB0aGlzLl9jLnB1c2gobm9kZS50LmMpO1xuICAgICAgICAvLyAjMWMgY29weSB0aGUgZGlnaXRcbiAgICAgICAgQkkuYWRkSW50Xyh0aGlzLl9kLCBub2RlLnQucCk7XG4gICAgICAgIGlmIChpIT09KGxlbmd0aC0xKSl7XG4gICAgICAgICAgICBCSS5sZWZ0U2hpZnRfKHRoaXMuX2QsIEJhc2UuZ2V0Qml0QmFzZShpKzEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgfTtcbn07XG5cbi8qIVxuICogXFxicmllZiBjb252ZXJ0IHRoZSBpZGVudGlmaWVyIGludG8gYSBub2RlIHdpdGhvdXQgZWxlbWVudFxuICogXFxwYXJhbSBlIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZVxuICovXG5JZGVudGlmaWVyLnByb3RvdHlwZS50b05vZGUgPSBmdW5jdGlvbihlKXtcbiAgICB2YXIgcmVzdWx0UGF0aCA9IFtdLCBkQml0TGVuZ3RoID0gQmFzZS5nZXRTdW1CaXQodGhpcy5fYy5sZW5ndGggLTEpLCBpID0gMCxcbiAgICAgICAgbWluZTtcbiAgICAvLyAjMSBkZWNvbnN0cnVjdCB0aGUgZGlnaXQgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jLmxlbmd0aDsgKytpKXtcbiAgICAgICAgLy8gIzEgdHJ1bmNhdGUgbWluZVxuICAgICAgICBtaW5lID0gQkkuZHVwKHRoaXMuX2QpO1xuICAgICAgICAvLyAjMWEgc2hpZnQgcmlnaHQgdG8gZXJhc2UgdGhlIHRhaWwgb2YgdGhlIHBhdGhcbiAgICAgICAgQkkucmlnaHRTaGlmdF8obWluZSwgZEJpdExlbmd0aCAtIEJhc2UuZ2V0U3VtQml0KGkpKTtcbiAgICAgICAgLy8gIzFiIGNvcHkgdmFsdWUgaW4gdGhlIHJlc3VsdFxuICAgICAgICByZXN1bHRQYXRoLnB1c2gobmV3IFRyaXBsZShCSS5tb2RJbnQobWluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KDIsQmFzZS5nZXRCaXRCYXNlKGkpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NbaV0pKTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgTFNFUU5vZGUocmVzdWx0UGF0aCwgZSk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgY29tcGFyZSB0d28gaWRlbnRpZmllcnNcbiAqIFxccGFyYW0gbyB0aGUgb3RoZXIgaWRlbnRpZmllclxuICogXFxyZXR1cm4gLTEgaWYgdGhpcyBpcyBsb3dlciwgMCBpZiB0aGV5IGFyZSBlcXVhbCwgMSBpZiB0aGlzIGlzIGdyZWF0ZXJcbiAqL1xuSWRlbnRpZmllci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKG8pe1xuICAgIHZhciBkQml0TGVuZ3RoID0gQmFzZS5nZXRTdW1CaXQodGhpcy5fYy5sZW5ndGggLSAxKSxcbiAgICAgICAgb2RCaXRMZW5ndGggPSBCYXNlLmdldFN1bUJpdChvLl9jLmxlbmd0aCAtIDEpLFxuICAgICAgICBjb21wYXJpbmcgPSB0cnVlLFxuICAgICAgICBjb21wID0gMCwgaSA9IDAsXG4gICAgICAgIHN1bSwgbWluZSwgb3RoZXI7XG4gICAgXG4gICAgLy8gIzEgQ29tcGFyZSB0aGUgbGlzdCBvZiA8ZCxzLGM+XG4gICAgd2hpbGUgKGNvbXBhcmluZyAmJiBpIDwgTWF0aC5taW4odGhpcy5fYy5sZW5ndGgsIG8uX2MubGVuZ3RoKSApIHtcbiAgICAgICAgLy8gY2FuIHN0b3AgYmVmb3JlIHRoZSBlbmQgb2YgZm9yIGxvb3Agd2l6IHJldHVyblxuICAgICAgICBzdW0gPSBCYXNlLmdldFN1bUJpdChpKTtcbiAgICAgICAgLy8gIzFhIHRydW5jYXRlIG1pbmVcbiAgICAgICAgbWluZSA9IEJJLmR1cCh0aGlzLl9kKTtcbiAgICAgICAgQkkucmlnaHRTaGlmdF8obWluZSwgZEJpdExlbmd0aCAtIHN1bSk7XG4gICAgICAgIC8vICMxYiB0cnVuY2F0ZSBvdGhlclxuICAgICAgICBvdGhlciA9IEJJLmR1cChvLl9kKTtcbiAgICAgICAgQkkucmlnaHRTaGlmdF8ob3RoZXIsIG9kQml0TGVuZ3RoIC0gc3VtKTtcbiAgICAgICAgLy8gIzIgQ29tcGFyZSB0cmlwbGVzXG4gICAgICAgIGlmICghQkkuZXF1YWxzKG1pbmUsb3RoZXIpKSB7ICAvLyAjMmEgZGlnaXRcbiAgICAgICAgICAgIGlmIChCSS5ncmVhdGVyKG1pbmUsb3RoZXIpKXtjb21wID0gMTt9ZWxzZXtjb21wID0gLTE7fTtcbiAgICAgICAgICAgIGNvbXBhcmluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcCA9IHRoaXMuX3NbaV0gLSBvLl9zW2ldOyAvLyAjMmIgc291cmNlXG4gICAgICAgICAgICBpZiAoY29tcCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbXBhcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5fY1tpXSAtIG8uX2NbaV07IC8vIDJjIGNsb2NrXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgICsraTtcbiAgICB9O1xuICAgIFxuICAgIGlmIChjb21wPT09MCl7XG4gICAgICAgIGNvbXAgPSB0aGlzLl9jLmxlbmd0aCAtIG8uX2MubGVuZ3RoOyAvLyAjMyBjb21wYXJlIGxpc3Qgc2l6ZVxuICAgIH07XG4gICAgcmV0dXJuIGNvbXA7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSWRlbnRpZmllcjtcbiIsInZhciBUcmlwbGUgPSByZXF1aXJlKCcuL3RyaXBsZS5qcycpO1xucmVxdWlyZSgnLi91dGlsLmpzJyk7XG5cbi8qIVxuICogXFxicmllZiBhIG5vZGUgb2YgdGhlIExTRVEgdHJlZVxuICogXFxwYXJhbSB0cmlwbGVMaXN0IHRoZSBsaXN0IG9mIHRyaXBsZSBjb21wb3NpbmcgdGhlIHBhdGggdG8gdGhlIGVsZW1lbnRcbiAqIFxccGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHN0cnVjdHVyZVxuICovXG5mdW5jdGlvbiBMU0VRTm9kZSh0cmlwbGVMaXN0LCBlbGVtZW50KXtcbiAgICB0aGlzLnQgPSB0cmlwbGVMaXN0LnNoaWZ0KCk7XG4gICAgaWYgKHRyaXBsZUxpc3QubGVuZ3RoID09PSAwKXtcbiAgICAgICAgdGhpcy5lID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5zdWJDb3VudGVyID0gMDsgLy8gY291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBhbmQgc3ViY2hpbGRyZW5cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViQ291bnRlciA9IDE7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5ldyBMU0VRTm9kZSh0cmlwbGVMaXN0LCBlbGVtZW50KSk7XG4gICAgfTtcbn07XG5cbi8qIVxuICogXFxicmllZiBhZGQgYSBwYXRoIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgbm9kZVxuICogXFxwYXJhbSBub2RlIHRoZSBub2RlIHRvIGFkZCBhcyBhIGNoaWxkcmVuIG9mIHRoaXMgbm9kZVxuICogXFxyZXR1cm4gLTEgaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBleGlzdHNcbiAqL1xuTFNFUU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5vZGUpe1xuICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uYmluYXJ5SW5kZXhPZihub2RlKTtcbiAgICBcbiAgICAvLyAjMSBpZiB0aGUgcGF0aCBkbyBubyBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAgfHxcbiAgICAgICAgKGluZGV4ID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBcbiAgICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uY29tcGFyZShub2RlKSE9PTApKXtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoLWluZGV4LCAwLCBub2RlKTtcbiAgICAgICAgdGhpcy5zdWJDb3VudGVyKz0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICMyIG90aGVyd2lzZSwgY29udGludWUgdG8gZXhwbG9yZSB0aGUgc3VidHJlZXNcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICAgIC8vICMyYSBjaGVjayBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baW5kZXhdLmUgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpbmRleF0uZSA9IG5vZGUuZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YkNvdW50ZXIrPTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gIzMgaWYgZGlkbm90IGV4aXN0LCBpbmNyZW1lbnQgdGhlIGNvdW50ZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2luZGV4XS5hZGQobm9kZS5jaGlsZHJlblswXSkhPT0tMSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJDb3VudGVyKz0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxuLyohIFxuICogXFxicmllZiByZW1vdmUgdGhlIG5vZGUgb2YgdGhlIHRyZWUgYW5kIGFsbCBub2RlIHdpdGhpbiBwYXRoIGJlaW5nIHVzZWxlc3NcbiAqIFxccGFyYW0gbm9kZSB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwYXRoIHRvIHJlbW92ZVxuICogXFxyZXR1cm4gLTEgaWYgdGhlIG5vZGUgZG9lcyBub3QgZXhpc3RcbiAqL1xuTFNFUU5vZGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKG5vZGUpe1xuICAgIHZhciBpbmRleGVzID0gdGhpcy5nZXRJbmRleGVzKG5vZGUpLFxuICAgICAgICBjdXJyZW50VHJlZSA9IHRoaXMsIGkgPSAwLCBpc1NwbGl0dGVkID0gZmFsc2U7XG5cbiAgICBpZiAoaW5kZXhlcyA9PT0gLTEpIHsgcmV0dXJuIC0xOyB9OyAvLyBpdCBkb2VzIG5vdCBleGlzdHNcbiAgICB0aGlzLnN1YkNvdW50ZXIgLT0gMTtcbiAgICB3aGlsZSAoaSA8IGluZGV4ZXMubGVuZ3RoICYmICEoaXNTcGxpdHRlZCkpe1xuICAgICAgICBpZiAoIShjdXJyZW50VHJlZS5jaGlsZHJlbltpbmRleGVzW2ldXS5lICE9PSBudWxsICYmXG4gICAgICAgICAgICAgIGk9PT0oaW5kZXhlcy5sZW5ndGggLSAxKSkpe1xuICAgICAgICAgICAgY3VycmVudFRyZWUuY2hpbGRyZW5baW5kZXhlc1tpXV0uc3ViQ291bnRlciAtPSAxOyAgICAgXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdXJyZW50VHJlZS5jaGlsZHJlbltpbmRleGVzW2ldXS5zdWJDb3VudGVyIDw9IDBcbiAgICAgICAgICAgICYmIChjdXJyZW50VHJlZS5jaGlsZHJlbltpbmRleGVzW2ldXS5lID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGN1cnJlbnRUcmVlLmNoaWxkcmVuW2luZGV4ZXNbaV1dLmUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgaT09PShpbmRleGVzLmxlbmd0aCAtIDEpKSkpe1xuICAgICAgICAgICAgY3VycmVudFRyZWUuY2hpbGRyZW4uc3BsaWNlKGluZGV4ZXNbaV0sMSk7XG4gICAgICAgICAgICBpc1NwbGl0dGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50VHJlZS5jaGlsZHJlbltpbmRleGVzW2ldXTtcbiAgICAgICAgKytpO1xuICAgIH07XG4gICAgaWYgKCFpc1NwbGl0dGVkKXsgY3VycmVudFRyZWUuZSA9IG51bGw7fTtcbn07XG5cbi8qIVxuICogXFxicmllZiBjb21wYXJpc29uIGZ1bmN0aW9uIHVzZWQgdG8gb3JkZXIgdGhlIGxpc3Qgb2YgY2hpbGRyZW4gYXQgZWFjaCBub2RlXG4gKiBcXHBhcmFtIG8gdGhlIG90aGVyIG5vZGUgdG8gY29tcGFyZSB3aXRoXG4gKi9cbkxTRVFOb2RlLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24obyl7XG4gICAgcmV0dXJuIHRoaXMudC5jb21wYXJlKG8udCk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgdGhlIG9yZGVyZWQgdHJlZSBjYW4gYmUgbGluZWFyaXplZCBpbnRvIGEgc2VxdWVuY2UuIFRoaXMgZnVuY3Rpb24gZ2V0XG4gKiB0aGUgaW5kZXggb2YgdGhlIHBhdGggcmVwcmVzZW50ZWQgYnkgdGhlIGxpc3Qgb2YgdHJpcGxlc1xuICogXFxwYXJhbSBub2RlIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBhdGhcbiAqIFxccmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgcGF0aCBpbiB0aGUgbm9kZVxuICovXG5MU0VRTm9kZS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uKG5vZGUpe1xuICAgIHZhciBpbmRleGVzID0gdGhpcy5nZXRJbmRleGVzKG5vZGUpLFxuICAgICAgICBzdW0gPSAwLCBjdXJyZW50VHJlZSA9IHRoaXMsXG4gICAgICAgIGogPSAwO1xuICAgIGlmIChpbmRleGVzID09PSAtMSl7cmV0dXJuIC0xO307IC8vIG5vZGUgZG9lcyBub3QgZXhpc3RcbiAgICBpZiAodGhpcy5lICE9PSBudWxsKXsgc3VtICs9MTsgfTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaTxpbmRleGVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaWYgKGluZGV4ZXNbaV0gPCAoY3VycmVudFRyZWUuY2hpbGRyZW4ubGVuZ3RoLzIpKXtcbiAgICAgICAgICAgIC8vICNBIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGo8aW5kZXhlc1tpXTsgKytqKXtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRyZWUuY2hpbGRyZW5bal0uZSAhPT0gbnVsbCl7IHN1bSs9MTsgfTtcbiAgICAgICAgICAgICAgICBzdW0gKz0gY3VycmVudFRyZWUuY2hpbGRyZW5bal0uc3ViQ291bnRlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAjQiBzdGFydCBmcm9tIHRoZSBlbmRcbiAgICAgICAgICAgIHN1bSArPSBjdXJyZW50VHJlZS5zdWJDb3VudGVyO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGN1cnJlbnRUcmVlLmNoaWxkcmVuLmxlbmd0aC0xOyBqPj1pbmRleGVzW2ldOy0tail7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUcmVlLmNoaWxkcmVuW2pdLmUgIT09IG51bGwpeyBzdW0tPTE7IH07XG4gICAgICAgICAgICAgICAgc3VtIC09IGN1cnJlbnRUcmVlLmNoaWxkcmVuW2pdLnN1YkNvdW50ZXI7ICBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdXJyZW50VHJlZS5jaGlsZHJlbltqXS5lICE9PSBudWxsKXsgc3VtKz0xOyB9O1xuICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRUcmVlLmNoaWxkcmVuW2pdO1xuICAgIH07XG4gICAgcmV0dXJuIHN1bS0xOyAvLyAtMSBiZWNhdXNlIGFsZ29yaXRobSBjb3VudGVkIHRoZSBlbGVtZW50IGl0c2VsZlxufTtcblxuLyohXG4gKiBcXGJyaWVmIGdldCB0aGUgbGlzdCBvZiBpbmRleGVzIG9mIHRoZSBhcnJheXMgcmVwcmVzZW50aW5nIHRoZSBjaGlsZHJlbiBpblxuICogdGhlIHRyZWVcbiAqIFxccGFyYW0gbm9kZSB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwYXRoXG4gKiBcXHJldHVybiBhIGxpc3Qgb2YgaW50ZWdlclxuICovXG5MU0VRTm9kZS5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IGZ1bmN0aW9uKG5vZGUpe1xuICAgIGZ1bmN0aW9uIF9nZXRJbmRleGVzKGluZGV4ZXMsIGN1cnJlbnRUcmVlLCBjdXJyZW50Tm9kZSl7XG4gICAgICAgIHZhciBpbmRleCA9IGN1cnJlbnRUcmVlLmNoaWxkcmVuLmJpbmFyeUluZGV4T2YoY3VycmVudE5vZGUpO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8XG4gICAgICAgICAgICAoaW5kZXg9PT0wICYmIGN1cnJlbnRUcmVlLmNoaWxkcmVuLmxlbmd0aD09PTApKXsgcmV0dXJuIC0xOyB9XG4gICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg9PT0wIHx8XG4gICAgICAgICAgICBjdXJyZW50VHJlZS5jaGlsZHJlbi5sZW5ndGg9PT0wKXtcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2dldEluZGV4ZXMoaW5kZXhlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlLmNoaWxkcmVuW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgXG4gICAgfTtcbiAgICByZXR1cm4gX2dldEluZGV4ZXMoW10sIHRoaXMsIG5vZGUpO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIHRoZSBvcmRlcmVkIHRyZWUgY2FuIGJlIGxpbmVhcml6ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyB0aGUgbm9kZSBhdFxuICogdGhlIGluZGV4IGluIHRoZSBwcm9qZWN0ZWQgc2VxdWVuY2UuXG4gKiBcXHBhcmFtIGluZGV4IHRoZSBpbmRleCBpbiB0aGUgc2VxdWVuY2VcbiAqIFxccmV0dXJucyB0aGUgbm9kZSBhdCB0aGUgaW5kZXhcbiAqL1xuTFNFUU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4KXtcbiAgICBmdW5jdGlvbiBfZ2V0KGxlZnRTdW0sIGJ1aWxkaW5nTm9kZSwgcXVldWUsIGN1cnJlbnROb2RlKXtcbiAgICAgICAgdmFyIHN0YXJ0QmVnaW5uaW5nID0gdHJ1ZSwgdXNlRnVuY3Rpb24sIGkgPSAwLFxuICAgICAgICAgICAgcCwgdGVtcDtcbiAgICAgICAgLy8gIzAgdGhlIG5vZGUgaXMgZm91bmQsIHJldHVybiB0aGUgaW5jcmVtZW50YWxseSBidWlsdCBub2RlIGFuZCBwcmFpc2VcbiAgICAgICAgLy8gI3RoZSBzdW4gIVxuICAgICAgICBpZiAobGVmdFN1bSA9PT0gaW5kZXggJiYgY3VycmVudE5vZGUuZSAhPT0gbnVsbCl7XG4gICAgICAgICAgICAvLyAxYSBjb3B5IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBpbiB0aGUgcGF0aFxuICAgICAgICAgICAgcXVldWUuZSA9IGN1cnJlbnROb2RlLmU7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRpbmdOb2RlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VycmVudE5vZGUuZSAhPT0gbnVsbCl7IGxlZnRTdW0gKz0gMTsgfTtcblxuICAgICAgICAvLyAjMSBzZWFyY2g6IGRvIEkgc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9yIHRoZSBlbmRcbiAgICAgICAgc3RhcnRCZWdpbm5pbmcgPSAoKGluZGV4LWxlZnRTdW0pPChjdXJyZW50Tm9kZS5zdWJDb3VudGVyLzIpKTtcbiAgICAgICAgaWYgKHN0YXJ0QmVnaW5uaW5nKXtcbiAgICAgICAgICAgIHVzZUZ1bmN0aW9uID0gZnVuY3Rpb24oYSxiKXtyZXR1cm4gYStiO307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0U3VtICs9IGN1cnJlbnROb2RlLnN1YkNvdW50ZXI7XG4gICAgICAgICAgICB1c2VGdW5jdGlvbiA9IGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYjt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIzJhIGNvdW50aW5nIHRoZSBlbGVtZW50IGZyb20gbGVmdCB0byByaWdodFxuICAgICAgICBpZiAoIXN0YXJ0QmVnaW5uaW5nKSB7IGkgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGgtMTsgfTtcbiAgICAgICAgd2hpbGUgKChzdGFydEJlZ2lubmluZyAmJiBsZWZ0U3VtIDw9IGluZGV4KSB8fFxuICAgICAgICAgICAgICAgKCFzdGFydEJlZ2lubmluZyAmJiBsZWZ0U3VtID4gaW5kZXgpKXtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5jaGlsZHJlbltpXS5lIT09bnVsbCl7XG4gICAgICAgICAgICAgICAgbGVmdFN1bSA9IHVzZUZ1bmN0aW9uKGxlZnRTdW0sIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxlZnRTdW0gPSB1c2VGdW5jdGlvbihsZWZ0U3VtLGN1cnJlbnROb2RlLmNoaWxkcmVuW2ldLnN1YkNvdW50ZXIpO1xuICAgICAgICAgICAgaSA9IHVzZUZ1bmN0aW9uKGksIDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vICMyYiBkZWNyZWFzaW5nIHRoZSBpbmNyZW1lbnRhdGlvblxuICAgICAgICBpID0gdXNlRnVuY3Rpb24oaSwtMSk7XG4gICAgICAgIGlmIChzdGFydEJlZ2lubmluZyl7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY2hpbGRyZW5baV0uZSE9PW51bGwpe1xuICAgICAgICAgICAgICAgIGxlZnRTdW0gPSB1c2VGdW5jdGlvbihsZWZ0U3VtLCAtMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGVmdFN1bSA9IHVzZUZ1bmN0aW9uKGxlZnRTdW0sLWN1cnJlbnROb2RlLmNoaWxkcmVuW2ldLnN1YkNvdW50ZXIpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gIzMgYnVpbGQgcGF0aFxuICAgICAgICBwID0gW107IHAucHVzaChjdXJyZW50Tm9kZS5jaGlsZHJlbltpXS50KTtcbiAgICAgICAgaWYgKGJ1aWxkaW5nTm9kZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICBidWlsZGluZ05vZGUgPSBuZXcgTFNFUU5vZGUocCxudWxsKTtcbiAgICAgICAgICAgIHF1ZXVlID0gYnVpbGRpbmdOb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IG5ldyBMU0VRTm9kZShwLG51bGwpO1xuICAgICAgICAgICAgcXVldWUuYWRkKHRlbXApO1xuICAgICAgICAgICAgcXVldWUgPSB0ZW1wO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2dldChsZWZ0U3VtLCBidWlsZGluZ05vZGUsIHF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbltpXSk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldCgwLCBudWxsLCBudWxsLCB0aGlzKTtcbn07XG5cbi8qIVxuICogXFxicmllZiBjYXN0IHRoZSBKU09OIG9iamVjdCB0byBhIExTRVFOb2RlXG4gKiBcXHBhcmFtIG9iamVjdCB0aGUgSlNPTiBvYmplY3RcbiAqIFxccmV0dXJuIGEgc2VsZiByZWZlcmVuY2VcbiAqL1xuTFNFUU5vZGUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICB0aGlzLnQgPSBuZXcgVHJpcGxlKG9iamVjdC50LnAsIG9iamVjdC50LnMsIG9iamVjdC50LmMpO1xuICAgIGlmIChvYmplY3QuY2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgICAgdGhpcy5lID0gb2JqZWN0LmU7XG4gICAgICAgIHRoaXMuc3ViQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmUgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YkNvdW50ZXIgPSAxO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChcbiAgICAgICAgICAgIChuZXcgTFNFUU5vZGUoW10sIG51bGwpLmZyb21KU09OKG9iamVjdC5jaGlsZHJlblswXSkpKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMU0VRTm9kZTtcbiIsInZhciBCSSA9IHJlcXVpcmUoJ0JpZ0ludCcpO1xudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKSgxNSk7XG52YXIgUyA9IHJlcXVpcmUoJy4vc3RyYXRlZ3kuanMnKSgxMCk7XG52YXIgSUQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXIuanMnKTtcbnZhciBUcmlwbGUgPSByZXF1aXJlKCcuL3RyaXBsZS5qcycpO1xudmFyIExTRVFOb2RlID0gcmVxdWlyZSgnLi9sc2Vxbm9kZS5qcycpO1xuXG4vKiFcbiAqIFxcY2xhc3MgTFNFUVRyZWVcbiAqXG4gKiBcXGJyaWVmIERpc3RyaWJ1dGVkIGFycmF5IHVzaW5nIExTRVEgYWxsb2NhdGlvbiBzdHJhdGVneSB3aXRoIGFuIHVuZGVybHlpbmdcbiAqIGV4cG9uZW50aWFsIHRyZWUgbW9kZWxcbiAqL1xuZnVuY3Rpb24gTFNFUVRyZWUocyl7XG4gICAgdmFyIGxpc3RUcmlwbGU7XG4gICAgXG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5fYyA9IDA7XG4gICAgdGhpcy5faGFzaCA9IGZ1bmN0aW9uKGRlcHRoKSB7IHJldHVybiBkZXB0aCUyOyB9O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMucm9vdCA9IG5ldyBMU0VRTm9kZShbXSxudWxsKTtcbiAgICBsaXN0VHJpcGxlID0gW107IGxpc3RUcmlwbGUucHVzaChuZXcgVHJpcGxlKDAsMCwwKSk7ICAvLyBtaW4gYm91bmRcbiAgICB0aGlzLnJvb3QuYWRkKG5ldyBMU0VRTm9kZShsaXN0VHJpcGxlLCBcIlwiKSk7XG4gICAgbGlzdFRyaXBsZSA9IFtdO1xuICAgIGxpc3RUcmlwbGUucHVzaChuZXcgVHJpcGxlKE1hdGgucG93KDIsQmFzZS5nZXRCaXRCYXNlKDApKS0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLk1BWF9WQUxVRSkpOyAvLyBtYXggYm91bmRcbiAgICB0aGlzLnJvb3QuYWRkKG5ldyBMU0VRTm9kZShsaXN0VHJpcGxlLCBcIlwiKSk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgcmV0dXJuIHRoZSBMU0VRTm9kZSBvZiB0aGUgZWxlbWVudCBhdCAgdGFyZ2V0ZWQgaW5kZXhcbiAqIFxccGFyYW0gaW5kZXggdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBmbGF0dGVuZWQgYXJyYXlcbiAqIFxccmV0dXJuIHRoZSBMU0VRTm9kZSB0YXJnZXRpbmcgdGhlIGVsZW1lbnQgYXQgaW5kZXhcbiAqL1xuTFNFUVRyZWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4KXtcbiAgICAvLyAjMSBzZWFyY2ggaW4gdGhlIHRyZWUgdG8gZ2V0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB0aGlzLnJvb3QuZ2V0KGluZGV4KTtcbn07XG5cbi8qIVxuICogXFxicmllZiBpbnNlcnQgYSB2YWx1ZSBhdCB0aGUgdGFyZ2V0ZWQgaW5kZXhcbiAqIFxccGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBpbnNlcnRcbiAqIFxccGFyYW0gaW5kZXggdGhlIHBvc2l0aW9uIGluIHRoZSBhcnJheVxuICogXFxyZXR1cm4gYSBwYWlyIHtfZTogZWxlbWVudCAsIF9pOiBpZGVudGlmaWVyfVxuICovXG5MU0VRVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpe1xuICAgIHZhciBwZWkgPSB0aGlzLmdldChpbmRleCksIC8vICMxYSBwcmV2aW91cyBib3VuZFxuICAgICAgICBxZWkgPSB0aGlzLmdldChpbmRleCsxKSwgLy8gIzFiIG5leHQgYm91bmRcbiAgICAgICAgaWQsIGNvdXBsZTtcbiAgICB0aGlzLl9jICs9IDE7IC8vICMyYSBpbmNyZW1lbnRpbmcgdGhlIGxvY2FsIGNvdW50ZXJcbiAgICBpZCA9IHRoaXMuYWxsb2MocGVpLCBxZWkpOyAvLyAjMmIgZ2VuZXJhdGluZyB0aGUgaWQgaW5iZXR3ZWVuIHRoZSBib3VuZHNcbiAgICAvLyAjMyBhZGQgaXQgdG8gdGhlIHN0cnVjdHVyZSBhbmQgcmV0dXJuIHZhbHVlXG4gICAgY291cGxlID0ge19lOiBlbGVtZW50LCBfaTogaWR9XG4gICAgdGhpcy5hcHBseUluc2VydChlbGVtZW50LCBpZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGNvdXBsZTtcbn07XG5cbi8qIVxuICogXFxicmllZiBkZWxldGUgdGhlIGVsZW1lbnQgYXQgdGhlIGluZGV4XG4gKiBcXHBhcmFtIGluZGV4IHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBkZWxldGUgaW4gdGhlIGFycmF5XG4gKiBcXHJldHVybiB0aGUgaWRlbnRpZmllciBvZiB0aGUgZWxlbWVudCBhdCB0aGUgaW5kZXhcbiAqL1xuTFNFUVRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGluZGV4KXtcbiAgICB2YXIgZWkgPSB0aGlzLmdldChpbmRleCsxKSxcbiAgICAgICAgaSA9IG5ldyBJRChudWxsLCBbXSwgW10pO1xuICAgIGkuZnJvbU5vZGUoZWkpOyAvLyBmcm9tIG5vZGUgLT4gaWRcbiAgICB0aGlzLmFwcGx5UmVtb3ZlKGVpKTsgXG4gICAgcmV0dXJuIGk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgZ2VuZXJhdGUgdGhlIGRpZ2l0IHBhcnQgb2YgdGhlIGlkZW50aWZpZXJzICBiZXR3ZWVuIHAgYW5kIHFcbiAqIFxccGFyYW0gcCB0aGUgZGlnaXQgcGFydCBvZiB0aGUgcHJldmlvdXMgaWRlbnRpZmllclxuICogXFxwYXJhbSBxIHRoZSBkaWdpdCBwYXJ0IG9mIHRoZSBuZXh0IGlkZW50aWZpZXJcbiAqIFxccmV0dXJuIHRoZSBkaWdpdCBwYXJ0IGxvY2F0ZWQgYmV0d2VlbiBwIGFuZCBxXG4gKi9cbkxTRVFUcmVlLnByb3RvdHlwZS5hbGxvYyA9IGZ1bmN0aW9uIChwLHEpe1xuICAgIHZhciBpbnRlcnZhbCA9IDAsIGxldmVsID0gMDtcbiAgICAvLyAjMSBwcm9jZXNzIHRoZSBsZXZlbCBvZiB0aGUgbmV3IGlkZW50aWZpZXJcbiAgICB3aGlsZSAoaW50ZXJ2YWw8PTApeyAvLyBubyByb29tIGZvciBpbnNlcnRpb25cbiAgICAgICAgaW50ZXJ2YWwgPSBCYXNlLmdldEludGVydmFsKHAsIHEsIGxldmVsKTsgLy8gKFRPRE8pIG9wdGltaXplXG4gICAgICAgICsrbGV2ZWw7XG4gICAgfTtcbiAgICBsZXZlbCAtPSAxO1xuICAgIGlmICh0aGlzLl9oYXNoKGxldmVsKSA9PT0gMCl7XG4gICAgICAgIHJldHVybiBTLmJQbHVzKHAsIHEsIGxldmVsLCBpbnRlcnZhbCwgdGhpcy5fcywgdGhpcy5fYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFMuYk1pbnVzKHAsIHEsIGxldmVsLCBpbnRlcnZhbCwgdGhpcy5fcywgdGhpcy5fYyk7XG4gICAgfTtcbn07XG5cbi8qIVxuICogXFxicmllZiBpbnNlcnQgYW4gZWxlbWVudCBjcmVhdGVkIGZyb20gYSByZW1vdGUgc2l0ZSBpbnRvIHRoZSBhcnJheVxuICogXFxwYXJhbSBlIHRoZSBlbGVtZW50IHRvIGluc2VydFxuICogXFxwYXJhbSBpIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBlbGVtZW50XG4gKiBcXHBhcmFtIG5vSW5kZXggd2hldGhlciBvciBub3QgaXQgc2hvdWxkIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIGluc2VydFxuICogXFxyZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBuZXdseSBpbnNlcnRlZCBlbGVtZW50IGluIHRoZSBhcnJheVxuICovXG5MU0VRVHJlZS5wcm90b3R5cGUuYXBwbHlJbnNlcnQgPSBmdW5jdGlvbihlLCBpLCBub0luZGV4KXtcbiAgICB2YXIgbm9kZSwgcmVzdWx0O1xuICAgIC8vICMwIGNhc3QgZnJvbSB0aGUgcHJvcGVyIHR5cGVcbiAgICAvLyAjMEEgdGhlIGlkZW50aWZpZXIgaXMgYW4gSURcbiAgICBpZiAoaSAmJiBpLl9kICYmIGkuX3MgJiYgaS5fYyl7XG4gICAgICAgIG5vZGUgPSAobmV3IElEKGkuX2QsIGkuX3MsIGkuX2MpLnRvTm9kZShlKSk7XG4gICAgfTtcbiAgICAvLyAjMEIgdGhlIGlkZW50aWZpZXIgaXMgYSBMU0VRTm9kZVxuICAgIGlmIChpICYmIGkudCAmJiBpLmNoaWxkcmVuKXtcbiAgICAgICAgbm9kZSA9IChuZXcgTFNFUU5vZGUoW10sbnVsbCkpLmZyb21KU09OKGkpO1xuICAgIH07XG4gICAgLy8gIzIgaW50ZWdyYXRlcyB0aGUgbmV3IGVsZW1lbnQgdG8gdGhlIGRhdGEgc3RydWN0dXJlXG4gICAgcmVzdWx0ID0gdGhpcy5yb290LmFkZChub2RlKTtcbiAgICBpZiAocmVzdWx0ICE9PSAtMSl7XG4gICAgICAgIC8vICMzIGlmIHRoZSBlbGVtZW50IGFzIGJlZW4gYWRkZWRcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQgfHwgKCFub0luZGV4ICYmIHRoaXMucm9vdC5pbmRleE9mKG5vZGUpKTtcbn07XG5cbi8qIVxuICogXFxicmllZiBkZWxldGUgdGhlIGVsZW1lbnQgd2l0aCB0aGUgdGFyZ2V0ZWQgaWRlbnRpZmllclxuICogXFxwYXJhbSBpIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBlbGVtZW50XG4gKiBcXHJldHVybiB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZmVzaGx5IGRlbGV0ZWQsIC0xIGlmIG5vIHJlbW92YWxcbiAqL1xuTFNFUVRyZWUucHJvdG90eXBlLmFwcGx5UmVtb3ZlID0gZnVuY3Rpb24oaSl7XG4gICAgdmFyIG5vZGUsIHBvc2l0aW9uO1xuICAgIC8vICMwIGNhc3QgZnJvbSB0aGUgcHJvcGVyIHR5cGVcbiAgICBpZiAoaSAmJiBpLl9kICYmIGkuX3MgJiYgaS5fYyl7XG4gICAgICAgIG5vZGUgPSAobmV3IElEKGkuX2QsIGkuX3MsIGkuX2MpKS50b05vZGUobnVsbCk7XG4gICAgfTtcbiAgICAvLyAjMEIgdGhlIGlkZW50aWZpZXIgaXMgYSBMU0VRTm9kZVxuICAgIGlmIChpICYmIGkudCAmJiBpLmNoaWxkcmVuKXtcbiAgICAgICAgbm9kZSA9IChuZXcgTFNFUU5vZGUoW10sbnVsbCkpLmZyb21KU09OKGkpO1xuICAgIH07XG4gICAgLy8gIzEgZ2V0IHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmVcbiAgICBwb3NpdGlvbiA9IHRoaXMucm9vdC5pbmRleE9mKG5vZGUpO1xuICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpe1xuICAgICAgICAvLyAjMiBpZiBpdCBleGlzdHMgcmVtb3ZlIGl0XG4gICAgICAgIHRoaXMucm9vdC5kZWwobm9kZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgfTtcbiAgICByZXR1cm4gcG9zaXRpb247XG59O1xuXG5cbi8qIVxuICogXFxicmllZiBjYXN0IHRoZSBKU09OIG9iamVjdCBpbnRvIGEgcHJvcGVyIExTRVFUcmVlLlxuICogXFxwYXJhbSBvYmplY3QgdGhlIEpTT04gb2JqZWN0IHRvIGNhc3RcbiAqIFxccmV0dXJuIGEgc2VsZiByZWZlcmVuY2VcbiAqL1xuTFNFUVRyZWUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICAvLyAjMSBjb3B5IHRoZSBzb3VyY2UsIGNvdW50ZXIsIGFuZCBsZW5ndGggb2YgdGhlIG9iamVjdFxuICAgIHRoaXMuX3MgPSBvYmplY3QuX3M7XG4gICAgdGhpcy5fYyA9IG9iamVjdC5fYztcbiAgICB0aGlzLmxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gICAgLy8gIzIgZGVwdGggZmlyc3QgYWRkaW5nXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGRlcHRoRmlyc3QoY3VycmVudE5vZGUsIGN1cnJlbnRQYXRoKXtcbiAgICAgICAgdmFyIHRyaXBsZSA9IG5ldyBUcmlwbGUoY3VycmVudE5vZGUudC5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS50LnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnQuYyk7XG4gICAgICAgIGN1cnJlbnRQYXRoLnB1c2godHJpcGxlKTsgLy8gc3RhY2tcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLmUhPT1udWxsKXtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gY3VycmVudFBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIHNlbGYucm9vdC5hZGQobmV3IExTRVFOb2RlKGNvcHksIGN1cnJlbnROb2RlLmUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGk8Y3VycmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgZGVwdGhGaXJzdChjdXJyZW50Tm9kZS5jaGlsZHJlbltpXSwgY3VycmVudFBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50UGF0aC5wb3AoKTsgLy8gdW5zdGFja1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGk8b2JqZWN0LnJvb3QuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICBkZXB0aEZpcnN0KG9iamVjdC5yb290LmNoaWxkcmVuW2ldLCBbXSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTFNFUVRyZWU7XG4iLCJ2YXIgQkkgPSByZXF1aXJlKCdCaWdJbnQnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJykoKTtcbnZhciBJRCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllci5qcycpO1xuXG4vKiFcbiAqIFxcY2xhc3MgU3RyYXRlZ3lcbiAqIFxcYnJpZWYgRW51bWVyYXRlIHRoZSBhdmFpbGFibGUgc3ViLWFsbG9jYXRpb24gc3RyYXRlZ2llcy4gVGhlIHNpZ25hdHVyZSBvZlxuICogdGhlc2UgZnVuY3Rpb25zIGlzIGYoSWQsIElkLCBOKywgTissIE4sIE4pOiBJZC5cbiAqIFxccGFyYW0gYm91bmRhcnkgdGhlIHZhbHVlIHVzZWQgYXMgdGhlIGRlZmF1bHQgbWF4aW11bSBzcGFjaW5nIGJldHdlZW4gaWRzXG4gKi9cbmZ1bmN0aW9uIFN0cmF0ZWd5KGJvdW5kYXJ5KXtcbiAgICB2YXIgREVGQVVMVF9CT1VOREFSWSA9IDEwO1xuICAgIHRoaXMuX2JvdW5kYXJ5ID0gYm91bmRhcnkgfHwgREVGQVVMVF9CT1VOREFSWTtcbn07XG5cbi8qIVxuICogXFxicmllZiBDaG9vc2UgYW4gaWQgc3RhcnRpbmcgZnJvbSBwcmV2aW91cyBib3VuZCBhbmQgYWRkaW5nIHJhbmRvbSBudW1iZXJcbiAqIFxccGFyYW0gcCB0aGUgcHJldmlvdXMgaWRlbnRpZmllclxuICogXFxwYXJhbSBxIHRoZSBuZXh0IGlkZW50aWZpZXJcbiAqIFxccGFyYW0gbGV2ZWwgdGhlIG51bWJlciBvZiBjb25jYXRlbmF0aW9uIGNvbXBvc2luZyB0aGUgbmV3IGlkZW50aWZpZXJcbiAqIFxccGFyYW0gaW50ZXJ2YWwgdGhlIGludGVydmFsIGJldHdlZW4gcCBhbmQgcVxuICogXFxwYXJhbSBzIHRoZSBzb3VyY2UgdGhhdCBjcmVhdGVzIHRoZSBuZXcgaWRlbnRpZmllclxuICogXFxwYXJhbSBjIHRoZSBjb3VudGVyIG9mIHRoYXQgc291cmNlXG4gKi9cblN0cmF0ZWd5LnByb3RvdHlwZS5iUGx1cyA9IGZ1bmN0aW9uIChwLCBxLCBsZXZlbCwgaW50ZXJ2YWwsIHMsIGMpe1xuICAgIHZhciBjb3B5UCA9IHAsIGNvcHlRID0gcSxcbiAgICAgICAgc3RlcCA9IE1hdGgubWluKHRoaXMuX2JvdW5kYXJ5LCBpbnRlcnZhbCksIC8vIzAgdGhlIG1pbiBpbnRlcnZhbFxuICAgICAgICBkaWdpdCA9IEJJLmludDJiaWdJbnQoMCxCYXNlLmdldFN1bUJpdChsZXZlbCkpLFxuICAgICAgICB2YWx1ZTtcbiAgICBcbiAgICAvLyAjMSBjb3B5IHRoZSBwcmV2aW91cyBpZGVudGlmaWVyXG4gICAgZm9yICh2YXIgaSA9IDA7IGk8PWxldmVsOysraSl7XG5cdCAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgaWYgKHAhPT1udWxsKXsgdmFsdWUgPSBwLnQucDsgfTtcbiAgICAgICAgQkkuYWRkSW50XyhkaWdpdCx2YWx1ZSk7XG4gICAgICAgIGlmIChpIT09bGV2ZWwpeyBCSS5sZWZ0U2hpZnRfKGRpZ2l0LEJhc2UuZ2V0Qml0QmFzZShpKzEpKTsgfTtcbiAgICAgICAgaWYgKHAhPT1udWxsICYmIHAuY2hpbGRyZW4ubGVuZ3RoIT09MCl7XG4gICAgICAgICAgICBwID0gcC5jaGlsZHJlblswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBudWxsO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gIzIgY3JlYXRlIGEgZGlnaXQgZm9yIGFuIGlkZW50aWZpZXIgYnkgYWRkaW5nIGEgcmFuZG9tIHZhbHVlXG4gICAgLy8gIzJhIERpZ2l0XG4gICAgQkkuYWRkSW50XyhkaWdpdCwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnN0ZXArMSkpO1xuICAgIC8vICMyYiBTb3VyY2UgJiBjb3VudGVyXG4gICAgcmV0dXJuIGdldFNDKGRpZ2l0LCBjb3B5UCwgY29weVEsIGxldmVsLCBzLCBjKTtcbn07XG5cblxuLyohXG4gKiBcXGJyaWVmIENob29zZSBhbiBpZCBzdGFydGluZyBmcm9tIG5leHQgYm91bmQgYW5kIHN1YnN0cmFjdCBhIHJhbmRvbSBudW1iZXJcbiAqIFxccGFyYW0gcCB0aGUgcHJldmlvdXMgaWRlbnRpZmllclxuICogXFxwYXJhbSBxIHRoZSBuZXh0IGlkZW50aWZpZXJcbiAqIFxccGFyYW0gbGV2ZWwgdGhlIG51bWJlciBvZiBjb25jYXRlbmF0aW9uIGNvbXBvc2luZyB0aGUgbmV3IGlkZW50aWZpZXJcbiAqIFxccGFyYW0gaW50ZXJ2YWwgdGhlIGludGVydmFsIGJldHdlZW4gcCBhbmQgcVxuICogXFxwYXJhbSBzIHRoZSBzb3VyY2UgdGhhdCBjcmVhdGVzIHRoZSBuZXcgaWRlbnRpZmllclxuICogXFxwYXJhbSBjIHRoZSBjb3VudGVyIG9mIHRoYXQgc291cmNlXG4gKi9cblN0cmF0ZWd5LnByb3RvdHlwZS5iTWludXMgPSBmdW5jdGlvbiAocCwgcSwgbGV2ZWwsIGludGVydmFsLCBzLCBjKXtcbiAgICB2YXIgY29weVAgPSBwLCBjb3B5USA9IHEsXG4gICAgICAgIHN0ZXAgPSBNYXRoLm1pbih0aGlzLl9ib3VuZGFyeSwgaW50ZXJ2YWwpLCAvLyAjMCBwcm9jZXNzIG1pbiBpbnRlcnZhbFxuICAgICAgICBkaWdpdCA9IEJJLmludDJiaWdJbnQoMCxCYXNlLmdldFN1bUJpdChsZXZlbCkpLFxuICAgICAgICBwSXNHcmVhdGVyID0gZmFsc2UsIGNvbW1vblJvb3QgPSB0cnVlLFxuICAgICAgICBwcmV2VmFsdWUsIG5leHRWYWx1ZTtcbiAgICBcbiAgICAvLyAjMSBjb3B5IG5leHQsIGlmIHByZXZpb3VzIGlzIGdyZWF0ZXIsIGNvcHkgbWF4VmFsdWUgQCBkZXB0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpPD1sZXZlbDsrK2kpe1xuICAgICAgICBwcmV2VmFsdWUgPSAwOyBpZiAocCAhPT0gbnVsbCl7IHByZXZWYWx1ZSA9IHAudC5wOyB9XG4gICAgICAgIG5leHRWYWx1ZSA9IDA7IGlmIChxICE9PSBudWxsKXsgbmV4dFZhbHVlID0gcS50LnA7IH1cbiAgICAgICAgaWYgKGNvbW1vblJvb3QgJiYgcHJldlZhbHVlICE9PSBuZXh0VmFsdWUpe1xuICAgICAgICAgICAgY29tbW9uUm9vdCA9IGZhbHNlO1xuICAgICAgICAgICAgcElzR3JlYXRlciA9IHByZXZWYWx1ZSA+IG5leHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocElzR3JlYXRlcil7IG5leHRWYWx1ZSA9IE1hdGgucG93KDIsQmFzZS5nZXRCaXRCYXNlKGkpKS0xOyB9XG4gICAgICAgIEJJLmFkZEludF8oZGlnaXQsIG5leHRWYWx1ZSk7XG4gICAgICAgIGlmIChpIT09bGV2ZWwpeyBCSS5sZWZ0U2hpZnRfKGRpZ2l0LEJhc2UuZ2V0Qml0QmFzZShpKzEpKTsgfVxuICAgICAgICBpZiAocSE9PW51bGwgJiYgcS5jaGlsZHJlbi5sZW5ndGghPT0wKXtcbiAgICAgICAgICAgIHEgPSBxLmNoaWxkcmVuWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwIT09bnVsbCAmJiBwLmNoaWxkcmVuLmxlbmd0aCE9PTApe1xuICAgICAgICAgICAgcCA9IHAuY2hpbGRyZW5bMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vICMzIGNyZWF0ZSBhIGRpZ2l0IGZvciBhbiBpZGVudGlmaWVyIGJ5IHN1YmluZyBhIHJhbmRvbSB2YWx1ZVxuICAgIC8vICMzYSBEaWdpdFxuICAgIGlmIChwSXNHcmVhdGVyKXtcbiAgICAgICAgQkkuYWRkSW50XyhkaWdpdCwgLU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpzdGVwKSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIEJJLmFkZEludF8oZGlnaXQsIC1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqc3RlcCktMSApO1xuICAgIH07XG4gICAgXG4gICAgLy8gIzNiIFNvdXJjZSAmIGNvdW50ZXJcbiAgICByZXR1cm4gZ2V0U0MoZGlnaXQsIGNvcHlQLCBjb3B5USwgbGV2ZWwsIHMsIGMpO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGNvcGllcyB0aGUgYXBwcm9wcmlhdGVzIHNvdXJjZSBhbmQgY291bnRlciBmcm9tIHRoZSBhZGphY2VudCBcbiAqIGlkZW50aWZpZXJzIGF0IHRoZSBpbnNlcnRpb24gcG9zaXRpb24uXG4gKiBcXHBhcmFtIGQgdGhlIGRpZ2l0IHBhcnQgb2YgdGhlIG5ldyBpZGVudGlmaWVyXG4gKiBcXHBhcmFtIHAgdGhlIHByZXZpb3VzIGlkZW50aWZpZXJcbiAqIFxccGFyYW0gcSB0aGUgbmV4dCBpZGVudGlmaWVyXG4gKiBcXHBhcmFtIGxldmVsIHRoZSBzaXplIG9mIHRoZSBuZXcgaWRlbnRpZmllclxuICogXFxwYXJhbSBzIHRoZSBsb2NhbCBzaXRlIGlkZW50aWZpZXIgXG4gKiBcXHBhcmFtIGMgdGhlIGxvY2FsIG1vbm90b25pYyBjb3VudGVyXG4gKi9cbmZ1bmN0aW9uIGdldFNDKGQsIHAsIHEsIGxldmVsLCBzLCBjKXtcbiAgICB2YXIgc291cmNlcyA9IFtdLCBjb3VudGVycyA9IFtdLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgc3VtQml0ID0gQmFzZS5nZXRTdW1CaXQobGV2ZWwpLFxuICAgICAgICB0ZW1wRGlnaXQsIHZhbHVlO1xuICAgIFxuICAgIHdoaWxlIChpPD1sZXZlbCl7XG4gICAgICAgIHRlbXBEaWdpdCA9IEJJLmR1cChkKTtcbiAgICAgICAgQkkucmlnaHRTaGlmdF8odGVtcERpZ2l0LCBzdW1CaXQgLSBCYXNlLmdldFN1bUJpdChpKSk7XG4gICAgICAgIHZhbHVlID0gQkkubW9kSW50KHRlbXBEaWdpdCxNYXRoLnBvdygyLEJhc2UuZ2V0Qml0QmFzZShpKSkpO1xuICAgICAgICBzb3VyY2VzW2ldPXM7XG4gICAgICAgIGNvdW50ZXJzW2ldPWNcbiAgICAgICAgaWYgKHEhPT1udWxsICYmIHEudC5wPT09dmFsdWUpeyBzb3VyY2VzW2ldPXEudC5zOyBjb3VudGVyc1tpXT1xLnQuY307XG4gICAgICAgIGlmIChwIT09bnVsbCAmJiBwLnQucD09PXZhbHVlKXsgc291cmNlc1tpXT1wLnQuczsgY291bnRlcnNbaV09cC50LmN9O1xuICAgICAgICBpZiAocSE9PW51bGwgJiYgcS5jaGlsZHJlbi5sZW5ndGghPT0wKXtcbiAgICAgICAgICAgIHEgPSBxLmNoaWxkcmVuWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChwIT09bnVsbCAmJiBwLmNoaWxkcmVuLmxlbmd0aCE9PTApe1xuICAgICAgICAgICAgcCA9IHAuY2hpbGRyZW5bMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgKytpO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIG5ldyBJRChkLCBzb3VyY2VzLCBjb3VudGVycyk7XG59O1xuXG5TdHJhdGVneS5pbnN0YW5jZSA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJncyl7XG4gICAgaWYgKGFyZ3Mpe1xuICAgICAgICBTdHJhdGVneS5pbnN0YW5jZSA9IG5ldyBTdHJhdGVneShhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoU3RyYXRlZ3kuaW5zdGFuY2UgPT09IG51bGwpe1xuICAgICAgICAgICAgU3RyYXRlZ3kuaW5zdGFuY2UgPSBuZXcgU3RyYXRlZ3koKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJhdGVneS5pbnN0YW5jZTtcbn07XG4iLCJcbi8qIVxuICogXFxicmllZiB0cmlwbGUgdGhhdCBjb250YWlucyBhIDxwYXRoIHNpdGUgY291bnRlcj5cbiAqIFxccGFyYW0gcGF0aCB0aGUgcGFydCBvZiB0aGUgcGF0aCBpbiB0aGUgdHJlZVxuICogXFxwYXJhbSBzaXRlIHRoZSB1bmlxdWUgc2l0ZSBpZGVudGlmaWVyIHRoYXQgY3JlYXRlZCB0aGUgdHJpcGxlXG4gKiBcXHBhcmFtIGNvdW50ZXIgdGhlIGNvdW50ZXIgb2YgdGhlIHNpdGUgd2hlbiBpdCBjcmVhdGVkIHRoZSB0cmlwbGVcbiAqL1xuZnVuY3Rpb24gVHJpcGxlKHBhdGgsIHNpdGUsIGNvdW50ZXIpe1xuICAgIHRoaXMucCA9IHBhdGg7XG4gICAgdGhpcy5zID0gc2l0ZTtcbiAgICB0aGlzLmMgPSBjb3VudGVyO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGNvbXBhcmUgdHdvIHRyaXBsZXMgcHJpb3JpdGl6aW5nIHRoZSBwYXRoLCB0aGVuIHNpdGUsIHRoZW4gY291bnRlclxuICogXFxwYXJhbSBvIHRoZSBvdGhlciB0cmlwbGUgdG8gY29tcGFyZVxuICogXFxyZXR1cm4gLTEgaWYgdGhpcyBpcyBsb3dlciB0aGFuIG8sIDEgaWYgdGhpcyBpcyBncmVhdGVyIHRoYW4gbywgMCBvdGhlcndpc2VcbiAqL1xuVHJpcGxlLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24obyl7XG4gICAgaWYgKHRoaXMucyA9PT0gTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLmMgPT09IE51bWJlci5NQVhfVkFMVUUpe1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIGlmIChvLnMgPT09IE51bWJlci5NQVhfVkFMVUUgJiYgby5zID09PSBOdW1iZXIuTUFYX1ZBTFVFKXtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgXG4gICAgaWYgKHRoaXMucCA8IG8ucCkgeyByZXR1cm4gLTE7fTtcbiAgICBpZiAodGhpcy5wID4gby5wKSB7IHJldHVybiAxIDt9O1xuICAgIGlmICh0aGlzLnMgPCBvLnMpIHsgcmV0dXJuIC0xO307XG4gICAgaWYgKHRoaXMucyA+IG8ucykgeyByZXR1cm4gMSA7fTtcbiAgICBpZiAodGhpcy5jIDwgby5jKSB7IHJldHVybiAtMTt9O1xuICAgIGlmICh0aGlzLmMgPiBvLmMpIHsgcmV0dXJuIDEgO307XG4gICAgcmV0dXJuIDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaXBsZTtcbiIsIlxuZnVuY3Rpb24gYmluYXJ5SW5kZXhPZigpe1xuXG4vKipcbiAqIFxcZnJvbTogW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dvbGZ5ODcvNTczNDUzMF1cbiAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgaG9zdCBhcnJheS4gVGhpcyBtZXRob2QgY2FuIGVpdGhlciBiZVxuICogaW5qZWN0ZWQgaW50byBBcnJheS5wcm90b3R5cGUgb3IgY2FsbGVkIHdpdGggYSBzcGVjaWZpZWQgc2NvcGUgbGlrZSB0aGlzOlxuICogYmluYXJ5SW5kZXhPZi5jYWxsKHNvbWVBcnJheSwgc2VhcmNoRWxlbWVudCk7XG4gKlxuICpcbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCBUaGUgaXRlbSB0byBzZWFyY2ggZm9yIHdpdGhpbiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB3aGljaCBkZWZhdWx0cyB0byAtMSB3aGVuIG5vdFxuICogZm91bmQuXG4gKi9cbkFycmF5LnByb3RvdHlwZS5iaW5hcnlJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoRWxlbWVudCkge1xuICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgdmFyIG1heEluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHZhciBjdXJyZW50SW5kZXg7XG4gICAgdmFyIGN1cnJlbnRFbGVtZW50O1xuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IE1hdGguZmxvb3IoKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMik7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50ID0gdGhpc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQuY29tcGFyZShzZWFyY2hFbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50RWxlbWVudC5jb21wYXJlKHNlYXJjaEVsZW1lbnQpID4gMCkge1xuICAgICAgICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIH5tYXhJbmRleDtcbn07XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiaW5hcnlJbmRleE9mKCk7IiwiLy8gVmpldXg6IEN1c3RvbWl6ZWQgYmlnSW50MnN0ciBhbmQgc3RyMmJpZ0ludCBpbiBvcmRlciB0byBhY2NlcHQgY3VzdG9tIGJhc2UuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEJpZyBJbnRlZ2VyIExpYnJhcnkgdi4gNS40XG4vLyBDcmVhdGVkIDIwMDAsIGxhc3QgbW9kaWZpZWQgMjAwOVxuLy8gTGVlbW9uIEJhaXJkXG4vLyB3d3cubGVlbW9uLmNvbVxuLy9cbi8vIFZlcnNpb24gaGlzdG9yeTpcbi8vIHYgNS40ICAzIE9jdCAyMDA5XG4vLyAgIC0gYWRkZWQgXCJ2YXIgaVwiIHRvIGdyZWF0ZXJTaGlmdCgpIHNvIGkgaXMgbm90IGdsb2JhbC4gKFRoYW5rcyB0byBQ77+9dGVyIFN6YWLvv70gZm9yIGZpbmRpbmcgdGhhdCBidWcpXG4vL1xuLy8gdiA1LjMgIDIxIFNlcCAyMDA5XG4vLyAgIC0gYWRkZWQgcmFuZFByb2JQcmltZShrKSBmb3IgcHJvYmFibGUgcHJpbWVzXG4vLyAgIC0gdW5yb2xsZWQgbG9vcCBpbiBtb250XyAoc2xpZ2h0bHkgZmFzdGVyKVxuLy8gICAtIG1pbGxlclJhYmluIG5vdyB0YWtlcyBhIGJpZ0ludCBwYXJhbWV0ZXIgcmF0aGVyIHRoYW4gYW4gaW50XG4vL1xuLy8gdiA1LjIgIDE1IFNlcCAyMDA5XG4vLyAgIC0gZml4ZWQgY2FwaXRhbGl6YXRpb24gaW4gY2FsbCB0byBpbnQyYmlnSW50IGluIHJhbmRCaWdJbnRcbi8vICAgICAodGhhbmtzIHRvIEVtaWxpIEV2cmlwaWRvdSwgUmVpbmhvbGQgQmVocmluZ2VyLCBhbmQgU2FtdWVsIE1hY2FsZWVzZSBmb3IgZmluZGluZyB0aGF0IGJ1Zylcbi8vXG4vLyB2IDUuMSAgOCBPY3QgMjAwN1xuLy8gICAtIHJlbmFtZWQgaW52ZXJzZU1vZEludF8gdG8gaW52ZXJzZU1vZEludCBzaW5jZSBpdCBkb2Vzbid0IGNoYW5nZSBpdHMgcGFyYW1ldGVyc1xuLy8gICAtIGFkZGVkIGZ1bmN0aW9ucyBHQ0QgYW5kIHJhbmRCaWdJbnQsIHdoaWNoIGNhbGwgR0NEXyBhbmQgcmFuZEJpZ0ludF9cbi8vICAgLSBmaXhlZCBhIGJ1ZyBmb3VuZCBieSBSb2IgVmlzc2VyIChzZWUgY29tbWVudCB3aXRoIGhpcyBuYW1lIGJlbG93KVxuLy8gICAtIGltcHJvdmVkIGNvbW1lbnRzXG4vL1xuLy8gVGhpcyBmaWxlIGlzIHB1YmxpYyBkb21haW4uICAgWW91IGNhbiB1c2UgaXQgZm9yIGFueSBwdXJwb3NlIHdpdGhvdXQgcmVzdHJpY3Rpb24uXG4vLyBJIGRvIG5vdCBndWFyYW50ZWUgdGhhdCBpdCBpcyBjb3JyZWN0LCBzbyB1c2UgaXQgYXQgeW91ciBvd24gcmlzay4gIElmIHlvdSB1c2Vcbi8vIGl0IGZvciBzb21ldGhpbmcgaW50ZXJlc3RpbmcsIEknZCBhcHByZWNpYXRlIGhlYXJpbmcgYWJvdXQgaXQuICBJZiB5b3UgZmluZFxuLy8gYW55IGJ1Z3Mgb3IgbWFrZSBhbnkgaW1wcm92ZW1lbnRzLCBJJ2QgYXBwcmVjaWF0ZSBoZWFyaW5nIGFib3V0IHRob3NlIHRvby5cbi8vIEl0IHdvdWxkIGFsc28gYmUgbmljZSBpZiBteSBuYW1lIGFuZCBVUkwgd2VyZSBsZWZ0IGluIHRoZSBjb21tZW50cy4gIEJ1dCBub25lXG4vLyBvZiB0aGF0IGlzIHJlcXVpcmVkLlxuLy9cbi8vIFRoaXMgY29kZSBkZWZpbmVzIGEgYmlnSW50IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gaW50ZWdlcnMuXG4vLyBBIGJpZ0ludCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycyBzdG9yaW5nIHRoZSB2YWx1ZSBpbiBjaHVua3Mgb2YgYnBlIGJpdHMsXG4vLyBsaXR0bGUgZW5kaWFuIChidWZmWzBdIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCB3b3JkKS5cbi8vIE5lZ2F0aXZlIGJpZ0ludHMgYXJlIHN0b3JlZCB0d28ncyBjb21wbGVtZW50LiAgQWxtb3N0IGFsbCB0aGUgZnVuY3Rpb25zIHRyZWF0XG4vLyBiaWdJbnRzIGFzIG5vbm5lZ2F0aXZlLiAgVGhlIGZldyB0aGF0IHZpZXcgdGhlbSBhcyB0d28ncyBjb21wbGVtZW50IHNheSBzb1xuLy8gaW4gdGhlaXIgY29tbWVudHMuICBTb21lIGZ1bmN0aW9ucyBhc3N1bWUgdGhlaXIgcGFyYW1ldGVycyBoYXZlIGF0IGxlYXN0IG9uZVxuLy8gbGVhZGluZyB6ZXJvIGVsZW1lbnQuIEZ1bmN0aW9ucyB3aXRoIGFuIHVuZGVyc2NvcmUgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZSBwdXRcbi8vIHRoZWlyIGFuc3dlciBpbnRvIG9uZSBvZiB0aGUgYXJyYXlzIHBhc3NlZCBpbiwgYW5kIGhhdmUgdW5wcmVkaWN0YWJsZSBiZWhhdmlvclxuLy8gaW4gY2FzZSBvZiBvdmVyZmxvdywgc28gdGhlIGNhbGxlciBtdXN0IG1ha2Ugc3VyZSB0aGUgYXJyYXlzIGFyZSBiaWcgZW5vdWdoIHRvXG4vLyBob2xkIHRoZSBhbnN3ZXIuICBCdXQgdGhlIGF2ZXJhZ2UgdXNlciBzaG91bGQgbmV2ZXIgaGF2ZSB0byBjYWxsIGFueSBvZiB0aGVcbi8vIHVuZGVyc2NvcmVkIGZ1bmN0aW9ucy4gIEVhY2ggaW1wb3J0YW50IHVuZGVyc2NvcmVkIGZ1bmN0aW9uIGhhcyBhIHdyYXBwZXIgZnVuY3Rpb25cbi8vIG9mIHRoZSBzYW1lIG5hbWUgd2l0aG91dCB0aGUgdW5kZXJzY29yZSB0aGF0IHRha2VzIGNhcmUgb2YgdGhlIGRldGFpbHMgZm9yIHlvdS5cbi8vIEZvciBlYWNoIHVuZGVyc2NvcmVkIGZ1bmN0aW9uIHdoZXJlIGEgcGFyYW1ldGVyIGlzIG1vZGlmaWVkLCB0aGF0IHNhbWUgdmFyaWFibGVcbi8vIG11c3Qgbm90IGJlIHVzZWQgYXMgYW5vdGhlciBhcmd1bWVudCB0b28uICBTbywgeW91IGNhbm5vdCBzcXVhcmUgeCBieSBkb2luZ1xuLy8gbXVsdE1vZF8oeCx4LG4pLiAgWW91IG11c3QgdXNlIHNxdWFyZU1vZF8oeCxuKSBpbnN0ZWFkLCBvciBkbyB5PWR1cCh4KTsgbXVsdE1vZF8oeCx5LG4pLlxuLy8gT3Igc2ltcGx5IHVzZSB0aGUgbXVsdE1vZCh4LHgsbikgZnVuY3Rpb24gd2l0aG91dCB0aGUgdW5kZXJzY29yZSwgd2hlcmVcbi8vIHN1Y2ggaXNzdWVzIG5ldmVyIGFyaXNlLCBiZWNhdXNlIG5vbi11bmRlcnNjb3JlZCBmdW5jdGlvbnMgbmV2ZXIgY2hhbmdlXG4vLyB0aGVpciBwYXJhbWV0ZXJzOyB0aGV5IGFsd2F5cyBhbGxvY2F0ZSBuZXcgbWVtb3J5IGZvciB0aGUgYW5zd2VyIHRoYXQgaXMgcmV0dXJuZWQuXG4vL1xuLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBkZXNpZ25lZCB0byBhdm9pZCBmcmVxdWVudCBkeW5hbWljIG1lbW9yeSBhbGxvY2F0aW9uIGluIHRoZSBpbm5lciBsb29wLlxuLy8gRm9yIG1vc3QgZnVuY3Rpb25zLCBpZiBpdCBuZWVkcyBhIEJpZ0ludCBhcyBhIGxvY2FsIHZhcmlhYmxlIGl0IHdpbGwgYWN0dWFsbHkgdXNlXG4vLyBhIGdsb2JhbCwgYW5kIHdpbGwgb25seSBhbGxvY2F0ZSB0byBpdCBvbmx5IHdoZW4gaXQncyBub3QgdGhlIHJpZ2h0IHNpemUuICBUaGlzIGVuc3VyZXNcbi8vIHRoYXQgd2hlbiBhIGZ1bmN0aW9uIGlzIGNhbGxlZCByZXBlYXRlZGx5IHdpdGggc2FtZS1zaXplZCBwYXJhbWV0ZXJzLCBpdCBvbmx5IGFsbG9jYXRlc1xuLy8gbWVtb3J5IG9uIHRoZSBmaXJzdCBjYWxsLlxuLy9cbi8vIE5vdGUgdGhhdCBmb3IgY3J5cHRvZ3JhcGhpYyBwdXJwb3NlcywgdGhlIGNhbGxzIHRvIE1hdGgucmFuZG9tKCkgbXVzdFxuLy8gYmUgcmVwbGFjZWQgd2l0aCBjYWxscyB0byBhIGJldHRlciBwc2V1ZG9yYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbi8vXG4vLyBJbiB0aGUgZm9sbG93aW5nLCBcImJpZ0ludFwiIG1lYW5zIGEgYmlnSW50IHdpdGggYXQgbGVhc3Qgb25lIGxlYWRpbmcgemVybyBlbGVtZW50LFxuLy8gYW5kIFwiaW50ZWdlclwiIG1lYW5zIGEgbm9ubmVnYXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gcmFkaXguICBJbiBzb21lIGNhc2VzLCBpbnRlZ2VyXG4vLyBjYW4gYmUgbmVnYXRpdmUuICBOZWdhdGl2ZSBiaWdJbnRzIGFyZSAycyBjb21wbGVtZW50LlxuLy9cbi8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGRvIG5vdCBtb2RpZnkgdGhlaXIgaW5wdXRzLlxuLy8gVGhvc2UgcmV0dXJuaW5nIGEgYmlnSW50LCBzdHJpbmcsIG9yIEFycmF5IHdpbGwgZHluYW1pY2FsbHkgYWxsb2NhdGUgbWVtb3J5IGZvciB0aGF0IHZhbHVlLlxuLy8gVGhvc2UgcmV0dXJuaW5nIGEgYm9vbGVhbiB3aWxsIHJldHVybiB0aGUgaW50ZWdlciAwIChmYWxzZSkgb3IgMSAodHJ1ZSkuXG4vLyBUaG9zZSByZXR1cm5pbmcgYm9vbGVhbiBvciBpbnQgd2lsbCBub3QgYWxsb2NhdGUgbWVtb3J5IGV4Y2VwdCBwb3NzaWJseSBvbiB0aGUgZmlyc3Rcbi8vIHRpbWUgdGhleSdyZSBjYWxsZWQgd2l0aCBhIGdpdmVuIHBhcmFtZXRlciBzaXplLlxuLy9cbi8vIGJpZ0ludCAgYWRkKHgseSkgICAgICAgICAgICAgICAvL3JldHVybiAoeCt5KSBmb3IgYmlnSW50cyB4IGFuZCB5LlxuLy8gYmlnSW50ICBhZGRJbnQoeCxuKSAgICAgICAgICAgIC8vcmV0dXJuICh4K24pIHdoZXJlIHggaXMgYSBiaWdJbnQgYW5kIG4gaXMgYW4gaW50ZWdlci5cbi8vIHN0cmluZyAgYmlnSW50MnN0cih4LGJhc2UpICAgICAvL3JldHVybiBhIHN0cmluZyBmb3JtIG9mIGJpZ0ludCB4IGluIGEgZ2l2ZW4gYmFzZSwgd2l0aCAyIDw9IGJhc2UgPD0gOTVcbi8vIGludCAgICAgYml0U2l6ZSh4KSAgICAgICAgICAgICAvL3JldHVybiBob3cgbWFueSBiaXRzIGxvbmcgdGhlIGJpZ0ludCB4IGlzLCBub3QgY291bnRpbmcgbGVhZGluZyB6ZXJvc1xuLy8gYmlnSW50ICBkdXAoeCkgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGEgY29weSBvZiBiaWdJbnQgeFxuLy8gYm9vbGVhbiBlcXVhbHMoeCx5KSAgICAgICAgICAgIC8vaXMgdGhlIGJpZ0ludCB4IGVxdWFsIHRvIHRoZSBiaWdpbnQgeT9cbi8vIGJvb2xlYW4gZXF1YWxzSW50KHgseSkgICAgICAgICAvL2lzIGJpZ2ludCB4IGVxdWFsIHRvIGludGVnZXIgeT9cbi8vIGJpZ0ludCAgZXhwYW5kKHgsbikgICAgICAgICAgICAvL3JldHVybiBhIGNvcHkgb2YgeCB3aXRoIGF0IGxlYXN0IG4gZWxlbWVudHMsIGFkZGluZyBsZWFkaW5nIHplcm9zIGlmIG5lZWRlZFxuLy8gQXJyYXkgICBmaW5kUHJpbWVzKG4pICAgICAgICAgIC8vcmV0dXJuIGFycmF5IG9mIGFsbCBwcmltZXMgbGVzcyB0aGFuIGludGVnZXIgblxuLy8gYmlnSW50ICBHQ0QoeCx5KSAgICAgICAgICAgICAgIC8vcmV0dXJuIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIG9mIGJpZ0ludHMgeCBhbmQgeSAoZWFjaCB3aXRoIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzKS5cbi8vIGJvb2xlYW4gZ3JlYXRlcih4LHkpICAgICAgICAgICAvL2lzIHg+eT8gICh4IGFuZCB5IGFyZSBub25uZWdhdGl2ZSBiaWdJbnRzKVxuLy8gYm9vbGVhbiBncmVhdGVyU2hpZnQoeCx5LHNoaWZ0KS8vaXMgKHggPDwoc2hpZnQqYnBlKSkgPiB5P1xuLy8gYmlnSW50ICBpbnQyYmlnSW50KHQsbixtKSAgICAgIC8vcmV0dXJuIGEgYmlnSW50IGVxdWFsIHRvIGludGVnZXIgdCwgd2l0aCBhdCBsZWFzdCBuIGJpdHMgYW5kIG0gYXJyYXkgZWxlbWVudHNcbi8vIGJpZ0ludCAgaW52ZXJzZU1vZCh4LG4pICAgICAgICAvL3JldHVybiAoeCoqKC0xKSBtb2QgbikgZm9yIGJpZ0ludHMgeCBhbmQgbi4gIElmIG5vIGludmVyc2UgZXhpc3RzLCBpdCByZXR1cm5zIG51bGxcbi8vIGludCAgICAgaW52ZXJzZU1vZEludCh4LG4pICAgICAvL3JldHVybiB4KiooLTEpIG1vZCBuLCBmb3IgaW50ZWdlcnMgeCBhbmQgbi4gIFJldHVybiAwIGlmIHRoZXJlIGlzIG5vIGludmVyc2Vcbi8vIGJvb2xlYW4gaXNaZXJvKHgpICAgICAgICAgICAgICAvL2lzIHRoZSBiaWdJbnQgeCBlcXVhbCB0byB6ZXJvP1xuLy8gYm9vbGVhbiBtaWxsZXJSYWJpbih4LGIpICAgICAgIC8vZG9lcyBvbmUgcm91bmQgb2YgTWlsbGVyLVJhYmluIGJhc2UgaW50ZWdlciBiIHNheSB0aGF0IGJpZ0ludCB4IGlzIHBvc3NpYmx5IHByaW1lPyAoYiBpcyBiaWdJbnQsIDE8Yjx4KVxuLy8gYm9vbGVhbiBtaWxsZXJSYWJpbkludCh4LGIpICAgIC8vZG9lcyBvbmUgcm91bmQgb2YgTWlsbGVyLVJhYmluIGJhc2UgaW50ZWdlciBiIHNheSB0aGF0IGJpZ0ludCB4IGlzIHBvc3NpYmx5IHByaW1lPyAoYiBpcyBpbnQsICAgIDE8Yjx4KVxuLy8gYmlnSW50ICBtb2QoeCxuKSAgICAgICAgICAgICAgIC8vcmV0dXJuIGEgbmV3IGJpZ0ludCBlcXVhbCB0byAoeCBtb2QgbikgZm9yIGJpZ0ludHMgeCBhbmQgbi5cbi8vIGludCAgICAgbW9kSW50KHgsbikgICAgICAgICAgICAvL3JldHVybiB4IG1vZCBuIGZvciBiaWdJbnQgeCBhbmQgaW50ZWdlciBuLlxuLy8gYmlnSW50ICBtdWx0KHgseSkgICAgICAgICAgICAgIC8vcmV0dXJuIHgqeSBmb3IgYmlnSW50cyB4IGFuZCB5LiBUaGlzIGlzIGZhc3RlciB3aGVuIHk8eC5cbi8vIGJpZ0ludCAgbXVsdE1vZCh4LHksbikgICAgICAgICAvL3JldHVybiAoeCp5IG1vZCBuKSBmb3IgYmlnSW50cyB4LHksbi4gIEZvciBncmVhdGVyIHNwZWVkLCBsZXQgeTx4LlxuLy8gYm9vbGVhbiBuZWdhdGl2ZSh4KSAgICAgICAgICAgIC8vaXMgYmlnSW50IHggbmVnYXRpdmU/XG4vLyBiaWdJbnQgIHBvd01vZCh4LHksbikgICAgICAgICAgLy9yZXR1cm4gKHgqKnkgbW9kIG4pIHdoZXJlIHgseSxuIGFyZSBiaWdJbnRzIGFuZCAqKiBpcyBleHBvbmVudGlhdGlvbi4gIDAqKjA9MS4gRmFzdGVyIGZvciBvZGQgbi5cbi8vIGJpZ0ludCAgcmFuZEJpZ0ludChuLHMpICAgICAgICAvL3JldHVybiBhbiBuLWJpdCByYW5kb20gQmlnSW50IChuPj0xKS4gIElmIHM9MSwgdGhlbiB0aGUgbW9zdCBzaWduaWZpY2FudCBvZiB0aG9zZSBuIGJpdHMgaXMgc2V0IHRvIDEuXG4vLyBiaWdJbnQgIHJhbmRUcnVlUHJpbWUoaykgICAgICAgLy9yZXR1cm4gYSBuZXcsIHJhbmRvbSwgay1iaXQsIHRydWUgcHJpbWUgYmlnSW50IHVzaW5nIE1hdXJlcidzIGFsZ29yaXRobS5cbi8vIGJpZ0ludCAgcmFuZFByb2JQcmltZShrKSAgICAgICAvL3JldHVybiBhIG5ldywgcmFuZG9tLCBrLWJpdCwgcHJvYmFibGUgcHJpbWUgYmlnSW50IChwcm9iYWJpbGl0eSBpdCdzIGNvbXBvc2l0ZSBsZXNzIHRoYW4gMl4tODApLlxuLy8gYmlnSW50ICBzdHIyYmlnSW50KHMsYixuLG0pICAgIC8vcmV0dXJuIGEgYmlnSW50IGZvciBudW1iZXIgcmVwcmVzZW50ZWQgaW4gc3RyaW5nIHMgaW4gYmFzZSBiIHdpdGggYXQgbGVhc3QgbiBiaXRzIGFuZCBtIGFycmF5IGVsZW1lbnRzXG4vLyBiaWdJbnQgIHN1Yih4LHkpICAgICAgICAgICAgICAgLy9yZXR1cm4gKHgteSkgZm9yIGJpZ0ludHMgeCBhbmQgeS4gIE5lZ2F0aXZlIGFuc3dlcnMgd2lsbCBiZSAycyBjb21wbGVtZW50XG4vLyBiaWdJbnQgIHRyaW0oeCxrKSAgICAgICAgICAgICAgLy9yZXR1cm4gYSBjb3B5IG9mIHggd2l0aCBleGFjdGx5IGsgbGVhZGluZyB6ZXJvIGVsZW1lbnRzXG4vL1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGVhY2ggaGF2ZSBhIG5vbi11bmRlcnNjb3JlZCB2ZXJzaW9uLCB3aGljaCBtb3N0IHVzZXJzIHNob3VsZCBjYWxsIGluc3RlYWQuXG4vLyBUaGVzZSBmdW5jdGlvbnMgZWFjaCB3cml0ZSB0byBhIHNpbmdsZSBwYXJhbWV0ZXIsIGFuZCB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGUgYXJyYXlcbi8vIHBhc3NlZCBpbiBpcyBsYXJnZSBlbm91Z2ggdG8gaG9sZCB0aGUgcmVzdWx0LlxuLy9cbi8vIHZvaWQgICAgYWRkSW50Xyh4LG4pICAgICAgICAgIC8vZG8geD14K24gd2hlcmUgeCBpcyBhIGJpZ0ludCBhbmQgbiBpcyBhbiBpbnRlZ2VyXG4vLyB2b2lkICAgIGFkZF8oeCx5KSAgICAgICAgICAgICAvL2RvIHg9eCt5IGZvciBiaWdJbnRzIHggYW5kIHlcbi8vIHZvaWQgICAgY29weV8oeCx5KSAgICAgICAgICAgIC8vZG8geD15IG9uIGJpZ0ludHMgeCBhbmQgeVxuLy8gdm9pZCAgICBjb3B5SW50Xyh4LG4pICAgICAgICAgLy9kbyB4PW4gb24gYmlnSW50IHggYW5kIGludGVnZXIgblxuLy8gdm9pZCAgICBHQ0RfKHgseSkgICAgICAgICAgICAgLy9zZXQgeCB0byB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3Igb2YgYmlnSW50cyB4IGFuZCB5LCAoeSBpcyBkZXN0cm95ZWQpLiAgKFRoaXMgbmV2ZXIgb3ZlcmZsb3dzIGl0cyBhcnJheSkuXG4vLyBib29sZWFuIGludmVyc2VNb2RfKHgsbikgICAgICAvL2RvIHg9eCoqKC0xKSBtb2QgbiwgZm9yIGJpZ0ludHMgeCBhbmQgbi4gUmV0dXJucyAxICgwKSBpZiBpbnZlcnNlIGRvZXMgKGRvZXNuJ3QpIGV4aXN0XG4vLyB2b2lkICAgIG1vZF8oeCxuKSAgICAgICAgICAgICAvL2RvIHg9eCBtb2QgbiBmb3IgYmlnSW50cyB4IGFuZCBuLiAoVGhpcyBuZXZlciBvdmVyZmxvd3MgaXRzIGFycmF5KS5cbi8vIHZvaWQgICAgbXVsdF8oeCx5KSAgICAgICAgICAgIC8vZG8geD14KnkgZm9yIGJpZ0ludHMgeCBhbmQgeS5cbi8vIHZvaWQgICAgbXVsdE1vZF8oeCx5LG4pICAgICAgIC8vZG8geD14KnkgIG1vZCBuIGZvciBiaWdJbnRzIHgseSxuLlxuLy8gdm9pZCAgICBwb3dNb2RfKHgseSxuKSAgICAgICAgLy9kbyB4PXgqKnkgbW9kIG4sIHdoZXJlIHgseSxuIGFyZSBiaWdJbnRzIChuIGlzIG9kZCkgYW5kICoqIGlzIGV4cG9uZW50aWF0aW9uLiAgMCoqMD0xLlxuLy8gdm9pZCAgICByYW5kQmlnSW50XyhiLG4scykgICAgLy9kbyBiID0gYW4gbi1iaXQgcmFuZG9tIEJpZ0ludC4gaWYgcz0xLCB0aGVuIG50aCBiaXQgKG1vc3Qgc2lnbmlmaWNhbnQgYml0KSBpcyBzZXQgdG8gMS4gbj49MS5cbi8vIHZvaWQgICAgcmFuZFRydWVQcmltZV8oYW5zLGspIC8vZG8gYW5zID0gYSByYW5kb20gay1iaXQgdHJ1ZSByYW5kb20gcHJpbWUgKG5vdCBqdXN0IHByb2JhYmxlIHByaW1lKSB3aXRoIDEgaW4gdGhlIG1zYi5cbi8vIHZvaWQgICAgc3ViXyh4LHkpICAgICAgICAgICAgIC8vZG8geD14LXkgZm9yIGJpZ0ludHMgeCBhbmQgeS4gTmVnYXRpdmUgYW5zd2VycyB3aWxsIGJlIDJzIGNvbXBsZW1lbnQuXG4vL1xuLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgZG8gTk9UIGhhdmUgYSBub24tdW5kZXJzY29yZWQgdmVyc2lvbi5cbi8vIFRoZXkgZWFjaCB3cml0ZSBhIGJpZ0ludCByZXN1bHQgdG8gb25lIG9yIG1vcmUgcGFyYW1ldGVycy4gIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yXG4vLyBlbnN1cmluZyB0aGUgYXJyYXlzIHBhc3NlZCBpbiBhcmUgbGFyZ2UgZW5vdWdoIHRvIGhvbGQgdGhlIHJlc3VsdHMuXG4vL1xuLy8gdm9pZCBhZGRTaGlmdF8oeCx5LHlzKSAgICAgICAvL2RvIHg9eCsoeTw8KHlzKmJwZSkpXG4vLyB2b2lkIGNhcnJ5Xyh4KSAgICAgICAgICAgICAgIC8vZG8gY2FycmllcyBhbmQgYm9ycm93cyBzbyBlYWNoIGVsZW1lbnQgb2YgdGhlIGJpZ0ludCB4IGZpdHMgaW4gYnBlIGJpdHMuXG4vLyB2b2lkIGRpdmlkZV8oeCx5LHEscikgICAgICAgIC8vZGl2aWRlIHggYnkgeSBnaXZpbmcgcXVvdGllbnQgcSBhbmQgcmVtYWluZGVyIHJcbi8vIGludCAgZGl2SW50Xyh4LG4pICAgICAgICAgICAgLy9kbyB4PWZsb29yKHgvbikgZm9yIGJpZ0ludCB4IGFuZCBpbnRlZ2VyIG4sIGFuZCByZXR1cm4gdGhlIHJlbWFpbmRlci4gKFRoaXMgbmV2ZXIgb3ZlcmZsb3dzIGl0cyBhcnJheSkuXG4vLyBpbnQgIGVHQ0RfKHgseSxkLGEsYikgICAgICAgIC8vc2V0cyBhLGIsZCB0byBwb3NpdGl2ZSBiaWdJbnRzIHN1Y2ggdGhhdCBkID0gR0NEXyh4LHkpID0gYSp4LWIqeVxuLy8gdm9pZCBoYWx2ZV8oeCkgICAgICAgICAgICAgICAvL2RvIHg9Zmxvb3IofHh8LzIpKnNnbih4KSBmb3IgYmlnSW50IHggaW4gMidzIGNvbXBsZW1lbnQuICAoVGhpcyBuZXZlciBvdmVyZmxvd3MgaXRzIGFycmF5KS5cbi8vIHZvaWQgbGVmdFNoaWZ0Xyh4LG4pICAgICAgICAgLy9sZWZ0IHNoaWZ0IGJpZ0ludCB4IGJ5IG4gYml0cy4gIG48YnBlLlxuLy8gdm9pZCBsaW5Db21iXyh4LHksYSxiKSAgICAgICAvL2RvIHg9YSp4K2IqeSBmb3IgYmlnSW50cyB4IGFuZCB5IGFuZCBpbnRlZ2VycyBhIGFuZCBiXG4vLyB2b2lkIGxpbkNvbWJTaGlmdF8oeCx5LGIseXMpIC8vZG8geD14K2IqKHk8PCh5cypicGUpKSBmb3IgYmlnSW50cyB4IGFuZCB5LCBhbmQgaW50ZWdlcnMgYiBhbmQgeXNcbi8vIHZvaWQgbW9udF8oeCx5LG4sbnApICAgICAgICAgLy9Nb250Z29tZXJ5IG11bHRpcGxpY2F0aW9uIChzZWUgY29tbWVudHMgd2hlcmUgdGhlIGZ1bmN0aW9uIGlzIGRlZmluZWQpXG4vLyB2b2lkIG11bHRJbnRfKHgsbikgICAgICAgICAgIC8vZG8geD14Km4gd2hlcmUgeCBpcyBhIGJpZ0ludCBhbmQgbiBpcyBhbiBpbnRlZ2VyLlxuLy8gdm9pZCByaWdodFNoaWZ0Xyh4LG4pICAgICAgICAvL3JpZ2h0IHNoaWZ0IGJpZ0ludCB4IGJ5IG4gYml0cy4gIDAgPD0gbiA8IGJwZS4gKFRoaXMgbmV2ZXIgb3ZlcmZsb3dzIGl0cyBhcnJheSkuXG4vLyB2b2lkIHNxdWFyZU1vZF8oeCxuKSAgICAgICAgIC8vZG8geD14KnggIG1vZCBuIGZvciBiaWdJbnRzIHgsblxuLy8gdm9pZCBzdWJTaGlmdF8oeCx5LHlzKSAgICAgICAvL2RvIHg9eC0oeTw8KHlzKmJwZSkpLiBOZWdhdGl2ZSBhbnN3ZXJzIHdpbGwgYmUgMnMgY29tcGxlbWVudC5cbi8vXG4vLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgYmFzZWQgb24gYWxnb3JpdGhtcyBmcm9tIHRoZSBfSGFuZGJvb2sgb2YgQXBwbGllZCBDcnlwdG9ncmFwaHlfXG4vLyAgICBwb3dNb2RfKCkgICAgICAgICAgID0gYWxnb3JpdGhtIDE0Ljk0LCBNb250Z29tZXJ5IGV4cG9uZW50aWF0aW9uXG4vLyAgICBlR0NEXyxpbnZlcnNlTW9kXygpID0gYWxnb3JpdGhtIDE0LjYxLCBCaW5hcnkgZXh0ZW5kZWQgR0NEX1xuLy8gICAgR0NEXygpICAgICAgICAgICAgICA9IGFsZ29yb3RobSAxNC41NywgTGVobWVyJ3MgYWxnb3JpdGhtXG4vLyAgICBtb250XygpICAgICAgICAgICAgID0gYWxnb3JpdGhtIDE0LjM2LCBNb250Z29tZXJ5IG11bHRpcGxpY2F0aW9uXG4vLyAgICBkaXZpZGVfKCkgICAgICAgICAgID0gYWxnb3JpdGhtIDE0LjIwICBNdWx0aXBsZS1wcmVjaXNpb24gZGl2aXNpb25cbi8vICAgIHNxdWFyZU1vZF8oKSAgICAgICAgPSBhbGdvcml0aG0gMTQuMTYgIE11bHRpcGxlLXByZWNpc2lvbiBzcXVhcmluZ1xuLy8gICAgcmFuZFRydWVQcmltZV8oKSAgICA9IGFsZ29yaXRobSAgNC42MiwgTWF1cmVyJ3MgYWxnb3JpdGhtXG4vLyAgICBtaWxsZXJSYWJpbigpICAgICAgID0gYWxnb3JpdGhtICA0LjI0LCBNaWxsZXItUmFiaW4gYWxnb3JpdGhtXG4vL1xuLy8gUHJvZmlsaW5nIHNob3dzOlxuLy8gICAgIHJhbmRUcnVlUHJpbWVfKCkgc3BlbmRzOlxuLy8gICAgICAgICAxMCUgb2YgaXRzIHRpbWUgaW4gY2FsbHMgdG8gcG93TW9kXygpXG4vLyAgICAgICAgIDg1JSBvZiBpdHMgdGltZSBpbiBjYWxscyB0byBtaWxsZXJSYWJpbigpXG4vLyAgICAgbWlsbGVyUmFiaW4oKSBzcGVuZHM6XG4vLyAgICAgICAgIDk5JSBvZiBpdHMgdGltZSBpbiBjYWxscyB0byBwb3dNb2RfKCkgICAoYWx3YXlzIHdpdGggYSBiYXNlIG9mIDIpXG4vLyAgICAgcG93TW9kXygpIHNwZW5kczpcbi8vICAgICAgICAgOTQlIG9mIGl0cyB0aW1lIGluIGNhbGxzIHRvIG1vbnRfKCkgIChhbG1vc3QgYWx3YXlzIHdpdGggeD09eSlcbi8vXG4vLyBUaGlzIHN1Z2dlc3RzIHRoZXJlIGFyZSBzZXZlcmFsIHdheXMgdG8gc3BlZWQgdXAgdGhpcyBsaWJyYXJ5IHNsaWdodGx5OlxuLy8gICAgIC0gY29udmVydCBwb3dNb2RfIHRvIHVzZSBhIE1vbnRnb21lcnkgZm9ybSBvZiBrLWFyeSB3aW5kb3cgKG9yIG1heWJlIGEgTW9udGdvbWVyeSBmb3JtIG9mIHNsaWRpbmcgd2luZG93KVxuLy8gICAgICAgICAtLSB0aGlzIHNob3VsZCBlc3BlY2lhbGx5IGZvY3VzIG9uIGJlaW5nIGZhc3Qgd2hlbiByYWlzaW5nIDIgdG8gYSBwb3dlciBtb2QgblxuLy8gICAgIC0gY29udmVydCByYW5kVHJ1ZVByaW1lXygpIHRvIHVzZSBhIG1pbmltdW0gciBvZiAxLzMgaW5zdGVhZCBvZiAxLzIgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY2hhbmdlIHRvIHRoZSB0ZXN0XG4vLyAgICAgLSB0dW5lIHRoZSBwYXJhbWV0ZXJzIGluIHJhbmRUcnVlUHJpbWVfKCksIGluY2x1ZGluZyBjLCBtLCBhbmQgcmVjTGltaXRcbi8vICAgICAtIHNwZWVkIHVwIHRoZSBzaW5nbGUgbG9vcCBpbiBtb250XygpIHRoYXQgdGFrZXMgOTUlIG9mIHRoZSBydW50aW1lLCBwZXJoYXBzIGJ5IHJlZHVjaW5nIGNoZWNraW5nXG4vLyAgICAgICB3aXRoaW4gdGhlIGxvb3Agd2hlbiBhbGwgdGhlIHBhcmFtZXRlcnMgYXJlIHRoZSBzYW1lIGxlbmd0aC5cbi8vXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBpZGVhcyB0aGF0IGxvb2sgbGlrZSB0aGV5IHdvdWxkbid0IGhlbHAgbXVjaCBhdCBhbGw6XG4vLyAgICAgLSByZXBsYWNpbmcgdHJpYWwgZGl2aXNpb24gaW4gcmFuZFRydWVQcmltZV8oKSB3aXRoIGEgc2lldmUgKHRoYXQgc3BlZWRzIHVwIHNvbWV0aGluZyB0YWtpbmcgYWxtb3N0IG5vIHRpbWUgYW55d2F5KVxuLy8gICAgIC0gaW5jcmVhc2UgYnBlIGZyb20gMTUgdG8gMzAgKHRoYXQgd291bGQgaGVscCBpZiB3ZSBoYWQgYSAzMiozMi0+NjQgbXVsdGlwbGllciwgYnV0IG5vdCB3aXRoIEphdmFTY3JpcHQncyAzMiozMi0+MzIpXG4vLyAgICAgLSBzcGVlZGluZyB1cCBtb250Xyh4LHksbixucCkgd2hlbiB4PT15IGJ5IGRvaW5nIGEgbm9uLW1vZHVsYXIsIG5vbi1Nb250Z29tZXJ5IHNxdWFyZVxuLy8gICAgICAgZm9sbG93ZWQgYnkgYSBNb250Z29tZXJ5IHJlZHVjdGlvbi4gIFRoZSBpbnRlcm1lZGlhdGUgYW5zd2VyIHdpbGwgYmUgdHdpY2UgYXMgbG9uZyBhcyB4LCBzbyB0aGF0XG4vLyAgICAgICBtZXRob2Qgd291bGQgYmUgc2xvd2VyLiAgVGhpcyBpcyB1bmZvcnR1bmF0ZSBiZWNhdXNlIHRoZSBjb2RlIGN1cnJlbnRseSBzcGVuZHMgYWxtb3N0IGFsbCBvZiBpdHMgdGltZVxuLy8gICAgICAgZG9pbmcgbW9udF8oeCx4LC4uLiksIGJvdGggZm9yIHJhbmRUcnVlUHJpbWVfKCkgYW5kIHBvd01vZF8oKS4gIEEgZmFzdGVyIG1ldGhvZCBmb3IgTW9udGdvbWVyeSBzcXVhcmluZ1xuLy8gICAgICAgd291bGQgaGF2ZSBhIGxhcmdlIGltcGFjdCBvbiB0aGUgc3BlZWQgb2YgcmFuZFRydWVQcmltZV8oKSBhbmQgcG93TW9kXygpLiAgSEFDIGhhcyBhIGNvdXBsZSBvZiBwb29ybHktd29yZGVkXG4vLyAgICAgICBzZW50ZW5jZXMgdGhhdCBzZWVtIHRvIGltcGx5IGl0J3MgZmFzdGVyIHRvIGRvIGEgbm9uLW1vZHVsYXIgc3F1YXJlIGZvbGxvd2VkIGJ5IGEgc2luZ2xlXG4vLyAgICAgICBNb250Z29tZXJ5IHJlZHVjdGlvbiwgYnV0IHRoYXQncyBvYnZpb3VzbHkgd3JvbmcuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbihmdW5jdGlvbiAoKSB7XG4vL2dsb2JhbHNcbmJwZT0wOyAgICAgICAgIC8vYml0cyBzdG9yZWQgcGVyIGFycmF5IGVsZW1lbnRcbm1hc2s9MDsgICAgICAgIC8vQU5EIHRoaXMgd2l0aCBhbiBhcnJheSBlbGVtZW50IHRvIGNob3AgaXQgZG93biB0byBicGUgYml0c1xucmFkaXg9bWFzaysxOyAgLy9lcXVhbHMgMl5icGUuICBBIHNpbmdsZSAxIGJpdCB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBiaXQgb2YgbWFzay5cblxuLy90aGUgZGlnaXRzIGZvciBjb252ZXJ0aW5nIHRvIGRpZmZlcmVudCBiYXNlc1xuZGlnaXRzU3RyPScwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5el89IUAjJCVeJiooKVtde318OzosLjw+Lz9gfiBcXFxcXFwnXFxcIistJztcblxuLy9pbml0aWFsaXplIHRoZSBnbG9iYWwgdmFyaWFibGVzXG5mb3IgKGJwZT0wOyAoMTw8KGJwZSsxKSkgPiAoMTw8YnBlKTsgYnBlKyspOyAgLy9icGU9bnVtYmVyIG9mIGJpdHMgaW4gdGhlIG1hbnRpc3NhIG9uIHRoaXMgcGxhdGZvcm1cbmJwZT4+PTE7ICAgICAgICAgICAgICAgICAgIC8vYnBlPW51bWJlciBvZiBiaXRzIGluIG9uZSBlbGVtZW50IG9mIHRoZSBhcnJheSByZXByZXNlbnRpbmcgdGhlIGJpZ0ludFxubWFzaz0oMTw8YnBlKS0xOyAgICAgICAgICAgLy9BTkQgdGhlIG1hc2sgd2l0aCBhbiBpbnRlZ2VyIHRvIGdldCBpdHMgYnBlIGxlYXN0IHNpZ25pZmljYW50IGJpdHNcbnJhZGl4PW1hc2srMTsgICAgICAgICAgICAgIC8vMl5icGUuICBhIHNpbmdsZSAxIGJpdCB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3QgYml0IG9mIG1hc2tcbm9uZT1pbnQyYmlnSW50KDEsMSwxKTsgICAgIC8vY29uc3RhbnQgdXNlZCBpbiBwb3dNb2RfKClcblxuLy90aGUgZm9sbG93aW5nIGdsb2JhbCB2YXJpYWJsZXMgYXJlIHNjcmF0Y2hwYWQgbWVtb3J5IHRvXG4vL3JlZHVjZSBkeW5hbWljIG1lbW9yeSBhbGxvY2F0aW9uIGluIHRoZSBpbm5lciBsb29wXG50PW5ldyBBcnJheSgwKTtcbnNzPXQ7ICAgICAgIC8vdXNlZCBpbiBtdWx0XygpXG5zMD10OyAgICAgICAvL3VzZWQgaW4gbXVsdE1vZF8oKSwgc3F1YXJlTW9kXygpXG5zMT10OyAgICAgICAvL3VzZWQgaW4gcG93TW9kXygpLCBtdWx0TW9kXygpLCBzcXVhcmVNb2RfKClcbnMyPXQ7ICAgICAgIC8vdXNlZCBpbiBwb3dNb2RfKCksIG11bHRNb2RfKClcbnMzPXQ7ICAgICAgIC8vdXNlZCBpbiBwb3dNb2RfKClcbnM0PXQ7IHM1PXQ7IC8vdXNlZCBpbiBtb2RfKClcbnM2PXQ7ICAgICAgIC8vdXNlZCBpbiBiaWdJbnQyc3RyKClcbnM3PXQ7ICAgICAgIC8vdXNlZCBpbiBwb3dNb2RfKClcblQ9dDsgICAgICAgIC8vdXNlZCBpbiBHQ0RfKClcbnNhPXQ7ICAgICAgIC8vdXNlZCBpbiBtb250XygpXG5tcl94MT10OyBtcl9yPXQ7IG1yX2E9dDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXNlZCBpbiBtaWxsZXJSYWJpbigpXG5lZ192PXQ7IGVnX3U9dDsgZWdfQT10OyBlZ19CPXQ7IGVnX0M9dDsgZWdfRD10OyAgICAgICAgICAgICAgIC8vdXNlZCBpbiBlR0NEXygpLCBpbnZlcnNlTW9kXygpXG5tZF9xMT10OyBtZF9xMj10OyBtZF9xMz10OyBtZF9yPXQ7IG1kX3IxPXQ7IG1kX3IyPXQ7IG1kX3R0PXQ7IC8vdXNlZCBpbiBtb2RfKClcblxucHJpbWVzPXQ7IHBvd3M9dDsgc19pPXQ7IHNfaTI9dDsgc19SPXQ7IHNfcm09dDsgc19xPXQ7IHNfbjE9dDtcbiAgc19hPXQ7IHNfcjI9dDsgc19uPXQ7IHNfYj10OyBzX2Q9dDsgc194MT10OyBzX3gyPXQsIHNfYWE9dDsgLy91c2VkIGluIHJhbmRUcnVlUHJpbWVfKClcblxucnBwcmI9dDsgLy91c2VkIGluIHJhbmRQcm9iUHJpbWVSb3VuZHMoKSAod2hpY2ggYWxzbyB1c2VzIFwicHJpbWVzXCIpXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vL3JldHVybiBhcnJheSBvZiBhbGwgcHJpbWVzIGxlc3MgdGhhbiBpbnRlZ2VyIG5cbmZ1bmN0aW9uIGZpbmRQcmltZXMobikge1xuICB2YXIgaSxzLHAsYW5zO1xuICBzPW5ldyBBcnJheShuKTtcbiAgZm9yIChpPTA7aTxuO2krKylcbiAgICBzW2ldPTA7XG4gIHNbMF09MjtcbiAgcD0wOyAgICAvL2ZpcnN0IHAgZWxlbWVudHMgb2YgcyBhcmUgcHJpbWVzLCB0aGUgcmVzdCBhcmUgYSBzaWV2ZVxuICBmb3IoO3NbcF08bjspIHsgICAgICAgICAgICAgICAgICAvL3NbcF0gaXMgdGhlIHB0aCBwcmltZVxuICAgIGZvcihpPXNbcF0qc1twXTsgaTxuOyBpKz1zW3BdKSAvL21hcmsgbXVsdGlwbGVzIG9mIHNbcF1cbiAgICAgIHNbaV09MTtcbiAgICBwKys7XG4gICAgc1twXT1zW3AtMV0rMTtcbiAgICBmb3IoOyBzW3BdPG4gJiYgc1tzW3BdXTsgc1twXSsrKTsgLy9maW5kIG5leHQgcHJpbWUgKHdoZXJlIHNbcF09PTApXG4gIH1cbiAgYW5zPW5ldyBBcnJheShwKTtcbiAgZm9yKGk9MDtpPHA7aSsrKVxuICAgIGFuc1tpXT1zW2ldO1xuICByZXR1cm4gYW5zO1xufVxuXG5cbi8vZG9lcyBhIHNpbmdsZSByb3VuZCBvZiBNaWxsZXItUmFiaW4gYmFzZSBiIGNvbnNpZGVyIHggdG8gYmUgYSBwb3NzaWJsZSBwcmltZT9cbi8veCBpcyBhIGJpZ0ludCwgYW5kIGIgaXMgYW4gaW50ZWdlciwgd2l0aCBiPHhcbmZ1bmN0aW9uIG1pbGxlclJhYmluSW50KHgsYikge1xuICBpZiAobXJfeDEubGVuZ3RoIT14Lmxlbmd0aCkge1xuICAgIG1yX3gxPWR1cCh4KTtcbiAgICBtcl9yPWR1cCh4KTtcbiAgICBtcl9hPWR1cCh4KTtcbiAgfVxuXG4gIGNvcHlJbnRfKG1yX2EsYik7XG4gIHJldHVybiBtaWxsZXJSYWJpbih4LG1yX2EpO1xufVxuXG4vL2RvZXMgYSBzaW5nbGUgcm91bmQgb2YgTWlsbGVyLVJhYmluIGJhc2UgYiBjb25zaWRlciB4IHRvIGJlIGEgcG9zc2libGUgcHJpbWU/XG4vL3ggYW5kIGIgYXJlIGJpZ0ludHMgd2l0aCBiPHhcbmZ1bmN0aW9uIG1pbGxlclJhYmluKHgsYikge1xuICB2YXIgaSxqLGsscztcblxuICBpZiAobXJfeDEubGVuZ3RoIT14Lmxlbmd0aCkge1xuICAgIG1yX3gxPWR1cCh4KTtcbiAgICBtcl9yPWR1cCh4KTtcbiAgICBtcl9hPWR1cCh4KTtcbiAgfVxuXG4gIGNvcHlfKG1yX2EsYik7XG4gIGNvcHlfKG1yX3IseCk7XG4gIGNvcHlfKG1yX3gxLHgpO1xuXG4gIGFkZEludF8obXJfciwtMSk7XG4gIGFkZEludF8obXJfeDEsLTEpO1xuXG4gIC8vcz10aGUgaGlnaGVzdCBwb3dlciBvZiB0d28gdGhhdCBkaXZpZGVzIG1yX3JcbiAgaz0wO1xuICBmb3IgKGk9MDtpPG1yX3IubGVuZ3RoO2krKylcbiAgICBmb3IgKGo9MTtqPG1hc2s7ajw8PTEpXG4gICAgICBpZiAoeFtpXSAmIGopIHtcbiAgICAgICAgcz0oazxtcl9yLmxlbmd0aCticGUgPyBrIDogMCk7XG4gICAgICAgICBpPW1yX3IubGVuZ3RoO1xuICAgICAgICAgaj1tYXNrO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGsrKztcblxuICBpZiAocylcbiAgICByaWdodFNoaWZ0Xyhtcl9yLHMpO1xuXG4gIHBvd01vZF8obXJfYSxtcl9yLHgpO1xuXG4gIGlmICghZXF1YWxzSW50KG1yX2EsMSkgJiYgIWVxdWFscyhtcl9hLG1yX3gxKSkge1xuICAgIGo9MTtcbiAgICB3aGlsZSAoajw9cy0xICYmICFlcXVhbHMobXJfYSxtcl94MSkpIHtcbiAgICAgIHNxdWFyZU1vZF8obXJfYSx4KTtcbiAgICAgIGlmIChlcXVhbHNJbnQobXJfYSwxKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGorKztcbiAgICB9XG4gICAgaWYgKCFlcXVhbHMobXJfYSxtcl94MSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLy9yZXR1cm5zIGhvdyBtYW55IGJpdHMgbG9uZyB0aGUgYmlnSW50IGlzLCBub3QgY291bnRpbmcgbGVhZGluZyB6ZXJvcy5cbmZ1bmN0aW9uIGJpdFNpemUoeCkge1xuICB2YXIgaix6LHc7XG4gIGZvciAoaj14Lmxlbmd0aC0xOyAoeFtqXT09MCkgJiYgKGo+MCk7IGotLSk7XG4gIGZvciAoej0wLHc9eFtqXTsgdzsgKHc+Pj0xKSx6KyspO1xuICB6Kz1icGUqajtcbiAgcmV0dXJuIHo7XG59XG5cbi8vcmV0dXJuIGEgY29weSBvZiB4IHdpdGggYXQgbGVhc3QgbiBlbGVtZW50cywgYWRkaW5nIGxlYWRpbmcgemVyb3MgaWYgbmVlZGVkXG5mdW5jdGlvbiBleHBhbmQoeCxuKSB7XG4gIHZhciBhbnM9aW50MmJpZ0ludCgwLCh4Lmxlbmd0aD5uID8geC5sZW5ndGggOiBuKSpicGUsMCk7XG4gIGNvcHlfKGFucyx4KTtcbiAgcmV0dXJuIGFucztcbn1cblxuLy9yZXR1cm4gYSBrLWJpdCB0cnVlIHJhbmRvbSBwcmltZSB1c2luZyBNYXVyZXIncyBhbGdvcml0aG0uXG5mdW5jdGlvbiByYW5kVHJ1ZVByaW1lKGspIHtcbiAgdmFyIGFucz1pbnQyYmlnSW50KDAsaywwKTtcbiAgcmFuZFRydWVQcmltZV8oYW5zLGspO1xuICByZXR1cm4gdHJpbShhbnMsMSk7XG59XG5cbi8vcmV0dXJuIGEgay1iaXQgcmFuZG9tIHByb2JhYmxlIHByaW1lIHdpdGggcHJvYmFiaWxpdHkgb2YgZXJyb3IgPCAyXi04MFxuZnVuY3Rpb24gcmFuZFByb2JQcmltZShrKSB7XG4gIGlmIChrPj02MDApIHJldHVybiByYW5kUHJvYlByaW1lUm91bmRzKGssMik7IC8vbnVtYmVycyBmcm9tIEhBQyB0YWJsZSA0LjNcbiAgaWYgKGs+PTU1MCkgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoayw0KTtcbiAgaWYgKGs+PTUwMCkgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoayw1KTtcbiAgaWYgKGs+PTQwMCkgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoayw2KTtcbiAgaWYgKGs+PTM1MCkgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoayw3KTtcbiAgaWYgKGs+PTMwMCkgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoayw5KTtcbiAgaWYgKGs+PTI1MCkgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoaywxMik7IC8vbnVtYmVycyBmcm9tIEhBQyB0YWJsZSA0LjRcbiAgaWYgKGs+PTIwMCkgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoaywxNSk7XG4gIGlmIChrPj0xNTApIHJldHVybiByYW5kUHJvYlByaW1lUm91bmRzKGssMTgpO1xuICBpZiAoaz49MTAwKSByZXR1cm4gcmFuZFByb2JQcmltZVJvdW5kcyhrLDI3KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmRQcm9iUHJpbWVSb3VuZHMoayw0MCk7IC8vbnVtYmVyIGZyb20gSEFDIHJlbWFyayA0LjI2IChvbmx5IGFuIGVzdGltYXRlKVxufVxuXG4vL3JldHVybiBhIGstYml0IHByb2JhYmxlIHJhbmRvbSBwcmltZSB1c2luZyBuIHJvdW5kcyBvZiBNaWxsZXIgUmFiaW4gKGFmdGVyIHRyaWFsIGRpdmlzaW9uIHdpdGggc21hbGwgcHJpbWVzKVxuZnVuY3Rpb24gcmFuZFByb2JQcmltZVJvdW5kcyhrLG4pIHtcbiAgdmFyIGFucywgaSwgZGl2aXNpYmxlLCBCO1xuICBCPTMwMDAwOyAgLy9CIGlzIGxhcmdlc3QgcHJpbWUgdG8gdXNlIGluIHRyaWFsIGRpdmlzaW9uXG4gIGFucz1pbnQyYmlnSW50KDAsaywwKTtcblxuICAvL29wdGltaXphdGlvbjogdHJ5IGxhcmdlciBhbmQgc21hbGxlciBCIHRvIGZpbmQgdGhlIGJlc3QgbGltaXQuXG5cbiAgaWYgKHByaW1lcy5sZW5ndGg9PTApXG4gICAgcHJpbWVzPWZpbmRQcmltZXMoMzAwMDApOyAgLy9jaGVjayBmb3IgZGl2aXNpYmlsaXR5IGJ5IHByaW1lcyA8PTMwMDAwXG5cbiAgaWYgKHJwcHJiLmxlbmd0aCE9YW5zLmxlbmd0aClcbiAgICBycHByYj1kdXAoYW5zKTtcblxuICBmb3IgKDs7KSB7IC8va2VlcCB0cnlpbmcgcmFuZG9tIHZhbHVlcyBmb3IgYW5zIHVudGlsIG9uZSBhcHBlYXJzIHRvIGJlIHByaW1lXG4gICAgLy9vcHRpbWl6YXRpb246IHBpY2sgYSByYW5kb20gbnVtYmVyIHRpbWVzIEw9MiozKjUqLi4uKnAsIHBsdXMgYVxuICAgIC8vICAgcmFuZG9tIGVsZW1lbnQgb2YgdGhlIGxpc3Qgb2YgYWxsIG51bWJlcnMgaW4gWzAsTCkgbm90IGRpdmlzaWJsZSBieSBhbnkgcHJpbWUgdXAgdG8gcC5cbiAgICAvLyAgIFRoaXMgY2FuIHJlZHVjZSB0aGUgYW1vdW50IG9mIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbi5cblxuICAgIHJhbmRCaWdJbnRfKGFucyxrLDApOyAvL2FucyA9IGEgcmFuZG9tIG9kZCBudW1iZXIgdG8gY2hlY2tcbiAgICBhbnNbMF0gfD0gMTtcbiAgICBkaXZpc2libGU9MDtcblxuICAgIC8vY2hlY2sgYW5zIGZvciBkaXZpc2liaWxpdHkgYnkgc21hbGwgcHJpbWVzIHVwIHRvIEJcbiAgICBmb3IgKGk9MDsgKGk8cHJpbWVzLmxlbmd0aCkgJiYgKHByaW1lc1tpXTw9Qik7IGkrKylcbiAgICAgIGlmIChtb2RJbnQoYW5zLHByaW1lc1tpXSk9PTAgJiYgIWVxdWFsc0ludChhbnMscHJpbWVzW2ldKSkge1xuICAgICAgICBkaXZpc2libGU9MTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAvL29wdGltaXphdGlvbjogY2hhbmdlIG1pbGxlclJhYmluIHNvIHRoZSBiYXNlIGNhbiBiZSBiaWdnZXIgdGhhbiB0aGUgbnVtYmVyIGJlaW5nIGNoZWNrZWQsIHRoZW4gZWxpbWluYXRlIHRoZSB3aGlsZSBoZXJlLlxuXG4gICAgLy9kbyBuIHJvdW5kcyBvZiBNaWxsZXIgUmFiaW4sIHdpdGggcmFuZG9tIGJhc2VzIGxlc3MgdGhhbiBhbnNcbiAgICBmb3IgKGk9MDsgaTxuICYmICFkaXZpc2libGU7IGkrKykge1xuICAgICAgcmFuZEJpZ0ludF8ocnBwcmIsaywwKTtcbiAgICAgIHdoaWxlKCFncmVhdGVyKGFucyxycHByYikpIC8vcGljayBhIHJhbmRvbSBycHByYiB0aGF0J3MgPCBhbnNcbiAgICAgICAgcmFuZEJpZ0ludF8ocnBwcmIsaywwKTtcbiAgICAgIGlmICghbWlsbGVyUmFiaW4oYW5zLHJwcHJiKSlcbiAgICAgICAgZGl2aXNpYmxlPTE7XG4gICAgfVxuXG4gICAgaWYoIWRpdmlzaWJsZSlcbiAgICAgIHJldHVybiBhbnM7XG4gIH1cbn1cblxuLy9yZXR1cm4gYSBuZXcgYmlnSW50IGVxdWFsIHRvICh4IG1vZCBuKSBmb3IgYmlnSW50cyB4IGFuZCBuLlxuZnVuY3Rpb24gbW9kKHgsbikge1xuICB2YXIgYW5zPWR1cCh4KTtcbiAgbW9kXyhhbnMsbik7XG4gIHJldHVybiB0cmltKGFucywxKTtcbn1cblxuLy9yZXR1cm4gKHgrbikgd2hlcmUgeCBpcyBhIGJpZ0ludCBhbmQgbiBpcyBhbiBpbnRlZ2VyLlxuZnVuY3Rpb24gYWRkSW50KHgsbikge1xuICB2YXIgYW5zPWV4cGFuZCh4LHgubGVuZ3RoKzEpO1xuICBhZGRJbnRfKGFucyxuKTtcbiAgcmV0dXJuIHRyaW0oYW5zLDEpO1xufVxuXG4vL3JldHVybiB4KnkgZm9yIGJpZ0ludHMgeCBhbmQgeS4gVGhpcyBpcyBmYXN0ZXIgd2hlbiB5PHguXG5mdW5jdGlvbiBtdWx0KHgseSkge1xuICB2YXIgYW5zPWV4cGFuZCh4LHgubGVuZ3RoK3kubGVuZ3RoKTtcbiAgbXVsdF8oYW5zLHkpO1xuICByZXR1cm4gdHJpbShhbnMsMSk7XG59XG5cbi8vcmV0dXJuICh4Kip5IG1vZCBuKSB3aGVyZSB4LHksbiBhcmUgYmlnSW50cyBhbmQgKiogaXMgZXhwb25lbnRpYXRpb24uICAwKiowPTEuIEZhc3RlciBmb3Igb2RkIG4uXG5mdW5jdGlvbiBwb3dNb2QoeCx5LG4pIHtcbiAgdmFyIGFucz1leHBhbmQoeCxuLmxlbmd0aCk7XG4gIHBvd01vZF8oYW5zLHRyaW0oeSwyKSx0cmltKG4sMiksMCk7ICAvL3RoaXMgc2hvdWxkIHdvcmsgd2l0aG91dCB0aGUgdHJpbSwgYnV0IGRvZXNuJ3RcbiAgcmV0dXJuIHRyaW0oYW5zLDEpO1xufVxuXG4vL3JldHVybiAoeC15KSBmb3IgYmlnSW50cyB4IGFuZCB5LiAgTmVnYXRpdmUgYW5zd2VycyB3aWxsIGJlIDJzIGNvbXBsZW1lbnRcbmZ1bmN0aW9uIHN1Yih4LHkpIHtcbiAgdmFyIGFucz1leHBhbmQoeCwoeC5sZW5ndGg+eS5sZW5ndGggPyB4Lmxlbmd0aCsxIDogeS5sZW5ndGgrMSkpO1xuICBzdWJfKGFucyx5KTtcbiAgcmV0dXJuIHRyaW0oYW5zLDEpO1xufVxuXG4vL3JldHVybiAoeCt5KSBmb3IgYmlnSW50cyB4IGFuZCB5LlxuZnVuY3Rpb24gYWRkKHgseSkge1xuICB2YXIgYW5zPWV4cGFuZCh4LCh4Lmxlbmd0aD55Lmxlbmd0aCA/IHgubGVuZ3RoKzEgOiB5Lmxlbmd0aCsxKSk7XG4gIGFkZF8oYW5zLHkpO1xuICByZXR1cm4gdHJpbShhbnMsMSk7XG59XG5cbi8vcmV0dXJuICh4KiooLTEpIG1vZCBuKSBmb3IgYmlnSW50cyB4IGFuZCBuLiAgSWYgbm8gaW52ZXJzZSBleGlzdHMsIGl0IHJldHVybnMgbnVsbFxuZnVuY3Rpb24gaW52ZXJzZU1vZCh4LG4pIHtcbiAgdmFyIGFucz1leHBhbmQoeCxuLmxlbmd0aCk7XG4gIHZhciBzO1xuICBzPWludmVyc2VNb2RfKGFucyxuKTtcbiAgcmV0dXJuIHMgPyB0cmltKGFucywxKSA6IG51bGw7XG59XG5cbi8vcmV0dXJuICh4KnkgbW9kIG4pIGZvciBiaWdJbnRzIHgseSxuLiAgRm9yIGdyZWF0ZXIgc3BlZWQsIGxldCB5PHguXG5mdW5jdGlvbiBtdWx0TW9kKHgseSxuKSB7XG4gIHZhciBhbnM9ZXhwYW5kKHgsbi5sZW5ndGgpO1xuICBtdWx0TW9kXyhhbnMseSxuKTtcbiAgcmV0dXJuIHRyaW0oYW5zLDEpO1xufVxuXG4vL2dlbmVyYXRlIGEgay1iaXQgdHJ1ZSByYW5kb20gcHJpbWUgdXNpbmcgTWF1cmVyJ3MgYWxnb3JpdGhtLFxuLy9hbmQgcHV0IGl0IGludG8gYW5zLiAgVGhlIGJpZ0ludCBhbnMgbXVzdCBiZSBsYXJnZSBlbm91Z2ggdG8gaG9sZCBpdC5cbmZ1bmN0aW9uIHJhbmRUcnVlUHJpbWVfKGFucyxrKSB7XG4gIHZhciBjLG0scG0sZGQsaixyLEIsZGl2aXNpYmxlLHosenoscmVjU2l6ZTtcblxuICBpZiAocHJpbWVzLmxlbmd0aD09MClcbiAgICBwcmltZXM9ZmluZFByaW1lcygzMDAwMCk7ICAvL2NoZWNrIGZvciBkaXZpc2liaWxpdHkgYnkgcHJpbWVzIDw9MzAwMDBcblxuICBpZiAocG93cy5sZW5ndGg9PTApIHtcbiAgICBwb3dzPW5ldyBBcnJheSg1MTIpO1xuICAgIGZvciAoaj0wO2o8NTEyO2orKykge1xuICAgICAgcG93c1tqXT1NYXRoLnBvdygyLGovNTExLi0xLik7XG4gICAgfVxuICB9XG5cbiAgLy9jIGFuZCBtIHNob3VsZCBiZSB0dW5lZCBmb3IgYSBwYXJ0aWN1bGFyIG1hY2hpbmUgYW5kIHZhbHVlIG9mIGssIHRvIG1heGltaXplIHNwZWVkXG4gIGM9MC4xOyAgLy9jPTAuMSBpbiBIQUNcbiAgbT0yMDsgICAvL2dlbmVyYXRlIHRoaXMgay1iaXQgbnVtYmVyIGJ5IGZpcnN0IHJlY3Vyc2l2ZWx5IGdlbmVyYXRpbmcgYSBudW1iZXIgdGhhdCBoYXMgYmV0d2VlbiBrLzIgYW5kIGstbSBiaXRzXG4gIHJlY0xpbWl0PTIwOyAvL3N0b3AgcmVjdXJzaW9uIHdoZW4gayA8PXJlY0xpbWl0LiAgTXVzdCBoYXZlIHJlY0xpbWl0ID49IDJcblxuICBpZiAoc19pMi5sZW5ndGghPWFucy5sZW5ndGgpIHtcbiAgICBzX2kyPWR1cChhbnMpO1xuICAgIHNfUiA9ZHVwKGFucyk7XG4gICAgc19uMT1kdXAoYW5zKTtcbiAgICBzX3IyPWR1cChhbnMpO1xuICAgIHNfZCA9ZHVwKGFucyk7XG4gICAgc194MT1kdXAoYW5zKTtcbiAgICBzX3gyPWR1cChhbnMpO1xuICAgIHNfYiA9ZHVwKGFucyk7XG4gICAgc19uID1kdXAoYW5zKTtcbiAgICBzX2kgPWR1cChhbnMpO1xuICAgIHNfcm09ZHVwKGFucyk7XG4gICAgc19xID1kdXAoYW5zKTtcbiAgICBzX2EgPWR1cChhbnMpO1xuICAgIHNfYWE9ZHVwKGFucyk7XG4gIH1cblxuICBpZiAoayA8PSByZWNMaW1pdCkgeyAgLy9nZW5lcmF0ZSBzbWFsbCByYW5kb20gcHJpbWVzIGJ5IHRyaWFsIGRpdmlzaW9uIHVwIHRvIGl0cyBzcXVhcmUgcm9vdFxuICAgIHBtPSgxPDwoKGsrMik+PjEpKS0xOyAvL3BtIGlzIGJpbmFyeSBudW1iZXIgd2l0aCBhbGwgb25lcywganVzdCBvdmVyIHNxcnQoMl5rKVxuICAgIGNvcHlJbnRfKGFucywwKTtcbiAgICBmb3IgKGRkPTE7ZGQ7KSB7XG4gICAgICBkZD0wO1xuICAgICAgYW5zWzBdPSAxIHwgKDE8PChrLTEpKSB8IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSooMTw8aykpOyAgLy9yYW5kb20sIGstYml0LCBvZGQgaW50ZWdlciwgd2l0aCBtc2IgMVxuICAgICAgZm9yIChqPTE7KGo8cHJpbWVzLmxlbmd0aCkgJiYgKChwcmltZXNbal0mcG0pPT1wcmltZXNbal0pO2orKykgeyAvL3RyaWFsIGRpdmlzaW9uIGJ5IGFsbCBwcmltZXMgMy4uLnNxcnQoMl5rKVxuICAgICAgICBpZiAoMD09KGFuc1swXSVwcmltZXNbal0pKSB7XG4gICAgICAgICAgZGQ9MTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYXJyeV8oYW5zKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBCPWMqayprOyAgICAvL3RyeSBzbWFsbCBwcmltZXMgdXAgdG8gQiAob3IgYWxsIHRoZSBwcmltZXNbXSBhcnJheSBpZiB0aGUgbGFyZ2VzdCBpcyBsZXNzIHRoYW4gQikuXG4gIGlmIChrPjIqbSkgIC8vZ2VuZXJhdGUgdGhpcyBrLWJpdCBudW1iZXIgYnkgZmlyc3QgcmVjdXJzaXZlbHkgZ2VuZXJhdGluZyBhIG51bWJlciB0aGF0IGhhcyBiZXR3ZWVuIGsvMiBhbmQgay1tIGJpdHNcbiAgICBmb3IgKHI9MTsgay1rKnI8PW07IClcbiAgICAgIHI9cG93c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNTEyKV07ICAgLy9yPU1hdGgucG93KDIsTWF0aC5yYW5kb20oKS0xKTtcbiAgZWxzZVxuICAgIHI9LjU7XG5cbiAgLy9zaW11bGF0aW9uIHN1Z2dlc3RzIHRoZSBtb3JlIGNvbXBsZXggYWxnb3JpdGhtIHVzaW5nIHI9LjMzMyBpcyBvbmx5IHNsaWdodGx5IGZhc3Rlci5cblxuICByZWNTaXplPU1hdGguZmxvb3IociprKSsxO1xuXG4gIHJhbmRUcnVlUHJpbWVfKHNfcSxyZWNTaXplKTtcbiAgY29weUludF8oc19pMiwwKTtcbiAgc19pMltNYXRoLmZsb29yKChrLTIpL2JwZSldIHw9ICgxPDwoKGstMiklYnBlKSk7ICAgLy9zX2kyPTJeKGstMilcbiAgZGl2aWRlXyhzX2kyLHNfcSxzX2ksc19ybSk7ICAgICAgICAgICAgICAgICAgICAgICAgLy9zX2k9Zmxvb3IoKDJeKGstMSkpLygycSkpXG5cbiAgej1iaXRTaXplKHNfaSk7XG5cbiAgZm9yICg7Oykge1xuICAgIGZvciAoOzspIHsgIC8vZ2VuZXJhdGUgei1iaXQgbnVtYmVycyB1bnRpbCBvbmUgZmFsbHMgaW4gdGhlIHJhbmdlIFswLHNfaS0xXVxuICAgICAgcmFuZEJpZ0ludF8oc19SLHosMCk7XG4gICAgICBpZiAoZ3JlYXRlcihzX2ksc19SKSlcbiAgICAgICAgYnJlYWs7XG4gICAgfSAgICAgICAgICAgICAgICAvL25vdyBzX1IgaXMgaW4gdGhlIHJhbmdlIFswLHNfaS0xXVxuICAgIGFkZEludF8oc19SLDEpOyAgLy9ub3cgc19SIGlzIGluIHRoZSByYW5nZSBbMSxzX2ldXG4gICAgYWRkXyhzX1Isc19pKTsgICAvL25vdyBzX1IgaXMgaW4gdGhlIHJhbmdlIFtzX2krMSwyKnNfaV1cblxuICAgIGNvcHlfKHNfbixzX3EpO1xuICAgIG11bHRfKHNfbixzX1IpO1xuICAgIG11bHRJbnRfKHNfbiwyKTtcbiAgICBhZGRJbnRfKHNfbiwxKTsgICAgLy9zX249MipzX1Iqc19xKzFcblxuICAgIGNvcHlfKHNfcjIsc19SKTtcbiAgICBtdWx0SW50XyhzX3IyLDIpOyAgLy9zX3IyPTIqc19SXG5cbiAgICAvL2NoZWNrIHNfbiBmb3IgZGl2aXNpYmlsaXR5IGJ5IHNtYWxsIHByaW1lcyB1cCB0byBCXG4gICAgZm9yIChkaXZpc2libGU9MCxqPTA7IChqPHByaW1lcy5sZW5ndGgpICYmIChwcmltZXNbal08Qik7IGorKylcbiAgICAgIGlmIChtb2RJbnQoc19uLHByaW1lc1tqXSk9PTAgJiYgIWVxdWFsc0ludChzX24scHJpbWVzW2pdKSkge1xuICAgICAgICBkaXZpc2libGU9MTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoIWRpdmlzaWJsZSkgICAgLy9pZiBpdCBwYXNzZXMgc21hbGwgcHJpbWVzIGNoZWNrLCB0aGVuIHRyeSBhIHNpbmdsZSBNaWxsZXItUmFiaW4gYmFzZSAyXG4gICAgICBpZiAoIW1pbGxlclJhYmluSW50KHNfbiwyKSkgLy90aGlzIGxpbmUgcmVwcmVzZW50cyA3NSUgb2YgdGhlIHRvdGFsIHJ1bnRpbWUgZm9yIHJhbmRUcnVlUHJpbWVfXG4gICAgICAgIGRpdmlzaWJsZT0xO1xuXG4gICAgaWYgKCFkaXZpc2libGUpIHsgIC8vaWYgaXQgcGFzc2VzIHRoYXQgdGVzdCwgY29udGludWUgY2hlY2tpbmcgc19uXG4gICAgICBhZGRJbnRfKHNfbiwtMyk7XG4gICAgICBmb3IgKGo9c19uLmxlbmd0aC0xOyhzX25bal09PTApICYmIChqPjApOyBqLS0pOyAgLy9zdHJpcCBsZWFkaW5nIHplcm9zXG4gICAgICBmb3IgKHp6PTAsdz1zX25bal07IHc7ICh3Pj49MSksenorKyk7XG4gICAgICB6eis9YnBlKmo7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3p6PW51bWJlciBvZiBiaXRzIGluIHNfbiwgaWdub3JpbmcgbGVhZGluZyB6ZXJvc1xuICAgICAgZm9yICg7OykgeyAgLy9nZW5lcmF0ZSB6LWJpdCBudW1iZXJzIHVudGlsIG9uZSBmYWxscyBpbiB0aGUgcmFuZ2UgWzAsc19uLTFdXG4gICAgICAgIHJhbmRCaWdJbnRfKHNfYSx6eiwwKTtcbiAgICAgICAgaWYgKGdyZWF0ZXIoc19uLHNfYSkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9ICAgICAgICAgICAgICAgIC8vbm93IHNfYSBpcyBpbiB0aGUgcmFuZ2UgWzAsc19uLTFdXG4gICAgICBhZGRJbnRfKHNfbiwzKTsgIC8vbm93IHNfYSBpcyBpbiB0aGUgcmFuZ2UgWzAsc19uLTRdXG4gICAgICBhZGRJbnRfKHNfYSwyKTsgIC8vbm93IHNfYSBpcyBpbiB0aGUgcmFuZ2UgWzIsc19uLTJdXG4gICAgICBjb3B5XyhzX2Isc19hKTtcbiAgICAgIGNvcHlfKHNfbjEsc19uKTtcbiAgICAgIGFkZEludF8oc19uMSwtMSk7XG4gICAgICBwb3dNb2RfKHNfYixzX24xLHNfbik7ICAgLy9zX2I9c19hXihzX24tMSkgbW9kdWxvIHNfblxuICAgICAgYWRkSW50XyhzX2IsLTEpO1xuICAgICAgaWYgKGlzWmVybyhzX2IpKSB7XG4gICAgICAgIGNvcHlfKHNfYixzX2EpO1xuICAgICAgICBwb3dNb2RfKHNfYixzX3IyLHNfbik7XG4gICAgICAgIGFkZEludF8oc19iLC0xKTtcbiAgICAgICAgY29weV8oc19hYSxzX24pO1xuICAgICAgICBjb3B5XyhzX2Qsc19iKTtcbiAgICAgICAgR0NEXyhzX2Qsc19uKTsgIC8vaWYgc19iIGFuZCBzX24gYXJlIHJlbGF0aXZlbHkgcHJpbWUsIHRoZW4gc19uIGlzIGEgcHJpbWVcbiAgICAgICAgaWYgKGVxdWFsc0ludChzX2QsMSkpIHtcbiAgICAgICAgICBjb3B5XyhhbnMsc19hYSk7XG4gICAgICAgICAgcmV0dXJuOyAgICAgLy9pZiB3ZSd2ZSBtYWRlIGl0IHRoaXMgZmFyLCB0aGVuIHNfbiBpcyBhYnNvbHV0ZWx5IGd1YXJhbnRlZWQgdG8gYmUgcHJpbWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL1JldHVybiBhbiBuLWJpdCByYW5kb20gQmlnSW50IChuPj0xKS4gIElmIHM9MSwgdGhlbiB0aGUgbW9zdCBzaWduaWZpY2FudCBvZiB0aG9zZSBuIGJpdHMgaXMgc2V0IHRvIDEuXG5mdW5jdGlvbiByYW5kQmlnSW50KG4scykge1xuICB2YXIgYSxiO1xuICBhPU1hdGguZmxvb3IoKG4tMSkvYnBlKSsyOyAvLyMgYXJyYXkgZWxlbWVudHMgdG8gaG9sZCB0aGUgQmlnSW50IHdpdGggYSBsZWFkaW5nIDAgZWxlbWVudFxuICBiPWludDJiaWdJbnQoMCwwLGEpO1xuICByYW5kQmlnSW50XyhiLG4scyk7XG4gIHJldHVybiBiO1xufVxuXG4vL1NldCBiIHRvIGFuIG4tYml0IHJhbmRvbSBCaWdJbnQuICBJZiBzPTEsIHRoZW4gdGhlIG1vc3Qgc2lnbmlmaWNhbnQgb2YgdGhvc2UgbiBiaXRzIGlzIHNldCB0byAxLlxuLy9BcnJheSBiIG11c3QgYmUgYmlnIGVub3VnaCB0byBob2xkIHRoZSByZXN1bHQuIE11c3QgaGF2ZSBuPj0xXG5mdW5jdGlvbiByYW5kQmlnSW50XyhiLG4scykge1xuICB2YXIgaSxhO1xuICBmb3IgKGk9MDtpPGIubGVuZ3RoO2krKylcbiAgICBiW2ldPTA7XG4gIGE9TWF0aC5mbG9vcigobi0xKS9icGUpKzE7IC8vIyBhcnJheSBlbGVtZW50cyB0byBob2xkIHRoZSBCaWdJbnRcbiAgZm9yIChpPTA7aTxhO2krKykge1xuICAgIGJbaV09TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKigxPDwoYnBlLTEpKSk7XG4gIH1cbiAgYlthLTFdICY9ICgyPDwoKG4tMSklYnBlKSktMTtcbiAgaWYgKHM9PTEpXG4gICAgYlthLTFdIHw9ICgxPDwoKG4tMSklYnBlKSk7XG59XG5cbi8vUmV0dXJuIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiBiaWdJbnRzIHggYW5kIHkgKGVhY2ggd2l0aCBzYW1lIG51bWJlciBvZiBlbGVtZW50cykuXG5mdW5jdGlvbiBHQ0QoeCx5KSB7XG4gIHZhciB4Yyx5YztcbiAgeGM9ZHVwKHgpO1xuICB5Yz1kdXAoeSk7XG4gIEdDRF8oeGMseWMpO1xuICByZXR1cm4geGM7XG59XG5cbi8vc2V0IHggdG8gdGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIG9mIGJpZ0ludHMgeCBhbmQgeSAoZWFjaCB3aXRoIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzKS5cbi8veSBpcyBkZXN0cm95ZWQuXG5mdW5jdGlvbiBHQ0RfKHgseSkge1xuICB2YXIgaSx4cCx5cCxBLEIsQyxELHEsc2luZztcbiAgaWYgKFQubGVuZ3RoIT14Lmxlbmd0aClcbiAgICBUPWR1cCh4KTtcblxuICBzaW5nPTE7XG4gIHdoaWxlIChzaW5nKSB7IC8vd2hpbGUgeSBoYXMgbm9uemVybyBlbGVtZW50cyBvdGhlciB0aGFuIHlbMF1cbiAgICBzaW5nPTA7XG4gICAgZm9yIChpPTE7aTx5Lmxlbmd0aDtpKyspIC8vY2hlY2sgaWYgeSBoYXMgbm9uemVybyBlbGVtZW50cyBvdGhlciB0aGFuIDBcbiAgICAgIGlmICh5W2ldKSB7XG4gICAgICAgIHNpbmc9MTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgaWYgKCFzaW5nKSBicmVhazsgLy9xdWl0IHdoZW4geSBhbGwgemVybyBlbGVtZW50cyBleGNlcHQgcG9zc2libHkgeVswXVxuXG4gICAgZm9yIChpPXgubGVuZ3RoOyF4W2ldICYmIGk+PTA7aS0tKTsgIC8vZmluZCBtb3N0IHNpZ25pZmljYW50IGVsZW1lbnQgb2YgeFxuICAgIHhwPXhbaV07XG4gICAgeXA9eVtpXTtcbiAgICBBPTE7IEI9MDsgQz0wOyBEPTE7XG4gICAgd2hpbGUgKCh5cCtDKSAmJiAoeXArRCkpIHtcbiAgICAgIHEgPU1hdGguZmxvb3IoKHhwK0EpLyh5cCtDKSk7XG4gICAgICBxcD1NYXRoLmZsb29yKCh4cCtCKS8oeXArRCkpO1xuICAgICAgaWYgKHEhPXFwKVxuICAgICAgICBicmVhaztcbiAgICAgIHQ9IEEtcSpDOyAgIEE9QzsgICBDPXQ7ICAgIC8vICBkbyAoQSxCLHhwLCBDLEQseXApID0gKEMsRCx5cCwgQSxCLHhwKSAtIHEqKDAsMCwwLCBDLEQseXApXG4gICAgICB0PSBCLXEqRDsgICBCPUQ7ICAgRD10O1xuICAgICAgdD14cC1xKnlwOyB4cD15cDsgeXA9dDtcbiAgICB9XG4gICAgaWYgKEIpIHtcbiAgICAgIGNvcHlfKFQseCk7XG4gICAgICBsaW5Db21iXyh4LHksQSxCKTsgLy94PUEqeCtCKnlcbiAgICAgIGxpbkNvbWJfKHksVCxELEMpOyAvL3k9RCp5K0MqVFxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RfKHgseSk7XG4gICAgICBjb3B5XyhULHgpO1xuICAgICAgY29weV8oeCx5KTtcbiAgICAgIGNvcHlfKHksVCk7XG4gICAgfVxuICB9XG4gIGlmICh5WzBdPT0wKVxuICAgIHJldHVybjtcbiAgdD1tb2RJbnQoeCx5WzBdKTtcbiAgY29weUludF8oeCx5WzBdKTtcbiAgeVswXT10O1xuICB3aGlsZSAoeVswXSkge1xuICAgIHhbMF0lPXlbMF07XG4gICAgdD14WzBdOyB4WzBdPXlbMF07IHlbMF09dDtcbiAgfVxufVxuXG4vL2RvIHg9eCoqKC0xKSBtb2QgbiwgZm9yIGJpZ0ludHMgeCBhbmQgbi5cbi8vSWYgbm8gaW52ZXJzZSBleGlzdHMsIGl0IHNldHMgeCB0byB6ZXJvIGFuZCByZXR1cm5zIDAsIGVsc2UgaXQgcmV0dXJucyAxLlxuLy9UaGUgeCBhcnJheSBtdXN0IGJlIGF0IGxlYXN0IGFzIGxhcmdlIGFzIHRoZSBuIGFycmF5LlxuZnVuY3Rpb24gaW52ZXJzZU1vZF8oeCxuKSB7XG4gIHZhciBrPTErMipNYXRoLm1heCh4Lmxlbmd0aCxuLmxlbmd0aCk7XG5cbiAgaWYoISh4WzBdJjEpICAmJiAhKG5bMF0mMSkpIHsgIC8vaWYgYm90aCBpbnB1dHMgYXJlIGV2ZW4sIHRoZW4gaW52ZXJzZSBkb2Vzbid0IGV4aXN0XG4gICAgY29weUludF8oeCwwKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChlZ191Lmxlbmd0aCE9aykge1xuICAgIGVnX3U9bmV3IEFycmF5KGspO1xuICAgIGVnX3Y9bmV3IEFycmF5KGspO1xuICAgIGVnX0E9bmV3IEFycmF5KGspO1xuICAgIGVnX0I9bmV3IEFycmF5KGspO1xuICAgIGVnX0M9bmV3IEFycmF5KGspO1xuICAgIGVnX0Q9bmV3IEFycmF5KGspO1xuICB9XG5cbiAgY29weV8oZWdfdSx4KTtcbiAgY29weV8oZWdfdixuKTtcbiAgY29weUludF8oZWdfQSwxKTtcbiAgY29weUludF8oZWdfQiwwKTtcbiAgY29weUludF8oZWdfQywwKTtcbiAgY29weUludF8oZWdfRCwxKTtcbiAgZm9yICg7Oykge1xuICAgIHdoaWxlKCEoZWdfdVswXSYxKSkgeyAgLy93aGlsZSBlZ191IGlzIGV2ZW5cbiAgICAgIGhhbHZlXyhlZ191KTtcbiAgICAgIGlmICghKGVnX0FbMF0mMSkgJiYgIShlZ19CWzBdJjEpKSB7IC8vaWYgZWdfQT09ZWdfQj09MCBtb2QgMlxuICAgICAgICBoYWx2ZV8oZWdfQSk7XG4gICAgICAgIGhhbHZlXyhlZ19CKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZF8oZWdfQSxuKTsgIGhhbHZlXyhlZ19BKTtcbiAgICAgICAgc3ViXyhlZ19CLHgpOyAgaGFsdmVfKGVnX0IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICghKGVnX3ZbMF0mMSkpIHsgIC8vd2hpbGUgZWdfdiBpcyBldmVuXG4gICAgICBoYWx2ZV8oZWdfdik7XG4gICAgICBpZiAoIShlZ19DWzBdJjEpICYmICEoZWdfRFswXSYxKSkgeyAvL2lmIGVnX0M9PWVnX0Q9PTAgbW9kIDJcbiAgICAgICAgaGFsdmVfKGVnX0MpO1xuICAgICAgICBoYWx2ZV8oZWdfRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRfKGVnX0Msbik7ICBoYWx2ZV8oZWdfQyk7XG4gICAgICAgIHN1Yl8oZWdfRCx4KTsgIGhhbHZlXyhlZ19EKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdyZWF0ZXIoZWdfdixlZ191KSkgeyAvL2VnX3YgPD0gZWdfdVxuICAgICAgc3ViXyhlZ191LGVnX3YpO1xuICAgICAgc3ViXyhlZ19BLGVnX0MpO1xuICAgICAgc3ViXyhlZ19CLGVnX0QpO1xuICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgIC8vZWdfdiA+IGVnX3VcbiAgICAgIHN1Yl8oZWdfdixlZ191KTtcbiAgICAgIHN1Yl8oZWdfQyxlZ19BKTtcbiAgICAgIHN1Yl8oZWdfRCxlZ19CKTtcbiAgICB9XG5cbiAgICBpZiAoZXF1YWxzSW50KGVnX3UsMCkpIHtcbiAgICAgIGlmIChuZWdhdGl2ZShlZ19DKSkgLy9tYWtlIHN1cmUgYW5zd2VyIGlzIG5vbm5lZ2F0aXZlXG4gICAgICAgIGFkZF8oZWdfQyxuKTtcbiAgICAgIGNvcHlfKHgsZWdfQyk7XG5cbiAgICAgIGlmICghZXF1YWxzSW50KGVnX3YsMSkpIHsgLy9pZiBHQ0RfKHgsbikhPTEsIHRoZW4gdGhlcmUgaXMgbm8gaW52ZXJzZVxuICAgICAgICBjb3B5SW50Xyh4LDApO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxufVxuXG4vL3JldHVybiB4KiooLTEpIG1vZCBuLCBmb3IgaW50ZWdlcnMgeCBhbmQgbi4gIFJldHVybiAwIGlmIHRoZXJlIGlzIG5vIGludmVyc2VcbmZ1bmN0aW9uIGludmVyc2VNb2RJbnQoeCxuKSB7XG4gIHZhciBhPTEsYj0wLHQ7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoeD09MSkgcmV0dXJuIGE7XG4gICAgaWYgKHg9PTApIHJldHVybiAwO1xuICAgIGItPWEqTWF0aC5mbG9vcihuL3gpO1xuICAgIG4lPXg7XG5cbiAgICBpZiAobj09MSkgcmV0dXJuIGI7IC8vdG8gYXZvaWQgbmVnYXRpdmVzLCBjaGFuZ2UgdGhpcyBiIHRvIG4tYiwgYW5kIGVhY2ggLT0gdG8gKz1cbiAgICBpZiAobj09MCkgcmV0dXJuIDA7XG4gICAgYS09YipNYXRoLmZsb29yKHgvbik7XG4gICAgeCU9bjtcbiAgfVxufVxuXG4vL3RoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbiBpcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbmx5LlxuZnVuY3Rpb24gaW52ZXJzZU1vZEludF8oeCxuKSB7XG4gICByZXR1cm4gaW52ZXJzZU1vZEludCh4LG4pO1xufVxuXG5cbi8vR2l2ZW4gcG9zaXRpdmUgYmlnSW50cyB4IGFuZCB5LCBjaGFuZ2UgdGhlIGJpZ2ludHMgdiwgYSwgYW5kIGIgdG8gcG9zaXRpdmUgYmlnSW50cyBzdWNoIHRoYXQ6XG4vLyAgICAgdiA9IEdDRF8oeCx5KSA9IGEqeC1iKnlcbi8vVGhlIGJpZ0ludHMgdiwgYSwgYiwgbXVzdCBoYXZlIGV4YWN0bHkgYXMgbWFueSBlbGVtZW50cyBhcyB0aGUgbGFyZ2VyIG9mIHggYW5kIHkuXG5mdW5jdGlvbiBlR0NEXyh4LHksdixhLGIpIHtcbiAgdmFyIGc9MDtcbiAgdmFyIGs9TWF0aC5tYXgoeC5sZW5ndGgseS5sZW5ndGgpO1xuICBpZiAoZWdfdS5sZW5ndGghPWspIHtcbiAgICBlZ191PW5ldyBBcnJheShrKTtcbiAgICBlZ19BPW5ldyBBcnJheShrKTtcbiAgICBlZ19CPW5ldyBBcnJheShrKTtcbiAgICBlZ19DPW5ldyBBcnJheShrKTtcbiAgICBlZ19EPW5ldyBBcnJheShrKTtcbiAgfVxuICB3aGlsZSghKHhbMF0mMSkgICYmICEoeVswXSYxKSkgeyAgLy93aGlsZSB4IGFuZCB5IGJvdGggZXZlblxuICAgIGhhbHZlXyh4KTtcbiAgICBoYWx2ZV8oeSk7XG4gICAgZysrO1xuICB9XG4gIGNvcHlfKGVnX3UseCk7XG4gIGNvcHlfKHYseSk7XG4gIGNvcHlJbnRfKGVnX0EsMSk7XG4gIGNvcHlJbnRfKGVnX0IsMCk7XG4gIGNvcHlJbnRfKGVnX0MsMCk7XG4gIGNvcHlJbnRfKGVnX0QsMSk7XG4gIGZvciAoOzspIHtcbiAgICB3aGlsZSghKGVnX3VbMF0mMSkpIHsgIC8vd2hpbGUgdSBpcyBldmVuXG4gICAgICBoYWx2ZV8oZWdfdSk7XG4gICAgICBpZiAoIShlZ19BWzBdJjEpICYmICEoZWdfQlswXSYxKSkgeyAvL2lmIEE9PUI9PTAgbW9kIDJcbiAgICAgICAgaGFsdmVfKGVnX0EpO1xuICAgICAgICBoYWx2ZV8oZWdfQik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRfKGVnX0EseSk7ICBoYWx2ZV8oZWdfQSk7XG4gICAgICAgIHN1Yl8oZWdfQix4KTsgIGhhbHZlXyhlZ19CKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoISh2WzBdJjEpKSB7ICAvL3doaWxlIHYgaXMgZXZlblxuICAgICAgaGFsdmVfKHYpO1xuICAgICAgaWYgKCEoZWdfQ1swXSYxKSAmJiAhKGVnX0RbMF0mMSkpIHsgLy9pZiBDPT1EPT0wIG1vZCAyXG4gICAgICAgIGhhbHZlXyhlZ19DKTtcbiAgICAgICAgaGFsdmVfKGVnX0QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkXyhlZ19DLHkpOyAgaGFsdmVfKGVnX0MpO1xuICAgICAgICBzdWJfKGVnX0QseCk7ICBoYWx2ZV8oZWdfRCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFncmVhdGVyKHYsZWdfdSkpIHsgLy92PD11XG4gICAgICBzdWJfKGVnX3Usdik7XG4gICAgICBzdWJfKGVnX0EsZWdfQyk7XG4gICAgICBzdWJfKGVnX0IsZWdfRCk7XG4gICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgLy92PnVcbiAgICAgIHN1Yl8odixlZ191KTtcbiAgICAgIHN1Yl8oZWdfQyxlZ19BKTtcbiAgICAgIHN1Yl8oZWdfRCxlZ19CKTtcbiAgICB9XG4gICAgaWYgKGVxdWFsc0ludChlZ191LDApKSB7XG4gICAgICBpZiAobmVnYXRpdmUoZWdfQykpIHsgICAvL21ha2Ugc3VyZSBhIChDKWlzIG5vbm5lZ2F0aXZlXG4gICAgICAgIGFkZF8oZWdfQyx5KTtcbiAgICAgICAgc3ViXyhlZ19ELHgpO1xuICAgICAgfVxuICAgICAgbXVsdEludF8oZWdfRCwtMSk7ICAvLy9tYWtlIHN1cmUgYiAoRCkgaXMgbm9ubmVnYXRpdmVcbiAgICAgIGNvcHlfKGEsZWdfQyk7XG4gICAgICBjb3B5XyhiLGVnX0QpO1xuICAgICAgbGVmdFNoaWZ0Xyh2LGcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vaXMgYmlnSW50IHggbmVnYXRpdmU/XG5mdW5jdGlvbiBuZWdhdGl2ZSh4KSB7XG4gIHJldHVybiAoKHhbeC5sZW5ndGgtMV0+PihicGUtMSkpJjEpO1xufVxuXG5cbi8vaXMgKHggPDwgKHNoaWZ0KmJwZSkpID4geT9cbi8veCBhbmQgeSBhcmUgbm9ubmVnYXRpdmUgYmlnSW50c1xuLy9zaGlmdCBpcyBhIG5vbm5lZ2F0aXZlIGludGVnZXJcbmZ1bmN0aW9uIGdyZWF0ZXJTaGlmdCh4LHksc2hpZnQpIHtcbiAgdmFyIGksIGt4PXgubGVuZ3RoLCBreT15Lmxlbmd0aDtcbiAgaz0oKGt4K3NoaWZ0KTxreSkgPyAoa3grc2hpZnQpIDoga3k7XG4gIGZvciAoaT1reS0xLXNoaWZ0OyBpPGt4ICYmIGk+PTA7IGkrKylcbiAgICBpZiAoeFtpXT4wKVxuICAgICAgcmV0dXJuIDE7IC8vaWYgdGhlcmUgYXJlIG5vbnplcm9zIGluIHggdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IGNvbHVtbiBvZiB5LCB0aGVuIHggaXMgYmlnZ2VyXG4gIGZvciAoaT1reC0xK3NoaWZ0OyBpPGt5OyBpKyspXG4gICAgaWYgKHlbaV0+MClcbiAgICAgIHJldHVybiAwOyAvL2lmIHRoZXJlIGFyZSBub256ZXJvcyBpbiB5IHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBjb2x1bW4gb2YgeCwgdGhlbiB4IGlzIG5vdCBiaWdnZXJcbiAgZm9yIChpPWstMTsgaT49c2hpZnQ7IGktLSlcbiAgICBpZiAgICAgICh4W2ktc2hpZnRdPnlbaV0pIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKHhbaS1zaGlmdF08eVtpXSkgcmV0dXJuIDA7XG4gIHJldHVybiAwO1xufVxuXG4vL2lzIHggPiB5PyAoeCBhbmQgeSBib3RoIG5vbm5lZ2F0aXZlKVxuZnVuY3Rpb24gZ3JlYXRlcih4LHkpIHtcbiAgdmFyIGk7XG4gIHZhciBrPSh4Lmxlbmd0aDx5Lmxlbmd0aCkgPyB4Lmxlbmd0aCA6IHkubGVuZ3RoO1xuXG4gIGZvciAoaT14Lmxlbmd0aDtpPHkubGVuZ3RoO2krKylcbiAgICBpZiAoeVtpXSlcbiAgICAgIHJldHVybiAwOyAgLy95IGhhcyBtb3JlIGRpZ2l0c1xuXG4gIGZvciAoaT15Lmxlbmd0aDtpPHgubGVuZ3RoO2krKylcbiAgICBpZiAoeFtpXSlcbiAgICAgIHJldHVybiAxOyAgLy94IGhhcyBtb3JlIGRpZ2l0c1xuXG4gIGZvciAoaT1rLTE7aT49MDtpLS0pXG4gICAgaWYgKHhbaV0+eVtpXSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKHhbaV08eVtpXSlcbiAgICAgIHJldHVybiAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9kaXZpZGUgeCBieSB5IGdpdmluZyBxdW90aWVudCBxIGFuZCByZW1haW5kZXIgci4gIChxPWZsb29yKHgveSksICByPXggbW9kIHkpLiAgQWxsIDQgYXJlIGJpZ2ludHMuXG4vL3ggbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBsZWFkaW5nIHplcm8gZWxlbWVudC5cbi8veSBtdXN0IGJlIG5vbnplcm8uXG4vL3EgYW5kIHIgbXVzdCBiZSBhcnJheXMgdGhhdCBhcmUgZXhhY3RseSB0aGUgc2FtZSBsZW5ndGggYXMgeC4gKE9yIHEgY2FuIGhhdmUgbW9yZSkuXG4vL011c3QgaGF2ZSB4Lmxlbmd0aCA+PSB5Lmxlbmd0aCA+PSAyLlxuZnVuY3Rpb24gZGl2aWRlXyh4LHkscSxyKSB7XG4gIHZhciBreCwga3k7XG4gIHZhciBpLGoseTEseTIsYyxhLGI7XG4gIGNvcHlfKHIseCk7XG4gIGZvciAoa3k9eS5sZW5ndGg7eVtreS0xXT09MDtreS0tKTsgLy9reSBpcyBudW1iZXIgb2YgZWxlbWVudHMgaW4geSwgbm90IGluY2x1ZGluZyBsZWFkaW5nIHplcm9zXG5cbiAgLy9ub3JtYWxpemU6IGVuc3VyZSB0aGUgbW9zdCBzaWduaWZpY2FudCBlbGVtZW50IG9mIHkgaGFzIGl0cyBoaWdoZXN0IGJpdCBzZXRcbiAgYj15W2t5LTFdO1xuICBmb3IgKGE9MDsgYjsgYSsrKVxuICAgIGI+Pj0xO1xuICBhPWJwZS1hOyAgLy9hIGlzIGhvdyBtYW55IGJpdHMgdG8gc2hpZnQgc28gdGhhdCB0aGUgaGlnaCBvcmRlciBiaXQgb2YgeSBpcyBsZWZ0bW9zdCBpbiBpdHMgYXJyYXkgZWxlbWVudFxuICBsZWZ0U2hpZnRfKHksYSk7ICAvL211bHRpcGx5IGJvdGggYnkgMTw8YSBub3csIHRoZW4gZGl2aWRlIGJvdGggYnkgdGhhdCBhdCB0aGUgZW5kXG4gIGxlZnRTaGlmdF8ocixhKTtcblxuICAvL1JvYiBWaXNzZXIgZGlzY292ZXJlZCBhIGJ1ZzogdGhlIGZvbGxvd2luZyBsaW5lIHdhcyBvcmlnaW5hbGx5IGp1c3QgYmVmb3JlIHRoZSBub3JtYWxpemF0aW9uLlxuICBmb3IgKGt4PXIubGVuZ3RoO3Jba3gtMV09PTAgJiYga3g+a3k7a3gtLSk7IC8va3ggaXMgbnVtYmVyIG9mIGVsZW1lbnRzIGluIG5vcm1hbGl6ZWQgeCwgbm90IGluY2x1ZGluZyBsZWFkaW5nIHplcm9zXG5cbiAgY29weUludF8ocSwwKTsgICAgICAgICAgICAgICAgICAgICAgLy8gcT0wXG4gIHdoaWxlICghZ3JlYXRlclNoaWZ0KHkscixreC1reSkpIHsgIC8vIHdoaWxlIChsZWZ0U2hpZnRfKHksa3gta3kpIDw9IHIpIHtcbiAgICBzdWJTaGlmdF8ocix5LGt4LWt5KTsgICAgICAgICAgICAgLy8gICByPXItbGVmdFNoaWZ0Xyh5LGt4LWt5KVxuICAgIHFba3gta3ldKys7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHFba3gta3ldKys7XG4gIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cblxuICBmb3IgKGk9a3gtMTsgaT49a3k7IGktLSkge1xuICAgIGlmIChyW2ldPT15W2t5LTFdKVxuICAgICAgcVtpLWt5XT1tYXNrO1xuICAgIGVsc2VcbiAgICAgIHFbaS1reV09TWF0aC5mbG9vcigocltpXSpyYWRpeCtyW2ktMV0pL3lba3ktMV0pO1xuXG4gICAgLy9UaGUgZm9sbG93aW5nIGZvcig7OykgbG9vcCBpcyBlcXVpdmFsZW50IHRvIHRoZSBjb21tZW50ZWQgd2hpbGUgbG9vcCxcbiAgICAvL2V4Y2VwdCB0aGF0IHRoZSB1bmNvbW1lbnRlZCB2ZXJzaW9uIGF2b2lkcyBvdmVyZmxvdy5cbiAgICAvL1RoZSBjb21tZW50ZWQgbG9vcCBjb21lcyBmcm9tIEhBQywgd2hpY2ggYXNzdW1lcyByWy0xXT09eVstMV09PTBcbiAgICAvLyAgd2hpbGUgKHFbaS1reV0qKHlba3ktMV0qcmFkaXgreVtreS0yXSkgPiByW2ldKnJhZGl4KnJhZGl4K3JbaS0xXSpyYWRpeCtyW2ktMl0pXG4gICAgLy8gICAgcVtpLWt5XS0tO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHkyPShreT4xID8geVtreS0yXSA6IDApKnFbaS1reV07XG4gICAgICBjPXkyPj5icGU7XG4gICAgICB5Mj15MiAmIG1hc2s7XG4gICAgICB5MT1jK3FbaS1reV0qeVtreS0xXTtcbiAgICAgIGM9eTE+PmJwZTtcbiAgICAgIHkxPXkxICYgbWFzaztcblxuICAgICAgaWYgKGM9PXJbaV0gPyB5MT09cltpLTFdID8geTI+KGk+MSA/IHJbaS0yXSA6IDApIDogeTE+cltpLTFdIDogYz5yW2ldKVxuICAgICAgICBxW2kta3ldLS07XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxpbkNvbWJTaGlmdF8ocix5LC1xW2kta3ldLGkta3kpOyAgICAvL3I9ci1xW2kta3ldKmxlZnRTaGlmdF8oeSxpLWt5KVxuICAgIGlmIChuZWdhdGl2ZShyKSkge1xuICAgICAgYWRkU2hpZnRfKHIseSxpLWt5KTsgICAgICAgICAvL3I9citsZWZ0U2hpZnRfKHksaS1reSlcbiAgICAgIHFbaS1reV0tLTtcbiAgICB9XG4gIH1cblxuICByaWdodFNoaWZ0Xyh5LGEpOyAgLy91bmRvIHRoZSBub3JtYWxpemF0aW9uIHN0ZXBcbiAgcmlnaHRTaGlmdF8ocixhKTsgIC8vdW5kbyB0aGUgbm9ybWFsaXphdGlvbiBzdGVwXG59XG5cbi8vZG8gY2FycmllcyBhbmQgYm9ycm93cyBzbyBlYWNoIGVsZW1lbnQgb2YgdGhlIGJpZ0ludCB4IGZpdHMgaW4gYnBlIGJpdHMuXG5mdW5jdGlvbiBjYXJyeV8oeCkge1xuICB2YXIgaSxrLGMsYjtcbiAgaz14Lmxlbmd0aDtcbiAgYz0wO1xuICBmb3IgKGk9MDtpPGs7aSsrKSB7XG4gICAgYys9eFtpXTtcbiAgICBiPTA7XG4gICAgaWYgKGM8MCkge1xuICAgICAgYj0tKGM+PmJwZSk7XG4gICAgICBjKz1iKnJhZGl4O1xuICAgIH1cbiAgICB4W2ldPWMgJiBtYXNrO1xuICAgIGM9KGM+PmJwZSktYjtcbiAgfVxufVxuXG4vL3JldHVybiB4IG1vZCBuIGZvciBiaWdJbnQgeCBhbmQgaW50ZWdlciBuLlxuZnVuY3Rpb24gbW9kSW50KHgsbikge1xuICB2YXIgaSxjPTA7XG4gIGZvciAoaT14Lmxlbmd0aC0xOyBpPj0wOyBpLS0pXG4gICAgYz0oYypyYWRpeCt4W2ldKSVuO1xuICByZXR1cm4gYztcbn1cblxuLy9jb252ZXJ0IHRoZSBpbnRlZ2VyIHQgaW50byBhIGJpZ0ludCB3aXRoIGF0IGxlYXN0IHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbi8vdGhlIHJldHVybmVkIGFycmF5IHN0b3JlcyB0aGUgYmlnSW50IGluIGJwZS1iaXQgY2h1bmtzLCBsaXR0bGUgZW5kaWFuIChidWZmWzBdIGlzIGxlYXN0IHNpZ25pZmljYW50IHdvcmQpXG4vL1BhZCB0aGUgYXJyYXkgd2l0aCBsZWFkaW5nIHplcm9zIHNvIHRoYXQgaXQgaGFzIGF0IGxlYXN0IG1pblNpemUgZWxlbWVudHMuXG4vL1RoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBsZWFkaW5nIDAgZWxlbWVudC5cbmZ1bmN0aW9uIGludDJiaWdJbnQodCxiaXRzLG1pblNpemUpIHtcbiAgdmFyIGksaztcbiAgaz1NYXRoLmNlaWwoYml0cy9icGUpKzE7XG4gIGs9bWluU2l6ZT5rID8gbWluU2l6ZSA6IGs7XG4gIGJ1ZmY9bmV3IEFycmF5KGspO1xuICBjb3B5SW50XyhidWZmLHQpO1xuICByZXR1cm4gYnVmZjtcbn1cblxuLy9yZXR1cm4gdGhlIGJpZ0ludCBnaXZlbiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBhIGdpdmVuIGJhc2UuXG4vL1BhZCB0aGUgYXJyYXkgd2l0aCBsZWFkaW5nIHplcm9zIHNvIHRoYXQgaXQgaGFzIGF0IGxlYXN0IG1pblNpemUgZWxlbWVudHMuXG4vL0lmIGJhc2U9LTEsIHRoZW4gaXQgcmVhZHMgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBhcnJheSBlbGVtZW50cyBpbiBkZWNpbWFsLlxuLy9UaGUgYXJyYXkgd2lsbCBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgbGVhZGluZyB6ZXJvLCB1bmxlc3MgYmFzZT0tMS5cbmZ1bmN0aW9uIHN0cjJiaWdJbnQocyxiLG1pblNpemUpIHtcbiAgdmFyIGQsIGksIGosIGJhc2UsIHN0ciwgeCwgeSwga2s7XG4gIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcblx0ICBiYXNlID0gYi5sZW5ndGg7XG5cdCAgc3RyID0gYjtcbiAgfSBlbHNlIHtcblx0ICBiYXNlID0gYjtcblx0ICBzdHIgPSBkaWdpdHNTdHI7XG4gIH1cbiAgdmFyIGs9cy5sZW5ndGg7XG4gIGlmIChiYXNlPT0tMSkgeyAvL2NvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGFycmF5IGVsZW1lbnRzIGluIGRlY2ltYWxcbiAgICB4PW5ldyBBcnJheSgwKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB5PW5ldyBBcnJheSh4Lmxlbmd0aCsxKTtcbiAgICAgIGZvciAoaT0wO2k8eC5sZW5ndGg7aSsrKVxuICAgICAgICB5W2krMV09eFtpXTtcbiAgICAgIHlbMF09cGFyc2VJbnQocywxMCk7XG4gICAgICB4PXk7XG4gICAgICBkPXMuaW5kZXhPZignLCcsMCk7XG4gICAgICBpZiAoZDwxKVxuICAgICAgICBicmVhaztcbiAgICAgIHM9cy5zdWJzdHJpbmcoZCsxKTtcbiAgICAgIGlmIChzLmxlbmd0aD09MClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh4Lmxlbmd0aDxtaW5TaXplKSB7XG4gICAgICB5PW5ldyBBcnJheShtaW5TaXplKTtcbiAgICAgIGNvcHlfKHkseCk7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICB4PWludDJiaWdJbnQoMCxiYXNlKmssMCk7XG4gIGZvciAoaT0wO2k8aztpKyspIHtcbiAgICBkPXN0ci5pbmRleE9mKHMuc3Vic3RyaW5nKGksaSsxKSwwKTtcbi8vICAgIGlmIChiYXNlPD0zNiAmJiBkPj0zNikgIC8vY29udmVydCBsb3dlcmNhc2UgdG8gdXBwZXJjYXNlIGlmIGJhc2U8PTM2XG4vLyAgICAgIGQtPTI2O1xuICAgIGlmIChkPj1iYXNlIHx8IGQ8MCkgeyAgIC8vaWdub3JlIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG11bHRJbnRfKHgsYmFzZSk7XG4gICAgYWRkSW50Xyh4LGQpO1xuICB9XG5cbiAgZm9yIChrPXgubGVuZ3RoO2s+MCAmJiAheFtrLTFdO2stLSk7IC8vc3RyaXAgb2ZmIGxlYWRpbmcgemVyb3NcbiAgaz1taW5TaXplPmsrMSA/IG1pblNpemUgOiBrKzE7XG4gIHk9bmV3IEFycmF5KGspO1xuICBraz1rPHgubGVuZ3RoID8gayA6IHgubGVuZ3RoO1xuICBmb3IgKGk9MDtpPGtrO2krKylcbiAgICB5W2ldPXhbaV07XG4gIGZvciAoO2k8aztpKyspXG4gICAgeVtpXT0wO1xuICByZXR1cm4geTtcbn1cblxuLy9pcyBiaWdpbnQgeCBlcXVhbCB0byBpbnRlZ2VyIHk/XG4vL3kgbXVzdCBoYXZlIGxlc3MgdGhhbiBicGUgYml0c1xuZnVuY3Rpb24gZXF1YWxzSW50KHgseSkge1xuICB2YXIgaTtcbiAgaWYgKHhbMF0hPXkpXG4gICAgcmV0dXJuIDA7XG4gIGZvciAoaT0xO2k8eC5sZW5ndGg7aSsrKVxuICAgIGlmICh4W2ldKVxuICAgICAgcmV0dXJuIDA7XG4gIHJldHVybiAxO1xufVxuXG4vL2FyZSBiaWdpbnRzIHggYW5kIHkgZXF1YWw/XG4vL3RoaXMgd29ya3MgZXZlbiBpZiB4IGFuZCB5IGFyZSBkaWZmZXJlbnQgbGVuZ3RocyBhbmQgaGF2ZSBhcmJpdHJhcmlseSBtYW55IGxlYWRpbmcgemVyb3NcbmZ1bmN0aW9uIGVxdWFscyh4LHkpIHtcbiAgdmFyIGk7XG4gIHZhciBrPXgubGVuZ3RoPHkubGVuZ3RoID8geC5sZW5ndGggOiB5Lmxlbmd0aDtcbiAgZm9yIChpPTA7aTxrO2krKylcbiAgICBpZiAoeFtpXSE9eVtpXSlcbiAgICAgIHJldHVybiAwO1xuICBpZiAoeC5sZW5ndGg+eS5sZW5ndGgpIHtcbiAgICBmb3IgKDtpPHgubGVuZ3RoO2krKylcbiAgICAgIGlmICh4W2ldKVxuICAgICAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKDtpPHkubGVuZ3RoO2krKylcbiAgICAgIGlmICh5W2ldKVxuICAgICAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gMTtcbn1cblxuLy9pcyB0aGUgYmlnSW50IHggZXF1YWwgdG8gemVybz9cbmZ1bmN0aW9uIGlzWmVybyh4KSB7XG4gIHZhciBpO1xuICBmb3IgKGk9MDtpPHgubGVuZ3RoO2krKylcbiAgICBpZiAoeFtpXSlcbiAgICAgIHJldHVybiAwO1xuICByZXR1cm4gMTtcbn1cblxuLy9jb252ZXJ0IGEgYmlnSW50IGludG8gYSBzdHJpbmcgaW4gYSBnaXZlbiBiYXNlLCBmcm9tIGJhc2UgMiB1cCB0byBiYXNlIDk1LlxuLy9CYXNlIC0xIHByaW50cyB0aGUgY29udGVudHMgb2YgdGhlIGFycmF5IHJlcHJlc2VudGluZyB0aGUgbnVtYmVyLlxuZnVuY3Rpb24gYmlnSW50MnN0cih4LGIpIHtcbiAgdmFyIGksdCxiYXNlLHN0cixzPVwiXCI7XG4gIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcblx0ICBiYXNlID0gYi5sZW5ndGg7XG5cdCAgc3RyID0gYjtcbiAgfSBlbHNlIHtcblx0ICBiYXNlID0gYjtcblx0ICBzdHIgPSBkaWdpdHNTdHI7XG4gIH1cblxuICBpZiAoczYubGVuZ3RoIT14Lmxlbmd0aClcbiAgICBzNj1kdXAoeCk7XG4gIGVsc2VcbiAgICBjb3B5XyhzNix4KTtcblxuICBpZiAoYmFzZT09LTEpIHsgLy9yZXR1cm4gdGhlIGxpc3Qgb2YgYXJyYXkgY29udGVudHNcbiAgICBmb3IgKGk9eC5sZW5ndGgtMTtpPjA7aS0tKVxuICAgICAgcys9eFtpXSsnLCc7XG4gICAgcys9eFswXTtcbiAgfVxuICBlbHNlIHsgLy9yZXR1cm4gaXQgaW4gdGhlIGdpdmVuIGJhc2VcbiAgICB3aGlsZSAoIWlzWmVybyhzNikpIHtcbiAgICAgIHQ9ZGl2SW50XyhzNixiYXNlKTsgIC8vdD1zNiAlIGJhc2U7IHM2PWZsb29yKHM2L2Jhc2UpO1xuICAgICAgcz1zdHIuc3Vic3RyaW5nKHQsdCsxKStzO1xuICAgIH1cbiAgfVxuICBpZiAocy5sZW5ndGg9PTApXG4gICAgcz1zdHJbMF07XG4gIHJldHVybiBzO1xufVxuXG4vL3JldHVybnMgYSBkdXBsaWNhdGUgb2YgYmlnSW50IHhcbmZ1bmN0aW9uIGR1cCh4KSB7XG4gIHZhciBpO1xuICBidWZmPW5ldyBBcnJheSh4Lmxlbmd0aCk7XG4gIGNvcHlfKGJ1ZmYseCk7XG4gIHJldHVybiBidWZmO1xufVxuXG4vL2RvIHg9eSBvbiBiaWdJbnRzIHggYW5kIHkuICB4IG11c3QgYmUgYW4gYXJyYXkgYXQgbGVhc3QgYXMgYmlnIGFzIHkgKG5vdCBjb3VudGluZyB0aGUgbGVhZGluZyB6ZXJvcyBpbiB5KS5cbmZ1bmN0aW9uIGNvcHlfKHgseSkge1xuICB2YXIgaTtcbiAgdmFyIGs9eC5sZW5ndGg8eS5sZW5ndGggPyB4Lmxlbmd0aCA6IHkubGVuZ3RoO1xuICBmb3IgKGk9MDtpPGs7aSsrKVxuICAgIHhbaV09eVtpXTtcbiAgZm9yIChpPWs7aTx4Lmxlbmd0aDtpKyspXG4gICAgeFtpXT0wO1xufVxuXG4vL2RvIHg9eSBvbiBiaWdJbnQgeCBhbmQgaW50ZWdlciB5LlxuZnVuY3Rpb24gY29weUludF8oeCxuKSB7XG4gIHZhciBpLGM7XG4gIGZvciAoYz1uLGk9MDtpPHgubGVuZ3RoO2krKykge1xuICAgIHhbaV09YyAmIG1hc2s7XG4gICAgYz4+PWJwZTtcbiAgfVxufVxuXG4vL2RvIHg9eCtuIHdoZXJlIHggaXMgYSBiaWdJbnQgYW5kIG4gaXMgYW4gaW50ZWdlci5cbi8veCBtdXN0IGJlIGxhcmdlIGVub3VnaCB0byBob2xkIHRoZSByZXN1bHQuXG5mdW5jdGlvbiBhZGRJbnRfKHgsbikge1xuICB2YXIgaSxrLGMsYjtcbiAgeFswXSs9bjtcbiAgaz14Lmxlbmd0aDtcbiAgYz0wO1xuICBmb3IgKGk9MDtpPGs7aSsrKSB7XG4gICAgYys9eFtpXTtcbiAgICBiPTA7XG4gICAgaWYgKGM8MCkge1xuICAgICAgYj0tKGM+PmJwZSk7XG4gICAgICBjKz1iKnJhZGl4O1xuICAgIH1cbiAgICB4W2ldPWMgJiBtYXNrO1xuICAgIGM9KGM+PmJwZSktYjtcbiAgICBpZiAoIWMpIHJldHVybjsgLy9zdG9wIGNhcnJ5aW5nIGFzIHNvb24gYXMgdGhlIGNhcnJ5IGlzIHplcm9cbiAgfVxufVxuXG4vL3JpZ2h0IHNoaWZ0IGJpZ0ludCB4IGJ5IG4gYml0cy4gIDAgPD0gbiA8IGJwZS5cbmZ1bmN0aW9uIHJpZ2h0U2hpZnRfKHgsbikge1xuICB2YXIgaTtcbiAgdmFyIGs9TWF0aC5mbG9vcihuL2JwZSk7XG4gIGlmIChrKSB7XG4gICAgZm9yIChpPTA7aTx4Lmxlbmd0aC1rO2krKykgLy9yaWdodCBzaGlmdCB4IGJ5IGsgZWxlbWVudHNcbiAgICAgIHhbaV09eFtpK2tdO1xuICAgIGZvciAoO2k8eC5sZW5ndGg7aSsrKVxuICAgICAgeFtpXT0wO1xuICAgIG4lPWJwZTtcbiAgfVxuICBmb3IgKGk9MDtpPHgubGVuZ3RoLTE7aSsrKSB7XG4gICAgeFtpXT1tYXNrICYgKCh4W2krMV08PChicGUtbikpIHwgKHhbaV0+Pm4pKTtcbiAgfVxuICB4W2ldPj49bjtcbn1cblxuLy9kbyB4PWZsb29yKHx4fC8yKSpzZ24oeCkgZm9yIGJpZ0ludCB4IGluIDIncyBjb21wbGVtZW50XG5mdW5jdGlvbiBoYWx2ZV8oeCkge1xuICB2YXIgaTtcbiAgZm9yIChpPTA7aTx4Lmxlbmd0aC0xO2krKykge1xuICAgIHhbaV09bWFzayAmICgoeFtpKzFdPDwoYnBlLTEpKSB8ICh4W2ldPj4xKSk7XG4gIH1cbiAgeFtpXT0oeFtpXT4+MSkgfCAoeFtpXSAmIChyYWRpeD4+MSkpOyAgLy9tb3N0IHNpZ25pZmljYW50IGJpdCBzdGF5cyB0aGUgc2FtZVxufVxuXG4vL2xlZnQgc2hpZnQgYmlnSW50IHggYnkgbiBiaXRzLlxuZnVuY3Rpb24gbGVmdFNoaWZ0Xyh4LG4pIHtcbiAgdmFyIGk7XG4gIHZhciBrPU1hdGguZmxvb3Iobi9icGUpO1xuICBpZiAoaykge1xuICAgIGZvciAoaT14Lmxlbmd0aDsgaT49azsgaS0tKSAvL2xlZnQgc2hpZnQgeCBieSBrIGVsZW1lbnRzXG4gICAgICB4W2ldPXhbaS1rXTtcbiAgICBmb3IgKDtpPj0wO2ktLSlcbiAgICAgIHhbaV09MDtcbiAgICBuJT1icGU7XG4gIH1cbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgZm9yIChpPXgubGVuZ3RoLTE7aT4wO2ktLSkge1xuICAgIHhbaV09bWFzayAmICgoeFtpXTw8bikgfCAoeFtpLTFdPj4oYnBlLW4pKSk7XG4gIH1cbiAgeFtpXT1tYXNrICYgKHhbaV08PG4pO1xufVxuXG4vL2RvIHg9eCpuIHdoZXJlIHggaXMgYSBiaWdJbnQgYW5kIG4gaXMgYW4gaW50ZWdlci5cbi8veCBtdXN0IGJlIGxhcmdlIGVub3VnaCB0byBob2xkIHRoZSByZXN1bHQuXG5mdW5jdGlvbiBtdWx0SW50Xyh4LG4pIHtcbiAgdmFyIGksayxjLGI7XG4gIGlmICghbilcbiAgICByZXR1cm47XG4gIGs9eC5sZW5ndGg7XG4gIGM9MDtcbiAgZm9yIChpPTA7aTxrO2krKykge1xuICAgIGMrPXhbaV0qbjtcbiAgICBiPTA7XG4gICAgaWYgKGM8MCkge1xuICAgICAgYj0tKGM+PmJwZSk7XG4gICAgICBjKz1iKnJhZGl4O1xuICAgIH1cbiAgICB4W2ldPWMgJiBtYXNrO1xuICAgIGM9KGM+PmJwZSktYjtcbiAgfVxufVxuXG4vL2RvIHg9Zmxvb3IoeC9uKSBmb3IgYmlnSW50IHggYW5kIGludGVnZXIgbiwgYW5kIHJldHVybiB0aGUgcmVtYWluZGVyXG5mdW5jdGlvbiBkaXZJbnRfKHgsbikge1xuICB2YXIgaSxyPTAscztcbiAgZm9yIChpPXgubGVuZ3RoLTE7aT49MDtpLS0pIHtcbiAgICBzPXIqcmFkaXgreFtpXTtcbiAgICB4W2ldPU1hdGguZmxvb3Iocy9uKTtcbiAgICByPXMlbjtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuLy9kbyB0aGUgbGluZWFyIGNvbWJpbmF0aW9uIHg9YSp4K2IqeSBmb3IgYmlnSW50cyB4IGFuZCB5LCBhbmQgaW50ZWdlcnMgYSBhbmQgYi5cbi8veCBtdXN0IGJlIGxhcmdlIGVub3VnaCB0byBob2xkIHRoZSBhbnN3ZXIuXG5mdW5jdGlvbiBsaW5Db21iXyh4LHksYSxiKSB7XG4gIHZhciBpLGMsayxraztcbiAgaz14Lmxlbmd0aDx5Lmxlbmd0aCA/IHgubGVuZ3RoIDogeS5sZW5ndGg7XG4gIGtrPXgubGVuZ3RoO1xuICBmb3IgKGM9MCxpPTA7aTxrO2krKykge1xuICAgIGMrPWEqeFtpXStiKnlbaV07XG4gICAgeFtpXT1jICYgbWFzaztcbiAgICBjPj49YnBlO1xuICB9XG4gIGZvciAoaT1rO2k8a2s7aSsrKSB7XG4gICAgYys9YSp4W2ldO1xuICAgIHhbaV09YyAmIG1hc2s7XG4gICAgYz4+PWJwZTtcbiAgfVxufVxuXG4vL2RvIHRoZSBsaW5lYXIgY29tYmluYXRpb24geD1hKngrYiooeTw8KHlzKmJwZSkpIGZvciBiaWdJbnRzIHggYW5kIHksIGFuZCBpbnRlZ2VycyBhLCBiIGFuZCB5cy5cbi8veCBtdXN0IGJlIGxhcmdlIGVub3VnaCB0byBob2xkIHRoZSBhbnN3ZXIuXG5mdW5jdGlvbiBsaW5Db21iU2hpZnRfKHgseSxiLHlzKSB7XG4gIHZhciBpLGMsayxraztcbiAgaz14Lmxlbmd0aDx5cyt5Lmxlbmd0aCA/IHgubGVuZ3RoIDogeXMreS5sZW5ndGg7XG4gIGtrPXgubGVuZ3RoO1xuICBmb3IgKGM9MCxpPXlzO2k8aztpKyspIHtcbiAgICBjKz14W2ldK2IqeVtpLXlzXTtcbiAgICB4W2ldPWMgJiBtYXNrO1xuICAgIGM+Pj1icGU7XG4gIH1cbiAgZm9yIChpPWs7YyAmJiBpPGtrO2krKykge1xuICAgIGMrPXhbaV07XG4gICAgeFtpXT1jICYgbWFzaztcbiAgICBjPj49YnBlO1xuICB9XG59XG5cbi8vZG8geD14Kyh5PDwoeXMqYnBlKSkgZm9yIGJpZ0ludHMgeCBhbmQgeSwgYW5kIGludGVnZXJzIGEsYiBhbmQgeXMuXG4vL3ggbXVzdCBiZSBsYXJnZSBlbm91Z2ggdG8gaG9sZCB0aGUgYW5zd2VyLlxuZnVuY3Rpb24gYWRkU2hpZnRfKHgseSx5cykge1xuICB2YXIgaSxjLGssa2s7XG4gIGs9eC5sZW5ndGg8eXMreS5sZW5ndGggPyB4Lmxlbmd0aCA6IHlzK3kubGVuZ3RoO1xuICBraz14Lmxlbmd0aDtcbiAgZm9yIChjPTAsaT15cztpPGs7aSsrKSB7XG4gICAgYys9eFtpXSt5W2kteXNdO1xuICAgIHhbaV09YyAmIG1hc2s7XG4gICAgYz4+PWJwZTtcbiAgfVxuICBmb3IgKGk9aztjICYmIGk8a2s7aSsrKSB7XG4gICAgYys9eFtpXTtcbiAgICB4W2ldPWMgJiBtYXNrO1xuICAgIGM+Pj1icGU7XG4gIH1cbn1cblxuLy9kbyB4PXgtKHk8PCh5cypicGUpKSBmb3IgYmlnSW50cyB4IGFuZCB5LCBhbmQgaW50ZWdlcnMgYSxiIGFuZCB5cy5cbi8veCBtdXN0IGJlIGxhcmdlIGVub3VnaCB0byBob2xkIHRoZSBhbnN3ZXIuXG5mdW5jdGlvbiBzdWJTaGlmdF8oeCx5LHlzKSB7XG4gIHZhciBpLGMsayxraztcbiAgaz14Lmxlbmd0aDx5cyt5Lmxlbmd0aCA/IHgubGVuZ3RoIDogeXMreS5sZW5ndGg7XG4gIGtrPXgubGVuZ3RoO1xuICBmb3IgKGM9MCxpPXlzO2k8aztpKyspIHtcbiAgICBjKz14W2ldLXlbaS15c107XG4gICAgeFtpXT1jICYgbWFzaztcbiAgICBjPj49YnBlO1xuICB9XG4gIGZvciAoaT1rO2MgJiYgaTxraztpKyspIHtcbiAgICBjKz14W2ldO1xuICAgIHhbaV09YyAmIG1hc2s7XG4gICAgYz4+PWJwZTtcbiAgfVxufVxuXG4vL2RvIHg9eC15IGZvciBiaWdJbnRzIHggYW5kIHkuXG4vL3ggbXVzdCBiZSBsYXJnZSBlbm91Z2ggdG8gaG9sZCB0aGUgYW5zd2VyLlxuLy9uZWdhdGl2ZSBhbnN3ZXJzIHdpbGwgYmUgMnMgY29tcGxlbWVudFxuZnVuY3Rpb24gc3ViXyh4LHkpIHtcbiAgdmFyIGksYyxrLGtrO1xuICBrPXgubGVuZ3RoPHkubGVuZ3RoID8geC5sZW5ndGggOiB5Lmxlbmd0aDtcbiAgZm9yIChjPTAsaT0wO2k8aztpKyspIHtcbiAgICBjKz14W2ldLXlbaV07XG4gICAgeFtpXT1jICYgbWFzaztcbiAgICBjPj49YnBlO1xuICB9XG4gIGZvciAoaT1rO2MgJiYgaTx4Lmxlbmd0aDtpKyspIHtcbiAgICBjKz14W2ldO1xuICAgIHhbaV09YyAmIG1hc2s7XG4gICAgYz4+PWJwZTtcbiAgfVxufVxuXG4vL2RvIHg9eCt5IGZvciBiaWdJbnRzIHggYW5kIHkuXG4vL3ggbXVzdCBiZSBsYXJnZSBlbm91Z2ggdG8gaG9sZCB0aGUgYW5zd2VyLlxuZnVuY3Rpb24gYWRkXyh4LHkpIHtcbiAgdmFyIGksYyxrLGtrO1xuICBrPXgubGVuZ3RoPHkubGVuZ3RoID8geC5sZW5ndGggOiB5Lmxlbmd0aDtcbiAgZm9yIChjPTAsaT0wO2k8aztpKyspIHtcbiAgICBjKz14W2ldK3lbaV07XG4gICAgeFtpXT1jICYgbWFzaztcbiAgICBjPj49YnBlO1xuICB9XG4gIGZvciAoaT1rO2MgJiYgaTx4Lmxlbmd0aDtpKyspIHtcbiAgICBjKz14W2ldO1xuICAgIHhbaV09YyAmIG1hc2s7XG4gICAgYz4+PWJwZTtcbiAgfVxufVxuXG4vL2RvIHg9eCp5IGZvciBiaWdJbnRzIHggYW5kIHkuICBUaGlzIGlzIGZhc3RlciB3aGVuIHk8eC5cbmZ1bmN0aW9uIG11bHRfKHgseSkge1xuICB2YXIgaTtcbiAgaWYgKHNzLmxlbmd0aCE9Mip4Lmxlbmd0aClcbiAgICBzcz1uZXcgQXJyYXkoMip4Lmxlbmd0aCk7XG4gIGNvcHlJbnRfKHNzLDApO1xuICBmb3IgKGk9MDtpPHkubGVuZ3RoO2krKylcbiAgICBpZiAoeVtpXSlcbiAgICAgIGxpbkNvbWJTaGlmdF8oc3MseCx5W2ldLGkpOyAgIC8vc3M9MSpzcyt5W2ldKih4PDwoaSpicGUpKVxuICBjb3B5Xyh4LHNzKTtcbn1cblxuLy9kbyB4PXggbW9kIG4gZm9yIGJpZ0ludHMgeCBhbmQgbi5cbmZ1bmN0aW9uIG1vZF8oeCxuKSB7XG4gIGlmIChzNC5sZW5ndGghPXgubGVuZ3RoKVxuICAgIHM0PWR1cCh4KTtcbiAgZWxzZVxuICAgIGNvcHlfKHM0LHgpO1xuICBpZiAoczUubGVuZ3RoIT14Lmxlbmd0aClcbiAgICBzNT1kdXAoeCk7XG4gIGRpdmlkZV8oczQsbixzNSx4KTsgIC8veCA9IHJlbWFpbmRlciBvZiBzNCAvIG5cbn1cblxuLy9kbyB4PXgqeSBtb2QgbiBmb3IgYmlnSW50cyB4LHksbi5cbi8vZm9yIGdyZWF0ZXIgc3BlZWQsIGxldCB5PHguXG5mdW5jdGlvbiBtdWx0TW9kXyh4LHksbikge1xuICB2YXIgaTtcbiAgaWYgKHMwLmxlbmd0aCE9Mip4Lmxlbmd0aClcbiAgICBzMD1uZXcgQXJyYXkoMip4Lmxlbmd0aCk7XG4gIGNvcHlJbnRfKHMwLDApO1xuICBmb3IgKGk9MDtpPHkubGVuZ3RoO2krKylcbiAgICBpZiAoeVtpXSlcbiAgICAgIGxpbkNvbWJTaGlmdF8oczAseCx5W2ldLGkpOyAgIC8vczA9MSpzMCt5W2ldKih4PDwoaSpicGUpKVxuICBtb2RfKHMwLG4pO1xuICBjb3B5Xyh4LHMwKTtcbn1cblxuLy9kbyB4PXgqeCBtb2QgbiBmb3IgYmlnSW50cyB4LG4uXG5mdW5jdGlvbiBzcXVhcmVNb2RfKHgsbikge1xuICB2YXIgaSxqLGQsYyxreCxrbixrO1xuICBmb3IgKGt4PXgubGVuZ3RoOyBreD4wICYmICF4W2t4LTFdOyBreC0tKTsgIC8vaWdub3JlIGxlYWRpbmcgemVyb3MgaW4geFxuICBrPWt4Pm4ubGVuZ3RoID8gMipreCA6IDIqbi5sZW5ndGg7IC8vaz0jIGVsZW1lbnRzIGluIHRoZSBwcm9kdWN0LCB3aGljaCBpcyB0d2ljZSB0aGUgZWxlbWVudHMgaW4gdGhlIGxhcmdlciBvZiB4IGFuZCBuXG4gIGlmIChzMC5sZW5ndGghPWspXG4gICAgczA9bmV3IEFycmF5KGspO1xuICBjb3B5SW50XyhzMCwwKTtcbiAgZm9yIChpPTA7aTxreDtpKyspIHtcbiAgICBjPXMwWzIqaV0reFtpXSp4W2ldO1xuICAgIHMwWzIqaV09YyAmIG1hc2s7XG4gICAgYz4+PWJwZTtcbiAgICBmb3IgKGo9aSsxO2o8a3g7aisrKSB7XG4gICAgICBjPXMwW2kral0rMip4W2ldKnhbal0rYztcbiAgICAgIHMwW2kral09KGMgJiBtYXNrKTtcbiAgICAgIGM+Pj1icGU7XG4gICAgfVxuICAgIHMwW2kra3hdPWM7XG4gIH1cbiAgbW9kXyhzMCxuKTtcbiAgY29weV8oeCxzMCk7XG59XG5cbi8vcmV0dXJuIHggd2l0aCBleGFjdGx5IGsgbGVhZGluZyB6ZXJvIGVsZW1lbnRzXG5mdW5jdGlvbiB0cmltKHgsaykge1xuICB2YXIgaSx5O1xuICBmb3IgKGk9eC5sZW5ndGg7IGk+MCAmJiAheFtpLTFdOyBpLS0pO1xuICB5PW5ldyBBcnJheShpK2spO1xuICBjb3B5Xyh5LHgpO1xuICByZXR1cm4geTtcbn1cblxuLy9kbyB4PXgqKnkgbW9kIG4sIHdoZXJlIHgseSxuIGFyZSBiaWdJbnRzIGFuZCAqKiBpcyBleHBvbmVudGlhdGlvbi4gIDAqKjA9MS5cbi8vdGhpcyBpcyBmYXN0ZXIgd2hlbiBuIGlzIG9kZC4gIHggdXN1YWxseSBuZWVkcyB0byBoYXZlIGFzIG1hbnkgZWxlbWVudHMgYXMgbi5cbmZ1bmN0aW9uIHBvd01vZF8oeCx5LG4pIHtcbiAgdmFyIGsxLGsyLGtuLG5wO1xuICBpZihzNy5sZW5ndGghPW4ubGVuZ3RoKVxuICAgIHM3PWR1cChuKTtcblxuICAvL2ZvciBldmVuIG1vZHVsdXMsIHVzZSBhIHNpbXBsZSBzcXVhcmUtYW5kLW11bHRpcGx5IGFsZ29yaXRobSxcbiAgLy9yYXRoZXIgdGhhbiB1c2luZyB0aGUgbW9yZSBjb21wbGV4IE1vbnRnb21lcnkgYWxnb3JpdGhtLlxuICBpZiAoKG5bMF0mMSk9PTApIHtcbiAgICBjb3B5XyhzNyx4KTtcbiAgICBjb3B5SW50Xyh4LDEpO1xuICAgIHdoaWxlKCFlcXVhbHNJbnQoeSwwKSkge1xuICAgICAgaWYgKHlbMF0mMSlcbiAgICAgICAgbXVsdE1vZF8oeCxzNyxuKTtcbiAgICAgIGRpdkludF8oeSwyKTtcbiAgICAgIHNxdWFyZU1vZF8oczcsbik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vY2FsY3VsYXRlIG5wIGZyb20gbiBmb3IgdGhlIE1vbnRnb21lcnkgbXVsdGlwbGljYXRpb25zXG4gIGNvcHlJbnRfKHM3LDApO1xuICBmb3IgKGtuPW4ubGVuZ3RoO2tuPjAgJiYgIW5ba24tMV07a24tLSk7XG4gIG5wPXJhZGl4LWludmVyc2VNb2RJbnQobW9kSW50KG4scmFkaXgpLHJhZGl4KTtcbiAgczdba25dPTE7XG4gIG11bHRNb2RfKHggLHM3LG4pOyAgIC8vIHggPSB4ICogMioqKGtuKmJwKSBtb2QgblxuXG4gIGlmIChzMy5sZW5ndGghPXgubGVuZ3RoKVxuICAgIHMzPWR1cCh4KTtcbiAgZWxzZVxuICAgIGNvcHlfKHMzLHgpO1xuXG4gIGZvciAoazE9eS5sZW5ndGgtMTtrMT4wICYgIXlbazFdOyBrMS0tKTsgIC8vazE9Zmlyc3Qgbm9uemVybyBlbGVtZW50IG9mIHlcbiAgaWYgKHlbazFdPT0wKSB7ICAvL2FueXRoaW5nIHRvIHRoZSAwdGggcG93ZXIgaXMgMVxuICAgIGNvcHlJbnRfKHgsMSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoazI9MTw8KGJwZS0xKTtrMiAmJiAhKHlbazFdICYgazIpOyBrMj4+PTEpOyAgLy9rMj1wb3NpdGlvbiBvZiBmaXJzdCAxIGJpdCBpbiB5W2sxXVxuICBmb3IgKDs7KSB7XG4gICAgaWYgKCEoazI+Pj0xKSkgeyAgLy9sb29rIGF0IG5leHQgYml0IG9mIHlcbiAgICAgIGsxLS07XG4gICAgICBpZiAoazE8MCkge1xuICAgICAgICBtb250Xyh4LG9uZSxuLG5wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgazI9MTw8KGJwZS0xKTtcbiAgICB9XG4gICAgbW9udF8oeCx4LG4sbnApO1xuXG4gICAgaWYgKGsyICYgeVtrMV0pIC8vaWYgbmV4dCBiaXQgaXMgYSAxXG4gICAgICBtb250Xyh4LHMzLG4sbnApO1xuICB9XG59XG5cblxuLy9kbyB4PXgqeSpSaSBtb2QgbiBmb3IgYmlnSW50cyB4LHksbixcbi8vICB3aGVyZSBSaSA9IDIqKigta24qYnBlKSBtb2QgbiwgYW5kIGtuIGlzIHRoZVxuLy8gIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbiBhcnJheSwgbm90XG4vLyAgY291bnRpbmcgbGVhZGluZyB6ZXJvcy5cbi8veCBhcnJheSBtdXN0IGhhdmUgYXQgbGVhc3QgYXMgbWFueSBlbGVtbnRzIGFzIHRoZSBuIGFycmF5XG4vL0l0J3MgT0sgaWYgeCBhbmQgeSBhcmUgdGhlIHNhbWUgdmFyaWFibGUuXG4vL211c3QgaGF2ZTpcbi8vICB4LHkgPCBuXG4vLyAgbiBpcyBvZGRcbi8vICBucCA9IC0obl4oLTEpKSBtb2QgcmFkaXhcbmZ1bmN0aW9uIG1vbnRfKHgseSxuLG5wKSB7XG4gIHZhciBpLGosYyx1aSx0LGtzO1xuICB2YXIga249bi5sZW5ndGg7XG4gIHZhciBreT15Lmxlbmd0aDtcblxuICBpZiAoc2EubGVuZ3RoIT1rbilcbiAgICBzYT1uZXcgQXJyYXkoa24pO1xuXG4gIGNvcHlJbnRfKHNhLDApO1xuXG4gIGZvciAoO2tuPjAgJiYgbltrbi0xXT09MDtrbi0tKTsgLy9pZ25vcmUgbGVhZGluZyB6ZXJvcyBvZiBuXG4gIGZvciAoO2t5PjAgJiYgeVtreS0xXT09MDtreS0tKTsgLy9pZ25vcmUgbGVhZGluZyB6ZXJvcyBvZiB5XG4gIGtzPXNhLmxlbmd0aC0xOyAvL3NhIHdpbGwgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gdGhpcyBtYW55IG5vbnplcm8gZWxlbWVudHMuXG5cbiAgLy90aGUgZm9sbG93aW5nIGxvb3AgY29uc3VtZXMgOTUlIG9mIHRoZSBydW50aW1lIGZvciByYW5kVHJ1ZVByaW1lXygpIGFuZCBwb3dNb2RfKCkgZm9yIGxhcmdlIG51bWJlcnNcbiAgZm9yIChpPTA7IGk8a247IGkrKykge1xuICAgIHQ9c2FbMF0reFtpXSp5WzBdO1xuICAgIHVpPSgodCAmIG1hc2spICogbnApICYgbWFzazsgIC8vdGhlIGlubmVyIFwiJiBtYXNrXCIgd2FzIG5lZWRlZCBvbiBTYWZhcmkgKGJ1dCBub3QgTVNJRSkgYXQgb25lIHRpbWVcbiAgICBjPSh0K3VpKm5bMF0pID4+IGJwZTtcbiAgICB0PXhbaV07XG5cbiAgICAvL2RvIHNhPShzYSt4W2ldKnkrdWkqbikvYiAgIHdoZXJlIGI9MioqYnBlLiAgTG9vcCBpcyB1bnJvbGxlZCA1LWZvbGQgZm9yIHNwZWVkXG4gICAgaj0xO1xuICAgIGZvciAoO2o8a3ktNDspIHsgYys9c2Fbal0rdWkqbltqXSt0Knlbal07ICAgc2Fbai0xXT1jICYgbWFzazsgICBjPj49YnBlOyAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgIGMrPXNhW2pdK3VpKm5bal0rdCp5W2pdOyAgIHNhW2otMV09YyAmIG1hc2s7ICAgYz4+PWJwZTsgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICBjKz1zYVtqXSt1aSpuW2pdK3QqeVtqXTsgICBzYVtqLTFdPWMgJiBtYXNrOyAgIGM+Pj1icGU7ICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgYys9c2Fbal0rdWkqbltqXSt0Knlbal07ICAgc2Fbai0xXT1jICYgbWFzazsgICBjPj49YnBlOyAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgIGMrPXNhW2pdK3VpKm5bal0rdCp5W2pdOyAgIHNhW2otMV09YyAmIG1hc2s7ICAgYz4+PWJwZTsgICBqKys7IH1cbiAgICBmb3IgKDtqPGt5OykgICB7IGMrPXNhW2pdK3VpKm5bal0rdCp5W2pdOyAgIHNhW2otMV09YyAmIG1hc2s7ICAgYz4+PWJwZTsgICBqKys7IH1cbiAgICBmb3IgKDtqPGtuLTQ7KSB7IGMrPXNhW2pdK3VpKm5bal07ICAgICAgICAgIHNhW2otMV09YyAmIG1hc2s7ICAgYz4+PWJwZTsgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICBjKz1zYVtqXSt1aSpuW2pdOyAgICAgICAgICBzYVtqLTFdPWMgJiBtYXNrOyAgIGM+Pj1icGU7ICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgYys9c2Fbal0rdWkqbltqXTsgICAgICAgICAgc2Fbai0xXT1jICYgbWFzazsgICBjPj49YnBlOyAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgIGMrPXNhW2pdK3VpKm5bal07ICAgICAgICAgIHNhW2otMV09YyAmIG1hc2s7ICAgYz4+PWJwZTsgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICBjKz1zYVtqXSt1aSpuW2pdOyAgICAgICAgICBzYVtqLTFdPWMgJiBtYXNrOyAgIGM+Pj1icGU7ICAgaisrOyB9XG4gICAgZm9yICg7ajxrbjspICAgeyBjKz1zYVtqXSt1aSpuW2pdOyAgICAgICAgICBzYVtqLTFdPWMgJiBtYXNrOyAgIGM+Pj1icGU7ICAgaisrOyB9XG4gICAgZm9yICg7ajxrczspICAgeyBjKz1zYVtqXTsgICAgICAgICAgICAgICAgICBzYVtqLTFdPWMgJiBtYXNrOyAgIGM+Pj1icGU7ICAgaisrOyB9XG4gICAgc2Fbai0xXT1jICYgbWFzaztcbiAgfVxuXG4gIGlmICghZ3JlYXRlcihuLHNhKSlcbiAgICBzdWJfKHNhLG4pO1xuICBjb3B5Xyh4LHNhKTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZSA9IHt9O1xufVxuQmlnSW50ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdCdhZGQnOiBhZGQsICdhZGRJbnQnOiBhZGRJbnQsICdiaWdJbnQyc3RyJzogYmlnSW50MnN0ciwgJ2JpdFNpemUnOiBiaXRTaXplLFxuXHQnZHVwJzogZHVwLCAnZXF1YWxzJzogZXF1YWxzLCAnZXF1YWxzSW50JzogZXF1YWxzSW50LCAnZXhwYW5kJzogZXhwYW5kLFxuXHQnZmluZFByaW1lcyc6IGZpbmRQcmltZXMsICdHQ0QnOiBHQ0QsICdncmVhdGVyJzogZ3JlYXRlcixcblx0J2dyZWF0ZXJTaGlmdCc6IGdyZWF0ZXJTaGlmdCwgJ2ludDJiaWdJbnQnOiBpbnQyYmlnSW50LFxuXHQnaW52ZXJzZU1vZCc6IGludmVyc2VNb2QsICdpbnZlcnNlTW9kSW50JzogaW52ZXJzZU1vZEludCwgJ2lzWmVybyc6IGlzWmVybyxcblx0J21pbGxlclJhYmluJzogbWlsbGVyUmFiaW4sICdtaWxsZXJSYWJpbkludCc6IG1pbGxlclJhYmluSW50LCAnbW9kJzogbW9kLFxuXHQnbW9kSW50JzogbW9kSW50LCAnbXVsdCc6IG11bHQsICdtdWx0TW9kJzogbXVsdE1vZCwgJ25lZ2F0aXZlJzogbmVnYXRpdmUsXG5cdCdwb3dNb2QnOiBwb3dNb2QsICdyYW5kQmlnSW50JzogcmFuZEJpZ0ludCwgJ3JhbmRUcnVlUHJpbWUnOiByYW5kVHJ1ZVByaW1lLFxuXHQncmFuZFByb2JQcmltZSc6IHJhbmRQcm9iUHJpbWUsICdzdHIyYmlnSW50Jzogc3RyMmJpZ0ludCwgJ3N1Yic6IHN1Yixcblx0J3RyaW0nOiB0cmltLCAnYWRkSW50Xyc6IGFkZEludF8sICdhZGRfJzogYWRkXywgJ2NvcHlfJzogY29weV8sXG5cdCdjb3B5SW50Xyc6IGNvcHlJbnRfLCAnR0NEXyc6IEdDRF8sICdpbnZlcnNlTW9kXyc6IGludmVyc2VNb2RfLCAnbW9kXyc6IG1vZF8sXG5cdCdtdWx0Xyc6IG11bHRfLCAnbXVsdE1vZF8nOiBtdWx0TW9kXywgJ3Bvd01vZF8nOiBwb3dNb2RfLFxuXHQncmFuZEJpZ0ludF8nOiByYW5kQmlnSW50XywgJ3JhbmRUcnVlUHJpbWVfJzogcmFuZFRydWVQcmltZV8sICdzdWJfJzogc3ViXyxcblx0J2FkZFNoaWZ0Xyc6IGFkZFNoaWZ0XywgJ2NhcnJ5Xyc6IGNhcnJ5XywgJ2RpdmlkZV8nOiBkaXZpZGVfLFxuXHQnZGl2SW50Xyc6IGRpdkludF8sICdlR0NEXyc6IGVHQ0RfLCAnaGFsdmVfJzogaGFsdmVfLCAnbGVmdFNoaWZ0Xyc6IGxlZnRTaGlmdF8sXG5cdCdsaW5Db21iXyc6IGxpbkNvbWJfLCAnbGluQ29tYlNoaWZ0Xyc6IGxpbkNvbWJTaGlmdF8sICdtb250Xyc6IG1vbnRfLFxuXHQnbXVsdEludF8nOiBtdWx0SW50XywgJ3JpZ2h0U2hpZnRfJzogcmlnaHRTaGlmdF8sICdzcXVhcmVNb2RfJzogc3F1YXJlTW9kXyxcblx0J3N1YlNoaWZ0Xyc6IHN1YlNoaWZ0XywgJ3Bvd01vZF8nOiBwb3dNb2RfLCAnZUdDRF8nOiBlR0NEXyxcblx0J2ludmVyc2VNb2RfJzogaW52ZXJzZU1vZF8sICdHQ0RfJzogR0NEXywgJ21vbnRfJzogbW9udF8sICdkaXZpZGVfJzogZGl2aWRlXyxcblx0J3NxdWFyZU1vZF8nOiBzcXVhcmVNb2RfLCAncmFuZFRydWVQcmltZV8nOiByYW5kVHJ1ZVByaW1lXyxcblx0J21pbGxlclJhYmluJzogbWlsbGVyUmFiaW5cbn07XG5cbn0pKCk7XG4iLCJ2YXIgU29ydGVkQXJyYXkgPSByZXF1aXJlKCdzb3J0ZWQtY21wLWFycmF5Jyk7XG5cbi8qIVxuICogXFxicmllZiBhcnJheSBjb250YWluaW5nIHRoZSBsaXN0IG9mIHNvY2tldHMgdGFyZ2V0aW5nIHRoaXMgcGVlclxuICovXG5mdW5jdGlvbiBJblZpZXcoKXtcbiAgICB0aGlzLnNvY2tldHMgPSBuZXcgU29ydGVkQXJyYXkoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgdmFyIGZpcnN0ID0gYS5pZCB8fCBhO1xuICAgICAgICB2YXIgc2Vjb25kID0gYi5pZCB8fCBiO1xuICAgICAgICBpZiAoZmlyc3QgPCBzZWNvbmQpIHsgcmV0dXJuIC0xfTtcbiAgICAgICAgaWYgKGZpcnN0ID4gc2Vjb25kKSB7IHJldHVybiAgMX07XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGFkZCBhbiBlbGVtZW50IHRvIHRoZSBpbnZpZXdcbiAqIFxccGFyYW0gc29ja2V0IHRoZSBzb2NrZXQgdG8gYWRkIGluIHRoZSBpbnZpZXdcbiAqIFxccGFyYW0gaWQgYSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgc29ja2V0XG4gKi9cbkluVmlldy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oc29ja2V0LCBpZCl7XG4gICAgdGhpcy5zb2NrZXRzLmluc2VydCh7aWQ6aWQsIHNvY2tldDpzb2NrZXR9KTtcbn07XG5cbi8qIVxuICogXFxicmllZiByZW1vdmUgdGhlIHRhcmdldGVkIHNvY2tldCBmcm9tIHRoZSBpbnZpZXdcbiAqIFxccGFyYW0gaWQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGludmlld1xuICogXFxyZXR1cm4gdGhlIHNvY2tldCByZW1vdmVkIGZyb20gdGhlIGludmlldywgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuSW5WaWV3LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zb2NrZXRzLmluZGV4T2YoaWQpLFxuICAgICAgICBzb2NrZXQgPSBudWxsO1xuICAgIGlmIChpbmRleCA+PSAwKXtcbiAgICAgICAgc29ja2V0ID0gdGhpcy5zb2NrZXRzLmFycltpbmRleF07XG4gICAgICAgIHRoaXMuc29ja2V0cy5hcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICAgIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgZ2V0IHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XG4gKi9cbkluVmlldy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmFyci5sZW5ndGg7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgY2xlYXIgdGhlIHdob2xlIGludmlldyBhbmQgY2xvc2UgdGhlIHNvY2tldHNcbiAqL1xuSW5WaWV3LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNvY2tldHMuYXJyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdGhpcy5zb2NrZXRzLmFycltpXS5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH07XG4gICAgdGhpcy5zb2NrZXRzLmFyci5zcGxpY2UoMCwgdGhpcy5zb2NrZXRzLmFyci5sZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJblZpZXc7XG4iLCIvKiFcbiAqIE1Kb2luKGlkKVxuICogTVJlcXVlc3RUaWNrZXQoaWQpXG4gKiBNT2ZmZXJUaWNrZXQoaWQsIHRpY2tldCwgcGVlcilcbiAqIE1TdGFtcGVkVGlja2V0KGlkLCB0aWNrZXQsIHBlZXIpXG4gKiBNRXhjaGFuZ2UoaWQsIHBlZXIpXG4gKi9cblxuLyohXG4gKiBcXGJyaWVmIG1lc3NhZ2UgcmVxdWVzdGluZyB0byBqb2luIHRoZSBuZXR3b3JrXG4gKiBcXHBhcmFtIGlkIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBqb2luIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gTUpvaW4oaWQpe1xuICAgIHRoaXMucHJvdG9jb2wgPSAnc3ByYXknO1xuICAgIHRoaXMudHlwZSA9ICdNSm9pbic7XG4gICAgdGhpcy5pZCA9IGlkO1xufTtcbm1vZHVsZS5leHBvcnRzLk1Kb2luID0gTUpvaW47XG5cbi8qIVxuICogXFxicmllZiBtZXNzYWdlIHJlcXVlc3RpbmcgYW4gb2ZmZXIgdGlja2V0XG4gKiBcXHBhcmFtIGlkIHRoZSBpZGVudGlmaWVyIG9mIHRoZSByZXF1ZXN0IG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gTVJlcXVlc3RUaWNrZXQoaWQpe1xuICAgIHRoaXMucHJvdG9jb2wgPSAnc3ByYXknO1xuICAgIHRoaXMudHlwZSA9ICdNUmVxdWVzdFRpY2tldCc7XG4gICAgdGhpcy5pZCA9IGlkO1xufTtcbm1vZHVsZS5leHBvcnRzLk1SZXF1ZXN0VGlja2V0ID0gTVJlcXVlc3RUaWNrZXQ7XG5cbi8qIVxuICogXFxicmllZiBhbiBvZmZlciB0aWNrZXQgY29udGFpbmluZyB0aGUgZmlyc3QgcGFydCBvZiB0aGUgd2VicnRjIGNvbm5lY3Rpb25cbiAqIGVzdGFibGlzaG1lbnRcbiAqIFxccGFyYW0gaWQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSByZXF1ZXN0IG1lc3NhZ2VcbiAqIFxccGFyYW0gdGlja2V0IHRoZSBmaXJzdCBzdGVwIG9mIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaGVtZW50IGRhdGFcbiAqIFxccGFyYW0gcGVlciB0aGUgcGVlciB0aGF0IGVtaXQgdGhlIG9mZmVyIHRpY2tldFxuICovXG5mdW5jdGlvbiBNT2ZmZXJUaWNrZXQoaWQsIHRpY2tldCwgcGVlcil7XG4gICAgdGhpcy5wcm90b2NvbCA9ICdzcHJheSc7XG4gICAgdGhpcy50eXBlID0gJ01PZmZlclRpY2tldCc7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMudGlja2V0ID0gdGlja2V0O1xuICAgIHRoaXMucGVlciA9IHBlZXI7XG59O1xubW9kdWxlLmV4cG9ydHMuTU9mZmVyVGlja2V0ID0gTU9mZmVyVGlja2V0O1xuXG4vKiFcbiAqIFxcYnJpZWYgYW4gc3RhbXBlZCB0aWNrZXQgY29udGFpbmluZyB0aGUgc2Vjb25kIHBhcnQgb2YgdGhlIHdlYnJ0YyBjb25uZWN0aW9uXG4gKiBlc3RhYmxpc2hlbWVudFxuICogXFxwYXJhbSBpZCB0aGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHJlcXVlc3QgdGlja2V0XG4gKiBcXHBhcmFtIHRpY2tldCB0aGUgc2Vjb25kIHN0ZXAgb2YgdGhlIGNvbm5lY3Rpb24gZXN0YWJsaXNoZW1lbnQgZGF0YVxuICogXFxwYXJhbSBwZWVyIHRoZSBwZWVyIHRoYXQgZW1pdCB0aGUgc3RhbXBlZCB0aWNrZXRcbiAqL1xuZnVuY3Rpb24gTVN0YW1wZWRUaWNrZXQoaWQsIHRpY2tldCwgcGVlcil7XG4gICAgdGhpcy5wcm90b2NvbCA9ICdzcHJheSc7XG4gICAgdGhpcy50eXBlID0gJ01TdGFtcGVkVGlja2V0JztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy50aWNrZXQgPSB0aWNrZXQ7XG4gICAgdGhpcy5wZWVyID0gcGVlcjtcbn07XG5tb2R1bGUuZXhwb3J0cy5NU3RhbXBlZFRpY2tldCA9IE1TdGFtcGVkVGlja2V0O1xuXG4vKiFcbiAqIFxcYnJpZWYgbWVzc2FnZSByZXF1ZXN0aW5nIGFuIGV4Y2hhbmdlIG9mIG5laWdoYm9yaG9vZFxuICogXFxwYXJhbSBpZCB0aGUgaWRlbnRpZmllciBvZiB0aGUgcmVxdWVzdCBtZXNzYWdlXG4gKiBcXHBhcmFtIHBlZXIgdGhlIGlkZW50aXR5IG9mIHRoZSBpbml0aWF0b3Igb2YgdGhlIGV4Y2hhbmdlXG4gKi9cbmZ1bmN0aW9uIE1FeGNoYW5nZShpZCwgcGVlcil7XG4gICAgdGhpcy5wcm90b2NvbCA9ICdzcHJheSc7XG4gICAgdGhpcy50eXBlID0gJ01FeGNoYW5nZSc7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMucGVlciA9IHBlZXI7XG59O1xubW9kdWxlLmV4cG9ydHMuTUV4Y2hhbmdlID0gTUV4Y2hhbmdlO1xuIiwidmFyIFNvcnRlZEFycmF5ID0gcmVxdWlyZShcInNvcnRlZC1jbXAtYXJyYXlcIik7XG5cbi8qIVxuICogXFxicmllZiBjb21wYXJhdG9yXG4gKiBcXHBhcmFtIGEgdGhlIGZpcnN0IG9iamVjdCBpbmNsdWRpbmcgYW4gJ2FnZScgcHJvcGVydHlcbiAqIFxccGFyYW0gYiB0aGUgc2Vjb25kIG9iamVjdCBpbmNsdWRpbmcgYW4gJ2FnZScgcHJvcGVydHlcbiAqIFxccmV0dXJuIDEgaWYgYS5hZ2UgPiBiLmFnZSwgLTEgaWYgYS5hZ2UgPCBiLmFnZSwgMCBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gY29tcChhLCBiKXtcbiAgICBpZiAoYS5hZ2UgPCBiLmFnZSl7IHJldHVybiAtMTt9O1xuICAgIGlmIChhLmFnZSA+IGIuYWdlKXsgcmV0dXJuICAxO307XG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgc3RydWN0dXJlIGNvbnRhaW5pbmcgdGhlIG5laWdoYm9yaG9vZCBvZiBhIHBlZXIuXG4gKi9cbmZ1bmN0aW9uIFBhcnRpYWxWaWV3KCl7XG4gICAgLy8gIzEgaW5pdGlhbGl6ZSB0aGUgcGFydGlhbCB2aWV3IGFzIGFuIGFycmF5IHNvcnRlZCBieSBhZ2VcbiAgICB0aGlzLmFycmF5ID0gbmV3IFNvcnRlZEFycmF5KGNvbXApO1xufTtcblxuLyohXG4gKiBcXHJldHVybiB0aGUgb2xkZXN0IHBlZXIgaW4gdGhlIGFycmF5XG4gKi9cblBhcnRpYWxWaWV3LnByb3RvdHlwZS5nZXRPbGRlc3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmFycmF5LmFyclswXTtcbn07XG5cbi8qIVxuICogXFxicmllZiBpbmNyZW1lbnQgdGhlIGFnZSBvZiB0aGUgd2hvbGUgcGFydGlhbCB2aWV3XG4gKi9cblBhcnRpYWxWaWV3LnByb3RvdHlwZS5pbmNyZW1lbnRBZ2UgPSBmdW5jdGlvbigpe1xuICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmFycmF5LmFyci5sZW5ndGg7ICsraSl7XG4gICAgICAgIHRoaXMuYXJyYXkuYXJyW2ldLmFnZSArPSAxO1xuICAgIH07XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgZ2V0IGEgc2FtcGxlIG9mIHRoZSBwYXJ0aWFsIHRvIHNlbmQgdG8gdGhlIG5laWdoYm9yXG4gKiBcXHBhcmFtIG5laWdoYm9yIHRoZSBuZWlnaGJvciB3aGljaCBwZXJmb3JtcyB0aGUgZXhjaGFuZ2Ugd2l0aCB1c1xuICogXFxwYXJhbSBpc0luaXRpYXRvciB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsbGVyIGlzIHRoZSBpbml0aWF0b3Igb2YgdGhlXG4gKiBleGNoYW5nZVxuICogXFxyZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBuZWlnaGJvcnMgZnJvbSB0aGlzIHBhcnRpYWwgdmlld1xuICovXG5QYXJ0aWFsVmlldy5wcm90b3R5cGUuZ2V0U2FtcGxlID0gZnVuY3Rpb24obmVpZ2hib3IsIGlzSW5pdGlhdG9yKXtcbiAgICB2YXIgc2FtcGxlID0gW107XG4gICAgLy8gIzEgY29weSB0aGUgcGFydGlhbCB2aWV3XG4gICAgdmFyIGNsb25lID0gbmV3IFNvcnRlZEFycmF5KGNvbXApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcnJheS5hcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICBjbG9uZS5hcnIucHVzaCh0aGlzLmFycmF5LmFycltpXSk7XG4gICAgfTtcblxuICAgIC8vICMyIHByb2Nlc3MgdGhlIHNpemUgb2YgdGhlIHNhbXBsZVxuICAgIHZhciBzYW1wbGVTaXplID0gTWF0aC5jZWlsKHRoaXMuYXJyYXkuYXJyLmxlbmd0aC8yKTtcbiAgICBcbiAgICBpZiAoaXNJbml0aWF0b3Ipe1xuICAgICAgICAvLyAjQSByZW1vdmUgYW4gb2NjdXJyZW5jZSBvZiB0aGUgY2hvc2VuIG5laWdoYm9yXG4gICAgICAgIHZhciBpbmRleCA9IGNsb25lLmluZGV4T2YobmVpZ2hib3IpO1xuICAgICAgICBzYW1wbGUucHVzaChjbG9uZS5hcnJbaW5kZXhdKTsgXG4gICAgICAgIGNsb25lLmFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gICAgXG4gICAgLy8gIzMgcmFuZG9tbHkgYWRkIG5laWdoYm9ycyB0byB0aGUgc2FtcGxlXG4gICAgd2hpbGUgKHNhbXBsZS5sZW5ndGggPCBzYW1wbGVTaXplKXtcbiAgICAgICAgdmFyIHJuID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmNsb25lLmFyci5sZW5ndGgpO1xuICAgICAgICBzYW1wbGUucHVzaChjbG9uZS5hcnJbcm5dKTtcbiAgICAgICAgY2xvbmUuYXJyLnNwbGljZShybiwgMSk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gc2FtcGxlO1xufTtcblxuXG5cbi8qIVxuICogXFxicmllZiByZXBsYWNlIHRoZSBvY2N1cnJlbmNlcyBvZiB0aGUgb2xkIHBlZXIgYnkgdGhlIGZyZXNoIG9uZVxuICogXFxwYXJhbSBzYW1wbGUgdGhlIHNhbXBsZSB0byBtb2RpZnlcbiAqIFxccGFyYW0gb2xkIHRoZSBvbGQgcmVmZXJlbmNlIHRvIHJlcGxhY2VcbiAqIFxccGFyYW0gZnJlc2ggdGhlIG5ldyByZWZlcmVuY2UgdG8gaW5zZXJ0XG4gKiBcXHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSByZXBsYWNlZCBvY2N1cmVuY2VzXG4gKi9cblBhcnRpYWxWaWV3LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oc2FtcGxlLCBvbGQsIGZyZXNoKXtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGUubGVuZ3RoOyArK2kpe1xuICAgICAgICBpZiAoc2FtcGxlW2ldLmlkID09PSBvbGQuaWQpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJlc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2FtcGxlW2ldKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgYWRkIHRoZSBuZWlnYmhvciB0byB0aGUgcGFydGlhbCB2aWV3IHdpdGggYW4gYWdlIG9mIDBcbiAqIFxccGFyYW0gcGVlciB0aGUgcGVlciB0byBhZGQgdG8gdGhlIHBhcnRpYWwgdmlld1xuICovXG5QYXJ0aWFsVmlldy5wcm90b3R5cGUuYWRkTmVpZ2hib3IgPSBmdW5jdGlvbihwZWVyKXtcbiAgICBwZWVyLmFnZSA9IDA7XG4gICAgdGhpcy5hcnJheS5hcnIucHVzaChwZWVyKTtcbn07XG5cblxuLyohXG4gKiBcXGJyaWVmIGdldCB0aGUgaW5kZXggb2YgdGhlIHBlZXIgaW4gdGhlIHBhcnRpYWx2aWV3XG4gKiBcXHJldHVybiB0aGUgaW5kZXggb2YgdGhlIHBlZXIgaW4gdGhlIGFycmF5LCAtMSBpZiBub3QgZm91bmRcbiAqL1xuUGFydGlhbFZpZXcucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24ocGVlcil7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgIHdoaWxlICghZm91bmQgJiYgaSA8IHRoaXMuYXJyYXkuYXJyLmxlbmd0aCl7XG4gICAgICAgIGlmIChwZWVyLmlkID09PSB0aGlzLmFycmF5LmFycltpXS5pZCl7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH07XG4gICAgICAgICsraTtcbiAgICB9O1xuICAgIHJldHVybiBpbmRleDtcbn07XG5cbi8qIVxuICogXFxicmllZiByZW1vdmUgdGhlIHBlZXIgZnJvbSB0aGUgcGFydGlhbCB2aWV3XG4gKiBcXHBhcmFtIHBlZXIgdGhlIHBlZXIgdG8gcmVtb3ZlXG4gKiBcXHJldHVybiB0aGUgcmVtb3ZlZCBlbnRyeSBpZiBpdCBleGlzdHMsIG51bGwgb3RoZXJ3aXNlXG4gKi9cblBhcnRpYWxWaWV3LnByb3RvdHlwZS5yZW1vdmVQZWVyID0gZnVuY3Rpb24ocGVlcil7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleChwZWVyKSxcbiAgICAgICAgcmVtb3ZlZEVudHJ5ID0gbnVsbDtcbiAgICBpZiAoaW5kZXggPiAtMSl7XG4gICAgICAgIHJlbW92ZWRFbnRyeSA9IHRoaXMuYXJyYXkuYXJyW2luZGV4XTtcbiAgICAgICAgdGhpcy5hcnJheS5hcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICAgIHJldHVybiByZW1vdmVkRW50cnk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgcmVtb3ZlIHRoZSBwZWVyIHdpdGggdGhlIGFzc29jaWF0ZWQgYWdlIGZyb20gdGhlIHBhcnRpYWwgdmlld1xuICogXFxwYXJhbSBwZWVyIHRoZSBwZWVyIHRvIHJlbW92ZVxuICogXFxwYXJhbSBhZ2UgdGhlIGFnZSBvZiB0aGUgcGVlciB0byByZW1vdmVcbiAqIFxccmV0dXJuIHRoZSByZW1vdmVkIGVudHJ5IGlmIGl0IGV4aXN0cywgbnVsbCBvdGhlcndpc2VcbiAqL1xuUGFydGlhbFZpZXcucHJvdG90eXBlLnJlbW92ZVBlZXJBZ2UgPSBmdW5jdGlvbihwZWVyLCBhZ2Upe1xuICAgIHZhciBmb3VuZCA9IGZhbHNlLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcmVtb3ZlZEVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSghZm91bmQgJiYgaSA8IHRoaXMuYXJyYXkuYXJyLmxlbmd0aCl7XG4gICAgICAgIGlmIChwZWVyLmlkID09PSB0aGlzLmFycmF5LmFycltpXS5pZCAmJiBhZ2UgPT09IHRoaXMuYXJyYXkuYXJyW2ldLmFnZSl7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICByZW1vdmVkRW50cnkgPSB0aGlzLmFycmF5LmFycltpXTtcbiAgICAgICAgICAgIHRoaXMuYXJyYXkuYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgKytpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlbW92ZWRFbnRyeTtcbn07XG5cbi8qIVxuICogXFxicmllZiByZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIHRoZSBwZWVyIGFuZCByZXR1cm4gdGhlIG51bWJlciBvZiByZW1vdmFsc1xuICogXFxwYXJhbSBwZWVyIHRoZSBwZWVyIHRvIHJlbW92ZVxuICogXFxyZXR1cm4gdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB0aGUgcmVtb3ZlZCBwZWVyXG4gKi9cblBhcnRpYWxWaWV3LnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbihwZWVyKXtcbiAgICB2YXIgb2NjID0gMCxcbiAgICAgICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB0aGlzLmFycmF5LmFyci5sZW5ndGgpe1xuICAgICAgICBpZiAodGhpcy5hcnJheS5hcnJbaV0uaWQgPT09IHBlZXIuaWQpe1xuICAgICAgICAgICAgdGhpcy5hcnJheS5hcnIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgb2NjICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gb2NjO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIHJlbW92ZSBhbGwgdGhlIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgc2FtcGxlIGluIGFyZ3VtZW50XG4gKiBcXHBhcmFtIHNhbXBsZSB0aGUgZWxlbWVudHMgdG8gcmVtb3ZlXG4gKi9cblBhcnRpYWxWaWV3LnByb3RvdHlwZS5yZW1vdmVTYW1wbGUgPSBmdW5jdGlvbihzYW1wbGUpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdGhpcy5yZW1vdmVQZWVyQWdlKHNhbXBsZVtpXSwgc2FtcGxlW2ldLmFnZSk7XG4gICAgfTtcbn07XG5cbi8qIVxuICogXFxicmllZiBnZXQgdGhlIHNpemUgb2YgdGhlIHBhcnRpYWwgdmlld1xuICogXFxyZXR1cm4gdGhlIHNpemUgb2YgdGhlIHBhcnRpYWwgdmlld1xuICovXG5QYXJ0aWFsVmlldy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5hcnJheS5hcnIubGVuZ3RoO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGNoZWNrIGlmIHRoZSBwYXJ0aWFsIHZpZXcgY29udGFpbnMgdGhlIHJlZmVyZW5jZVxuICogXFxwYXJhbSBwZWVyIHRoZSBwZWVyIHRvIGNoZWNrXG4gKiBcXHJldHVybiB0cnVlIGlmIHRoZSBwZWVyIGlzIGluIHRoZSBwYXJ0aWFsIHZpZXcsIGZhbHNlIG90aGVyd2lzZVxuICovXG5QYXJ0aWFsVmlldy5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihwZWVyKXtcbiAgICByZXR1cm4gdGhpcy5nZXRJbmRleChwZWVyKT49MDtcbn07XG5cbi8qIVxuICogXFxicmllZiByZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHBhcnRpYWwgdmlld1xuICovXG5QYXJ0aWFsVmlldy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJyYXkuYXJyLnNwbGljZSgwLCB0aGlzLmFycmF5LmFyci5sZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWFsVmlldztcbiIsInZhciBTb3J0ZWRBcnJheSA9IHJlcXVpcmUoXCJzb3J0ZWQtY21wLWFycmF5XCIpO1xuXG4vKiFcbiAqIFxcYnJpZWYgcmVwcmVzZW50IHRoZSBhcnJheSBjb250YWluaW5nIHRoZSBzb2NrZXRzIGFzc29jaWF0ZWQgd2l0aFxuICogYSB1bmlxdWUgaWRlbnRpZmllciBpZFxuICovXG5mdW5jdGlvbiBTb2NrZXRzKCl7XG4gICAgdGhpcy5hcnJheSA9IG5ldyBTb3J0ZWRBcnJheShcbiAgICAgICAgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICBpZiAoYS5pZCA8IGIuaWQpeyByZXR1cm4gLTE7IH07XG4gICAgICAgICAgICBpZiAoYS5pZCA+IGIuaWQpeyByZXR1cm4gIDE7IH07XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5sYXN0Q2hhbmNlID0gbnVsbDsgLy8gbGFzdCBjaGFuY2Ugc29ja2V0LlxufTtcblxuLyohXG4gKiBcXGJyaWVmIGFkZCB0aGUgc29ja2V0IHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gaWRlbnRpZmllciBcbiAqIFxccGFyYW0gc29ja2V0IHRoZSBzb2NrZXQgdG8gY29tbXVuaWNhdGUgd2l0aCBwZWVyXG4gKiBcXHBhcmFtIG9iamVjdCB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGlkZW50aWZpZXJcbiAqIFxccmV0dXJuIHRydWUgaWYgdGhlIHNvY2tldCBhcyBiZWVuIGFkZGVkLCBmYWxzZSBvdGhlcndpc2VcbiAqLyBcblNvY2tldHMucHJvdG90eXBlLmFkZFNvY2tldCA9IGZ1bmN0aW9uKHNvY2tldCwgb2JqZWN0KXtcbiAgICB2YXIgY29udGFpbnMgPSB0aGlzLmNvbnRhaW5zKG9iamVjdCk7XG4gICAgaWYgKCFjb250YWlucyl7XG4gICAgICAgIHRoaXMuYXJyYXkuaW5zZXJ0KHtpZDpvYmplY3QuaWQsIHNvY2tldDpzb2NrZXR9KTtcbiAgICB9O1xuICAgIHJldHVybiAhY29udGFpbnM7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgcmVtb3ZlIHRoZSBvYmplY3QgYW5kIGl0cyBhc3NvY2lhdGVkIHNvY2tldCBmcm9tIHRoZSBhcnJheVxuICogXFxwYXJhbSBvYmplY3QgdGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBpZGVudGlmaWVyIHRvIHJlbW92ZVxuICogXFxyZXR1cm4gdGhlIHNvY2tldCB0YXJnZXRlZCBieSB0aGUgcmVtb3ZhbCwgbnVsbCBpZiBpdCBkb2VzIG5vdCBleGlzdFxuICovXG5Tb2NrZXRzLnByb3RvdHlwZS5yZW1vdmVTb2NrZXQgPSBmdW5jdGlvbihvYmplY3Qpe1xuICAgIHZhciBzb2NrZXQgPSB0aGlzLmdldFNvY2tldChvYmplY3QpO1xuICAgIGlmIChzb2NrZXQgIT09IG51bGwpe1xuICAgICAgICB0aGlzLmFycmF5LnJlbW92ZShvYmplY3QpO1xuICAgICAgICB0aGlzLmxhc3RDaGFuY2UgPSBzb2NrZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gc29ja2V0O1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGdldCB0aGUgc29ja2V0IGF0dGFjaGVkIHRvIHRoZSBvYmplY3QgaWRlbnRpdHlcbiAqIFxccGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgaWRlbnRpZmllciB0byBzZWFyY2hcbiAqIFxccmV0dXJuIHRoZSBzb2NrZXQgaWYgdGhlIG9iamVjdCBleGlzdHMsIG51bGwgb3RoZXJ3aXNlXG4gKi9cblNvY2tldHMucHJvdG90eXBlLmdldFNvY2tldCA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5hcnJheS5pbmRleE9mKG9iamVjdCksXG4gICAgICAgIHNvY2tldCA9IG51bGw7XG4gICAgaWYgKGluZGV4ICE9PSAtMSl7XG4gICAgICAgIHNvY2tldCA9IHRoaXMuYXJyYXkuYXJyW2luZGV4XS5zb2NrZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gc29ja2V0O1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGNoZWNrIGlmIHRoZXJlIGlzIGEgc29ja2V0IGFzc29jaWF0ZWQgdG8gdGhlIG9iamVjdFxuICogXFxwYXJhbSBvYmplY3QgdGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBpZGVudGlmaWVyIHRvIGNoZWNrXG4gKiBcXHJldHVybiB0cnVlIGlmIGEgc29ja2V0IGFzc29jaWF0ZWQgdG8gdGhlIG9iamVjdCBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5Tb2NrZXRzLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgcmV0dXJuICh0aGlzLmFycmF5LmluZGV4T2Yob2JqZWN0KSAhPT0gLTEpO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5XG4gKiBcXHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICovXG5Tb2NrZXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmFycmF5LmFyci5sZW5ndGg7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgcmVtb3ZlIGFsbCB0aGUgc29ja2V0cyBmcm9tIHRoaXMgcmVnaXN0ZXIsIGFuZCBjbG9zZSB0aGVtXG4gKi9cblNvY2tldHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5hcnJheS5hcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICB0aGlzLmFycmF5LmFycltpXS5zb2NrZXQuZGVzdHJveSgpOyAgICAgICAgXG4gICAgfTtcbiAgICB0aGlzLmFycmF5LmFyci5zcGxpY2UoMCwgdGhpcy5hcnJheS5hcnIubGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0cztcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnc2ltcGxlLXBlZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgUGFydGlhbFZpZXcgPSByZXF1aXJlKCcuL3BhcnRpYWx2aWV3LmpzJyk7XG52YXIgSW5WaWV3ID0gcmVxdWlyZSgnLi9pbnZpZXcuanMnKTtcbnZhciBTb2NrZXRzID0gcmVxdWlyZSgnLi9zb2NrZXRzLmpzJyk7XG52YXIgR1VJRCA9IHJlcXVpcmUoJy4vZ3VpZC5qcycpO1xuXG52YXIgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzLmpzJyk7XG52YXIgTUpvaW4gPSBNZXNzYWdlcy5NSm9pbjtcbnZhciBNUmVxdWVzdFRpY2tldCA9IE1lc3NhZ2VzLk1SZXF1ZXN0VGlja2V0O1xudmFyIE1PZmZlclRpY2tldCA9IE1lc3NhZ2VzLk1PZmZlclRpY2tldDtcbnZhciBNU3RhbXBlZFRpY2tldCA9IE1lc3NhZ2VzLk1TdGFtcGVkVGlja2V0O1xudmFyIE1FeGNoYW5nZSA9IE1lc3NhZ2VzLk1FeGNoYW5nZTtcblxudXRpbC5pbmhlcml0cyhTcHJheSwgRXZlbnRFbWl0dGVyKTtcblxuLyohXG4gKiBcXGJyaWVmIEltcGxlbWVudGF0aW9uIG9mIHRoZSByYW5kb20gcGVlciBzYW1wbGluZyBjYWxsZWQgU3ByYXkgb24gdG9wIG9mXG4gKiBzb2NrZXQuaW9cbiAqIFxccGFyYW0gaWQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIG91ciBwZWVyXG4gKiBcXHBhcmFtIG9wdGlvbnMgdGhlIFdlYlJUQyBvcHRpb25zLCBmb3IgbW9yZSBpbmZvcm1hdGlvbnM6IFxuICogXFx1cmwgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlclxuICovXG5mdW5jdGlvbiBTcHJheShpZCwgb3B0aW9ucyl7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgLy8gI0EgY29uc3RhbnRzXG4gICAgdGhpcy5ERUxUQVRJTUUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlbHRhdGltZSkgfHwgMTAwMCAqIDYwICogMjsgLy8gMm1pblxuICAgIHRoaXMuVElNRU9VVCA9IChvcHRpb25zICYmIG9wdGlvbnMudGltZW91dCkgfHwgMTAwMCAqIDYwICogMTsgLy8gMW1pblxuICAgIHRoaXMuSUQgPSAoaWQgJiYgJycraWQrJycpIHx8IEdVSUQoKTtcbiAgICB0aGlzLk9QVElPTlMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIC8vICNCIHByb3RvY29sIHZhcmlhYmxlc1xuICAgIHRoaXMucGFydGlhbFZpZXcgPSBuZXcgUGFydGlhbFZpZXcoKTtcbiAgICB0aGlzLmluVmlldyA9IG5ldyBJblZpZXcoKTtcbiAgICBcbiAgICB0aGlzLnNvY2tldHMgPSBuZXcgU29ja2V0cygpO1xuICAgIHRoaXMucGVuZGluZyA9IG5ldyBTb2NrZXRzKCk7XG4gICAgdGhpcy5mb3J3YXJkcyA9IG5ldyBTb2NrZXRzKCk7XG4gICAgdGhpcy5zdGF0ZSA9ICdkaXNjb25uZWN0JztcbiAgICBcbiAgICAvLyAjQyB3ZWJydGMgc3BlY2lmaWNzXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChzZWxmLnBhcnRpYWxWaWV3Lmxlbmd0aCgpPjApe1xuICAgICAgICAgICAgc2VsZi5leGNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgIH0sIHRoaXMuREVMVEFUSU1FKTtcblxuICAgIC8vICNEIGV2ZW50c1xuICAgIHRoaXMub24oJ3NwcmF5LXJlY2VpdmUnLCBmdW5jdGlvbihzb2NrZXQsIG1lc3NhZ2Upe1xuICAgICAgICBzZWxmLm9uU3ByYXlSZWNlaXZlKHNvY2tldCwgbWVzc2FnZSk7XG4gICAgfSk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgY2hlY2sgaWYgdGhlIG5ldHdvcmsgaXMgcmVhZHkgYW5kIGNhbGxiYWNrLCBub3RoaW5nIG90aGVyd2lzZVxuICogXFxwYXJhbSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGUgbmV0d29yayBpcyByZWFkeVxuICovXG5TcHJheS5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgaWYgKHRoaXMucGFydGlhbFZpZXcubGVuZ3RoKCkgPiAwKXsgY2FsbGJhY2soKTsgfTtcbn07XG5cbi8qIVxuICogXFxicmllZiBnZXQgYSBzZXQgb2YgbmVpZ2hib3JzLiAoVE9ETykgaW5jbHVkZSB0aGUgc29ja2V0cyBmcm9tIHRoZSBpblZpZXdcbiAqIFxccGFyYW0gayB0aGUgbnVtYmVyIG9mIG5laWdoYm9ycyByZXF1ZXN0ZWRcbiAqIFxccmV0dXJuIGEgbGlzdCBvZiBzb2NrZXRzXG4gKi9cblNwcmF5LnByb3RvdHlwZS5nZXRQZWVycyA9IGZ1bmN0aW9uKGspe1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAvLyAjQSBjb3B5IHRoZSBzb2NrZXRzIG9mIHRoZSBwYXJ0aWFsIHZpZXdcbiAgICB2YXIgY2xvbmVTb2NrZXRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNvY2tldHMubGVuZ3RoKCk7ICsraSl7XG4gICAgICAgIGNsb25lU29ja2V0c1tpXSA9IHRoaXMuc29ja2V0cy5hcnJheS5hcnJbaV07XG4gICAgfTtcbiAgICAvLyAjQiBnZXQgYXMgbXVjaCBuZWlnaGJvcnMgYXMgcG9zc2libGVcbiAgICB3aGlsZSAoMCA8IGNsb25lU29ja2V0cy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IGspe1xuICAgICAgICB2YXIgcm4gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqY2xvbmVTb2NrZXRzLmxlbmd0aCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNsb25lU29ja2V0c1tybl0uc29ja2V0KTtcbiAgICAgICAgY2xvbmVTb2NrZXRzLnNwbGljZShybiwgMSk7XG4gICAgfTtcbiAgICAvLyAjQyBsYXN0IGNoYW5jZSBzb2NrZXRcbiAgICBpZiAoaz4wICYmIHJlc3VsdC5sZW5ndGg9PT0wICYmIHRoaXMuc29ja2V0cy5sYXN0Q2hhbmNlIT09bnVsbCl7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc29ja2V0cy5sYXN0Q2hhbmNlKTtcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgdXBkYXRlIHRoZSBsb2NhbCBjb25uZWN0aW9uIHN0YXRlIG9mIHRoZSBwZWVyIGFuZCBlbWl0IGFuIGV2ZW50XG4gKiBpZiB0aGUgc3RhdGUgaXMgZGlmZmVyZW50IHRoYW4gYXQgdGhlIHByZXZpb3VzIGNhbGwgb2YgdGhpcyBmdW5jdGlvbi5cbiAqIFRoZSBlbWl0dGVkIGV2ZW50IGlzICdzdGF0ZWNoYW5nZScgd2l0aCB0aGUgXG4gKiBhcmd1bWVudHMgJ2Nvbm5lY3QnIHwgJ3BhcnRpYWwnIHwgJ2Rpc2Nvbm5lY3QnXG4gKi9cblNwcmF5LnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMucGFydGlhbFZpZXcubGVuZ3RoKCkgPiAwICYmIHRoaXMuc3RhdGUgIT09ICdjb25uZWN0Jyl7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnY29ubmVjdCc7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhdGVjaGFuZ2UnLCAnY29ubmVjdCcpO1xuICAgIH0gZWxzZSBpZiAoKHRoaXMucGFydGlhbFZpZXcubGVuZ3RoKCkgPT09IDAgJiYgdGhpcy5pblZpZXcubGVuZ3RoKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsVmlldy5sZW5ndGgoKSA+IDAgJiYgdGhpcy5pblZpZXcubGVuZ3RoKCkgPT09IDAgKSAmJlxuICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gJ3BhcnRpYWwnKXtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJ0aWFsJztcbiAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZWNoYW5nZScsICdwYXJ0aWFsJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcnRpYWxWaWV3Lmxlbmd0aCgpID09PSAwICYmIHRoaXMucGVuZGluZy5sZW5ndGgoKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gJ2Rpc2Nvbm5lY3QnKXtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdkaXNjb25uZWN0JztcbiAgICAgICAgdGhpcy5lbWl0KCdzdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0Jyk7XG4gICAgfTtcbn07XG5cbi8qIVxuICogXFxicmllZiBsZWF2ZSB0aGUgbmV0d29yayBieSBjbG9zaW5nIHRoZSBpbnZpZXcgYW5kIHBhcnRpYWx2aWV3XG4gKi9cblNwcmF5LnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5wYXJ0aWFsVmlldy5jbGVhcigpO1xuICAgIHRoaXMuaW5WaWV3LmNsZWFyKCk7XG4gICAgXG4gICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgdGhpcy5wZW5kaW5nLmNsZWFyKCk7XG4gICAgdGhpcy5mb3J3YXJkcy5jbGVhcigpO1xufTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEJvb3RzdHJhcCB0aGUgZmlyc3QgV2ViUlRDIGNvbm5lY3Rpb25cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qIVxuICogXFxicmllZiB0aGUgdmVyeSBmaXJzdCBwYXJ0IG9mIGEgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50IHRvIGpvaW4gdGhlIG5ldHdvcmsuXG4gKiBUaGlzIHBhcnQgY29ycmVzcG9uZHMgdG8gdGhlIGZpcnN0IHBhcnQgb2YgdGhlICdvblN0YW1wZWRUaWNrZXRSZXF1ZXN0JyBvZlxuICogdGhlIHNwcmF5IHByb3RvY29sLlxuICogXFxwYXJhbSBjYWxsYmFjayBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRha2luZyBhICdtZXNzYWdlJyBpbiBhcmd1bWVudCBhbmRcbiAqIGNhbGxlZCB3aGVuIHdlIHJlY2VpdmUgdGhlIGRhdGEgZnJvbSB0aGUgc3R1biBzZXJ2ZXJcbiAqL1xuU3ByYXkucHJvdG90eXBlLmxhdW5jaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICB2YXIgb3B0aW9ucz10aGlzLk9QVElPTlM7IG9wdGlvbnMuaW5pdGlhdG9yPXRydWU7IG9wdGlvbnMudHJpY2tsZT1mYWxzZTtcbiAgICB2YXIgc29ja2V0ID0gbmV3IFNvY2tldChvcHRpb25zKSxcbiAgICAgICAgaWQgPSBHVUlEKCksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignc2lnbmFsJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IE1PZmZlclRpY2tldChpZCwgZGF0YSwge2lkOiBzZWxmLklEfSk7XG4gICAgICAgIHNlbGYucGVuZGluZy5hZGRTb2NrZXQoc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBpZiAoc2VsZi5wZW5kaW5nLmNvbnRhaW5zKHtpZDppZH0pKXtcbiAgICAgICAgICAgIHNlbGYucGVuZGluZy5yZW1vdmVTb2NrZXQoe2lkOmlkfSk7XG4gICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH0sIHRoaXMuVElNRU9VVCk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQuIFRoaXMgZnVuY3Rpb24gaXNcbiAqIGNhbGxlZCBhdCB0aGUgcGVlciBhbHJlYWR5IGluc2lkZSB0aGUgbmV0d29yay4gSXQgY29ycmVzcG9uZHMgdG8gdGhlIGZ1bmN0aW9uXG4gKiAnb25UaWNrZXRSZXF1ZXN0JyBvZiB0aGUgU3ByYXkgcHJvdG9jb2xcbiAqIFxccGFyYW0gbWVzc2FnZSB0aGUgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgdGhlIGxhdW5jaCBmdW5jdGlvbiBhdCB0aGUgam9pbmluZ1xuICogcGVlclxuICogXFxwYXJhbSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gd2UgcmVjZWl2ZSB0aGUgc3RhbXBlZCB0aWNrZXQgZnJvbVxuICogdGhlIHN0dW4gc2VydmVyLiBJdCBoYXMgYSAnbWVzc2FnZScgYXJndW1lbnQuXG4gKi9cblNwcmF5LnByb3RvdHlwZS5hbnN3ZXIgPSBmdW5jdGlvbihtZXNzYWdlLCBjYWxsYmFjayl7XG4gICAgdmFyIG9wdGlvbnM9dGhpcy5PUFRJT05TOyBvcHRpb25zLmluaXRpYXRvcj1mYWxzZTsgb3B0aW9ucy50cmlja2xlPWZhbHNlO1xuICAgIHZhciBzb2NrZXQgPSBuZXcgU29ja2V0KG9wdGlvbnMpLFxuICAgICAgICBpZCA9IG1lc3NhZ2UuaWQsXG4gICAgICAgIHRpY2tldCA9IG1lc3NhZ2UudGlja2V0LFxuICAgICAgICBwZWVyID0gbWVzc2FnZS5wZWVyLFxuICAgICAgICBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ3NpZ25hbCcsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICB2YXIgc3RhbXBlZFRpY2tldCA9IG5ldyBNU3RhbXBlZFRpY2tldChpZCwgZGF0YSwge2lkOnNlbGYuSUR9KTtcbiAgICAgICAgc2VsZi5wZW5kaW5nLmFkZFNvY2tldChzb2NrZXQsIHN0YW1wZWRUaWNrZXQpO1xuICAgICAgICBjYWxsYmFjayhzdGFtcGVkVGlja2V0KTtcbiAgICB9KTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgICBjb25zb2xlLmxvZygnd3J0Yzogc3VjY2Vzc2Z1bCBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQnKTtcbiAgICAgICAgc2VsZi5wZW5kaW5nLnJlbW92ZVNvY2tldChtZXNzYWdlKTtcbiAgICAgICAgc2VsZi5pblZpZXcuYWRkKHNvY2tldCwgaWQpO1xuICAgICAgICBzZWxmLnVwZGF0ZVN0YXRlKCk7XG4gICAgfSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgZnVuY3Rpb24ocmVjZWl2ZWRNZXNzYWdlKXtcbiAgICAgICAgc2VsZi5yZWNlaXZlKHNvY2tldCwgcmVjZWl2ZWRNZXNzYWdlKTtcbiAgICB9KTtcbiAgICBzb2NrZXQub24oJ3N0cmVhbScsIGZ1bmN0aW9uKHN0cmVhbSl7XG4gICAgICAgIHNlbGYuZW1pdCgnc3RyZWFtJywgc29ja2V0LCBzdHJlYW0pO1xuICAgIH0pO1xuICAgIHNvY2tldC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgICAgICBjb25zb2xlLmxvZygnd3J0YzogYSBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCcpO1xuICAgICAgICBzZWxmLmluVmlldy5yZW1vdmUoaWQpO1xuICAgICAgICBzZWxmLnVwZGF0ZVN0YXRlKCk7XG4gICAgfSk7XG4gICAgc29ja2V0LnNpZ25hbCh0aWNrZXQpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHNlbGYucGVuZGluZy5jb250YWlucyh7aWQ6aWR9KSl7XG4gICAgICAgICAgICB2YXIgc29ja2V0ID0gc2VsZi5wZW5kaW5nLnJlbW92ZVNvY2tldCh7aWQ6aWR9KTtcbiAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgfSwgdGhpcy5USU1FT1VUKTtcbn07XG5cbi8qIVxuICogXFxicmllZiB0aGUgdGhpcmQgcGFydCBvZiB0aGUgdmVyeSBmaXJzdCBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgdG8gam9pbiB0aGVcbiAqIG5ldHdvcmsuIEl0IGNvcnJlc3BvbmRzIHRvIHRoZSBsYXN0IHBhcnQgb2YgdGhlIGZ1bmN0aW9uIG9mXG4gKiAnb25TdGFtcGVkVGlja2V0UmVxdWVzdCcgb2YgdGhlIFNwcmF5IHByb3RvY29sLlxuICogXFxwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgdGlja2V0IGZyb20gdGhlIGNvbnRhY3RcbiAqIHBlZXJcbiAqL1xuU3ByYXkucHJvdG90eXBlLmhhbmRzaGFrZSA9IGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgIHZhciBzb2NrZXQgPSB0aGlzLnBlbmRpbmcucmVtb3ZlU29ja2V0KG1lc3NhZ2UpLFxuICAgICAgICBpZCA9IG1lc3NhZ2UuaWQsXG4gICAgICAgIHRpY2tldCA9IG1lc3NhZ2UudGlja2V0LFxuICAgICAgICBwZWVyID0gbWVzc2FnZS5wZWVyLFxuICAgICAgICBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgICBjb25zb2xlLmxvZygnd3J0Yzogc3VjY2Vzc2Z1bCBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQnKTtcbiAgICAgICAgc2VsZi5wYXJ0aWFsVmlldy5hZGROZWlnaGJvcihwZWVyKTtcbiAgICAgICAgc2VsZi5zb2NrZXRzLmFkZFNvY2tldChzb2NrZXQsIHBlZXIpO1xuICAgICAgICBzZWxmLmpvaW4ocGVlcik7XG4gICAgICAgIHNlbGYudXBkYXRlU3RhdGUoKTtcbiAgICB9KTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBmdW5jdGlvbihyZWNlaXZlZE1lc3NhZ2Upe1xuICAgICAgICBzZWxmLnJlY2VpdmUoc29ja2V0LCByZWNlaXZlZE1lc3NhZ2UpO1xuICAgIH0pO1xuICAgIHNvY2tldC5vbignc3RyZWFtJywgZnVuY3Rpb24oc3RyZWFtKXtcbiAgICAgICAgc2VsZi5lbWl0KCdzdHJlYW0nLCBzb2NrZXQsIHN0cmVhbSk7XG4gICAgfSk7XG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBhIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkJyk7XG4gICAgICAgIHNlbGYudXBkYXRlU3RhdGUoKTtcbiAgICB9KTtcbiAgICBzb2NrZXQuc2lnbmFsKHRpY2tldCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTcHJheSdzIHByb3RvY29sIGltcGxlbWVudGF0aW9uXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiFcbiAqIFxcYnJpZWYgam9pbiB0aGUgbmV0d29yayB1c2luZyB0aGUga3dub24gY29udGFjdCBwZWVyIFxuICogXFxwYXJhbSBjb250YWN0IHRoZSBrbm93biBwZWVyIHRoYXQgd2lsbCBpbnRyb2R1Y2UgdXMgdG8gdGhlIG5ldHdvcmtcbiAqL1xuU3ByYXkucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbihjb250YWN0KXtcbiAgICAvLyAjQSBhc2sgdG8gdGhlIGNvbnRhY3QgcGVlciB0byBhZHZlcnRpc2UgeW91ciBwcmVzZW5jZSBpbiB0aGUgbmV0d29ya1xuICAgIHZhciBtZXNzYWdlID0gbmV3IE1Kb2luKEdVSUQoKSk7XG4gICAgdGhpcy5zZW5kKG1lc3NhZ2UsIGNvbnRhY3QpO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGV2ZW50IGV4ZWN1dGVyIHdoZW4gXCJ0aGlzXCIgcmVjZWl2ZXMgYSBqb2luIG1lc3NhZ2VcbiAqIFxccGFyYW0gaWQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIHJlcXVlc3RcbiAqL1xuU3ByYXkucHJvdG90eXBlLm9uSm9pbiA9IGZ1bmN0aW9uKGlkKXtcbiAgICAvLyAjQSBpZiBpdCBpcyB0aGUgdmVyeSBmaXJzdCBjb25uZWN0aW9uLCBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIGZyb21cbiAgICAvLyB1cyB0byB0aGUgbmV3Y29tZXJcbiAgICBpZiAodGhpcy5wYXJ0aWFsVmlldy5sZW5ndGgoKT09PTApe1xuICAgICAgICB2YXIgbVJlcXVlc3RUaWNrZXQgPSBuZXcgTVJlcXVlc3RUaWNrZXQoR1VJRCgpKTtcbiAgICAgICAgdGhpcy5zZW5kKG1SZXF1ZXN0VGlja2V0LCB7aWQ6aWR9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyAjQiBpZiB0aGVyZSBpcyBhbiBhbHJlYWR5IGVzdGFibGlzaGVkIG5ldHdvcmssIHdlIHJlcXVlc3QgdGhhdFxuICAgICAgICAvLyB0aGUgbmV3Y29tZXIgc2VuZHMgdXMgYW4gb2ZmZXIgdGlja2V0IGZvciBlYWNoIG9mIG91ciBuZWlnaGJvcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcnRpYWxWaWV3Lmxlbmd0aCgpOyArK2kpe1xuICAgICAgICAgICAgLy8gIzEgY3JlYXRlIHRoZSB0aWNrZXQgd2l0aCBhbiBvcmlnaW5hbCBpZGVudGlmaWVyXG4gICAgICAgICAgICB2YXIgbVJlcXVlc3RUaWNrZXQgPSBuZXcgTVJlcXVlc3RUaWNrZXQoR1VJRCgpKTtcbiAgICAgICAgICAgIC8vICMyIHJlZ2lzdGVyIHRoZSBmb3J3YXJkaW5nIHJvdXRlIGZvciB0aGUgYW5zd2Vyc1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkcy5hZGRTb2NrZXQoXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmdldFNvY2tldCh0aGlzLnBhcnRpYWxWaWV3LmFycmF5LmFycltpXSksXG4gICAgICAgICAgICAgICAgbVJlcXVlc3RUaWNrZXQpO1xuICAgICAgICAgICAgLy8gIzMgc2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgbmV3IGNvbWVyXG4gICAgICAgICAgICB0aGlzLnNlbmQobVJlcXVlc3RUaWNrZXQsIHtpZDppZH0pO1xuICAgICAgICB9O1xuICAgIH07XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgcGVyaW9kaWNhbGx5IGNhbGxlZCBmdW5jdGlvbiB0aGF0IGFpbXMgdG8gYmFsYW5jZSB0aGUgcGFydGlhbCB2aWV3XG4gKiBhbmQgdG8gbWl4IHRoZSBuZWlnaGJvcnMgaW5zaWRlIHRoZW1cbiAqL1xuU3ByYXkucHJvdG90eXBlLmV4Y2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNvY2tldE9sZGVzdCA9IG51bGw7XG4gICAgLy8gIzEgZ2V0IHRoZSBvbGRlc3QgbmVpZ2hib3IgcmVhY2hhYmxlXG4gICAgd2hpbGUgKChzb2NrZXRPbGRlc3Q9PT1udWxsKSB8fFxuICAgICAgICAgICAoc29ja2V0T2xkZXN0IT09bnVsbCAmJiAhc29ja2V0T2xkZXN0LmNvbm5lY3RlZCkgJiZcbiAgICAgICAgICAgdGhpcy5wYXJ0aWFsVmlldy5sZW5ndGgoKT4wKXtcbiAgICAgICAgdmFyIG9sZGVzdCA9IHRoaXMucGFydGlhbFZpZXcuZ2V0T2xkZXN0KCk7XG4gICAgICAgIHNvY2tldE9sZGVzdCA9IHRoaXMuc29ja2V0cy5nZXRTb2NrZXQob2xkZXN0KTtcbiAgICAgICAgaWYgKHNvY2tldE9sZGVzdD09PW51bGwgfHxcbiAgICAgICAgICAgIChzb2NrZXRPbGRlc3QhPT1udWxsICYmICFzb2NrZXRPbGRlc3QuY29ubmVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5vblBlZXJEb3duKG9sZGVzdCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpZiAodGhpcy5wYXJ0aWFsVmlldy5sZW5ndGgoKT09PTApe3JldHVybjt9OyAvLyB1Z2x5IHJldHVyblxuICAgIC8vICMyIG5vdGlmeSB0aGUgb2xkZXN0IG5laWdoYm9yIHRoYXQgaXQgaXMgdGhlIGNob3NlbiBvbmVcbiAgICB2YXIgbUV4Y2hhbmdlID0gbmV3IE1FeGNoYW5nZShHVUlEKCksIHtpZDp0aGlzLklEfSk7XG4gICAgdGhpcy5zZW5kKG1FeGNoYW5nZSwgb2xkZXN0KTtcbiAgICAvLyAjMyBnZXQgYSBzYW1wbGUgZnJvbSBvdXIgcGFydGlhbCB2aWV3XG4gICAgdmFyIHNhbXBsZSA9IHRoaXMucGFydGlhbFZpZXcuZ2V0U2FtcGxlKG9sZGVzdCwgdHJ1ZSk7XG4gICAgLy8gIzQgYXNrIHRvIHRoZSBuZWlnaGJvcnMgaW4gdGhlIHNhbXBsZSB0byBjcmVhdGUgdGhlIG9mZmVyIHRpY2tldHMgaW5cbiAgICAvLyBvcmRlciB0byBmb3J3YXJkIHRoZW0gdG8gdGhlIG9sZGVzdCBuZWlnaGJvclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaWYgKHNhbXBsZVtpXS5pZCAhPT0gb2xkZXN0LmlkKXtcbiAgICAgICAgICAgIC8vICM1IGlmIHRoZSBuZWlnaGJvciBpcyBub3QgdGhlIG9sZGVzdCBuZWlnaGJvclxuICAgICAgICAgICAgLy8gIzVBIHJlZ2lzdGVyIHRoZSBmb3J3YXJkaW5nIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBNUmVxdWVzdFRpY2tldChHVUlEKCkpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkcy5hZGRTb2NrZXQodGhpcy5zb2NrZXRzLmdldFNvY2tldChvbGRlc3QpLG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gIzVCIHNlbmQgYSB0aWNrZXQgcmVxdWVzdCB0byB0aGUgbmVpZ2hib3IgaW4gdGhlIHNhbXBsZVxuICAgICAgICAgICAgdGhpcy5zZW5kKG1lc3NhZ2UsIHNhbXBsZVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAjNiBvdGhlcndpc2UsIGNyZWF0ZSBhbiBvZmZlciB0aWNrZXQgb3Vyc2VsZiBhbmQgc2VuZCBpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIG9sZGVzdCBuZWlnYmhvclxuICAgICAgICAgICAgdmFyIGlkVGlja2V0ID0gR1VJRCgpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkcy5hZGRTb2NrZXQodGhpcy5zb2NrZXRzLmdldFNvY2tldChvbGRlc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lkOmlkVGlja2V0fSk7XG4gICAgICAgICAgICB0aGlzLm9uVGlja2V0UmVxdWVzdChpZFRpY2tldCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyAjNyByZW1vdmUgdGhlIHNlbnQgc2FtcGxlIGZyb20gb3VyIHBhcnRpYWwgdmlld1xuICAgIHRoaXMucGFydGlhbFZpZXcucmVtb3ZlU2FtcGxlKHNhbXBsZSk7XG4gICAgLy8gIzggcmVtb3ZlIGZyb20gdGhlIHNvY2tldHMgZGljdGlvbm5hcnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZS5sZW5ndGg7ICsraSl7XG4gICAgICAgIC8vICM4QSBjaGVjayBpZiB0aGUgcGFydGlhbCB2aWV3IHN0aWxsIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gdGhlIHNvY2tldFxuICAgICAgICBpZiAoIXRoaXMucGFydGlhbFZpZXcuY29udGFpbnMoc2FtcGxlW2ldKSl7XG4gICAgICAgICAgICAvLyAjOEIgb3RoZXJ3aXNlIHJlbW92ZSB0aGUgc29ja2V0IGZyb20gdGhlIGRpY3Rpb25uYXJ5XG4gICAgICAgICAgICB2YXIgc29ja2V0ID0gdGhpcy5zb2NrZXRzLnJlbW92ZVNvY2tldChzYW1wbGVbaV0pO1xuICAgICAgICAgICAgLy8gIzhDIGNsb3NlIHRoZSBzb2NrZXQgYWZ0ZXIgYSB3aGlsZVxuICAgICAgICAgICAgaWYgKHNvY2tldCE9PW51bGwpe1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24ocyl7XG4gICAgICAgICAgICAgICAgICAgIHMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuVElNRU9VVCwgc29ja2V0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTsgICAgXG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgZXZlbnQgZXhlY3V0ZWQgd2hlbiB3ZSByZWNlaXZlIGFuIGV4Y2hhbmdlIHJlcXVlc3RcbiAqIFxccGFyYW0gaWQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIHJlcXVlc3QgbWVzc2FnZVxuICogXFxwYXJhbSBpbml0aWF0b3IgdGhlIHBlZXIgdGhhdCByZXF1ZXN0ZWQgdGhlIGV4Y2hhbmdlXG4gKi9cblNwcmF5LnByb3RvdHlwZS5vbkV4Y2hhbmdlID0gZnVuY3Rpb24oaWQsIGluaXRpYXRvcil7XG4gICAgLy8gIzEgZ2V0IGEgc2FtcGxlIG9mIG5laWdoYm9ycyBmcm9tIG91ciBwYXJ0aWFsIHZpZXdcbiAgICB2YXIgc2FtcGxlID0gdGhpcy5wYXJ0aWFsVmlldy5nZXRTYW1wbGUoaW5pdGlhdG9yLCBmYWxzZSk7XG4gICAgLy8gIzIgYXNrIHRvIGVhY2ggbmVpZ2hib3IgaW4gdGhlIHNhbXBsZSB0byBjcmVhdGUgYW4gb2ZmZXIgdGlja2V0IHRvXG4gICAgLy8gZ2l2ZSB0byB0aGUgaW5pdGlhdG9yIHBlZXJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZS5sZW5ndGg7ICsraSl7XG4gICAgICAgIGlmIChzYW1wbGVbaV0uaWQgIT09IGluaXRpYXRvci5pZCl7XG4gICAgICAgICAgICAvLyAjMkEgaWYgdGhlIG5laWdiaG9yIGlzIG5vdCB0aGUgaW5pdGlhdG9yLCByZXF1ZXN0IGFuIG9mZmVyIHRpY2tldFxuICAgICAgICAgICAgLy8gZnJvbSBpdFxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgTVJlcXVlc3RUaWNrZXQoR1VJRCgpKTtcbiAgICAgICAgICAgIC8vICMyQiByZWdpc3RlciB0aGUgZm9yd2FyZGluZyByb3V0ZVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkcy5hZGRTb2NrZXQodGhpcy5mb3J3YXJkcy5nZXRTb2NrZXQoe2lkOmlkfSksIG1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gIzJDIHNlbmQgdGhlIHRpY2tldCByZXF1ZXN0IHRvIHRoZSBuZWlnYmhvclxuICAgICAgICAgICAgdGhpcy5zZW5kKG1lc3NhZ2UsIHNhbXBsZVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAjM0EgaWYgdGhlIG5laWdiaG9yIGlzIHRoZSBpbml0aWF0b3IsIGNyZWF0ZSBhbiBvZmZlciB0aWNrZXRcbiAgICAgICAgICAgIC8vIG91cnNlbGYgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpZFRpY2tldCA9IEdVSUQoKTtcbiAgICAgICAgICAgIC8vICMzQiByZWdpc3RlciB0aGUgZm9yd2FyZGluZyByb3V0ZSBmb3Igb3VyIG93biBvZmZlciB0aWNrZXRcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZHMuYWRkU29ja2V0KHRoaXMuZm9yd2FyZHMuZ2V0U29ja2V0KHtpZDppZH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lkOmlkVGlja2V0fSk7XG4gICAgICAgICAgICAvLyAjM0MgY3JlYXRlIHRoZSBvZmZlciB0aWNrZXQgYW5kIHNlbmQgaXRcbiAgICAgICAgICAgIHRoaXMub25UaWNrZXRSZXF1ZXN0KGlkVGlja2V0KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vICM0IHJlbW92ZSB0aGUgc2FtcGxlIGZyb20gb3VyIHBhcnRpYWwgdmlld1xuICAgIHRoaXMucGFydGlhbFZpZXcucmVtb3ZlU2FtcGxlKHNhbXBsZSk7XG4gICAgLy8gIzUgcmVtb3ZlIHRoZSBzYW1wbGUgZnJvbSB0aGUgc29ja2V0cyBkaWN0aW9ubmFyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlLmxlbmd0aDsgKytpKXtcbiAgICAgICAgLy8gIzVBIGNoZWNrIGlmIHRoZSBwYXJ0aWFsIHZpZXcgc3RpbGwgY29udGFpbnMgcmVmZXJlbmNlcyB0byB0aGUgc29ja2V0XG4gICAgICAgIGlmICghdGhpcy5wYXJ0aWFsVmlldy5jb250YWlucyhzYW1wbGVbaV0pKXtcbiAgICAgICAgICAgIC8vICM1QiBvdGhlcndpc2UgcmVtb3ZlIHRoZSBzb2NrZXQgZnJvbSB0aGUgZGljdGlvbm5hcnlcbiAgICAgICAgICAgIHZhciBzb2NrZXQgPSB0aGlzLnNvY2tldHMucmVtb3ZlU29ja2V0KHNhbXBsZVtpXSlcbiAgICAgICAgICAgIC8vICM1QyBjbG9zZSB0aGUgc29ja2V0IGFmdGVyIGEgd2hpbGVcbiAgICAgICAgICAgIGlmIChzb2NrZXQhPT1udWxsKXtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKHMpe1xuICAgICAgICAgICAgICAgICAgICBzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLlRJTUVPVVQsIHNvY2tldCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH07XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgbmVpZ2hib3IgaXMgdW5yZWFjaGFibGUgYW5kIHN1cHBvc2VkbHlcbiAqIGNyYXNoZWQvZGVwYXJ0ZWQuIEl0IHByb2JhYmlsaXN0aWNhbGx5IGtlZXBzIGFuIGFyYyB1cFxuICogXFxwYXJhbSBwZWVyIHRoZSBwZWVyIHRoYXQgY2Fubm90IGJlIHJlYWNoZWRcbiAqL1xuU3ByYXkucHJvdG90eXBlLm9uUGVlckRvd24gPSBmdW5jdGlvbihwZWVyKXtcbiAgICBjb25zb2xlLmxvZygnd3J0YzogYSBuZWlnaGJvciBjcmFzaGVkL2xlZnQnKTtcbiAgICAvLyAjQSByZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIHRoZSBwZWVyIGluIHRoZSBwYXJ0aWFsIHZpZXdcbiAgICB2YXIgb2NjID0gdGhpcy5wYXJ0aWFsVmlldy5yZW1vdmVBbGwocGVlcik7XG4gICAgdGhpcy5zb2NrZXRzLnJlbW92ZVNvY2tldChwZWVyKTtcbiAgICAvLyAjQiBwcm9iYWJpbGlzdGljYWxseSByZWNyZWF0ZSBhbiBhcmMgdG8gYSBrbm93biBwZWVyXG4gICAgaWYgKHRoaXMucGFydGlhbFZpZXcubGVuZ3RoKCkgPiAwKXtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvY2M7ICsraSl7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+ICgxLyh0aGlzLnBhcnRpYWxWaWV3Lmxlbmd0aCgpK29jYykpKXtcbiAgICAgICAgICAgICAgICB2YXIgcm4gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdGhpcy5wYXJ0aWFsVmlldy5sZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsVmlldy5hZGROZWlnaGJvcih0aGlzLnBhcnRpYWxWaWV3LmFycmF5LmFycltybl0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBjcmVhdGUgYSBkdXBsaWNhdGUnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgYSBjb25uZWN0aW9uIGZhaWxlZCB0byBlc3RhYmxpc2ggcHJvcGVybHksIHN5c3RlbWF0aWNhbGx5IGR1cGxpY2F0ZXNcbiAqIGFuIGVsZW1lbnQgb2YgdGhlIHBhcnRpYWwgdmlldy5cbiAqL1xuU3ByYXkucHJvdG90eXBlLm9uQXJjRG93biA9IGZ1bmN0aW9uKCl7XG4gICAgY29uc29sZS5sb2coJ3dydGM6IGFuIGFyYyBkaWQgbm90IHByb3Blcmx5IGVzdGFibGlzaGVkJyk7XG4gICAgaWYgKHRoaXMucGFydGlhbFZpZXcubGVuZ3RoKCk+MCl7XG4gICAgICAgIHZhciBybiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp0aGlzLnBhcnRpYWxWaWV3Lmxlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsVmlldy5hZGROZWlnaGJvcih0aGlzLnBhcnRpYWxWaWV3LmFycmF5LmFycltybl0pO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIFdlYlJUQyBzcGVjaWZpYyBldmVudC4gQSBuZWlnaGJvciB3YW50cyB1cyB0byBjb25uZWN0IHRvIGFub3RoZXIgcGVlci5cbiAqIFRvIGRvIHNvLCB0aGUgZm9ybWVyIHJlcXVlc3RzIGFuIG9mZmVyIHRpY2tldCBpdCBjYW4gZXhjaGFuZ2Ugd2l0aCBvbmUgb2ZcbiAqIGl0cyBuZWlnaGJvci5cbiAqIFxccGFyYW0gcGVlciB0aGUgaWRlbnRpZmllciBvZiB0aGUgcmVxdWVzdCBtZXNzYWdlXG4gKi9cblNwcmF5LnByb3RvdHlwZS5vblRpY2tldFJlcXVlc3QgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIG9wdGlvbnM9dGhpcy5PUFRJT05TOyBvcHRpb25zLmluaXRpYXRvcj10cnVlOyBvcHRpb25zLnRyaWNrbGU9ZmFsc2U7XG4gICAgdmFyIHNvY2tldCA9IG5ldyBTb2NrZXQob3B0aW9ucyksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgIC8vICMxIGdldCB0aGUgb2ZmZXIgdGlja2V0IGZyb20gdGhlIHN0dW4gc2VydmljZSAgICBcbiAgICBzb2NrZXQub24oJ3NpZ25hbCcsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAvLyAjQSByZWdpc3RlciB0aGlzIHNvY2tldCBpbiBwZW5kaW5nIHNvY2tldHMgZGljdGlvbm5hcnlcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgTU9mZmVyVGlja2V0KGlkLCBkYXRhLCB7aWQ6IHNlbGYuSUR9KTtcbiAgICAgICAgc2VsZi5wZW5kaW5nLmFkZFNvY2tldChzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICAvLyAjQiBzZW5kIHRoZSBvZmZlciB0aWNrZXQgdG8gdGhlIHJlcXVlc3RlciBhbG9uZyB3aXRoIG91ciBpZGVudGlmaWVyXG4gICAgICAgIHNlbGYuc2VuZChtZXNzYWdlLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gI0MgcmVtb3ZlIHRoZSBmb3J3YXJkaW5nIHJvdXRlIFxuICAgICAgICBzZWxmLmZvcndhcmRzLnJlbW92ZVNvY2tldChtZXNzYWdlKTtcbiAgICB9KTtcbiAgICAvLyAjMiBzdWNjZXNzZnVsIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudFxuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBzdWNjZXNzZnVsIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCcpO1xuICAgICAgICAvLyAjQSByZW1vdmUgZnJvbSB0aGUgcGVuZGluZyBzb2NrZXRzIGRpY3Rpb25uYXJ5XG4gICAgICAgIHNlbGYucGVuZGluZy5yZW1vdmVTb2NrZXQoe2lkOmlkfSk7XG4gICAgICAgIHNlbGYuaW5WaWV3LmFkZChzb2NrZXQsIGlkKTtcbiAgICAgICAgc2VsZi51cGRhdGVTdGF0ZSgpO1xuICAgIH0pO1xuICAgIC8vICMzIGNsb3NlZCBjb25uZWN0aW9uXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBhIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkJyk7XG4gICAgICAgIHNlbGYuaW5WaWV3LnJlbW92ZShpZCk7XG4gICAgICAgIHNlbGYudXBkYXRlU3RhdGUoKTtcbiAgICB9KTtcbiAgICAvLyAjNCByZWNlaXZlIGEgbWVzc2FnZVxuICAgIHNvY2tldC5vbignZGF0YScsIGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgICAgICBzZWxmLnJlY2VpdmUoc29ja2V0LCBtZXNzYWdlKTtcbiAgICB9KTtcbiAgICBzb2NrZXQub24oJ3N0cmVhbScsIGZ1bmN0aW9uKHN0cmVhbSl7XG4gICAgICAgIHNlbGYuZW1pdCgnc3RyZWFtJywgc29ja2V0LCBzdHJlYW0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vICM1IHRpbWVvdXQgb24gY29ubmVjdGlvbiBlc3RhYmxpc2htZW50XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAvLyAjQSBjaGVjayBpZiBpdCB0aGUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCwgb3RoZXJ3aXNlLCBjbGVhbiBzb2NrZXRcbiAgICAgICAgaWYgKHNlbGYucGVuZGluZy5jb250YWlucyh7aWQ6aWR9KSl7XG4gICAgICAgICAgICBzZWxmLnBlbmRpbmcucmVtb3ZlU29ja2V0KHtpZDppZH0pO1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICB9LCB0aGlzLlRJTUVPVVQpO1xufTtcblxuLyohXG4gKiBcXGJyaWVmIFdlYlJUQyBzcGVjaWZpYyBldmVudC4gQSBuZWlnaGJvciBzZW50IGEgdGlja2V0IHRvIHN0YW1wLiBXZSBtdXN0XG4gKiBzdGFtcCBpdCBiYWNrIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24uXG4gKiBcXHBhcmFtIGlkIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBtZXNzYWdlIGNhcnJ5aW5nIHRoZSBvZmZlciB0aWNrZXRcbiAqIFxccGFyYW0gdGlja2V0IHRoZSBvZmZlciB0aWNrZXQgdG8gc3RhbXBcbiAqIFxccGFyYW0gcGVlciB0aGUgZW1pdHRpbmcgcGVlciBjb250YWluaW5nIGl0cyBpZGVudGlmaWVyXG4gKi9cblNwcmF5LnByb3RvdHlwZS5vblN0YW1wZWRUaWNrZXRSZXF1ZXN0ID0gZnVuY3Rpb24oaWQsIHRpY2tldCwgcGVlcil7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vICMxIGlmIHRoZSBwYXJ0aWFsIHZpZXcgYWxyZWFkeSBjb250YWlucyB0aGlzIG5laWdiaG9yLCBkdXBsaWNhdGUgdGhlXG4gICAgLy8gZW50cnkgYW5kIHN0b3AgdGhlIHByb2Nlc3N1c1xuICAgIGlmICh0aGlzLnBhcnRpYWxWaWV3LmNvbnRhaW5zKHBlZXIpKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJ3cnRjOiBjcmVhdGUgYSBkdXBsaWNhdGVcIik7XG4gICAgICAgIHRoaXMucGFydGlhbFZpZXcuYWRkTmVpZ2hib3IocGVlcik7XG4gICAgICAgIC8vICMyIHNlbmQgYW4gZW1wdHkgc3RhbXBlZCB0aWNrZXQgdG8gY2xvc2UgdGhlIHBlbmRpbmcgYW5kIGZvcndhcmRpbmdzXG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IE1TdGFtcGVkVGlja2V0KGlkLCBudWxsLCB7aWQ6c2VsZi5JRH0pO1xuICAgICAgICBzZWxmLnNlbmQobWVzc2FnZSwgbWVzc2FnZSk7XG4gICAgICAgIHNlbGYuZm9yd2FyZHMucmVtb3ZlU29ja2V0KHtpZDppZH0pO1xuICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgZWxzZS4gVWdseSByZXR1cm5cbiAgICB9O1xuICAgIC8vICMyIG90aGVyd2lzZSBjcmVhdGVzIGFuIGFuc3dlclxuICAgIHZhciBvcHRpb25zPXRoaXMuT1BUSU9OUzsgb3B0aW9ucy5pbml0aWF0b3I9ZmFsc2U7IG9wdGlvbnMudHJpY2tsZT1mYWxzZTtcbiAgICB2YXIgc29ja2V0ID0gbmV3IFNvY2tldChvcHRpb25zKTtcbiAgICAvLyAjMyBnZXQgdGhlIHN0YW1wZWQgdGlja2V0IGZyb20gdGhlIHN0dW4gc2VydmljZVxuICAgIHNvY2tldC5vbignc2lnbmFsJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIC8vICNBIGNyZWF0ZSB0aGUgbWVzc2FnZSBjb250YWluaW5nIHRoZSBzdGFtcGVkIHRpY2tldFxuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBNU3RhbXBlZFRpY2tldChpZCwgZGF0YSwge2lkOnNlbGYuSUR9KTtcbiAgICAgICAgLy8gI0Igc2VuZCBpdCBiYWNrIGZyb20gd2hlcmUgaXQgYXJyaXZlc1xuICAgICAgICBzZWxmLnNlbmQobWVzc2FnZSwgbWVzc2FnZSk7XG4gICAgICAgIC8vICNDIHJlbW92ZSB0aGUgZm9yd2FyZGluZyByb3V0ZVxuICAgICAgICBzZWxmLmZvcndhcmRzLnJlbW92ZVNvY2tldChtZXNzYWdlKTtcbiAgICB9KTtcbiAgICAvLyAjNCBzdWNjZXNzZnVsIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudFxuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBzdWNjZXNzZnVsIGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCcpO1xuICAgICAgICAvLyAjQSByZW1vdmUgZnJvbSBwZW5kaW5nXG4gICAgICAgIHNlbGYucGVuZGluZy5yZW1vdmVTb2NrZXQoe2lkOmlkfSk7ICAgICAgICBcbiAgICAgICAgLy8gI0IgYWRkIHRoZSBuZWlnYmhvciB0byBvdXIgcGFydGlhbCB2aWV3XG4gICAgICAgIHNlbGYucGFydGlhbFZpZXcuYWRkTmVpZ2hib3IocGVlcik7XG4gICAgICAgIC8vICNDIGFkZCB0aGUgbmVpZ2Job3IgdG8gdGhlIHNvY2tldCBkaWN0aW9ubmFyeSwgaWYgaXQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKCFzZWxmLnNvY2tldHMuYWRkU29ja2V0KHNvY2tldCwgcGVlcikpe1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi51cGRhdGVTdGF0ZSgpO1xuICAgIH0pO1xuICAgIC8vICM1IGNsb3NlZCBjb25uZWN0aW9uXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBhIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkJyk7XG4gICAgICAgIHNlbGYudXBkYXRlU3RhdGUoKTtcbiAgICB9KTtcbiAgICAvLyAjNiByZWNlaXZlIGEgbWVzc2FnZVxuICAgIHNvY2tldC5vbignZGF0YScsIGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgICAgICBzZWxmLnJlY2VpdmUoc29ja2V0LCBtZXNzYWdlKTtcbiAgICB9KTtcbiAgICBzb2NrZXQub24oJ3N0cmVhbScsIGZ1bmN0aW9uKHN0cmVhbSl7XG4gICAgICAgIHNlbGYuZW1pdCgnc3RyZWFtJywgc29ja2V0LCBzdHJlYW0pO1xuICAgIH0pO1xuICAgIC8vICM3IHNpZ25hbCB0aGUgb2ZmZXIgdGlja2V0IHRvIHRoZSBmcmVzaCBzb2NrZXRcbiAgICBzb2NrZXQuc2lnbmFsKHRpY2tldCk7XG4gICAgdGhpcy5wZW5kaW5nLmFkZFNvY2tldChzb2NrZXQsIHtpZDppZH0pO1xuICAgIC8vICM4IGEgdGltZW91dCBvbiBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnRcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChzZWxmLnBlbmRpbmcuY29udGFpbnMoe2lkOmlkfSkpe1xuICAgICAgICAgICAgLy8gI0EgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IHN1Y2Nlc3NmdWwsIHJlbW92ZSB0aGUgc29ja2V0IGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgZHVwbGljYXRlXG4gICAgICAgICAgICBzZWxmLnBlbmRpbmcucmVtb3ZlU29ja2V0KHtpZDppZH0pO1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHNlbGYub25BcmNEb3duKCk7XG4gICAgICAgIH07XG4gICAgfSwgdGhpcy5USU1FT1VUKTtcbn07XG5cbi8qIVxuICogXFxicmllZiBzZW5kIGEgbWVzc2FnZSB0byBhIHBhcnRpY3VsYXIgcGVlci4gSWYgbm8gcGVlciBhcmUgcGFzc2VkIGluXG4gKiBhcmd1bWVudHMsIGl0IHdpbGwgdHJ5IHRvIGZvcndhcmRzIGl0IHRoZSBhcHByb3ByaWF0ZSBwZWVyLlxuICogXFxwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIHNlbmRcbiAqIFxccGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgaWQgdG8gc2VuZCB0aGUgbWVzc2FnZVxuICogXFxwYXJhbSByZXR1cm4gdHJ1ZSBpZiB0aGUgbWVzc2FnZSBhcyBiZWVuIHNlbnQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5TcHJheS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG9iamVjdCl7XG4gICAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgICB2YXIgaWQgPSAob2JqZWN0ICYmIG9iamVjdC5pZCkgfHwgbWVzc2FnZS5pZDtcbiAgICB2YXIgc29ja2V0ID0gdGhpcy5zb2NrZXRzLmdldFNvY2tldCh7aWQ6aWR9KTtcbiAgICBpZiAoc29ja2V0ICE9PSBudWxsKXtcbiAgICAgICAgaWYgKHNvY2tldC5jb25uZWN0ZWQgJiZcbiAgICAgICAgICAgIHNvY2tldC5fY2hhbm5lbCAmJiBzb2NrZXQuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKXtcbiAgICAgICAgICAgIHNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuICAgICAgICAgICAgc2VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uUGVlckRvd24oe2lkOmlkfSk7ICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0ID0gdGhpcy5mb3J3YXJkcy5nZXRTb2NrZXQoe2lkOmlkfSk7XG4gICAgICAgIGlmIChzb2NrZXQgIT09IG51bGwgJiYgc29ja2V0LmNvbm5lY3RlZCAmJlxuICAgICAgICAgICAgc29ja2V0Ll9jaGFubmVsICYmIHNvY2tldC5fY2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3Blbicpe1xuICAgICAgICAgICAgc29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBzZW50O1xufTtcblxuLyohXG4gKiBcXGJyaWVmIHJlY2VpdmUgYSBtZW1iZXJzaGlwIG1lc3NhZ2UgYW5kIHByb2Nlc3MgaXQgYWNjb3JkaW5nbHlcbiAqIFxccGFyYW0gc29ja2V0IHRoZSBzb2NrZXQgZnJvbSB3aGljaCB3ZSByZWNlaXZlIHRoZSBtZXNzYWdlXG4gKiBcXHBhcmFtIG1lc3NhZ2UgdGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqL1xuU3ByYXkucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbihzb2NrZXQsIG1lc3NhZ2Upe1xuICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UucHJvdG9jb2wpe1xuICAgICAgICB0aGlzLmVtaXQobWVzc2FnZS5wcm90b2NvbCsnLXJlY2VpdmUnLCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgIH07XG59O1xuXG5TcHJheS5wcm90b3R5cGUub25TcHJheVJlY2VpdmUgPSBmdW5jdGlvbihzb2NrZXQsIG1lc3NhZ2Upe1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKXtcbiAgICBjYXNlICdNSm9pbic6XG4gICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBhIG5ldyBtZW1iZXIgam9pbnMgdGhlIG5ldHdvcmsnKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLmZvcndhcmRzLmFkZFNvY2tldChzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgc2VsZi5vbkpvaW4obWVzc2FnZS5pZCk7XG4gICAgICAgICAgICBzZWxmLmZvcndhcmRzLnJlbW92ZVNvY2tldChtZXNzYWdlKTtcbiAgICAgICAgfSwgMTAwMCk7IC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBzb2NrZXQgaXMgdW5kb3VidGVkbHkgb3BlbmVkXG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ01SZXF1ZXN0VGlja2V0JzpcbiAgICAgICAgY29uc29sZS5sb2coJ3dydGM6IGEgbWVtYmVyIHJlcXVlc3QgYW4gb2ZmZXIgdGlja2V0Jyk7XG4gICAgICAgIHRoaXMuZm9yd2FyZHMuYWRkU29ja2V0KHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMub25UaWNrZXRSZXF1ZXN0KG1lc3NhZ2UuaWQpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdNT2ZmZXJUaWNrZXQnOlxuICAgICAgICBjb25zb2xlLmxvZygnd3J0YzogeW91IHJlY2VpdmVkIGFuIG9mZmVyIHRpY2tldCcpO1xuICAgICAgICBpZiAoIXRoaXMuZm9yd2FyZHMuY29udGFpbnMobWVzc2FnZSkpe1xuICAgICAgICAgICAgLy8gIzEgaWYgdGhlcmUgaXMgbm8gZm9yd2FyZGluZyByb3V0ZSwgdGhlIG9mZmVyIHRpY2tldCBpcyBmb3IgdXMgdG9cbiAgICAgICAgICAgIC8vIHN0YW1wXG4gICAgICAgICAgICB0aGlzLmZvcndhcmRzLmFkZFNvY2tldChzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5vblN0YW1wZWRUaWNrZXRSZXF1ZXN0KG1lc3NhZ2UuaWQsbWVzc2FnZS50aWNrZXQsbWVzc2FnZS5wZWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICMyQSBvdGhlcndpc2UsIHdlIGZvcndhcmQgdGhlIG9mZmVyIHRpY2tldCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VuZChtZXNzYWdlLCBtZXNzYWdlKSl7XG4gICAgICAgICAgICAgICAgLy8gIzJCIGludmVydCB0aGUgZGlyZWN0aW9uIG9mIGZvcndhcmRpbmcgcm91dGUgaW4gb3JkZXIgdG9cbiAgICAgICAgICAgICAgICAvLyBjb25zaXN0ZW50bHkgcmVkaXJlY3QgdGhlIHN0YW1wZWQgdGlja2V0XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkcy5yZW1vdmVTb2NrZXQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkcy5hZGRTb2NrZXQoc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gIzJDIGlmIHRoZSBtZXNzYWdlIGhhcyBub3QgYmVlbiBzZW50LCBzaW1wbHkgcmVtb3ZlIHRoZSByb3V0ZVxuICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZHMucmVtb3ZlU29ja2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTVN0YW1wZWRUaWNrZXQnOlxuICAgICAgICBjb25zb2xlLmxvZygnd3J0YzogeW91IHJlY2VpdmVkIGEgc3RhbXBlZCB0aWNrZXQnKTtcbiAgICAgICAgaWYgKCF0aGlzLmZvcndhcmRzLmNvbnRhaW5zKG1lc3NhZ2UpKXtcbiAgICAgICAgICAgIC8vICMxIGlmIHRoZXJlIGlzIG5vIGZvcndhcmRpbmcgcm91dGUsIHRoZSBtZXNzYWdlIGlzIGZvciB1cyB0b1xuICAgICAgICAgICAgLy8gZmluYWxpemVcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRpY2tldCA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgLy8gIzFBIGVtcHR5IHRpY2tldCBtZWFuaW5nIHRoZSByZW1vdGUgcGVlciBhbHJlYWR5IGtub3dzIHVzLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSwgc2ltcGx5IGNsb3NlIHRoZSBwZW5kaW5nIG9mZmVyXG4gICAgICAgICAgICAgICAgdmFyIHNvY2tldCA9IHRoaXMucGVuZGluZy5yZW1vdmVTb2NrZXQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gIzFCIG90aGVyd2lzZSwgZmluYWxpemUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcuZ2V0U29ja2V0KG1lc3NhZ2UpLnNpZ25hbChtZXNzYWdlLnRpY2tldCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gIzJBIG90aGVyd2lzZSwgd2UgZm9yd2FyZCB0aGUgc3RhbXBlZCB0aWNrZXQgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIHRoaXMuc2VuZChtZXNzYWdlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIC8vICMyQiByZW1vdmUgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBrbm93biBmb3J3YXJkaW5nIHJvdXRlc1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkcy5yZW1vdmVTb2NrZXQobWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ01FeGNoYW5nZSc6XG4gICAgICAgIGNvbnNvbGUubG9nKCd3cnRjOiBhIHBlZXIgc3RhcnRzIHRvIGV4Y2hhbmdlIHdpdGggeW91Jyk7XG4gICAgICAgIHRoaXMuZm9yd2FyZHMuYWRkU29ja2V0KHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMub25FeGNoYW5nZShtZXNzYWdlLmlkLCBtZXNzYWdlLnBlZXIpO1xuICAgICAgICB0aGlzLmZvcndhcmRzLnJlbW92ZVNvY2tldChtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3ByYXk7XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vKiBnbG9iYWwgQmxvYiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlLXBlZXInKVxudmFyIGhhdCA9IHJlcXVpcmUoJ2hhdCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWRhcnJheScpXG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgdG9CdWZmZXIgPSByZXF1aXJlKCd0eXBlZGFycmF5LXRvLWJ1ZmZlcicpXG5cbmluaGVyaXRzKFBlZXIsIHN0cmVhbS5EdXBsZXgpXG5cbi8qKlxuICogV2ViUlRDIHBlZXIgY29ubmVjdGlvbi4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YCwgcGx1cyBhIGZldyBleHRyYSBtZXRob2RzLlxuICogRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIFBlZXIgKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBQZWVyKSkgcmV0dXJuIG5ldyBQZWVyKG9wdHMpXG4gIHNlbGYuX2RlYnVnKCduZXcgcGVlciAlbycsIG9wdHMpXG5cbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgb3B0cy5hbGxvd0hhbGZPcGVuID0gZmFsc2VcbiAgaWYgKG9wdHMuaGlnaFdhdGVyTWFyayA9PSBudWxsKSBvcHRzLmhpZ2hXYXRlck1hcmsgPSAxMDI0ICogMTAyNFxuXG4gIHN0cmVhbS5EdXBsZXguY2FsbChzZWxmLCBvcHRzKVxuXG4gIHNlbGYuaW5pdGlhdG9yID0gb3B0cy5pbml0aWF0b3IgfHwgZmFsc2VcbiAgc2VsZi5jaGFubmVsQ29uZmlnID0gb3B0cy5jaGFubmVsQ29uZmlnIHx8IFBlZXIuY2hhbm5lbENvbmZpZ1xuICBzZWxmLmNoYW5uZWxOYW1lID0gb3B0cy5jaGFubmVsTmFtZSB8fCBoYXQoMTYwKVxuICBpZiAoIW9wdHMuaW5pdGlhdG9yKSBzZWxmLmNoYW5uZWxOYW1lID0gbnVsbFxuICBzZWxmLmNvbmZpZyA9IG9wdHMuY29uZmlnIHx8IFBlZXIuY29uZmlnXG4gIHNlbGYuY29uc3RyYWludHMgPSBvcHRzLmNvbnN0cmFpbnRzIHx8IFBlZXIuY29uc3RyYWludHNcbiAgc2VsZi5yZWNvbm5lY3RUaW1lciA9IG9wdHMucmVjb25uZWN0VGltZXIgfHwgMFxuICBzZWxmLnNkcFRyYW5zZm9ybSA9IG9wdHMuc2RwVHJhbnNmb3JtIHx8IGZ1bmN0aW9uIChzZHApIHsgcmV0dXJuIHNkcCB9XG4gIHNlbGYuc3RyZWFtID0gb3B0cy5zdHJlYW0gfHwgZmFsc2VcbiAgc2VsZi50cmlja2xlID0gb3B0cy50cmlja2xlICE9PSB1bmRlZmluZWQgPyBvcHRzLnRyaWNrbGUgOiB0cnVlXG5cbiAgc2VsZi5kZXN0cm95ZWQgPSBmYWxzZVxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgLy8gc28gUGVlciBvYmplY3QgYWx3YXlzIGhhcyBzYW1lIHNoYXBlIChWOCBvcHRpbWl6YXRpb24pXG4gIHNlbGYucmVtb3RlQWRkcmVzcyA9IHVuZGVmaW5lZFxuICBzZWxmLnJlbW90ZUZhbWlseSA9IHVuZGVmaW5lZFxuICBzZWxmLnJlbW90ZVBvcnQgPSB1bmRlZmluZWRcbiAgc2VsZi5sb2NhbEFkZHJlc3MgPSB1bmRlZmluZWRcbiAgc2VsZi5sb2NhbFBvcnQgPSB1bmRlZmluZWRcblxuICBzZWxmLl93cnRjID0gb3B0cy53cnRjIHx8IGdldEJyb3dzZXJSVEMoKVxuICBpZiAoIXNlbGYuX3dydGMpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IFNwZWNpZnkgYG9wdHMud3J0Y2Agb3B0aW9uIGluIHRoaXMgZW52aXJvbm1lbnQnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBOb3QgYSBzdXBwb3J0ZWQgYnJvd3NlcicpXG4gICAgfVxuICB9XG5cbiAgc2VsZi5fbWF4QnVmZmVyZWRBbW91bnQgPSBvcHRzLmhpZ2hXYXRlck1hcmtcbiAgc2VsZi5fcGNSZWFkeSA9IGZhbHNlXG4gIHNlbGYuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG4gIHNlbGYuX2ljZUNvbXBsZXRlID0gZmFsc2UgLy8gaWNlIGNhbmRpZGF0ZSB0cmlja2xlIGRvbmUgKGdvdCBudWxsIGNhbmRpZGF0ZSlcbiAgc2VsZi5fY2hhbm5lbCA9IG51bGxcblxuICBzZWxmLl9jaHVuayA9IG51bGxcbiAgc2VsZi5fY2IgPSBudWxsXG4gIHNlbGYuX2ludGVydmFsID0gbnVsbFxuICBzZWxmLl9yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbFxuXG4gIHNlbGYuX3BjID0gbmV3IChzZWxmLl93cnRjLlJUQ1BlZXJDb25uZWN0aW9uKShzZWxmLmNvbmZpZywgc2VsZi5jb25zdHJhaW50cylcbiAgc2VsZi5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBzZWxmLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZS5iaW5kKHNlbGYpXG4gIHNlbGYuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBzZWxmLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlLmJpbmQoc2VsZilcbiAgc2VsZi5fcGMub25pY2VjYW5kaWRhdGUgPSBzZWxmLl9vbkljZUNhbmRpZGF0ZS5iaW5kKHNlbGYpXG5cbiAgaWYgKHNlbGYuc3RyZWFtKSBzZWxmLl9wYy5hZGRTdHJlYW0oc2VsZi5zdHJlYW0pXG4gIHNlbGYuX3BjLm9uYWRkc3RyZWFtID0gc2VsZi5fb25BZGRTdHJlYW0uYmluZChzZWxmKVxuXG4gIGlmIChzZWxmLmluaXRpYXRvcikge1xuICAgIHNlbGYuX3NldHVwRGF0YSh7IGNoYW5uZWw6IHNlbGYuX3BjLmNyZWF0ZURhdGFDaGFubmVsKHNlbGYuY2hhbm5lbE5hbWUsIHNlbGYuY2hhbm5lbENvbmZpZykgfSlcbiAgICBzZWxmLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gb25jZShzZWxmLl9jcmVhdGVPZmZlci5iaW5kKHNlbGYpKVxuICAgIC8vIE9ubHkgQ2hyb21lIHRyaWdnZXJzIFwibmVnb3RpYXRpb25uZWVkZWRcIjsgdGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIG90aGVyXG4gICAgLy8gaW1wbGVtZW50YXRpb25zXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHNlbGYuX3BjLm9ubmVnb3RpYXRpb25uZWVkZWQoKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9wYy5vbmRhdGFjaGFubmVsID0gc2VsZi5fc2V0dXBEYXRhLmJpbmQoc2VsZilcbiAgfVxuXG4gIHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5jb25uZWN0ZWQpIHtcbiAgICAgIC8vIFdoZW4gbG9jYWwgcGVlciBpcyBmaW5pc2hlZCB3cml0aW5nLCBjbG9zZSBjb25uZWN0aW9uIHRvIHJlbW90ZSBwZWVyLlxuICAgICAgLy8gSGFsZiBvcGVuIGNvbm5lY3Rpb25zIGFyZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cbiAgICAgIC8vIFdhaXQgYSBiaXQgYmVmb3JlIGRlc3Ryb3lpbmcgc28gdGhlIGRhdGFjaGFubmVsIGZsdXNoZXMuXG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kZXN0cm95KClcbiAgICAgIH0sIDEwMClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgZGF0YSBjaGFubmVsIGlzIG5vdCBjb25uZWN0ZWQgd2hlbiBsb2NhbCBwZWVyIGlzIGZpbmlzaGVkIHdyaXRpbmcsIHdhaXQgdW50aWxcbiAgICAgIC8vIGRhdGEgaXMgZmx1c2hlZCB0byBuZXR3b3JrIGF0IFwiY29ubmVjdFwiIGV2ZW50LlxuICAgICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgICBzZWxmLm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgICB9LCAxMDApXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuUGVlci5XRUJSVENfU1VQUE9SVCA9ICEhZ2V0QnJvd3NlclJUQygpXG5cbi8qKlxuICogRXhwb3NlIGNvbmZpZywgY29uc3RyYWludHMsIGFuZCBkYXRhIGNoYW5uZWwgY29uZmlnIGZvciBvdmVycmlkaW5nIGFsbCBQZWVyXG4gKiBpbnN0YW5jZXMuIE90aGVyd2lzZSwganVzdCBzZXQgb3B0cy5jb25maWcsIG9wdHMuY29uc3RyYWludHMsIG9yIG9wdHMuY2hhbm5lbENvbmZpZ1xuICogd2hlbiBjb25zdHJ1Y3RpbmcgYSBQZWVyLlxuICovXG5QZWVyLmNvbmZpZyA9IHtcbiAgaWNlU2VydmVyczogW1xuICAgIHtcbiAgICAgIHVybDogJ3N0dW46MjMuMjEuMTUwLjEyMScsIC8vIGRlcHJlY2F0ZWQsIHJlcGxhY2VkIGJ5IGB1cmxzYFxuICAgICAgdXJsczogJ3N0dW46MjMuMjEuMTUwLjEyMSdcbiAgICB9XG4gIF1cbn1cblBlZXIuY29uc3RyYWludHMgPSB7fVxuUGVlci5jaGFubmVsQ29uZmlnID0ge31cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBlZXIucHJvdG90eXBlLCAnYnVmZmVyU2l6ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgcmV0dXJuIChzZWxmLl9jaGFubmVsICYmIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpIHx8IDBcbiAgfVxufSlcblxuUGVlci5wcm90b3R5cGUuYWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiB7IHBvcnQ6IHNlbGYubG9jYWxQb3J0LCBmYW1pbHk6ICdJUHY0JywgYWRkcmVzczogc2VsZi5sb2NhbEFkZHJlc3MgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzaWduYWwgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkYXRhID0ge31cbiAgICB9XG4gIH1cbiAgc2VsZi5fZGVidWcoJ3NpZ25hbCgpJylcbiAgaWYgKGRhdGEuc2RwKSB7XG4gICAgc2VsZi5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IChzZWxmLl93cnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoZGF0YSksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICBpZiAoc2VsZi5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykgc2VsZi5fY3JlYXRlQW5zd2VyKClcbiAgICB9LCBzZWxmLl9vbkVycm9yLmJpbmQoc2VsZikpXG4gIH1cbiAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX3BjLmFkZEljZUNhbmRpZGF0ZShcbiAgICAgICAgbmV3IChzZWxmLl93cnRjLlJUQ0ljZUNhbmRpZGF0ZSkoZGF0YS5jYW5kaWRhdGUpLCBub29wLCBzZWxmLl9vbkVycm9yLmJpbmQoc2VsZilcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNlbGYuX2Rlc3Ryb3kobmV3IEVycm9yKCdlcnJvciBhZGRpbmcgY2FuZGlkYXRlOiAnICsgZXJyLm1lc3NhZ2UpKVxuICAgIH1cbiAgfVxuICBpZiAoIWRhdGEuc2RwICYmICFkYXRhLmNhbmRpZGF0ZSkge1xuICAgIHNlbGYuX2Rlc3Ryb3kobmV3IEVycm9yKCdzaWduYWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIHNpZ25hbCBkYXRhJykpXG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kIHRleHQvYmluYXJ5IGRhdGEgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICogQHBhcmFtIHtUeXBlZEFycmF5Vmlld3xBcnJheUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nfEJsb2J8T2JqZWN0fSBjaHVua1xuICovXG5QZWVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghaXNUeXBlZEFycmF5LnN0cmljdChjaHVuaykgJiYgIShjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxuICAgICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiZcbiAgICAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8ICEoY2h1bmsgaW5zdGFuY2VvZiBCbG9iKSkpIHtcbiAgICBjaHVuayA9IEpTT04uc3RyaW5naWZ5KGNodW5rKVxuICB9XG5cbiAgLy8gYHdydGNgIG1vZHVsZSBkb2Vzbid0IGFjY2VwdCBub2RlLmpzIGJ1ZmZlclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiAhaXNUeXBlZEFycmF5LnN0cmljdChjaHVuaykpIHtcbiAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKVxuICB9XG5cbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aCB8fCBjaHVuay5ieXRlTGVuZ3RoIHx8IGNodW5rLnNpemVcbiAgc2VsZi5fY2hhbm5lbC5zZW5kKGNodW5rKVxuICBzZWxmLl9kZWJ1Zygnd3JpdGU6ICVkIGJ5dGVzJywgbGVuKVxufVxuXG5QZWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9uY2xvc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2Rlc3Ryb3kobnVsbCwgb25jbG9zZSlcbn1cblxuUGVlci5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBvbmNsb3NlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBpZiAob25jbG9zZSkgc2VsZi5vbmNlKCdjbG9zZScsIG9uY2xvc2UpXG5cbiAgc2VsZi5fZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgZXJyLm1lc3NhZ2UpXG5cbiAgc2VsZi5yZWFkYWJsZSA9IHNlbGYud3JpdGFibGUgPSBmYWxzZVxuXG4gIGlmICghc2VsZi5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgc2VsZi5wdXNoKG51bGwpXG4gIGlmICghc2VsZi5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgc2VsZi5lbmQoKVxuXG4gIHNlbGYuZGVzdHJveWVkID0gdHJ1ZVxuICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlXG4gIHNlbGYuX3BjUmVhZHkgPSBmYWxzZVxuICBzZWxmLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuXG4gIHNlbGYuX2NodW5rID0gbnVsbFxuICBzZWxmLl9jYiA9IG51bGxcbiAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbClcbiAgY2xlYXJUaW1lb3V0KHNlbGYuX3JlY29ubmVjdFRpbWVvdXQpXG5cbiAgaWYgKHNlbGYuX3BjKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuX3BjLmNsb3NlKClcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICBzZWxmLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGxcbiAgICBzZWxmLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgIHNlbGYuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbFxuICB9XG5cbiAgaWYgKHNlbGYuX2NoYW5uZWwpIHtcbiAgICB0cnkge1xuICAgICAgc2VsZi5fY2hhbm5lbC5jbG9zZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgc2VsZi5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBudWxsXG4gICAgc2VsZi5fY2hhbm5lbC5vbm9wZW4gPSBudWxsXG4gICAgc2VsZi5fY2hhbm5lbC5vbmNsb3NlID0gbnVsbFxuICB9XG4gIHNlbGYuX3BjID0gbnVsbFxuICBzZWxmLl9jaGFubmVsID0gbnVsbFxuXG4gIGlmIChlcnIpIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gIHNlbGYuZW1pdCgnY2xvc2UnKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fc2V0dXBEYXRhID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9jaGFubmVsID0gZXZlbnQuY2hhbm5lbFxuICBzZWxmLmNoYW5uZWxOYW1lID0gc2VsZi5fY2hhbm5lbC5sYWJlbFxuXG4gIHNlbGYuX2NoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgc2VsZi5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBzZWxmLl9vbkNoYW5uZWxNZXNzYWdlLmJpbmQoc2VsZilcbiAgc2VsZi5fY2hhbm5lbC5vbm9wZW4gPSBzZWxmLl9vbkNoYW5uZWxPcGVuLmJpbmQoc2VsZilcbiAgc2VsZi5fY2hhbm5lbC5vbmNsb3NlID0gc2VsZi5fb25DaGFubmVsQ2xvc2UuYmluZChzZWxmKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9XG5cblBlZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVybiBjYihuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpKVxuXG4gIGlmIChzZWxmLmNvbm5lY3RlZCkge1xuICAgIHNlbGYuc2VuZChjaHVuaylcbiAgICBpZiAoc2VsZi5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IHNlbGYuX21heEJ1ZmZlcmVkQW1vdW50KSB7XG4gICAgICBzZWxmLl9kZWJ1Zygnc3RhcnQgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gICAgICBzZWxmLl9jYiA9IGNiXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX2RlYnVnKCd3cml0ZSBiZWZvcmUgY29ubmVjdCcpXG4gICAgc2VsZi5fY2h1bmsgPSBjaHVua1xuICAgIHNlbGYuX2NiID0gY2JcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuX3BjLmNyZWF0ZU9mZmVyKGZ1bmN0aW9uIChvZmZlcikge1xuICAgIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgc3BlZWRIYWNrKG9mZmVyKVxuICAgIG9mZmVyLnNkcCA9IHNlbGYuc2RwVHJhbnNmb3JtKG9mZmVyLnNkcClcbiAgICBzZWxmLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyLCBub29wLCBzZWxmLl9vbkVycm9yLmJpbmQoc2VsZikpXG4gICAgdmFyIHNlbmRPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX2RlYnVnKCdzaWduYWwnKVxuICAgICAgc2VsZi5lbWl0KCdzaWduYWwnLCBzZWxmLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IG9mZmVyKVxuICAgIH1cbiAgICBpZiAoc2VsZi50cmlja2xlIHx8IHNlbGYuX2ljZUNvbXBsZXRlKSBzZW5kT2ZmZXIoKVxuICAgIGVsc2Ugc2VsZi5vbmNlKCdfaWNlQ29tcGxldGUnLCBzZW5kT2ZmZXIpIC8vIHdhaXQgZm9yIGNhbmRpZGF0ZXNcbiAgfSwgc2VsZi5fb25FcnJvci5iaW5kKHNlbGYpLCBzZWxmLm9mZmVyQ29uc3RyYWludHMpXG59XG5cblBlZXIucHJvdG90eXBlLl9jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuXG4gIHNlbGYuX3BjLmNyZWF0ZUFuc3dlcihmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgICBzcGVlZEhhY2soYW5zd2VyKVxuICAgIGFuc3dlci5zZHAgPSBzZWxmLnNkcFRyYW5zZm9ybShhbnN3ZXIuc2RwKVxuICAgIHNlbGYuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyLCBub29wLCBzZWxmLl9vbkVycm9yLmJpbmQoc2VsZikpXG4gICAgdmFyIHNlbmRBbnN3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgIHNlbGYuZW1pdCgnc2lnbmFsJywgc2VsZi5fcGMubG9jYWxEZXNjcmlwdGlvbiB8fCBhbnN3ZXIpXG4gICAgfVxuICAgIGlmIChzZWxmLnRyaWNrbGUgfHwgc2VsZi5faWNlQ29tcGxldGUpIHNlbmRBbnN3ZXIoKVxuICAgIGVsc2Ugc2VsZi5vbmNlKCdfaWNlQ29tcGxldGUnLCBzZW5kQW5zd2VyKVxuICB9LCBzZWxmLl9vbkVycm9yLmJpbmQoc2VsZiksIHNlbGYuYW5zd2VyQ29uc3RyYWludHMpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHZhciBpY2VHYXRoZXJpbmdTdGF0ZSA9IHNlbGYuX3BjLmljZUdhdGhlcmluZ1N0YXRlXG4gIHZhciBpY2VDb25uZWN0aW9uU3RhdGUgPSBzZWxmLl9wYy5pY2VDb25uZWN0aW9uU3RhdGVcbiAgc2VsZi5fZGVidWcoJ2ljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSAlcyAlcycsIGljZUdhdGhlcmluZ1N0YXRlLCBpY2VDb25uZWN0aW9uU3RhdGUpXG4gIHNlbGYuZW1pdCgnaWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlJywgaWNlR2F0aGVyaW5nU3RhdGUsIGljZUNvbm5lY3Rpb25TdGF0ZSlcbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykge1xuICAgIGNsZWFyVGltZW91dChzZWxmLl9yZWNvbm5lY3RUaW1lb3V0KVxuICAgIHNlbGYuX3BjUmVhZHkgPSB0cnVlXG4gICAgc2VsZi5fbWF5YmVSZWFkeSgpXG4gIH1cbiAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICBpZiAoc2VsZi5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgLy8gSWYgdXNlciBoYXMgc2V0IGBvcHQucmVjb25uZWN0VGltZXJgLCBhbGxvdyB0aW1lIGZvciBJQ0UgdG8gYXR0ZW1wdCBhIHJlY29ubmVjdFxuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3JlY29ubmVjdFRpbWVvdXQpXG4gICAgICBzZWxmLl9yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2Rlc3Ryb3koKVxuICAgICAgfSwgc2VsZi5yZWNvbm5lY3RUaW1lcilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fZGVzdHJveSgpXG4gICAgfVxuICB9XG4gIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgc2VsZi5fZGVzdHJveSgpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX21heWJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9kZWJ1ZygnbWF5YmVSZWFkeSBwYyAlcyBjaGFubmVsICVzJywgc2VsZi5fcGNSZWFkeSwgc2VsZi5fY2hhbm5lbFJlYWR5KVxuICBpZiAoc2VsZi5jb25uZWN0ZWQgfHwgc2VsZi5fY29ubmVjdGluZyB8fCAhc2VsZi5fcGNSZWFkeSB8fCAhc2VsZi5fY2hhbm5lbFJlYWR5KSByZXR1cm5cbiAgc2VsZi5fY29ubmVjdGluZyA9IHRydWVcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICBzZWxmLl9wYy5nZXRTdGF0cyhudWxsLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuICAgICAgfSlcbiAgICAgIG9uU3RhdHMoaXRlbXMpXG4gICAgfSwgc2VsZi5fb25FcnJvci5iaW5kKHNlbGYpKVxuICB9IGVsc2Uge1xuICAgIHNlbGYuX3BjLmdldFN0YXRzKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICByZXMucmVzdWx0KCkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBpdGVtID0ge31cbiAgICAgICAgcmVzdWx0Lm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGl0ZW1bbmFtZV0gPSByZXN1bHQuc3RhdChuYW1lKVxuICAgICAgICB9KVxuICAgICAgICBpdGVtLmlkID0gcmVzdWx0LmlkXG4gICAgICAgIGl0ZW0udHlwZSA9IHJlc3VsdC50eXBlXG4gICAgICAgIGl0ZW0udGltZXN0YW1wID0gcmVzdWx0LnRpbWVzdGFtcFxuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG4gICAgICB9KVxuICAgICAgb25TdGF0cyhpdGVtcylcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gb25TdGF0cyAoaXRlbXMpIHtcbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbS50eXBlID09PSAncmVtb3RlY2FuZGlkYXRlJykge1xuICAgICAgICBzZWxmLnJlbW90ZUFkZHJlc3MgPSBpdGVtLmlwQWRkcmVzc1xuICAgICAgICBzZWxmLnJlbW90ZUZhbWlseSA9ICdJUHY0J1xuICAgICAgICBzZWxmLnJlbW90ZVBvcnQgPSBOdW1iZXIoaXRlbS5wb3J0TnVtYmVyKVxuICAgICAgICBzZWxmLl9kZWJ1ZyhcbiAgICAgICAgICAnY29ubmVjdCByZW1vdGU6ICVzOiVzICglcyknLFxuICAgICAgICAgIHNlbGYucmVtb3RlQWRkcmVzcywgc2VsZi5yZW1vdGVQb3J0LCBzZWxmLnJlbW90ZUZhbWlseVxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ2xvY2FsY2FuZGlkYXRlJyAmJiBpdGVtLmNhbmRpZGF0ZVR5cGUgPT09ICdob3N0Jykge1xuICAgICAgICBzZWxmLmxvY2FsQWRkcmVzcyA9IGl0ZW0uaXBBZGRyZXNzXG4gICAgICAgIHNlbGYubG9jYWxQb3J0ID0gTnVtYmVyKGl0ZW0ucG9ydE51bWJlcilcbiAgICAgICAgc2VsZi5fZGVidWcoJ2Nvbm5lY3QgbG9jYWw6ICVzOiVzJywgc2VsZi5sb2NhbEFkZHJlc3MsIHNlbGYubG9jYWxQb3J0KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBzZWxmLl9jb25uZWN0aW5nID0gZmFsc2VcbiAgICBzZWxmLmNvbm5lY3RlZCA9IHRydWVcblxuICAgIGlmIChzZWxmLl9jaHVuaykge1xuICAgICAgc2VsZi5zZW5kKHNlbGYuX2NodW5rKVxuICAgICAgc2VsZi5fY2h1bmsgPSBudWxsXG4gICAgICBzZWxmLl9kZWJ1Zygnc2VudCBjaHVuayBmcm9tIFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcIicpXG5cbiAgICAgIHZhciBjYiA9IHNlbGYuX2NiXG4gICAgICBzZWxmLl9jYiA9IG51bGxcbiAgICAgIGNiKG51bGwpXG4gICAgfVxuXG4gICAgc2VsZi5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNlbGYuX2NiIHx8ICFzZWxmLl9jaGFubmVsIHx8IHNlbGYuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBzZWxmLl9tYXhCdWZmZXJlZEFtb3VudCkgcmV0dXJuXG4gICAgICBzZWxmLl9kZWJ1ZygnZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCBzZWxmLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KVxuICAgICAgdmFyIGNiID0gc2VsZi5fY2JcbiAgICAgIHNlbGYuX2NiID0gbnVsbFxuICAgICAgY2IobnVsbClcbiAgICB9LCAxNTApXG4gICAgaWYgKHNlbGYuX2ludGVydmFsLnVucmVmKSBzZWxmLl9pbnRlcnZhbC51bnJlZigpXG5cbiAgICBzZWxmLl9kZWJ1ZygnY29ubmVjdCcpXG4gICAgc2VsZi5lbWl0KCdjb25uZWN0JylcbiAgfVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdzaWduYWxpbmdTdGF0ZUNoYW5nZSAlcycsIHNlbGYuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICBzZWxmLmVtaXQoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlJywgc2VsZi5fcGMuc2lnbmFsaW5nU3RhdGUpXG59XG5cblBlZXIucHJvdG90eXBlLl9vbkljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiBzZWxmLnRyaWNrbGUpIHtcbiAgICBzZWxmLmVtaXQoJ3NpZ25hbCcsIHsgY2FuZGlkYXRlOiBldmVudC5jYW5kaWRhdGUgfSlcbiAgfSBlbHNlIGlmICghZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgc2VsZi5faWNlQ29tcGxldGUgPSB0cnVlXG4gICAgc2VsZi5lbWl0KCdfaWNlQ29tcGxldGUnKVxuICB9XG59XG5cblBlZXIucHJvdG90eXBlLl9vbkNoYW5uZWxNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFcbiAgc2VsZi5fZGVidWcoJ3JlYWQ6ICVkIGJ5dGVzJywgZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoKVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBkYXRhID0gdG9CdWZmZXIobmV3IFVpbnQ4QXJyYXkoZGF0YSkpXG4gICAgc2VsZi5wdXNoKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgIHNlbGYuZW1pdCgnZGF0YScsIGRhdGEpXG4gIH1cbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbE9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5jb25uZWN0ZWQgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gY2hhbm5lbCBvcGVuJylcbiAgc2VsZi5fY2hhbm5lbFJlYWR5ID0gdHJ1ZVxuICBzZWxmLl9tYXliZVJlYWR5KClcbn1cblxuUGVlci5wcm90b3R5cGUuX29uQ2hhbm5lbENsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuZGVzdHJveWVkKSByZXR1cm5cbiAgc2VsZi5fZGVidWcoJ29uIGNoYW5uZWwgY2xvc2UnKVxuICBzZWxmLl9kZXN0cm95KClcbn1cblxuUGVlci5wcm90b3R5cGUuX29uQWRkU3RyZWFtID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5kZXN0cm95ZWQpIHJldHVyblxuICBzZWxmLl9kZWJ1Zygnb24gYWRkIHN0cmVhbScpXG4gIHNlbGYuZW1pdCgnc3RyZWFtJywgZXZlbnQuc3RyZWFtKVxufVxuXG5QZWVyLnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHNlbGYuX2RlYnVnKCdlcnJvciAlcycsIGVyci5tZXNzYWdlIHx8IGVycilcbiAgc2VsZi5fZGVzdHJveShlcnIpXG59XG5cblBlZXIucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIHZhciBpZCA9IHNlbGYuY2hhbm5lbE5hbWUgJiYgc2VsZi5jaGFubmVsTmFtZS5zdWJzdHJpbmcoMCwgNylcbiAgYXJnc1swXSA9ICdbJyArIGlkICsgJ10gJyArIGFyZ3NbMF1cbiAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbn1cblxuZnVuY3Rpb24gZ2V0QnJvd3NlclJUQyAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGxcbiAgdmFyIHdydGMgPSB7XG4gICAgUlRDUGVlckNvbm5lY3Rpb246IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbixcbiAgICBSVENTZXNzaW9uRGVzY3JpcHRpb246IHdpbmRvdy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb24gfHxcbiAgICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgd2luZG93LndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbixcbiAgICBSVENJY2VDYW5kaWRhdGU6IHdpbmRvdy5tb3pSVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fFxuICAgICAgd2luZG93LndlYmtpdFJUQ0ljZUNhbmRpZGF0ZVxuICB9XG4gIGlmICghd3J0Yy5SVENQZWVyQ29ubmVjdGlvbikgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHdydGNcbn1cblxuZnVuY3Rpb24gc3BlZWRIYWNrIChvYmopIHtcbiAgdmFyIHMgPSBvYmouc2RwLnNwbGl0KCdiPUFTOjMwJylcbiAgaWYgKHMubGVuZ3RoID4gMSkgb2JqLnNkcCA9IHNbMF0gKyAnYj1BUzoxNjM4NDAwJyArIHNbMV1cbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG59KS5jYWxsKHRoaXMse1wiaXNCdWZmZXJcIjpyZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXCIpfSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlqY21GMFpTMWpiM0psTDI1dlpHVmZiVzlrZFd4bGN5OXpjSEpoZVMxM2NuUmpMMjV2WkdWZmJXOWtkV3hsY3k5emFXMXdiR1V0Y0dWbGNpOXBibVJsZUM1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFJR2RzYjJKaGJDQkNiRzlpSUNvdlhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdVR1ZsY2x4dVhHNTJZWElnWkdWaWRXY2dQU0J5WlhGMWFYSmxLQ2RrWldKMVp5Y3BLQ2R6YVcxd2JHVXRjR1ZsY2ljcFhHNTJZWElnYUdGMElEMGdjbVZ4ZFdseVpTZ25hR0YwSnlsY2JuWmhjaUJwYm1obGNtbDBjeUE5SUhKbGNYVnBjbVVvSjJsdWFHVnlhWFJ6SnlsY2JuWmhjaUJwYzFSNWNHVmtRWEp5WVhrZ1BTQnlaWEYxYVhKbEtDZHBjeTEwZVhCbFpHRnljbUY1SnlsY2JuWmhjaUJ2Ym1ObElEMGdjbVZ4ZFdseVpTZ25iMjVqWlNjcFhHNTJZWElnYzNSeVpXRnRJRDBnY21WeGRXbHlaU2duYzNSeVpXRnRKeWxjYm5aaGNpQjBiMEoxWm1abGNpQTlJSEpsY1hWcGNtVW9KM1I1Y0dWa1lYSnlZWGt0ZEc4dFluVm1abVZ5SnlsY2JseHVhVzVvWlhKcGRITW9VR1ZsY2l3Z2MzUnlaV0Z0TGtSMWNHeGxlQ2xjYmx4dUx5b3FYRzRnS2lCWFpXSlNWRU1nY0dWbGNpQmpiMjV1WldOMGFXOXVMaUJUWVcxbElFRlFTU0JoY3lCdWIyUmxJR052Y21VZ1lHNWxkQzVUYjJOclpYUmdMQ0J3YkhWeklHRWdabVYzSUdWNGRISmhJRzFsZEdodlpITXVYRzRnS2lCRWRYQnNaWGdnYzNSeVpXRnRMbHh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUc5d2RITmNiaUFxTDF4dVpuVnVZM1JwYjI0Z1VHVmxjaUFvYjNCMGN5a2dlMXh1SUNCMllYSWdjMlZzWmlBOUlIUm9hWE5jYmlBZ2FXWWdLQ0VvYzJWc1ppQnBibk4wWVc1alpXOW1JRkJsWlhJcEtTQnlaWFIxY200Z2JtVjNJRkJsWlhJb2IzQjBjeWxjYmlBZ2MyVnNaaTVmWkdWaWRXY29KMjVsZHlCd1pXVnlJQ1Z2Snl3Z2IzQjBjeWxjYmx4dUlDQnBaaUFvSVc5d2RITXBJRzl3ZEhNZ1BTQjdmVnh1SUNCdmNIUnpMbUZzYkc5M1NHRnNaazl3Wlc0Z1BTQm1ZV3h6WlZ4dUlDQnBaaUFvYjNCMGN5NW9hV2RvVjJGMFpYSk5ZWEpySUQwOUlHNTFiR3dwSUc5d2RITXVhR2xuYUZkaGRHVnlUV0Z5YXlBOUlERXdNalFnS2lBeE1ESTBYRzVjYmlBZ2MzUnlaV0Z0TGtSMWNHeGxlQzVqWVd4c0tITmxiR1lzSUc5d2RITXBYRzVjYmlBZ2MyVnNaaTVwYm1sMGFXRjBiM0lnUFNCdmNIUnpMbWx1YVhScFlYUnZjaUI4ZkNCbVlXeHpaVnh1SUNCelpXeG1MbU5vWVc1dVpXeERiMjVtYVdjZ1BTQnZjSFJ6TG1Ob1lXNXVaV3hEYjI1bWFXY2dmSHdnVUdWbGNpNWphR0Z1Ym1Wc1EyOXVabWxuWEc0Z0lITmxiR1l1WTJoaGJtNWxiRTVoYldVZ1BTQnZjSFJ6TG1Ob1lXNXVaV3hPWVcxbElIeDhJR2hoZENneE5qQXBYRzRnSUdsbUlDZ2hiM0IwY3k1cGJtbDBhV0YwYjNJcElITmxiR1l1WTJoaGJtNWxiRTVoYldVZ1BTQnVkV3hzWEc0Z0lITmxiR1l1WTI5dVptbG5JRDBnYjNCMGN5NWpiMjVtYVdjZ2ZId2dVR1ZsY2k1amIyNW1hV2RjYmlBZ2MyVnNaaTVqYjI1emRISmhhVzUwY3lBOUlHOXdkSE11WTI5dWMzUnlZV2x1ZEhNZ2ZId2dVR1ZsY2k1amIyNXpkSEpoYVc1MGMxeHVJQ0J6Wld4bUxuSmxZMjl1Ym1WamRGUnBiV1Z5SUQwZ2IzQjBjeTV5WldOdmJtNWxZM1JVYVcxbGNpQjhmQ0F3WEc0Z0lITmxiR1l1YzJSd1ZISmhibk5tYjNKdElEMGdiM0IwY3k1elpIQlVjbUZ1YzJadmNtMGdmSHdnWm5WdVkzUnBiMjRnS0hOa2NDa2dleUJ5WlhSMWNtNGdjMlJ3SUgxY2JpQWdjMlZzWmk1emRISmxZVzBnUFNCdmNIUnpMbk4wY21WaGJTQjhmQ0JtWVd4elpWeHVJQ0J6Wld4bUxuUnlhV05yYkdVZ1BTQnZjSFJ6TG5SeWFXTnJiR1VnSVQwOUlIVnVaR1ZtYVc1bFpDQS9JRzl3ZEhNdWRISnBZMnRzWlNBNklIUnlkV1ZjYmx4dUlDQnpaV3htTG1SbGMzUnliM2xsWkNBOUlHWmhiSE5sWEc0Z0lITmxiR1l1WTI5dWJtVmpkR1ZrSUQwZ1ptRnNjMlZjYmx4dUlDQXZMeUJ6YnlCUVpXVnlJRzlpYW1WamRDQmhiSGRoZVhNZ2FHRnpJSE5oYldVZ2MyaGhjR1VnS0ZZNElHOXdkR2x0YVhwaGRHbHZiaWxjYmlBZ2MyVnNaaTV5WlcxdmRHVkJaR1J5WlhOeklEMGdkVzVrWldacGJtVmtYRzRnSUhObGJHWXVjbVZ0YjNSbFJtRnRhV3g1SUQwZ2RXNWtaV1pwYm1Wa1hHNGdJSE5sYkdZdWNtVnRiM1JsVUc5eWRDQTlJSFZ1WkdWbWFXNWxaRnh1SUNCelpXeG1MbXh2WTJGc1FXUmtjbVZ6Y3lBOUlIVnVaR1ZtYVc1bFpGeHVJQ0J6Wld4bUxteHZZMkZzVUc5eWRDQTlJSFZ1WkdWbWFXNWxaRnh1WEc0Z0lITmxiR1l1WDNkeWRHTWdQU0J2Y0hSekxuZHlkR01nZkh3Z1oyVjBRbkp2ZDNObGNsSlVReWdwWEc0Z0lHbG1JQ2doYzJWc1ppNWZkM0owWXlrZ2UxeHVJQ0FnSUdsbUlDaDBlWEJsYjJZZ2QybHVaRzkzSUQwOVBTQW5kVzVrWldacGJtVmtKeWtnZTF4dUlDQWdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RPYnlCWFpXSlNWRU1nYzNWd2NHOXlkRG9nVTNCbFkybG1lU0JnYjNCMGN5NTNjblJqWUNCdmNIUnBiMjRnYVc0Z2RHaHBjeUJsYm5acGNtOXViV1Z1ZENjcFhHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSFJvY205M0lHNWxkeUJGY25KdmNpZ25UbThnVjJWaVVsUkRJSE4xY0hCdmNuUTZJRTV2ZENCaElITjFjSEJ2Y25SbFpDQmljbTkzYzJWeUp5bGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnpaV3htTGw5dFlYaENkV1ptWlhKbFpFRnRiM1Z1ZENBOUlHOXdkSE11YUdsbmFGZGhkR1Z5VFdGeWExeHVJQ0J6Wld4bUxsOXdZMUpsWVdSNUlEMGdabUZzYzJWY2JpQWdjMlZzWmk1ZlkyaGhibTVsYkZKbFlXUjVJRDBnWm1Gc2MyVmNiaUFnYzJWc1ppNWZhV05sUTI5dGNHeGxkR1VnUFNCbVlXeHpaU0F2THlCcFkyVWdZMkZ1Wkdsa1lYUmxJSFJ5YVdOcmJHVWdaRzl1WlNBb1oyOTBJRzUxYkd3Z1kyRnVaR2xrWVhSbEtWeHVJQ0J6Wld4bUxsOWphR0Z1Ym1Wc0lEMGdiblZzYkZ4dVhHNGdJSE5sYkdZdVgyTm9kVzVySUQwZ2JuVnNiRnh1SUNCelpXeG1MbDlqWWlBOUlHNTFiR3hjYmlBZ2MyVnNaaTVmYVc1MFpYSjJZV3dnUFNCdWRXeHNYRzRnSUhObGJHWXVYM0psWTI5dWJtVmpkRlJwYldWdmRYUWdQU0J1ZFd4c1hHNWNiaUFnYzJWc1ppNWZjR01nUFNCdVpYY2dLSE5sYkdZdVgzZHlkR011VWxSRFVHVmxja052Ym01bFkzUnBiMjRwS0hObGJHWXVZMjl1Wm1sbkxDQnpaV3htTG1OdmJuTjBjbUZwYm5SektWeHVJQ0J6Wld4bUxsOXdZeTV2Ym1salpXTnZibTVsWTNScGIyNXpkR0YwWldOb1lXNW5aU0E5SUhObGJHWXVYMjl1U1dObFEyOXVibVZqZEdsdmJsTjBZWFJsUTJoaGJtZGxMbUpwYm1Rb2MyVnNaaWxjYmlBZ2MyVnNaaTVmY0dNdWIyNXphV2R1WVd4cGJtZHpkR0YwWldOb1lXNW5aU0E5SUhObGJHWXVYMjl1VTJsbmJtRnNhVzVuVTNSaGRHVkRhR0Z1WjJVdVltbHVaQ2h6Wld4bUtWeHVJQ0J6Wld4bUxsOXdZeTV2Ym1salpXTmhibVJwWkdGMFpTQTlJSE5sYkdZdVgyOXVTV05sUTJGdVpHbGtZWFJsTG1KcGJtUW9jMlZzWmlsY2JseHVJQ0JwWmlBb2MyVnNaaTV6ZEhKbFlXMHBJSE5sYkdZdVgzQmpMbUZrWkZOMGNtVmhiU2h6Wld4bUxuTjBjbVZoYlNsY2JpQWdjMlZzWmk1ZmNHTXViMjVoWkdSemRISmxZVzBnUFNCelpXeG1MbDl2YmtGa1pGTjBjbVZoYlM1aWFXNWtLSE5sYkdZcFhHNWNiaUFnYVdZZ0tITmxiR1l1YVc1cGRHbGhkRzl5S1NCN1hHNGdJQ0FnYzJWc1ppNWZjMlYwZFhCRVlYUmhLSHNnWTJoaGJtNWxiRG9nYzJWc1ppNWZjR011WTNKbFlYUmxSR0YwWVVOb1lXNXVaV3dvYzJWc1ppNWphR0Z1Ym1Wc1RtRnRaU3dnYzJWc1ppNWphR0Z1Ym1Wc1EyOXVabWxuS1NCOUtWeHVJQ0FnSUhObGJHWXVYM0JqTG05dWJtVm5iM1JwWVhScGIyNXVaV1ZrWldRZ1BTQnZibU5sS0hObGJHWXVYMk55WldGMFpVOW1abVZ5TG1KcGJtUW9jMlZzWmlrcFhHNGdJQ0FnTHk4Z1QyNXNlU0JEYUhKdmJXVWdkSEpwWjJkbGNuTWdYQ0p1WldkdmRHbGhkR2x2Ym01bFpXUmxaRndpT3lCMGFHbHpJR2x6SUdFZ2QyOXlhMkZ5YjNWdVpDQm1iM0lnYjNSb1pYSmNiaUFnSUNBdkx5QnBiWEJzWlcxbGJuUmhkR2x2Ym5OY2JpQWdJQ0JwWmlBb2RIbHdaVzltSUhkcGJtUnZkeUE5UFQwZ0ozVnVaR1ZtYVc1bFpDY2dmSHdnSVhkcGJtUnZkeTUzWldKcmFYUlNWRU5RWldWeVEyOXVibVZqZEdsdmJpa2dlMXh1SUNBZ0lDQWdjMlZzWmk1ZmNHTXViMjV1WldkdmRHbGhkR2x2Ym01bFpXUmxaQ2dwWEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSE5sYkdZdVgzQmpMbTl1WkdGMFlXTm9ZVzV1Wld3Z1BTQnpaV3htTGw5elpYUjFjRVJoZEdFdVltbHVaQ2h6Wld4bUtWeHVJQ0I5WEc1Y2JpQWdjMlZzWmk1dmJpZ25abWx1YVhOb0p5d2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJR2xtSUNoelpXeG1MbU52Ym01bFkzUmxaQ2tnZTF4dUlDQWdJQ0FnTHk4Z1YyaGxiaUJzYjJOaGJDQndaV1Z5SUdseklHWnBibWx6YUdWa0lIZHlhWFJwYm1jc0lHTnNiM05sSUdOdmJtNWxZM1JwYjI0Z2RHOGdjbVZ0YjNSbElIQmxaWEl1WEc0Z0lDQWdJQ0F2THlCSVlXeG1JRzl3Wlc0Z1kyOXVibVZqZEdsdmJuTWdZWEpsSUdOMWNuSmxiblJzZVNCdWIzUWdjM1Z3Y0c5eWRHVmtMbHh1SUNBZ0lDQWdMeThnVjJGcGRDQmhJR0pwZENCaVpXWnZjbVVnWkdWemRISnZlV2x1WnlCemJ5QjBhR1VnWkdGMFlXTm9ZVzV1Wld3Z1pteDFjMmhsY3k1Y2JpQWdJQ0FnSUM4dklGUlBSRTg2SUdseklIUm9aWEpsSUdFZ2JXOXlaU0J5Wld4cFlXSnNaU0IzWVhrZ2RHOGdZV05qYjIxd2JHbHphQ0IwYUdselAxeHVJQ0FnSUNBZ2MyVjBWR2x0Wlc5MWRDaG1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdJQ0FnSUhObGJHWXVYMlJsYzNSeWIza29LVnh1SUNBZ0lDQWdmU3dnTVRBd0tWeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0F2THlCSlppQmtZWFJoSUdOb1lXNXVaV3dnYVhNZ2JtOTBJR052Ym01bFkzUmxaQ0IzYUdWdUlHeHZZMkZzSUhCbFpYSWdhWE1nWm1sdWFYTm9aV1FnZDNKcGRHbHVaeXdnZDJGcGRDQjFiblJwYkZ4dUlDQWdJQ0FnTHk4Z1pHRjBZU0JwY3lCbWJIVnphR1ZrSUhSdklHNWxkSGR2Y21zZ1lYUWdYQ0pqYjI1dVpXTjBYQ0lnWlhabGJuUXVYRzRnSUNBZ0lDQXZMeUJVVDBSUE9pQnBjeUIwYUdWeVpTQmhJRzF2Y21VZ2NtVnNhV0ZpYkdVZ2QyRjVJSFJ2SUdGalkyOXRjR3hwYzJnZ2RHaHBjejljYmlBZ0lDQWdJSE5sYkdZdWIyNWpaU2duWTI5dWJtVmpkQ2NzSUdaMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lDQWdjMlYwVkdsdFpXOTFkQ2htZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjMlZzWmk1ZlpHVnpkSEp2ZVNncFhHNGdJQ0FnSUNBZ0lIMHNJREV3TUNsY2JpQWdJQ0FnSUgwcFhHNGdJQ0FnZlZ4dUlDQjlLVnh1ZlZ4dVhHNVFaV1Z5TGxkRlFsSlVRMTlUVlZCUVQxSlVJRDBnSVNGblpYUkNjbTkzYzJWeVVsUkRLQ2xjYmx4dUx5b3FYRzRnS2lCRmVIQnZjMlVnWTI5dVptbG5MQ0JqYjI1emRISmhhVzUwY3l3Z1lXNWtJR1JoZEdFZ1kyaGhibTVsYkNCamIyNW1hV2NnWm05eUlHOTJaWEp5YVdScGJtY2dZV3hzSUZCbFpYSmNiaUFxSUdsdWMzUmhibU5sY3k0Z1QzUm9aWEozYVhObExDQnFkWE4wSUhObGRDQnZjSFJ6TG1OdmJtWnBaeXdnYjNCMGN5NWpiMjV6ZEhKaGFXNTBjeXdnYjNJZ2IzQjBjeTVqYUdGdWJtVnNRMjl1Wm1sblhHNGdLaUIzYUdWdUlHTnZibk4wY25WamRHbHVaeUJoSUZCbFpYSXVYRzRnS2k5Y2JsQmxaWEl1WTI5dVptbG5JRDBnZTF4dUlDQnBZMlZUWlhKMlpYSnpPaUJiWEc0Z0lDQWdlMXh1SUNBZ0lDQWdkWEpzT2lBbmMzUjFiam95TXk0eU1TNHhOVEF1TVRJeEp5d2dMeThnWkdWd2NtVmpZWFJsWkN3Z2NtVndiR0ZqWldRZ1lua2dZSFZ5YkhOZ1hHNGdJQ0FnSUNCMWNteHpPaUFuYzNSMWJqb3lNeTR5TVM0eE5UQXVNVEl4SjF4dUlDQWdJSDFjYmlBZ1hWeHVmVnh1VUdWbGNpNWpiMjV6ZEhKaGFXNTBjeUE5SUh0OVhHNVFaV1Z5TG1Ob1lXNXVaV3hEYjI1bWFXY2dQU0I3ZlZ4dVhHNVBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkSGtvVUdWbGNpNXdjbTkwYjNSNWNHVXNJQ2RpZFdabVpYSlRhWHBsSnl3Z2UxeHVJQ0JuWlhRNklHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ0lDQjJZWElnYzJWc1ppQTlJSFJvYVhOY2JpQWdJQ0J5WlhSMWNtNGdLSE5sYkdZdVgyTm9ZVzV1Wld3Z0ppWWdjMlZzWmk1ZlkyaGhibTVsYkM1aWRXWm1aWEpsWkVGdGIzVnVkQ2tnZkh3Z01GeHVJQ0I5WEc1OUtWeHVYRzVRWldWeUxuQnliM1J2ZEhsd1pTNWhaR1J5WlhOeklEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQjJZWElnYzJWc1ppQTlJSFJvYVhOY2JpQWdjbVYwZFhKdUlIc2djRzl5ZERvZ2MyVnNaaTVzYjJOaGJGQnZjblFzSUdaaGJXbHNlVG9nSjBsUWRqUW5MQ0JoWkdSeVpYTnpPaUJ6Wld4bUxteHZZMkZzUVdSa2NtVnpjeUI5WEc1OVhHNWNibEJsWlhJdWNISnZkRzkwZVhCbExuTnBaMjVoYkNBOUlHWjFibU4wYVc5dUlDaGtZWFJoS1NCN1hHNGdJSFpoY2lCelpXeG1JRDBnZEdocGMxeHVJQ0JwWmlBb2MyVnNaaTVrWlhOMGNtOTVaV1FwSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduWTJGdWJtOTBJSE5wWjI1aGJDQmhablJsY2lCd1pXVnlJR2x6SUdSbGMzUnliM2xsWkNjcFhHNGdJR2xtSUNoMGVYQmxiMllnWkdGMFlTQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ1pHRjBZU0E5SUVwVFQwNHVjR0Z5YzJVb1pHRjBZU2xjYmlBZ0lDQjlJR05oZEdOb0lDaGxjbklwSUh0Y2JpQWdJQ0FnSUdSaGRHRWdQU0I3ZlZ4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0J6Wld4bUxsOWtaV0oxWnlnbmMybG5ibUZzS0NrbktWeHVJQ0JwWmlBb1pHRjBZUzV6WkhBcElIdGNiaUFnSUNCelpXeG1MbDl3WXk1elpYUlNaVzF2ZEdWRVpYTmpjbWx3ZEdsdmJpaHVaWGNnS0hObGJHWXVYM2R5ZEdNdVVsUkRVMlZ6YzJsdmJrUmxjMk55YVhCMGFXOXVLU2hrWVhSaEtTd2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tITmxiR1l1WkdWemRISnZlV1ZrS1NCeVpYUjFjbTVjYmlBZ0lDQWdJR2xtSUNoelpXeG1MbDl3WXk1eVpXMXZkR1ZFWlhOamNtbHdkR2x2Ymk1MGVYQmxJRDA5UFNBbmIyWm1aWEluS1NCelpXeG1MbDlqY21WaGRHVkJibk4zWlhJb0tWeHVJQ0FnSUgwc0lITmxiR1l1WDI5dVJYSnliM0l1WW1sdVpDaHpaV3htS1NsY2JpQWdmVnh1SUNCcFppQW9aR0YwWVM1allXNWthV1JoZEdVcElIdGNiaUFnSUNCMGNua2dlMXh1SUNBZ0lDQWdjMlZzWmk1ZmNHTXVZV1JrU1dObFEyRnVaR2xrWVhSbEtGeHVJQ0FnSUNBZ0lDQnVaWGNnS0hObGJHWXVYM2R5ZEdNdVVsUkRTV05sUTJGdVpHbGtZWFJsS1Noa1lYUmhMbU5oYm1ScFpHRjBaU2tzSUc1dmIzQXNJSE5sYkdZdVgyOXVSWEp5YjNJdVltbHVaQ2h6Wld4bUtWeHVJQ0FnSUNBZ0tWeHVJQ0FnSUgwZ1kyRjBZMmdnS0dWeWNpa2dlMXh1SUNBZ0lDQWdjMlZzWmk1ZlpHVnpkSEp2ZVNodVpYY2dSWEp5YjNJb0oyVnljbTl5SUdGa1pHbHVaeUJqWVc1a2FXUmhkR1U2SUNjZ0t5Qmxjbkl1YldWemMyRm5aU2twWEc0Z0lDQWdmVnh1SUNCOVhHNGdJR2xtSUNnaFpHRjBZUzV6WkhBZ0ppWWdJV1JoZEdFdVkyRnVaR2xrWVhSbEtTQjdYRzRnSUNBZ2MyVnNaaTVmWkdWemRISnZlU2h1WlhjZ1JYSnliM0lvSjNOcFoyNWhiQ2dwSUdOaGJHeGxaQ0IzYVhSb0lHbHVkbUZzYVdRZ2MybG5ibUZzSUdSaGRHRW5LU2xjYmlBZ2ZWeHVmVnh1WEc0dktpcGNiaUFxSUZObGJtUWdkR1Y0ZEM5aWFXNWhjbmtnWkdGMFlTQjBieUIwYUdVZ2NtVnRiM1JsSUhCbFpYSXVYRzRnS2lCQWNHRnlZVzBnZTFSNWNHVmtRWEp5WVhsV2FXVjNmRUZ5Y21GNVFuVm1abVZ5ZkVKMVptWmxjbnh6ZEhKcGJtZDhRbXh2WW54UFltcGxZM1I5SUdOb2RXNXJYRzRnS2k5Y2JsQmxaWEl1Y0hKdmRHOTBlWEJsTG5ObGJtUWdQU0JtZFc1amRHbHZiaUFvWTJoMWJtc3BJSHRjYmlBZ2RtRnlJSE5sYkdZZ1BTQjBhR2x6WEc1Y2JpQWdhV1lnS0NGcGMxUjVjR1ZrUVhKeVlYa3VjM1J5YVdOMEtHTm9kVzVyS1NBbUppQWhLR05vZFc1cklHbHVjM1JoYm1ObGIyWWdRWEp5WVhsQ2RXWm1aWElwSUNZbVhHNGdJQ0FnSVVKMVptWmxjaTVwYzBKMVptWmxjaWhqYUhWdWF5a2dKaVlnZEhsd1pXOW1JR05vZFc1cklDRTlQU0FuYzNSeWFXNW5KeUFtSmx4dUlDQWdJQ2gwZVhCbGIyWWdRbXh2WWlBOVBUMGdKM1Z1WkdWbWFXNWxaQ2NnZkh3Z0lTaGphSFZ1YXlCcGJuTjBZVzVqWlc5bUlFSnNiMklwS1NrZ2UxeHVJQ0FnSUdOb2RXNXJJRDBnU2xOUFRpNXpkSEpwYm1kcFpua29ZMmgxYm1zcFhHNGdJSDFjYmx4dUlDQXZMeUJnZDNKMFkyQWdiVzlrZFd4bElHUnZaWE51SjNRZ1lXTmpaWEIwSUc1dlpHVXVhbk1nWW5WbVptVnlYRzRnSUdsbUlDaENkV1ptWlhJdWFYTkNkV1ptWlhJb1kyaDFibXNwSUNZbUlDRnBjMVI1Y0dWa1FYSnlZWGt1YzNSeWFXTjBLR05vZFc1cktTa2dlMXh1SUNBZ0lHTm9kVzVySUQwZ2JtVjNJRlZwYm5RNFFYSnlZWGtvWTJoMWJtc3BYRzRnSUgxY2JseHVJQ0IyWVhJZ2JHVnVJRDBnWTJoMWJtc3ViR1Z1WjNSb0lIeDhJR05vZFc1ckxtSjVkR1ZNWlc1bmRHZ2dmSHdnWTJoMWJtc3VjMmw2WlZ4dUlDQnpaV3htTGw5amFHRnVibVZzTG5ObGJtUW9ZMmgxYm1zcFhHNGdJSE5sYkdZdVgyUmxZblZuS0NkM2NtbDBaVG9nSldRZ1lubDBaWE1uTENCc1pXNHBYRzU5WEc1Y2JsQmxaWEl1Y0hKdmRHOTBlWEJsTG1SbGMzUnliM2tnUFNCbWRXNWpkR2x2YmlBb2IyNWpiRzl6WlNrZ2UxeHVJQ0IyWVhJZ2MyVnNaaUE5SUhSb2FYTmNiaUFnYzJWc1ppNWZaR1Z6ZEhKdmVTaHVkV3hzTENCdmJtTnNiM05sS1Z4dWZWeHVYRzVRWldWeUxuQnliM1J2ZEhsd1pTNWZaR1Z6ZEhKdmVTQTlJR1oxYm1OMGFXOXVJQ2hsY25Jc0lHOXVZMnh2YzJVcElIdGNiaUFnZG1GeUlITmxiR1lnUFNCMGFHbHpYRzRnSUdsbUlDaHpaV3htTG1SbGMzUnliM2xsWkNrZ2NtVjBkWEp1WEc0Z0lHbG1JQ2h2Ym1Oc2IzTmxLU0J6Wld4bUxtOXVZMlVvSjJOc2IzTmxKeXdnYjI1amJHOXpaU2xjYmx4dUlDQnpaV3htTGw5a1pXSjFaeWduWkdWemRISnZlU0FvWlhKeWIzSTZJQ1Z6S1Njc0lHVnljaUFtSmlCbGNuSXViV1Z6YzJGblpTbGNibHh1SUNCelpXeG1MbkpsWVdSaFlteGxJRDBnYzJWc1ppNTNjbWwwWVdKc1pTQTlJR1poYkhObFhHNWNiaUFnYVdZZ0tDRnpaV3htTGw5eVpXRmtZV0pzWlZOMFlYUmxMbVZ1WkdWa0tTQnpaV3htTG5CMWMyZ29iblZzYkNsY2JpQWdhV1lnS0NGelpXeG1MbDkzY21sMFlXSnNaVk4wWVhSbExtWnBibWx6YUdWa0tTQnpaV3htTG1WdVpDZ3BYRzVjYmlBZ2MyVnNaaTVrWlhOMGNtOTVaV1FnUFNCMGNuVmxYRzRnSUhObGJHWXVZMjl1Ym1WamRHVmtJRDBnWm1Gc2MyVmNiaUFnYzJWc1ppNWZjR05TWldGa2VTQTlJR1poYkhObFhHNGdJSE5sYkdZdVgyTm9ZVzV1Wld4U1pXRmtlU0E5SUdaaGJITmxYRzVjYmlBZ2MyVnNaaTVmWTJoMWJtc2dQU0J1ZFd4c1hHNGdJSE5sYkdZdVgyTmlJRDBnYm5Wc2JGeHVJQ0JqYkdWaGNrbHVkR1Z5ZG1Gc0tITmxiR1l1WDJsdWRHVnlkbUZzS1Z4dUlDQmpiR1ZoY2xScGJXVnZkWFFvYzJWc1ppNWZjbVZqYjI1dVpXTjBWR2x0Wlc5MWRDbGNibHh1SUNCcFppQW9jMlZzWmk1ZmNHTXBJSHRjYmlBZ0lDQjBjbmtnZTF4dUlDQWdJQ0FnYzJWc1ppNWZjR011WTJ4dmMyVW9LVnh1SUNBZ0lIMGdZMkYwWTJnZ0tHVnljaWtnZTMxY2JseHVJQ0FnSUhObGJHWXVYM0JqTG05dWFXTmxZMjl1Ym1WamRHbHZibk4wWVhSbFkyaGhibWRsSUQwZ2JuVnNiRnh1SUNBZ0lITmxiR1l1WDNCakxtOXVjMmxuYm1Gc2FXNW5jM1JoZEdWamFHRnVaMlVnUFNCdWRXeHNYRzRnSUNBZ2MyVnNaaTVmY0dNdWIyNXBZMlZqWVc1a2FXUmhkR1VnUFNCdWRXeHNYRzRnSUgxY2JseHVJQ0JwWmlBb2MyVnNaaTVmWTJoaGJtNWxiQ2tnZTF4dUlDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNCelpXeG1MbDlqYUdGdWJtVnNMbU5zYjNObEtDbGNiaUFnSUNCOUlHTmhkR05vSUNobGNuSXBJSHQ5WEc1Y2JpQWdJQ0J6Wld4bUxsOWphR0Z1Ym1Wc0xtOXViV1Z6YzJGblpTQTlJRzUxYkd4Y2JpQWdJQ0J6Wld4bUxsOWphR0Z1Ym1Wc0xtOXViM0JsYmlBOUlHNTFiR3hjYmlBZ0lDQnpaV3htTGw5amFHRnVibVZzTG05dVkyeHZjMlVnUFNCdWRXeHNYRzRnSUgxY2JpQWdjMlZzWmk1ZmNHTWdQU0J1ZFd4c1hHNGdJSE5sYkdZdVgyTm9ZVzV1Wld3Z1BTQnVkV3hzWEc1Y2JpQWdhV1lnS0dWeWNpa2djMlZzWmk1bGJXbDBLQ2RsY25KdmNpY3NJR1Z5Y2lsY2JpQWdjMlZzWmk1bGJXbDBLQ2RqYkc5elpTY3BYRzU5WEc1Y2JsQmxaWEl1Y0hKdmRHOTBlWEJsTGw5elpYUjFjRVJoZEdFZ1BTQm1kVzVqZEdsdmJpQW9aWFpsYm5RcElIdGNiaUFnZG1GeUlITmxiR1lnUFNCMGFHbHpYRzRnSUhObGJHWXVYMk5vWVc1dVpXd2dQU0JsZG1WdWRDNWphR0Z1Ym1Wc1hHNGdJSE5sYkdZdVkyaGhibTVsYkU1aGJXVWdQU0J6Wld4bUxsOWphR0Z1Ym1Wc0xteGhZbVZzWEc1Y2JpQWdjMlZzWmk1ZlkyaGhibTVsYkM1aWFXNWhjbmxVZVhCbElEMGdKMkZ5Y21GNVluVm1abVZ5SjF4dUlDQnpaV3htTGw5amFHRnVibVZzTG05dWJXVnpjMkZuWlNBOUlITmxiR1l1WDI5dVEyaGhibTVsYkUxbGMzTmhaMlV1WW1sdVpDaHpaV3htS1Z4dUlDQnpaV3htTGw5amFHRnVibVZzTG05dWIzQmxiaUE5SUhObGJHWXVYMjl1UTJoaGJtNWxiRTl3Wlc0dVltbHVaQ2h6Wld4bUtWeHVJQ0J6Wld4bUxsOWphR0Z1Ym1Wc0xtOXVZMnh2YzJVZ1BTQnpaV3htTGw5dmJrTm9ZVzV1Wld4RGJHOXpaUzVpYVc1a0tITmxiR1lwWEc1OVhHNWNibEJsWlhJdWNISnZkRzkwZVhCbExsOXlaV0ZrSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMzFjYmx4dVVHVmxjaTV3Y205MGIzUjVjR1V1WDNkeWFYUmxJRDBnWm5WdVkzUnBiMjRnS0dOb2RXNXJMQ0JsYm1OdlpHbHVaeXdnWTJJcElIdGNiaUFnZG1GeUlITmxiR1lnUFNCMGFHbHpYRzRnSUdsbUlDaHpaV3htTG1SbGMzUnliM2xsWkNrZ2NtVjBkWEp1SUdOaUtHNWxkeUJGY25KdmNpZ25ZMkZ1Ym05MElIZHlhWFJsSUdGbWRHVnlJSEJsWlhJZ2FYTWdaR1Z6ZEhKdmVXVmtKeWtwWEc1Y2JpQWdhV1lnS0hObGJHWXVZMjl1Ym1WamRHVmtLU0I3WEc0Z0lDQWdjMlZzWmk1elpXNWtLR05vZFc1cktWeHVJQ0FnSUdsbUlDaHpaV3htTGw5amFHRnVibVZzTG1KMVptWmxjbVZrUVcxdmRXNTBJRDRnYzJWc1ppNWZiV0Y0UW5WbVptVnlaV1JCYlc5MWJuUXBJSHRjYmlBZ0lDQWdJSE5sYkdZdVgyUmxZblZuS0NkemRHRnlkQ0JpWVdOcmNISmxjM04xY21VNklHSjFabVpsY21Wa1FXMXZkVzUwSUNWa0p5d2djMlZzWmk1ZlkyaGhibTVsYkM1aWRXWm1aWEpsWkVGdGIzVnVkQ2xjYmlBZ0lDQWdJSE5sYkdZdVgyTmlJRDBnWTJKY2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdZMklvYm5Wc2JDbGNiaUFnSUNCOVhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2MyVnNaaTVmWkdWaWRXY29KM2R5YVhSbElHSmxabTl5WlNCamIyNXVaV04wSnlsY2JpQWdJQ0J6Wld4bUxsOWphSFZ1YXlBOUlHTm9kVzVyWEc0Z0lDQWdjMlZzWmk1ZlkySWdQU0JqWWx4dUlDQjlYRzU5WEc1Y2JsQmxaWEl1Y0hKdmRHOTBlWEJsTGw5amNtVmhkR1ZQWm1abGNpQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkbUZ5SUhObGJHWWdQU0IwYUdselhHNGdJR2xtSUNoelpXeG1MbVJsYzNSeWIzbGxaQ2tnY21WMGRYSnVYRzVjYmlBZ2MyVnNaaTVmY0dNdVkzSmxZWFJsVDJabVpYSW9ablZ1WTNScGIyNGdLRzltWm1WeUtTQjdYRzRnSUNBZ2FXWWdLSE5sYkdZdVpHVnpkSEp2ZVdWa0tTQnlaWFIxY201Y2JpQWdJQ0J6Y0dWbFpFaGhZMnNvYjJabVpYSXBYRzRnSUNBZ2IyWm1aWEl1YzJSd0lEMGdjMlZzWmk1elpIQlVjbUZ1YzJadmNtMG9iMlptWlhJdWMyUndLVnh1SUNBZ0lITmxiR1l1WDNCakxuTmxkRXh2WTJGc1JHVnpZM0pwY0hScGIyNG9iMlptWlhJc0lHNXZiM0FzSUhObGJHWXVYMjl1UlhKeWIzSXVZbWx1WkNoelpXeG1LU2xjYmlBZ0lDQjJZWElnYzJWdVpFOW1abVZ5SUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lDQWdjMlZzWmk1ZlpHVmlkV2NvSjNOcFoyNWhiQ2NwWEc0Z0lDQWdJQ0J6Wld4bUxtVnRhWFFvSjNOcFoyNWhiQ2NzSUhObGJHWXVYM0JqTG14dlkyRnNSR1Z6WTNKcGNIUnBiMjRnZkh3Z2IyWm1aWElwWEc0Z0lDQWdmVnh1SUNBZ0lHbG1JQ2h6Wld4bUxuUnlhV05yYkdVZ2ZId2djMlZzWmk1ZmFXTmxRMjl0Y0d4bGRHVXBJSE5sYm1SUFptWmxjaWdwWEc0Z0lDQWdaV3h6WlNCelpXeG1MbTl1WTJVb0oxOXBZMlZEYjIxd2JHVjBaU2NzSUhObGJtUlBabVpsY2lrZ0x5OGdkMkZwZENCbWIzSWdZMkZ1Wkdsa1lYUmxjMXh1SUNCOUxDQnpaV3htTGw5dmJrVnljbTl5TG1KcGJtUW9jMlZzWmlrc0lITmxiR1l1YjJabVpYSkRiMjV6ZEhKaGFXNTBjeWxjYm4xY2JseHVVR1ZsY2k1d2NtOTBiM1I1Y0dVdVgyTnlaV0YwWlVGdWMzZGxjaUE5SUdaMWJtTjBhVzl1SUNncElIdGNiaUFnZG1GeUlITmxiR1lnUFNCMGFHbHpYRzRnSUdsbUlDaHpaV3htTG1SbGMzUnliM2xsWkNrZ2NtVjBkWEp1WEc1Y2JpQWdjMlZzWmk1ZmNHTXVZM0psWVhSbFFXNXpkMlZ5S0daMWJtTjBhVzl1SUNoaGJuTjNaWElwSUh0Y2JpQWdJQ0JwWmlBb2MyVnNaaTVrWlhOMGNtOTVaV1FwSUhKbGRIVnlibHh1SUNBZ0lITndaV1ZrU0dGamF5aGhibk4zWlhJcFhHNGdJQ0FnWVc1emQyVnlMbk5rY0NBOUlITmxiR1l1YzJSd1ZISmhibk5tYjNKdEtHRnVjM2RsY2k1elpIQXBYRzRnSUNBZ2MyVnNaaTVmY0dNdWMyVjBURzlqWVd4RVpYTmpjbWx3ZEdsdmJpaGhibk4zWlhJc0lHNXZiM0FzSUhObGJHWXVYMjl1UlhKeWIzSXVZbWx1WkNoelpXeG1LU2xjYmlBZ0lDQjJZWElnYzJWdVpFRnVjM2RsY2lBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ0lDQWdJSE5sYkdZdVgyUmxZblZuS0NkemFXZHVZV3duS1Z4dUlDQWdJQ0FnYzJWc1ppNWxiV2wwS0NkemFXZHVZV3duTENCelpXeG1MbDl3WXk1c2IyTmhiRVJsYzJOeWFYQjBhVzl1SUh4OElHRnVjM2RsY2lsY2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0hObGJHWXVkSEpwWTJ0c1pTQjhmQ0J6Wld4bUxsOXBZMlZEYjIxd2JHVjBaU2tnYzJWdVpFRnVjM2RsY2lncFhHNGdJQ0FnWld4elpTQnpaV3htTG05dVkyVW9KMTlwWTJWRGIyMXdiR1YwWlNjc0lITmxibVJCYm5OM1pYSXBYRzRnSUgwc0lITmxiR1l1WDI5dVJYSnliM0l1WW1sdVpDaHpaV3htS1N3Z2MyVnNaaTVoYm5OM1pYSkRiMjV6ZEhKaGFXNTBjeWxjYm4xY2JseHVVR1ZsY2k1d2NtOTBiM1I1Y0dVdVgyOXVTV05sUTI5dWJtVmpkR2x2YmxOMFlYUmxRMmhoYm1kbElEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQjJZWElnYzJWc1ppQTlJSFJvYVhOY2JpQWdhV1lnS0hObGJHWXVaR1Z6ZEhKdmVXVmtLU0J5WlhSMWNtNWNiaUFnZG1GeUlHbGpaVWRoZEdobGNtbHVaMU4wWVhSbElEMGdjMlZzWmk1ZmNHTXVhV05sUjJGMGFHVnlhVzVuVTNSaGRHVmNiaUFnZG1GeUlHbGpaVU52Ym01bFkzUnBiMjVUZEdGMFpTQTlJSE5sYkdZdVgzQmpMbWxqWlVOdmJtNWxZM1JwYjI1VGRHRjBaVnh1SUNCelpXeG1MbDlrWldKMVp5Z25hV05sUTI5dWJtVmpkR2x2YmxOMFlYUmxRMmhoYm1kbElDVnpJQ1Z6Snl3Z2FXTmxSMkYwYUdWeWFXNW5VM1JoZEdVc0lHbGpaVU52Ym01bFkzUnBiMjVUZEdGMFpTbGNiaUFnYzJWc1ppNWxiV2wwS0NkcFkyVkRiMjV1WldOMGFXOXVVM1JoZEdWRGFHRnVaMlVuTENCcFkyVkhZWFJvWlhKcGJtZFRkR0YwWlN3Z2FXTmxRMjl1Ym1WamRHbHZibE4wWVhSbEtWeHVJQ0JwWmlBb2FXTmxRMjl1Ym1WamRHbHZibE4wWVhSbElEMDlQU0FuWTI5dWJtVmpkR1ZrSnlCOGZDQnBZMlZEYjI1dVpXTjBhVzl1VTNSaGRHVWdQVDA5SUNkamIyMXdiR1YwWldRbktTQjdYRzRnSUNBZ1kyeGxZWEpVYVcxbGIzVjBLSE5sYkdZdVgzSmxZMjl1Ym1WamRGUnBiV1Z2ZFhRcFhHNGdJQ0FnYzJWc1ppNWZjR05TWldGa2VTQTlJSFJ5ZFdWY2JpQWdJQ0J6Wld4bUxsOXRZWGxpWlZKbFlXUjVLQ2xjYmlBZ2ZWeHVJQ0JwWmlBb2FXTmxRMjl1Ym1WamRHbHZibE4wWVhSbElEMDlQU0FuWkdselkyOXVibVZqZEdWa0p5a2dlMXh1SUNBZ0lHbG1JQ2h6Wld4bUxuSmxZMjl1Ym1WamRGUnBiV1Z5S1NCN1hHNGdJQ0FnSUNBdkx5QkpaaUIxYzJWeUlHaGhjeUJ6WlhRZ1lHOXdkQzV5WldOdmJtNWxZM1JVYVcxbGNtQXNJR0ZzYkc5M0lIUnBiV1VnWm05eUlFbERSU0IwYnlCaGRIUmxiWEIwSUdFZ2NtVmpiMjV1WldOMFhHNGdJQ0FnSUNCamJHVmhjbFJwYldWdmRYUW9jMlZzWmk1ZmNtVmpiMjV1WldOMFZHbHRaVzkxZENsY2JpQWdJQ0FnSUhObGJHWXVYM0psWTI5dWJtVmpkRlJwYldWdmRYUWdQU0J6WlhSVWFXMWxiM1YwS0daMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lDQWdjMlZzWmk1ZlpHVnpkSEp2ZVNncFhHNGdJQ0FnSUNCOUxDQnpaV3htTG5KbFkyOXVibVZqZEZScGJXVnlLVnh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCelpXeG1MbDlrWlhOMGNtOTVLQ2xjYmlBZ0lDQjlYRzRnSUgxY2JpQWdhV1lnS0dsalpVTnZibTVsWTNScGIyNVRkR0YwWlNBOVBUMGdKMk5zYjNObFpDY3BJSHRjYmlBZ0lDQnpaV3htTGw5a1pYTjBjbTk1S0NsY2JpQWdmVnh1ZlZ4dVhHNVFaV1Z5TG5CeWIzUnZkSGx3WlM1ZmJXRjVZbVZTWldGa2VTQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkbUZ5SUhObGJHWWdQU0IwYUdselhHNGdJSE5sYkdZdVgyUmxZblZuS0NkdFlYbGlaVkpsWVdSNUlIQmpJQ1Z6SUdOb1lXNXVaV3dnSlhNbkxDQnpaV3htTGw5d1kxSmxZV1I1TENCelpXeG1MbDlqYUdGdWJtVnNVbVZoWkhrcFhHNGdJR2xtSUNoelpXeG1MbU52Ym01bFkzUmxaQ0I4ZkNCelpXeG1MbDlqYjI1dVpXTjBhVzVuSUh4OElDRnpaV3htTGw5d1kxSmxZV1I1SUh4OElDRnpaV3htTGw5amFHRnVibVZzVW1WaFpIa3BJSEpsZEhWeWJseHVJQ0J6Wld4bUxsOWpiMjV1WldOMGFXNW5JRDBnZEhKMVpWeHVYRzRnSUdsbUlDaDBlWEJsYjJZZ2QybHVaRzkzSUNFOVBTQW5kVzVrWldacGJtVmtKeUFtSmlBaElYZHBibVJ2ZHk1dGIzcFNWRU5RWldWeVEyOXVibVZqZEdsdmJpa2dlMXh1SUNBZ0lITmxiR1l1WDNCakxtZGxkRk4wWVhSektHNTFiR3dzSUdaMWJtTjBhVzl1SUNoeVpYTXBJSHRjYmlBZ0lDQWdJSFpoY2lCcGRHVnRjeUE5SUZ0ZFhHNGdJQ0FnSUNCeVpYTXVabTl5UldGamFDaG1kVzVqZEdsdmJpQW9hWFJsYlNrZ2UxeHVJQ0FnSUNBZ0lDQnBkR1Z0Y3k1d2RYTm9LR2wwWlcwcFhHNGdJQ0FnSUNCOUtWeHVJQ0FnSUNBZ2IyNVRkR0YwY3locGRHVnRjeWxjYmlBZ0lDQjlMQ0J6Wld4bUxsOXZia1Z5Y205eUxtSnBibVFvYzJWc1ppa3BYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdjMlZzWmk1ZmNHTXVaMlYwVTNSaGRITW9ablZ1WTNScGIyNGdLSEpsY3lrZ2UxeHVJQ0FnSUNBZ2RtRnlJR2wwWlcxeklEMGdXMTFjYmlBZ0lDQWdJSEpsY3k1eVpYTjFiSFFvS1M1bWIzSkZZV05vS0daMWJtTjBhVzl1SUNoeVpYTjFiSFFwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR2wwWlcwZ1BTQjdmVnh1SUNBZ0lDQWdJQ0J5WlhOMWJIUXVibUZ0WlhNb0tTNW1iM0pGWVdOb0tHWjFibU4wYVc5dUlDaHVZVzFsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdhWFJsYlZ0dVlXMWxYU0E5SUhKbGMzVnNkQzV6ZEdGMEtHNWhiV1VwWEc0Z0lDQWdJQ0FnSUgwcFhHNGdJQ0FnSUNBZ0lHbDBaVzB1YVdRZ1BTQnlaWE4xYkhRdWFXUmNiaUFnSUNBZ0lDQWdhWFJsYlM1MGVYQmxJRDBnY21WemRXeDBMblI1Y0dWY2JpQWdJQ0FnSUNBZ2FYUmxiUzUwYVcxbGMzUmhiWEFnUFNCeVpYTjFiSFF1ZEdsdFpYTjBZVzF3WEc0Z0lDQWdJQ0FnSUdsMFpXMXpMbkIxYzJnb2FYUmxiU2xjYmlBZ0lDQWdJSDBwWEc0Z0lDQWdJQ0J2YmxOMFlYUnpLR2wwWlcxektWeHVJQ0FnSUgwcFhHNGdJSDFjYmx4dUlDQm1kVzVqZEdsdmJpQnZibE4wWVhSeklDaHBkR1Z0Y3lrZ2UxeHVJQ0FnSUdsMFpXMXpMbVp2Y2tWaFkyZ29ablZ1WTNScGIyNGdLR2wwWlcwcElIdGNiaUFnSUNBZ0lHbG1JQ2hwZEdWdExuUjVjR1VnUFQwOUlDZHlaVzF2ZEdWallXNWthV1JoZEdVbktTQjdYRzRnSUNBZ0lDQWdJSE5sYkdZdWNtVnRiM1JsUVdSa2NtVnpjeUE5SUdsMFpXMHVhWEJCWkdSeVpYTnpYRzRnSUNBZ0lDQWdJSE5sYkdZdWNtVnRiM1JsUm1GdGFXeDVJRDBnSjBsUWRqUW5YRzRnSUNBZ0lDQWdJSE5sYkdZdWNtVnRiM1JsVUc5eWRDQTlJRTUxYldKbGNpaHBkR1Z0TG5CdmNuUk9kVzFpWlhJcFhHNGdJQ0FnSUNBZ0lITmxiR1l1WDJSbFluVm5LRnh1SUNBZ0lDQWdJQ0FnSUNkamIyNXVaV04wSUhKbGJXOTBaVG9nSlhNNkpYTWdLQ1Z6S1Njc1hHNGdJQ0FnSUNBZ0lDQWdjMlZzWmk1eVpXMXZkR1ZCWkdSeVpYTnpMQ0J6Wld4bUxuSmxiVzkwWlZCdmNuUXNJSE5sYkdZdWNtVnRiM1JsUm1GdGFXeDVYRzRnSUNBZ0lDQWdJQ2xjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvYVhSbGJTNTBlWEJsSUQwOVBTQW5iRzlqWVd4allXNWthV1JoZEdVbklDWW1JR2wwWlcwdVkyRnVaR2xrWVhSbFZIbHdaU0E5UFQwZ0oyaHZjM1FuS1NCN1hHNGdJQ0FnSUNBZ0lITmxiR1l1Ykc5allXeEJaR1J5WlhOeklEMGdhWFJsYlM1cGNFRmtaSEpsYzNOY2JpQWdJQ0FnSUNBZ2MyVnNaaTVzYjJOaGJGQnZjblFnUFNCT2RXMWlaWElvYVhSbGJTNXdiM0owVG5WdFltVnlLVnh1SUNBZ0lDQWdJQ0J6Wld4bUxsOWtaV0oxWnlnblkyOXVibVZqZENCc2IyTmhiRG9nSlhNNkpYTW5MQ0J6Wld4bUxteHZZMkZzUVdSa2NtVnpjeXdnYzJWc1ppNXNiMk5oYkZCdmNuUXBYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTbGNibHh1SUNBZ0lITmxiR1l1WDJOdmJtNWxZM1JwYm1jZ1BTQm1ZV3h6WlZ4dUlDQWdJSE5sYkdZdVkyOXVibVZqZEdWa0lEMGdkSEoxWlZ4dVhHNGdJQ0FnYVdZZ0tITmxiR1l1WDJOb2RXNXJLU0I3WEc0Z0lDQWdJQ0J6Wld4bUxuTmxibVFvYzJWc1ppNWZZMmgxYm1zcFhHNGdJQ0FnSUNCelpXeG1MbDlqYUhWdWF5QTlJRzUxYkd4Y2JpQWdJQ0FnSUhObGJHWXVYMlJsWW5WbktDZHpaVzUwSUdOb2RXNXJJR1p5YjIwZ1hDSjNjbWwwWlNCaVpXWnZjbVVnWTI5dWJtVmpkRndpSnlsY2JseHVJQ0FnSUNBZ2RtRnlJR05pSUQwZ2MyVnNaaTVmWTJKY2JpQWdJQ0FnSUhObGJHWXVYMk5pSUQwZ2JuVnNiRnh1SUNBZ0lDQWdZMklvYm5Wc2JDbGNiaUFnSUNCOVhHNWNiaUFnSUNCelpXeG1MbDlwYm5SbGNuWmhiQ0E5SUhObGRFbHVkR1Z5ZG1Gc0tHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ0lDQWdJR2xtSUNnaGMyVnNaaTVmWTJJZ2ZId2dJWE5sYkdZdVgyTm9ZVzV1Wld3Z2ZId2djMlZzWmk1ZlkyaGhibTVsYkM1aWRXWm1aWEpsWkVGdGIzVnVkQ0ErSUhObGJHWXVYMjFoZUVKMVptWmxjbVZrUVcxdmRXNTBLU0J5WlhSMWNtNWNiaUFnSUNBZ0lITmxiR1l1WDJSbFluVm5LQ2RsYm1ScGJtY2dZbUZqYTNCeVpYTnpkWEpsT2lCaWRXWm1aWEpsWkVGdGIzVnVkQ0FsWkNjc0lITmxiR1l1WDJOb1lXNXVaV3d1WW5WbVptVnlaV1JCYlc5MWJuUXBYRzRnSUNBZ0lDQjJZWElnWTJJZ1BTQnpaV3htTGw5allseHVJQ0FnSUNBZ2MyVnNaaTVmWTJJZ1BTQnVkV3hzWEc0Z0lDQWdJQ0JqWWlodWRXeHNLVnh1SUNBZ0lIMHNJREUxTUNsY2JpQWdJQ0JwWmlBb2MyVnNaaTVmYVc1MFpYSjJZV3d1ZFc1eVpXWXBJSE5sYkdZdVgybHVkR1Z5ZG1Gc0xuVnVjbVZtS0NsY2JseHVJQ0FnSUhObGJHWXVYMlJsWW5WbktDZGpiMjV1WldOMEp5bGNiaUFnSUNCelpXeG1MbVZ0YVhRb0oyTnZibTVsWTNRbktWeHVJQ0I5WEc1OVhHNWNibEJsWlhJdWNISnZkRzkwZVhCbExsOXZibE5wWjI1aGJHbHVaMU4wWVhSbFEyaGhibWRsSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNCMllYSWdjMlZzWmlBOUlIUm9hWE5jYmlBZ2FXWWdLSE5sYkdZdVpHVnpkSEp2ZVdWa0tTQnlaWFIxY201Y2JpQWdjMlZzWmk1ZlpHVmlkV2NvSjNOcFoyNWhiR2x1WjFOMFlYUmxRMmhoYm1kbElDVnpKeXdnYzJWc1ppNWZjR011YzJsbmJtRnNhVzVuVTNSaGRHVXBYRzRnSUhObGJHWXVaVzFwZENnbmMybG5ibUZzYVc1blUzUmhkR1ZEYUdGdVoyVW5MQ0J6Wld4bUxsOXdZeTV6YVdkdVlXeHBibWRUZEdGMFpTbGNibjFjYmx4dVVHVmxjaTV3Y205MGIzUjVjR1V1WDI5dVNXTmxRMkZ1Wkdsa1lYUmxJRDBnWm5WdVkzUnBiMjRnS0dWMlpXNTBLU0I3WEc0Z0lIWmhjaUJ6Wld4bUlEMGdkR2hwYzF4dUlDQnBaaUFvYzJWc1ppNWtaWE4wY205NVpXUXBJSEpsZEhWeWJseHVJQ0JwWmlBb1pYWmxiblF1WTJGdVpHbGtZWFJsSUNZbUlITmxiR1l1ZEhKcFkydHNaU2tnZTF4dUlDQWdJSE5sYkdZdVpXMXBkQ2duYzJsbmJtRnNKeXdnZXlCallXNWthV1JoZEdVNklHVjJaVzUwTG1OaGJtUnBaR0YwWlNCOUtWeHVJQ0I5SUdWc2MyVWdhV1lnS0NGbGRtVnVkQzVqWVc1a2FXUmhkR1VwSUh0Y2JpQWdJQ0J6Wld4bUxsOXBZMlZEYjIxd2JHVjBaU0E5SUhSeWRXVmNiaUFnSUNCelpXeG1MbVZ0YVhRb0oxOXBZMlZEYjIxd2JHVjBaU2NwWEc0Z0lIMWNibjFjYmx4dVVHVmxjaTV3Y205MGIzUjVjR1V1WDI5dVEyaGhibTVsYkUxbGMzTmhaMlVnUFNCbWRXNWpkR2x2YmlBb1pYWmxiblFwSUh0Y2JpQWdkbUZ5SUhObGJHWWdQU0IwYUdselhHNGdJR2xtSUNoelpXeG1MbVJsYzNSeWIzbGxaQ2tnY21WMGRYSnVYRzRnSUhaaGNpQmtZWFJoSUQwZ1pYWmxiblF1WkdGMFlWeHVJQ0J6Wld4bUxsOWtaV0oxWnlnbmNtVmhaRG9nSldRZ1lubDBaWE1uTENCa1lYUmhMbUo1ZEdWTVpXNW5kR2dnZkh3Z1pHRjBZUzVzWlc1bmRHZ3BYRzVjYmlBZ2FXWWdLR1JoZEdFZ2FXNXpkR0Z1WTJWdlppQkJjbkpoZVVKMVptWmxjaWtnZTF4dUlDQWdJR1JoZEdFZ1BTQjBiMEoxWm1abGNpaHVaWGNnVldsdWREaEJjbkpoZVNoa1lYUmhLU2xjYmlBZ0lDQnpaV3htTG5CMWMyZ29aR0YwWVNsY2JpQWdmU0JsYkhObElIdGNiaUFnSUNCMGNua2dlMXh1SUNBZ0lDQWdaR0YwWVNBOUlFcFRUMDR1Y0dGeWMyVW9aR0YwWVNsY2JpQWdJQ0I5SUdOaGRHTm9JQ2hsY25JcElIdDlYRzRnSUNBZ2MyVnNaaTVsYldsMEtDZGtZWFJoSnl3Z1pHRjBZU2xjYmlBZ2ZWeHVmVnh1WEc1UVpXVnlMbkJ5YjNSdmRIbHdaUzVmYjI1RGFHRnVibVZzVDNCbGJpQTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkbUZ5SUhObGJHWWdQU0IwYUdselhHNGdJR2xtSUNoelpXeG1MbU52Ym01bFkzUmxaQ0I4ZkNCelpXeG1MbVJsYzNSeWIzbGxaQ2tnY21WMGRYSnVYRzRnSUhObGJHWXVYMlJsWW5WbktDZHZiaUJqYUdGdWJtVnNJRzl3Wlc0bktWeHVJQ0J6Wld4bUxsOWphR0Z1Ym1Wc1VtVmhaSGtnUFNCMGNuVmxYRzRnSUhObGJHWXVYMjFoZVdKbFVtVmhaSGtvS1Z4dWZWeHVYRzVRWldWeUxuQnliM1J2ZEhsd1pTNWZiMjVEYUdGdWJtVnNRMnh2YzJVZ1BTQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lIWmhjaUJ6Wld4bUlEMGdkR2hwYzF4dUlDQnBaaUFvYzJWc1ppNWtaWE4wY205NVpXUXBJSEpsZEhWeWJseHVJQ0J6Wld4bUxsOWtaV0oxWnlnbmIyNGdZMmhoYm01bGJDQmpiRzl6WlNjcFhHNGdJSE5sYkdZdVgyUmxjM1J5YjNrb0tWeHVmVnh1WEc1UVpXVnlMbkJ5YjNSdmRIbHdaUzVmYjI1QlpHUlRkSEpsWVcwZ1BTQm1kVzVqZEdsdmJpQW9aWFpsYm5RcElIdGNiaUFnZG1GeUlITmxiR1lnUFNCMGFHbHpYRzRnSUdsbUlDaHpaV3htTG1SbGMzUnliM2xsWkNrZ2NtVjBkWEp1WEc0Z0lITmxiR1l1WDJSbFluVm5LQ2R2YmlCaFpHUWdjM1J5WldGdEp5bGNiaUFnYzJWc1ppNWxiV2wwS0NkemRISmxZVzBuTENCbGRtVnVkQzV6ZEhKbFlXMHBYRzU5WEc1Y2JsQmxaWEl1Y0hKdmRHOTBlWEJsTGw5dmJrVnljbTl5SUQwZ1puVnVZM1JwYjI0Z0tHVnljaWtnZTF4dUlDQjJZWElnYzJWc1ppQTlJSFJvYVhOY2JpQWdhV1lnS0hObGJHWXVaR1Z6ZEhKdmVXVmtLU0J5WlhSMWNtNWNiaUFnYzJWc1ppNWZaR1ZpZFdjb0oyVnljbTl5SUNWekp5d2daWEp5TG0xbGMzTmhaMlVnZkh3Z1pYSnlLVnh1SUNCelpXeG1MbDlrWlhOMGNtOTVLR1Z5Y2lsY2JuMWNibHh1VUdWbGNpNXdjbTkwYjNSNWNHVXVYMlJsWW5WbklEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQjJZWElnYzJWc1ppQTlJSFJvYVhOY2JpQWdkbUZ5SUdGeVozTWdQU0JiWFM1emJHbGpaUzVqWVd4c0tHRnlaM1Z0Wlc1MGN5bGNiaUFnZG1GeUlHbGtJRDBnYzJWc1ppNWphR0Z1Ym1Wc1RtRnRaU0FtSmlCelpXeG1MbU5vWVc1dVpXeE9ZVzFsTG5OMVluTjBjbWx1Wnlnd0xDQTNLVnh1SUNCaGNtZHpXekJkSUQwZ0oxc25JQ3NnYVdRZ0t5QW5YU0FuSUNzZ1lYSm5jMXN3WFZ4dUlDQmtaV0oxWnk1aGNIQnNlU2h1ZFd4c0xDQmhjbWR6S1Z4dWZWeHVYRzVtZFc1amRHbHZiaUJuWlhSQ2NtOTNjMlZ5VWxSRElDZ3BJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQjNhVzVrYjNjZ1BUMDlJQ2QxYm1SbFptbHVaV1FuS1NCeVpYUjFjbTRnYm5Wc2JGeHVJQ0IyWVhJZ2QzSjBZeUE5SUh0Y2JpQWdJQ0JTVkVOUVpXVnlRMjl1Ym1WamRHbHZiam9nZDJsdVpHOTNMbTF2ZWxKVVExQmxaWEpEYjI1dVpXTjBhVzl1SUh4OElIZHBibVJ2ZHk1U1ZFTlFaV1Z5UTI5dWJtVmpkR2x2YmlCOGZGeHVJQ0FnSUNBZ2QybHVaRzkzTG5kbFltdHBkRkpVUTFCbFpYSkRiMjV1WldOMGFXOXVMRnh1SUNBZ0lGSlVRMU5sYzNOcGIyNUVaWE5qY21sd2RHbHZiam9nZDJsdVpHOTNMbTF2ZWxKVVExTmxjM05wYjI1RVpYTmpjbWx3ZEdsdmJpQjhmRnh1SUNBZ0lDQWdkMmx1Wkc5M0xsSlVRMU5sYzNOcGIyNUVaWE5qY21sd2RHbHZiaUI4ZkNCM2FXNWtiM2N1ZDJWaWEybDBVbFJEVTJWemMybHZia1JsYzJOeWFYQjBhVzl1TEZ4dUlDQWdJRkpVUTBsalpVTmhibVJwWkdGMFpUb2dkMmx1Wkc5M0xtMXZlbEpVUTBsalpVTmhibVJwWkdGMFpTQjhmQ0IzYVc1a2IzY3VVbFJEU1dObFEyRnVaR2xrWVhSbElIeDhYRzRnSUNBZ0lDQjNhVzVrYjNjdWQyVmlhMmwwVWxSRFNXTmxRMkZ1Wkdsa1lYUmxYRzRnSUgxY2JpQWdhV1lnS0NGM2NuUmpMbEpVUTFCbFpYSkRiMjV1WldOMGFXOXVLU0J5WlhSMWNtNGdiblZzYkZ4dUlDQnlaWFIxY200Z2QzSjBZMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQnpjR1ZsWkVoaFkyc2dLRzlpYWlrZ2UxeHVJQ0IyWVhJZ2N5QTlJRzlpYWk1elpIQXVjM0JzYVhRb0oySTlRVk02TXpBbktWeHVJQ0JwWmlBb2N5NXNaVzVuZEdnZ1BpQXhLU0J2WW1vdWMyUndJRDBnYzFzd1hTQXJJQ2RpUFVGVE9qRTJNemcwTURBbklDc2djMXN4WFZ4dWZWeHVYRzVtZFc1amRHbHZiaUJ1YjI5d0lDZ3BJSHQ5WEc0aVhYMD0iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsInZhciBoYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRzLCBiYXNlKSB7XG4gICAgaWYgKCFiYXNlKSBiYXNlID0gMTY7XG4gICAgaWYgKGJpdHMgPT09IHVuZGVmaW5lZCkgYml0cyA9IDEyODtcbiAgICBpZiAoYml0cyA8PSAwKSByZXR1cm4gJzAnO1xuICAgIFxuICAgIHZhciBkaWdpdHMgPSBNYXRoLmxvZyhNYXRoLnBvdygyLCBiaXRzKSkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICBmb3IgKHZhciBpID0gMjsgZGlnaXRzID09PSBJbmZpbml0eTsgaSAqPSAyKSB7XG4gICAgICAgIGRpZ2l0cyA9IE1hdGgubG9nKE1hdGgucG93KDIsIGJpdHMgLyBpKSkgLyBNYXRoLmxvZyhiYXNlKSAqIGk7XG4gICAgfVxuICAgIFxuICAgIHZhciByZW0gPSBkaWdpdHMgLSBNYXRoLmZsb29yKGRpZ2l0cyk7XG4gICAgXG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5mbG9vcihkaWdpdHMpOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgcmVzID0geCArIHJlcztcbiAgICB9XG4gICAgXG4gICAgaWYgKHJlbSkge1xuICAgICAgICB2YXIgYiA9IE1hdGgucG93KGJhc2UsIHJlbSk7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYikudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIHJlcyA9IHggKyByZXM7XG4gICAgfVxuICAgIFxuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChyZXMsIGJhc2UpO1xuICAgIGlmIChwYXJzZWQgIT09IEluZmluaXR5ICYmIHBhcnNlZCA+PSBNYXRoLnBvdygyLCBiaXRzKSkge1xuICAgICAgICByZXR1cm4gaGF0KGJpdHMsIGJhc2UpXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIHJlcztcbn07XG5cbmhhdC5yYWNrID0gZnVuY3Rpb24gKGJpdHMsIGJhc2UsIGV4cGFuZEJ5KSB7XG4gICAgdmFyIGZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGl0ZXJzID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGl0ZXJzICsrID4gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kQnkpIGJpdHMgKz0gZXhwYW5kQnk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IElEIGNvbGxpc2lvbnMsIHVzZSBtb3JlIGJpdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaWQgPSBoYXQoYml0cywgYmFzZSk7XG4gICAgICAgIH0gd2hpbGUgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhhdHMsIGlkKSk7XG4gICAgICAgIFxuICAgICAgICBoYXRzW2lkXSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIHZhciBoYXRzID0gZm4uaGF0cyA9IHt9O1xuICAgIFxuICAgIGZuLmdldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gZm4uaGF0c1tpZF07XG4gICAgfTtcbiAgICBcbiAgICBmbi5zZXQgPSBmdW5jdGlvbiAoaWQsIHZhbHVlKSB7XG4gICAgICAgIGZuLmhhdHNbaWRdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIFxuICAgIGZuLmJpdHMgPSBiaXRzIHx8IDEyODtcbiAgICBmbi5iYXNlID0gYmFzZSB8fCAxNjtcbiAgICByZXR1cm4gZm47XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyAgICAgID0gaXNUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkuc3RyaWN0ID0gaXNTdHJpY3RUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkubG9vc2UgID0gaXNMb29zZVR5cGVkQXJyYXlcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIG5hbWVzID0ge1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MTZBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgICAgaXNTdHJpY3RUeXBlZEFycmF5KGFycilcbiAgICB8fCBpc0xvb3NlVHlwZWRBcnJheShhcnIpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGFyciBpbnN0YW5jZW9mIEludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBJbnQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuICApXG59XG5cbmZ1bmN0aW9uIGlzTG9vc2VUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gbmFtZXNbdG9TdHJpbmcuY2FsbChhcnIpXVxufVxuIiwiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iLCJ2YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5Jylcbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KG9uY2UpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZCkgcmV0dXJuIGYudmFsdWVcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4vKipcbiAqIENvbnZlcnQgYSB0eXBlZCBhcnJheSB0byBhIEJ1ZmZlciB3aXRob3V0IGEgY29weVxuICpcbiAqIEF1dGhvcjogICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogTGljZW5zZTogIE1JVFxuICpcbiAqIGBucG0gaW5zdGFsbCB0eXBlZGFycmF5LXRvLWJ1ZmZlcmBcbiAqL1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWRhcnJheScpLnN0cmljdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgLy8gSWYgYEJ1ZmZlcmAgaXMgdGhlIGJyb3dzZXIgYGJ1ZmZlcmAgbW9kdWxlLCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLFxuICAvLyB0aGVuIGF2b2lkIGEgY29weS4gT3RoZXJ3aXNlLCBjcmVhdGUgYSBgQnVmZmVyYCB3aXRoIGEgY29weS5cbiAgdmFyIGNvbnN0cnVjdG9yID0gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IEJ1ZmZlci5fYXVnbWVudFxuICAgIDogZnVuY3Rpb24gKGFycikgeyByZXR1cm4gbmV3IEJ1ZmZlcihhcnIpIH1cblxuICBpZiAoYXJyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb25zdHJ1Y3RvcihhcnIpXG4gIH0gZWxzZSBpZiAoYXJyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IobmV3IFVpbnQ4QXJyYXkoYXJyKSlcbiAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoYXJyKSkge1xuICAgIC8vIFVzZSB0aGUgdHlwZWQgYXJyYXkncyB1bmRlcmx5aW5nIEFycmF5QnVmZmVyIHRvIGJhY2sgbmV3IEJ1ZmZlci4gVGhpcyByZXNwZWN0c1xuICAgIC8vIHRoZSBcInZpZXdcIiBvbiB0aGUgQXJyYXlCdWZmZXIsIGkuZS4gYnl0ZU9mZnNldCBhbmQgYnl0ZUxlbmd0aC4gTm8gY29weS5cbiAgICByZXR1cm4gY29uc3RydWN0b3IobmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBVbnN1cHBvcnRlZCB0eXBlLCBqdXN0IHBhc3MgaXQgdGhyb3VnaCB0byB0aGUgYEJ1ZmZlcmAgY29uc3RydWN0b3IuXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJyKVxuICB9XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlqY21GMFpTMWpiM0psTDI1dlpHVmZiVzlrZFd4bGN5OXpjSEpoZVMxM2NuUmpMMjV2WkdWZmJXOWtkV3hsY3k5emFXMXdiR1V0Y0dWbGNpOXViMlJsWDIxdlpIVnNaWE12ZEhsd1pXUmhjbkpoZVMxMGJ5MWlkV1ptWlhJdmFXNWtaWGd1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFLbHh1SUNvZ1EyOXVkbVZ5ZENCaElIUjVjR1ZrSUdGeWNtRjVJSFJ2SUdFZ1FuVm1abVZ5SUhkcGRHaHZkWFFnWVNCamIzQjVYRzRnS2x4dUlDb2dRWFYwYUc5eU9pQWdJRVpsY205emN5QkJZbTkxYTJoaFpHbHFaV2dnUEdabGNtOXpjMEJtWlhKdmMzTXViM0puUGlBOGFIUjBjRG92TDJabGNtOXpjeTV2Y21jK1hHNGdLaUJNYVdObGJuTmxPaUFnVFVsVVhHNGdLbHh1SUNvZ1lHNXdiU0JwYm5OMFlXeHNJSFI1Y0dWa1lYSnlZWGt0ZEc4dFluVm1abVZ5WUZ4dUlDb3ZYRzVjYm5aaGNpQnBjMVI1Y0dWa1FYSnlZWGtnUFNCeVpYRjFhWEpsS0NkcGN5MTBlWEJsWkdGeWNtRjVKeWt1YzNSeWFXTjBYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWm5WdVkzUnBiMjRnS0dGeWNpa2dlMXh1SUNBdkx5QkpaaUJnUW5WbVptVnlZQ0JwY3lCMGFHVWdZbkp2ZDNObGNpQmdZblZtWm1WeVlDQnRiMlIxYkdVc0lHRnVaQ0IwYUdVZ1luSnZkM05sY2lCemRYQndiM0owY3lCMGVYQmxaQ0JoY25KaGVYTXNYRzRnSUM4dklIUm9aVzRnWVhadmFXUWdZU0JqYjNCNUxpQlBkR2hsY25kcGMyVXNJR055WldGMFpTQmhJR0JDZFdabVpYSmdJSGRwZEdnZ1lTQmpiM0I1TGx4dUlDQjJZWElnWTI5dWMzUnlkV04wYjNJZ1BTQkNkV1ptWlhJdVZGbFFSVVJmUVZKU1FWbGZVMVZRVUU5U1ZGeHVJQ0FnSUQ4Z1FuVm1abVZ5TGw5aGRXZHRaVzUwWEc0Z0lDQWdPaUJtZFc1amRHbHZiaUFvWVhKeUtTQjdJSEpsZEhWeWJpQnVaWGNnUW5WbVptVnlLR0Z5Y2lrZ2ZWeHVYRzRnSUdsbUlDaGhjbklnYVc1emRHRnVZMlZ2WmlCVmFXNTBPRUZ5Y21GNUtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdOdmJuTjBjblZqZEc5eUtHRnljaWxjYmlBZ2ZTQmxiSE5sSUdsbUlDaGhjbklnYVc1emRHRnVZMlZ2WmlCQmNuSmhlVUoxWm1abGNpa2dlMXh1SUNBZ0lISmxkSFZ5YmlCamIyNXpkSEoxWTNSdmNpaHVaWGNnVldsdWREaEJjbkpoZVNoaGNuSXBLVnh1SUNCOUlHVnNjMlVnYVdZZ0tHbHpWSGx3WldSQmNuSmhlU2hoY25JcEtTQjdYRzRnSUNBZ0x5OGdWWE5sSUhSb1pTQjBlWEJsWkNCaGNuSmhlU2R6SUhWdVpHVnliSGxwYm1jZ1FYSnlZWGxDZFdabVpYSWdkRzhnWW1GamF5QnVaWGNnUW5WbVptVnlMaUJVYUdseklISmxjM0JsWTNSelhHNGdJQ0FnTHk4Z2RHaGxJRndpZG1sbGQxd2lJRzl1SUhSb1pTQkJjbkpoZVVKMVptWmxjaXdnYVM1bExpQmllWFJsVDJabWMyVjBJR0Z1WkNCaWVYUmxUR1Z1WjNSb0xpQk9ieUJqYjNCNUxseHVJQ0FnSUhKbGRIVnliaUJqYjI1emRISjFZM1J2Y2lodVpYY2dWV2x1ZERoQmNuSmhlU2hoY25JdVluVm1abVZ5TENCaGNuSXVZbmwwWlU5bVpuTmxkQ3dnWVhKeUxtSjVkR1ZNWlc1bmRHZ3BLVnh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJQzh2SUZWdWMzVndjRzl5ZEdWa0lIUjVjR1VzSUdwMWMzUWdjR0Z6Y3lCcGRDQjBhSEp2ZFdkb0lIUnZJSFJvWlNCZ1FuVm1abVZ5WUNCamIyNXpkSEoxWTNSdmNpNWNiaUFnSUNCeVpYUjFjbTRnYm1WM0lFSjFabVpsY2loaGNuSXBYRzRnSUgxY2JuMWNiaUpkZlE9PSIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gU29ydGVkQXJyYXlcbnZhciBzZWFyY2ggPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoJylcblxuZnVuY3Rpb24gU29ydGVkQXJyYXkoY21wLCBhcnIpIHtcbiAgaWYgKHR5cGVvZiBjbXAgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb21wYXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG5cbiAgdGhpcy5hcnIgPSBhcnIgfHwgW11cbiAgdGhpcy5jbXAgPSBjbXBcbn1cblxuU29ydGVkQXJyYXkucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGluZGV4ID0gc2VhcmNoKHRoaXMuYXJyLCBlbGVtZW50LCB0aGlzLmNtcClcbiAgaWYgKGluZGV4IDwgMClcbiAgICBpbmRleCA9IH5pbmRleFxuXG4gIHRoaXMuYXJyLnNwbGljZShpbmRleCwgMCwgZWxlbWVudClcbn1cblxuU29ydGVkQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBpbmRleCA9IHNlYXJjaCh0aGlzLmFyciwgZWxlbWVudCwgdGhpcy5jbXApXG4gIHJldHVybiBpbmRleCA+PSAwXG4gICAgPyBpbmRleFxuICAgIDogLTFcbn1cblxuU29ydGVkQXJyYXkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGluZGV4ID0gc2VhcmNoKHRoaXMuYXJyLCBlbGVtZW50LCB0aGlzLmNtcClcbiAgaWYgKGluZGV4IDwgMClcbiAgICByZXR1cm4gZmFsc2VcblxuICB0aGlzLmFyci5zcGxpY2UoaW5kZXgsIDEpXG4gIHJldHVybiB0cnVlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhheXN0YWNrLCBuZWVkbGUsIGNvbXBhcmF0b3IsIGxvdywgaGlnaCkge1xuICB2YXIgbWlkLCBjbXA7XG5cbiAgaWYobG93ID09PSB1bmRlZmluZWQpXG4gICAgbG93ID0gMDtcblxuICBlbHNlIHtcbiAgICBsb3cgPSBsb3d8MDtcbiAgICBpZihsb3cgPCAwIHx8IGxvdyA+PSBoYXlzdGFjay5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgbG93ZXIgYm91bmRcIik7XG4gIH1cblxuICBpZihoaWdoID09PSB1bmRlZmluZWQpXG4gICAgaGlnaCA9IGhheXN0YWNrLmxlbmd0aCAtIDE7XG5cbiAgZWxzZSB7XG4gICAgaGlnaCA9IGhpZ2h8MDtcbiAgICBpZihoaWdoIDwgbG93IHx8IGhpZ2ggPj0gaGF5c3RhY2subGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIHVwcGVyIGJvdW5kXCIpO1xuICB9XG5cbiAgd2hpbGUobG93IDw9IGhpZ2gpIHtcbiAgICAvKiBOb3RlIHRoYXQgXCIobG93ICsgaGlnaCkgPj4+IDFcIiBtYXkgb3ZlcmZsb3csIGFuZCByZXN1bHRzIGluIGEgdHlwZWNhc3RcbiAgICAgKiB0byBkb3VibGUgKHdoaWNoIGdpdmVzIHRoZSB3cm9uZyByZXN1bHRzKS4gKi9cbiAgICBtaWQgPSBsb3cgKyAoaGlnaCAtIGxvdyA+PiAxKTtcbiAgICBjbXAgPSArY29tcGFyYXRvcihoYXlzdGFja1ttaWRdLCBuZWVkbGUpO1xuXG4gICAgLyogVG9vIGxvdy4gKi9cbiAgICBpZihjbXAgPCAwLjApIFxuICAgICAgbG93ICA9IG1pZCArIDE7XG5cbiAgICAvKiBUb28gaGlnaC4gKi9cbiAgICBlbHNlIGlmKGNtcCA+IDAuMClcbiAgICAgIGhpZ2ggPSBtaWQgLSAxO1xuICAgIFxuICAgIC8qIEtleSBmb3VuZC4gKi9cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWlkO1xuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIH5sb3c7XG59XG4iLCJ2YXIgU29ydGVkQXJyYXkgPSByZXF1aXJlKCdzb3J0ZWQtY21wLWFycmF5Jyk7XG52YXIgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vdnZ3ZWVudHJ5LmpzJykuQ29tcGFyYXRvcjtcbnZhciBWVndFRW50cnkgPSByZXF1aXJlKCcuL3Z2d2VlbnRyeS5qcycpO1xuXG4vKipcbiAqIFxcY2xhc3MgVlZ3RVxuICogXFxicmllZiBjbGFzcyB2ZXJzaW9uIHZlY3RvciB3aXRoIGV4Y2VwdGlvbiBrZWVwcyB0cmFjayBvZiBldmVudHMgaW4gYSBcbiAqIGNvbmNpc2Ugd2F5XG4gKiBcXHBhcmFtIGUgdGhlIGVudHJ5IGNob3NlbiBieSB0aGUgbG9jYWwgc2l0ZSAoMSBlbnRyeSA8LT4gMSBzaXRlKVxuICovXG5mdW5jdGlvbiBWVndFKGUpe1xuICAgIHRoaXMubG9jYWwgPSBuZXcgVlZ3RUVudHJ5KGUpO1xuICAgIHRoaXMudmVjdG9yID0gbmV3IFNvcnRlZEFycmF5KENvbXBhcmF0b3IpO1xuICAgIHRoaXMudmVjdG9yLmluc2VydCh0aGlzLmxvY2FsKTtcbn07XG5cbi8qIVxuICogXFxicmllZiBjbG9uZSBvZiB0aGlzIHZ2d2VcbiAqL1xuVlZ3RS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjbG9uZVZWd0UgPSBuZXcgVlZ3RSh0aGlzLmxvY2FsLmUpO1xuICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLnZlY3Rvci5hcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICBjbG9uZVZWd0UudmVjdG9yLmFycltpXSA9IG5ldyBWVndFRW50cnkodGhpcy52ZWN0b3IuYXJyW2ldLmUpO1xuICAgICAgICBjbG9uZVZWd0UudmVjdG9yLmFycltpXS52ID0gdGhpcy52ZWN0b3IuYXJyW2ldLnY7XG4gICAgICAgIGZvciAodmFyIGo9MDsgajx0aGlzLnZlY3Rvci5hcnJbaV0ueC5sZW5ndGg7ICsrail7XG4gICAgICAgICAgICBjbG9uZVZWd0UudmVjdG9yLmFycltpXS54LnB1c2godGhpcy52ZWN0b3IuYXJyW2ldLnhbal0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY2xvbmVWVndFLnZlY3Rvci5hcnJbaV0uZSA9PT0gdGhpcy5sb2NhbC5lKXtcbiAgICAgICAgICAgIGNsb25lVlZ3RS5sb2NhbCA9IGNsb25lVlZ3RS52ZWN0b3IuYXJyW2ldO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGNsb25lVlZ3RTtcbn07XG5cblZWd0UucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICBmb3IgKHZhciBpPTA7IGk8b2JqZWN0LnZlY3Rvci5hcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICB0aGlzLnZlY3Rvci5hcnJbaV0gPSBuZXcgVlZ3RUVudHJ5KG9iamVjdC52ZWN0b3IuYXJyW2ldLmUpO1xuICAgICAgICB0aGlzLnZlY3Rvci5hcnJbaV0udiA9IG9iamVjdC52ZWN0b3IuYXJyW2ldLnY7XG4gICAgICAgIGZvciAodmFyIGo9MDsgajxvYmplY3QudmVjdG9yLmFycltpXS54Lmxlbmd0aDsgKytqKXtcbiAgICAgICAgICAgIHRoaXMudmVjdG9yLmFycltpXS54LnB1c2gob2JqZWN0LnZlY3Rvci5hcnJbaV0ueFtqXSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvYmplY3QudmVjdG9yLmFycltpXS5lID09PSBvYmplY3QubG9jYWwuZSl7XG4gICAgICAgICAgICB0aGlzLmxvY2FsID0gdGhpcy52ZWN0b3IuYXJyW2ldO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFxcYnJpZWYgaW5jcmVtZW50IHRoZSBlbnRyeSBvZiB0aGUgdmVjdG9yIG9uIGxvY2FsIHVwZGF0ZVxuICogXFxyZXR1cm4ge19lOiBlbnRyeSwgX2M6IGNvdW50ZXJ9IHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoZSBvcGVyYXRpb25cbiAqL1xuVlZ3RS5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmxvY2FsLmluY3JlbWVudCgpO1xuICAgIHJldHVybiB7X2U6IHRoaXMubG9jYWwuZSwgX2M6dGhpcy5sb2NhbC52fTsgXG59O1xuXG5cbi8qKlxuICogXFxicmllZiBpbmNyZW1lbnQgZnJvbSBhIHJlbW90ZSBvcGVyYXRpb25cbiAqIFxccGFyYW0gZWMgdGhlIGVudHJ5IGFuZCBjbG9jayBvZiB0aGUgcmVjZWl2ZWQgZXZlbnQgdG8gYWRkIHN1cHBvc2VkbHkgcmR5XG4gKiB0aGUgdHlwZSBpcyB7X2U6IGVudHJ5LCBfYzogY291bnRlcn1cbiAqL1xuVlZ3RS5wcm90b3R5cGUuaW5jcmVtZW50RnJvbSA9IGZ1bmN0aW9uIChlYyl7XG4gICAgaWYgKCFlYyB8fCAoZWMgJiYgIWVjLl9lKSB8fCAoZWMgJiYgIWVjLl9jKSkge3JldHVybjt9XG4gICAgLy8gIzAgZmluZCB0aGUgZW50cnkgd2l0aGluIHRoZSBhcnJheSBvZiBWVndFbnRyaWVzXG4gICAgdmFyIGluZGV4ID0gdGhpcy52ZWN0b3IuaW5kZXhPZihlYy5fZSk7XG4gICAgaWYgKGluZGV4IDwgMCl7XG4gICAgICAgIC8vICMxIGlmIHRoZSBlbnRyeSBkb2VzIG5vdCBleGlzdCwgaW5pdGlhbGl6ZSBhbmQgaW5jcmVtZW50XG4gICAgICAgIHRoaXMudmVjdG9yLmluc2VydChuZXcgVlZ3RUVudHJ5KGVjLl9lKSk7XG4gICAgICAgIHRoaXMudmVjdG9yLmFyclt0aGlzLnZlY3Rvci5pbmRleE9mKGVjLl9lKV0uaW5jcmVtZW50RnJvbShlYy5fYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIzIgb3RoZXJ3aXNlLCBvbmx5IGluY3JlbWVudFxuICAgICAgICB0aGlzLnZlY3Rvci5hcnJbaW5kZXhdLmluY3JlbWVudEZyb20oZWMuX2MpO1xuICAgIH07XG59O1xuXG5cbi8qKlxuICogXFxicmllZiBjaGVjayBpZiB0aGUgYXJndW1lbnQgYXJlIGNhdXNhbGx5IHJlYWR5IHJlZ2FyZHMgdG8gdGhpcyB2ZWN0b3JcbiAqIFxccGFyYW0gZWMgdGhlIHNpdGUgY2xvY2sgdGhhdCBoYXBwZW4tYmVmb3JlIHRoZSBjdXJyZW50IGV2ZW50XG4gKi9cblZWd0UucHJvdG90eXBlLmlzUmVhZHkgPSBmdW5jdGlvbihlYyl7XG4gICAgdmFyIHJlYWR5ID0gIWVjO1xuICAgIGlmICghcmVhZHkpe1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnZlY3Rvci5pbmRleE9mKGVjLl9lKTtcbiAgICAgICAgcmVhZHkgPSBpbmRleCA+PTAgJiYgZWMuX2MgPD0gdGhpcy52ZWN0b3IuYXJyW2luZGV4XS52ICYmXG4gICAgICAgICAgICB0aGlzLnZlY3Rvci5hcnJbaW5kZXhdLnguaW5kZXhPZihlYy5fYyk8MDtcbiAgICB9O1xuICAgIHJldHVybiByZWFkeTtcbn07XG5cbi8qKlxuICogXFxicmllZiBjaGVjayBpZiB0aGUgbWVzc2FnZSBjb250YWlucyBpbmZvcm1hdGlvbiBhbHJlYWR5IGRlbGl2ZXJlZFxuICogXFxwYXJhbSBlYyB0aGUgc2l0ZSBjbG9jayB0byBjaGVja1xuICovXG5WVndFLnByb3RvdHlwZS5pc0xvd2VyID0gZnVuY3Rpb24oZWMpe1xuICAgIHJldHVybiAoZWMgJiYgdGhpcy5pc1JlYWR5KGVjKSk7XG59O1xuXG4vKipcbiAqIFxcYnJpZWYgbWVyZ2UgdGhlIHZlcnNpb24gdmVjdG9yIGluIGFyZ3VtZW50IHdpdGggdGhpc1xuICogXFxwYXJhbSBvdGhlciB0aGUgb3RoZXIgdmVyc2lvbiB2ZWN0b3IgdG8gbWVyZ2VcbiAqL1xuVlZ3RS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlcil7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlci52ZWN0b3IuYXJyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGVudHJ5ID0gb3RoZXIudmVjdG9yLmFycltpXTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy52ZWN0b3IuaW5kZXhPZihlbnRyeSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApe1xuICAgICAgICAgICAgLy8gIzEgZW50cnkgZG9lcyBub3QgZXhpc3QsIGZ1bGx5IGNvcHkgaXRcbiAgICAgICAgICAgIHZhciBuZXdFbnRyeSA9IG5ldyBWVndFRW50cnkoZW50cnkuZSk7XG4gICAgICAgICAgICBuZXdFbnRyeS52ID0gZW50cnkudjtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZW50cnkueC5sZW5ndGg7ICsrail7XG4gICAgICAgICAgICAgICAgbmV3RW50cnkueC5wdXNoKGVudHJ5Lnhbal0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudmVjdG9yLmluc2VydChuZXdFbnRyeSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy8gIzIgb3RoZXJ3aXNlIG1lcmdlIHRoZSBlbnRyaWVzXG4gICAgICAgICAgICB2YXIgY3VyckVudHJ5ID0gdGhpcy52ZWN0b3IuYXJyW2ldO1xuICAgICAgICAgICAgLy8gIzJBIHJlbW92ZSB0aGUgZXhjZXB0aW9uIGZyb20gb3VyIHZlY3RvclxuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGo8Y3VyckVudHJ5LngubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckVudHJ5Lnhbal08ZW50cnkudiAmJlxuICAgICAgICAgICAgICAgICAgICBlbnRyeS54LmluZGV4T2YoY3VyckVudHJ5Lnhbal0pPDApe1xuICAgICAgICAgICAgICAgICAgICBjdXJyRW50cnkueC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gIzJCIGFkZCB0aGUgbmV3IGV4Y2VwdGlvbnNcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGo8ZW50cnkueC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS54W2pdID4gY3VyckVudHJ5LnYgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VyckVudHJ5LnguaW5kZXhPZihlbnRyeS54W2pdKTwwKXtcbiAgICAgICAgICAgICAgICAgICAgY3VyckVudHJ5LngucHVzaChlbnRyeS54W2pdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdXJyRW50cnkudiA9IE1hdGgubWF4KGN1cnJFbnRyeS52LCBlbnRyeS52KTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWVndFO1xuXG4iLCJcbi8qIVxuICBcXGJyaWVmIGNyZWF0ZSBhbiBlbnRyeSBvZiB0aGUgdmVyc2lvbiB2ZWN0b3Igd2l0aCBleGNlcHRpb25zIGNvbnRhaW5pbmcgdGhlXG4gIGluZGV4IG9mIHRoZSBlbnRyeSwgdGhlIHZhbHVlIHYgdGhhdCBjcmVhdGVzIGEgY29udGlndW91cyBpbnRlcnZhbFxuICBmcm9tIDAgdG8gdiwgYW4gYXJyYXkgb2YgaW50ZWdlcnMgdGhhdCBjb250YWluIHRoZSBvcGVyYXRpb25zIGxvd2VyIHRvIHYgdGhhdFxuICBoYXZlIG5vdCBiZWVuIHJlY2VpdmVkIHlldFxuICBcXHBhcmFtIGUgdGhlIGVudHJ5IGluIHRoZSBpbnRlcnZhbCB2ZXJzaW9uIHZlY3RvclxuKi9cbmZ1bmN0aW9uIFZWd0VFbnRyeShlKXtcbiAgICB0aGlzLmUgPSBlOyAgIFxuICAgIHRoaXMudiA9IDA7XG4gICAgdGhpcy54ID0gW107XG59O1xuXG4vKiFcbiAqIFxcYnJpZWYgbG9jYWwgY291bnRlciBpbmNyZW1lbnRlZFxuICovXG5WVndFRW50cnkucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy52ICs9IDE7XG59O1xuXG4vKipcbiAqIFxcYnJpZWYgaW5jcmVtZW50IGZyb20gYSByZW1vdGUgb3BlcmF0aW9uXG4gKiBcXHBhcmFtIGMgdGhlIGNvdW50ZXIgb2YgdGhlIG9wZXJhdGlvbiB0byBhZGQgdG8gdGhpcyBcbiAqL1xuVlZ3RUVudHJ5LnByb3RvdHlwZS5pbmNyZW1lbnRGcm9tID0gZnVuY3Rpb24oYyl7XG4gICAgLy8gIzEgY2hlY2sgaWYgdGhlIGNvdW50ZXIgaXMgaW5jbHVkZWQgaW4gdGhlIGV4Y2VwdGlvbnNcbiAgICBpZiAoYyA8IHRoaXMudil7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMueC5pbmRleE9mKGMpO1xuICAgICAgICBpZiAoaW5kZXg+PTApeyAvLyB0aGUgZXhjZXB0aW9uIGlzIGZvdW5kXG4gICAgICAgICAgICB0aGlzLnguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vICMyIGlmIHRoZSB2YWx1ZSBpcyArMSBjb21wYXJlZCB0byB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgdmVjdG9yXG4gICAgaWYgKGMgPT0gKHRoaXMudiArIDEpKXtcbiAgICAgICAgdGhpcy52ICs9IDE7XG4gICAgfTtcbiAgICAvLyAjMyBvdGhlcndpc2UgZXhjZXB0aW9uIGFyZSBtYWRlXG4gICAgaWYgKGMgPiAodGhpcy52ICsgMSkpe1xuICAgICAgICBmb3IgKHZhciBpID0gKHRoaXMudiArIDEpOyBpPGM7ICsraSl7XG4gICAgICAgICAgICB0aGlzLngucHVzaChpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52ID0gYztcbiAgICB9O1xufTtcblxuLyohXG4gKiBcXGJyaWVmIGNvbXBhcmlzb24gZnVuY3Rpb24gYmV0d2VlbiB0d28gVlZ3RSBlbnRyaWVzXG4gKiBcXHBhcmFtIGEgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIFxccGFyYW0gYiB0aGUgc2Vjb25kIGVsZW1lbnRcbiAqIFxccmV0dXJuIC0xIGlmIGEgPCBiLCAxIGlmIGEgPiBiLCAwIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBDb21wYXJhdG9yIChhLCBiKXtcbiAgICB2YXIgYUVudHJ5ID0gKGEuZSkgfHwgYTtcbiAgICB2YXIgYkVudHJ5ID0gKGIuZSkgfHwgYjtcbiAgICBpZiAoYUVudHJ5IDwgYkVudHJ5KXsgcmV0dXJuIC0xOyB9O1xuICAgIGlmIChhRW50cnkgPiBiRW50cnkpeyByZXR1cm4gIDE7IH07XG4gICAgcmV0dXJuIDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZWd0VFbnRyeTtcbm1vZHVsZS5leHBvcnRzLkNvbXBhcmF0b3IgPSBDb21wYXJhdG9yO1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7VHlwZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZSkge1xuICBpZiAoIWRlYnVnLmVuYWJsZWQobmFtZSkpIHJldHVybiBmdW5jdGlvbigpe307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZtdCl7XG4gICAgZm10ID0gY29lcmNlKGZtdCk7XG5cbiAgICB2YXIgY3VyciA9IG5ldyBEYXRlO1xuICAgIHZhciBtcyA9IGN1cnIgLSAoZGVidWdbbmFtZV0gfHwgY3Vycik7XG4gICAgZGVidWdbbmFtZV0gPSBjdXJyO1xuXG4gICAgZm10ID0gbmFtZVxuICAgICAgKyAnICdcbiAgICAgICsgZm10XG4gICAgICArICcgKycgKyBkZWJ1Zy5odW1hbml6ZShtcyk7XG5cbiAgICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOFxuICAgIC8vIHdoZXJlIGBjb25zb2xlLmxvZ2AgZG9lc24ndCBoYXZlICdhcHBseSdcbiAgICB3aW5kb3cuY29uc29sZVxuICAgICAgJiYgY29uc29sZS5sb2dcbiAgICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcy5cbiAqL1xuXG5kZWJ1Zy5uYW1lcyA9IFtdO1xuZGVidWcuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmRlYnVnLmVuYWJsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UuZGVidWcgPSBuYW1lO1xuICB9IGNhdGNoKGUpe31cblxuICB2YXIgc3BsaXQgPSAobmFtZSB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKVxuICAgICwgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYW1lID0gc3BsaXRbaV0ucmVwbGFjZSgnKicsICcuKj8nKTtcbiAgICBpZiAobmFtZVswXSA9PT0gJy0nKSB7XG4gICAgICBkZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZS5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZSArICckJykpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmRlYnVnLmRpc2FibGUgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zy5lbmFibGUoJycpO1xufTtcblxuLyoqXG4gKiBIdW1hbml6ZSB0aGUgZ2l2ZW4gYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZGVidWcuaHVtYW5pemUgPSBmdW5jdGlvbihtcykge1xuICB2YXIgc2VjID0gMTAwMFxuICAgICwgbWluID0gNjAgKiAxMDAwXG4gICAgLCBob3VyID0gNjAgKiBtaW47XG5cbiAgaWYgKG1zID49IGhvdXIpIHJldHVybiAobXMgLyBob3VyKS50b0ZpeGVkKDEpICsgJ2gnO1xuICBpZiAobXMgPj0gbWluKSByZXR1cm4gKG1zIC8gbWluKS50b0ZpeGVkKDEpICsgJ20nO1xuICBpZiAobXMgPj0gc2VjKSByZXR1cm4gKG1zIC8gc2VjIHwgMCkgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZW5hYmxlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGRlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGRlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuLy8gcGVyc2lzdFxuXG50cnkge1xuICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkgZGVidWcuZW5hYmxlKGxvY2FsU3RvcmFnZS5kZWJ1Zyk7XG59IGNhdGNoKGUpe31cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSAgcmVxdWlyZSgnLi9saWIvJyk7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZWpzb24gPSByZXF1aXJlKCdwYXJzZWpzb24nKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe31cblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdCA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6XG4gICAgKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdCkge1xuICAgIHZhciBwaWVjZXMgPSBvcHRzLmhvc3Quc3BsaXQoJzonKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGllY2VzLnNoaWZ0KCk7XG4gICAgaWYgKHBpZWNlcy5sZW5ndGgpIHtcbiAgICAgIG9wdHMucG9ydCA9IHBpZWNlcy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG4gICAgICAgbG9jYXRpb24ucG9ydCA6XG4gICAgICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZFxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHZhciB0cmFuc3BvcnQ7XG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuICAgICwgZmFpbGVkID0gZmFsc2VcbiAgICAsIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcbiAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKXtcbiAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCgpe1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwdWJsaWNcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcmV2QnVmZmVyTGVuOyBpKyspIHtcbiAgICBpZiAodGhpcy5jYWxsYmFja0J1ZmZlcltpXSkge1xuICAgICAgdGhpcy5jYWxsYmFja0J1ZmZlcltpXSgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBmbikge1xuICBpZiAoJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFja2V0ID0geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIucHVzaChmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuICAgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgaW4gbmV4dCB0aWNrLCBzbyBkZXZlbG9wZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgICBzZWxmLmNhbGxiYWNrQnVmZmVyID0gW107XG4gICAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgIH0sIDApO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWxibWRwYm1VdWFXOHRZMnhwWlc1MEwyeHBZaTl6YjJOclpYUXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaXBjYmlBcUlFMXZaSFZzWlNCa1pYQmxibVJsYm1OcFpYTXVYRzRnS2k5Y2JseHVkbUZ5SUhSeVlXNXpjRzl5ZEhNZ1BTQnlaWEYxYVhKbEtDY3VMM1J5WVc1emNHOXlkSE1uS1R0Y2JuWmhjaUJGYldsMGRHVnlJRDBnY21WeGRXbHlaU2duWTI5dGNHOXVaVzUwTFdWdGFYUjBaWEluS1R0Y2JuWmhjaUJrWldKMVp5QTlJSEpsY1hWcGNtVW9KMlJsWW5Wbkp5a29KMlZ1WjJsdVpTNXBieTFqYkdsbGJuUTZjMjlqYTJWMEp5azdYRzUyWVhJZ2FXNWtaWGdnUFNCeVpYRjFhWEpsS0NkcGJtUmxlRzltSnlrN1hHNTJZWElnY0dGeWMyVnlJRDBnY21WeGRXbHlaU2duWlc1bmFXNWxMbWx2TFhCaGNuTmxjaWNwTzF4dWRtRnlJSEJoY25ObGRYSnBJRDBnY21WeGRXbHlaU2duY0dGeWMyVjFjbWtuS1R0Y2JuWmhjaUJ3WVhKelpXcHpiMjRnUFNCeVpYRjFhWEpsS0Nkd1lYSnpaV3B6YjI0bktUdGNiblpoY2lCd1lYSnpaWEZ6SUQwZ2NtVnhkV2x5WlNnbmNHRnljMlZ4Y3ljcE8xeHVYRzR2S2lwY2JpQXFJRTF2WkhWc1pTQmxlSEJ2Y25SekxseHVJQ292WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1UyOWphMlYwTzF4dVhHNHZLaXBjYmlBcUlFNXZiM0FnWm5WdVkzUnBiMjR1WEc0Z0tseHVJQ29nUUdGd2FTQndjbWwyWVhSbFhHNGdLaTljYmx4dVpuVnVZM1JwYjI0Z2JtOXZjQ2dwZTMxY2JseHVMeW9xWEc0Z0tpQlRiMk5yWlhRZ1kyOXVjM1J5ZFdOMGIzSXVYRzRnS2x4dUlDb2dRSEJoY21GdElIdFRkSEpwYm1kOFQySnFaV04wZlNCMWNta2diM0lnYjNCMGFXOXVjMXh1SUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUc5d2RHbHZibk5jYmlBcUlFQmhjR2tnY0hWaWJHbGpYRzRnS2k5Y2JseHVablZ1WTNScGIyNGdVMjlqYTJWMEtIVnlhU3dnYjNCMGN5bDdYRzRnSUdsbUlDZ2hLSFJvYVhNZ2FXNXpkR0Z1WTJWdlppQlRiMk5yWlhRcEtTQnlaWFIxY200Z2JtVjNJRk52WTJ0bGRDaDFjbWtzSUc5d2RITXBPMXh1WEc0Z0lHOXdkSE1nUFNCdmNIUnpJSHg4SUh0OU8xeHVYRzRnSUdsbUlDaDFjbWtnSmlZZ0oyOWlhbVZqZENjZ1BUMGdkSGx3Wlc5bUlIVnlhU2tnZTF4dUlDQWdJRzl3ZEhNZ1BTQjFjbWs3WEc0Z0lDQWdkWEpwSUQwZ2JuVnNiRHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaDFjbWtwSUh0Y2JpQWdJQ0IxY21rZ1BTQndZWEp6WlhWeWFTaDFjbWtwTzF4dUlDQWdJRzl3ZEhNdWFHOXpkQ0E5SUhWeWFTNW9iM04wTzF4dUlDQWdJRzl3ZEhNdWMyVmpkWEpsSUQwZ2RYSnBMbkJ5YjNSdlkyOXNJRDA5SUNkb2RIUndjeWNnZkh3Z2RYSnBMbkJ5YjNSdlkyOXNJRDA5SUNkM2MzTW5PMXh1SUNBZ0lHOXdkSE11Y0c5eWRDQTlJSFZ5YVM1d2IzSjBPMXh1SUNBZ0lHbG1JQ2gxY21rdWNYVmxjbmtwSUc5d2RITXVjWFZsY25rZ1BTQjFjbWt1Y1hWbGNuazdYRzRnSUgxY2JseHVJQ0IwYUdsekxuTmxZM1Z5WlNBOUlHNTFiR3dnSVQwZ2IzQjBjeTV6WldOMWNtVWdQeUJ2Y0hSekxuTmxZM1Z5WlNBNlhHNGdJQ0FnS0dkc2IySmhiQzVzYjJOaGRHbHZiaUFtSmlBbmFIUjBjSE02SnlBOVBTQnNiMk5oZEdsdmJpNXdjbTkwYjJOdmJDazdYRzVjYmlBZ2FXWWdLRzl3ZEhNdWFHOXpkQ2tnZTF4dUlDQWdJSFpoY2lCd2FXVmpaWE1nUFNCdmNIUnpMbWh2YzNRdWMzQnNhWFFvSnpvbktUdGNiaUFnSUNCdmNIUnpMbWh2YzNSdVlXMWxJRDBnY0dsbFkyVnpMbk5vYVdaMEtDazdYRzRnSUNBZ2FXWWdLSEJwWldObGN5NXNaVzVuZEdncElIdGNiaUFnSUNBZ0lHOXdkSE11Y0c5eWRDQTlJSEJwWldObGN5NXdiM0FvS1R0Y2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0NGdmNIUnpMbkJ2Y25RcElIdGNiaUFnSUNBZ0lDOHZJR2xtSUc1dklIQnZjblFnYVhNZ2MzQmxZMmxtYVdWa0lHMWhiblZoYkd4NUxDQjFjMlVnZEdobElIQnliM1J2WTI5c0lHUmxabUYxYkhSY2JpQWdJQ0FnSUc5d2RITXVjRzl5ZENBOUlIUm9hWE11YzJWamRYSmxJRDhnSnpRME15Y2dPaUFuT0RBbk8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lIUm9hWE11WVdkbGJuUWdQU0J2Y0hSekxtRm5aVzUwSUh4OElHWmhiSE5sTzF4dUlDQjBhR2x6TG1odmMzUnVZVzFsSUQwZ2IzQjBjeTVvYjNOMGJtRnRaU0I4ZkZ4dUlDQWdJQ2huYkc5aVlXd3ViRzlqWVhScGIyNGdQeUJzYjJOaGRHbHZiaTVvYjNOMGJtRnRaU0E2SUNkc2IyTmhiR2h2YzNRbktUdGNiaUFnZEdocGN5NXdiM0owSUQwZ2IzQjBjeTV3YjNKMElIeDhJQ2huYkc5aVlXd3ViRzlqWVhScGIyNGdKaVlnYkc5allYUnBiMjR1Y0c5eWRDQS9YRzRnSUNBZ0lDQWdiRzlqWVhScGIyNHVjRzl5ZENBNlhHNGdJQ0FnSUNBZ0tIUm9hWE11YzJWamRYSmxJRDhnTkRReklEb2dPREFwS1R0Y2JpQWdkR2hwY3k1eGRXVnllU0E5SUc5d2RITXVjWFZsY25rZ2ZId2dlMzA3WEc0Z0lHbG1JQ2duYzNSeWFXNW5KeUE5UFNCMGVYQmxiMllnZEdocGN5NXhkV1Z5ZVNrZ2RHaHBjeTV4ZFdWeWVTQTlJSEJoY25ObGNYTXVaR1ZqYjJSbEtIUm9hWE11Y1hWbGNua3BPMXh1SUNCMGFHbHpMblZ3WjNKaFpHVWdQU0JtWVd4elpTQWhQVDBnYjNCMGN5NTFjR2R5WVdSbE8xeHVJQ0IwYUdsekxuQmhkR2dnUFNBb2IzQjBjeTV3WVhSb0lIeDhJQ2N2Wlc1bmFXNWxMbWx2SnlrdWNtVndiR0ZqWlNndlhGd3ZKQzhzSUNjbktTQXJJQ2N2Snp0Y2JpQWdkR2hwY3k1bWIzSmpaVXBUVDA1UUlEMGdJU0Z2Y0hSekxtWnZjbU5sU2xOUFRsQTdYRzRnSUhSb2FYTXVhbk52Ym5BZ1BTQm1ZV3h6WlNBaFBUMGdiM0IwY3k1cWMyOXVjRHRjYmlBZ2RHaHBjeTVtYjNKalpVSmhjMlUyTkNBOUlDRWhiM0IwY3k1bWIzSmpaVUpoYzJVMk5EdGNiaUFnZEdocGN5NWxibUZpYkdWeldFUlNJRDBnSVNGdmNIUnpMbVZ1WVdKc1pYTllSRkk3WEc0Z0lIUm9hWE11ZEdsdFpYTjBZVzF3VUdGeVlXMGdQU0J2Y0hSekxuUnBiV1Z6ZEdGdGNGQmhjbUZ0SUh4OElDZDBKenRjYmlBZ2RHaHBjeTUwYVcxbGMzUmhiWEJTWlhGMVpYTjBjeUE5SUc5d2RITXVkR2x0WlhOMFlXMXdVbVZ4ZFdWemRITTdYRzRnSUhSb2FYTXVkSEpoYm5Od2IzSjBjeUE5SUc5d2RITXVkSEpoYm5Od2IzSjBjeUI4ZkNCYkozQnZiR3hwYm1jbkxDQW5kMlZpYzI5amEyVjBKMTA3WEc0Z0lIUm9hWE11Y21WaFpIbFRkR0YwWlNBOUlDY25PMXh1SUNCMGFHbHpMbmR5YVhSbFFuVm1abVZ5SUQwZ1cxMDdYRzRnSUhSb2FYTXVZMkZzYkdKaFkydENkV1ptWlhJZ1BTQmJYVHRjYmlBZ2RHaHBjeTV3YjJ4cFkzbFFiM0owSUQwZ2IzQjBjeTV3YjJ4cFkzbFFiM0owSUh4OElEZzBNenRjYmlBZ2RHaHBjeTV5WlcxbGJXSmxjbFZ3WjNKaFpHVWdQU0J2Y0hSekxuSmxiV1Z0WW1WeVZYQm5jbUZrWlNCOGZDQm1ZV3h6WlR0Y2JpQWdkR2hwY3k1aWFXNWhjbmxVZVhCbElEMGdiblZzYkR0Y2JpQWdkR2hwY3k1dmJteDVRbWx1WVhKNVZYQm5jbUZrWlhNZ1BTQnZjSFJ6TG05dWJIbENhVzVoY25sVmNHZHlZV1JsY3p0Y2JseHVJQ0F2THlCVFUwd2diM0IwYVc5dWN5Qm1iM0lnVG05a1pTNXFjeUJqYkdsbGJuUmNiaUFnZEdocGN5NXdabmdnUFNCdmNIUnpMbkJtZUNCOGZDQnVkV3hzTzF4dUlDQjBhR2x6TG10bGVTQTlJRzl3ZEhNdWEyVjVJSHg4SUc1MWJHdzdYRzRnSUhSb2FYTXVjR0Z6YzNCb2NtRnpaU0E5SUc5d2RITXVjR0Z6YzNCb2NtRnpaU0I4ZkNCdWRXeHNPMXh1SUNCMGFHbHpMbU5sY25RZ1BTQnZjSFJ6TG1ObGNuUWdmSHdnYm5Wc2JEdGNiaUFnZEdocGN5NWpZU0E5SUc5d2RITXVZMkVnZkh3Z2JuVnNiRHRjYmlBZ2RHaHBjeTVqYVhCb1pYSnpJRDBnYjNCMGN5NWphWEJvWlhKeklIeDhJRzUxYkd3N1hHNGdJSFJvYVhNdWNtVnFaV04wVlc1aGRYUm9iM0pwZW1Wa0lEMGdiM0IwY3k1eVpXcGxZM1JWYm1GMWRHaHZjbWw2WldRZ2ZId2diblZzYkR0Y2JseHVJQ0IwYUdsekxtOXdaVzRvS1R0Y2JuMWNibHh1VTI5amEyVjBMbkJ5YVc5eVYyVmljMjlqYTJWMFUzVmpZMlZ6Y3lBOUlHWmhiSE5sTzF4dVhHNHZLaXBjYmlBcUlFMXBlQ0JwYmlCZ1JXMXBkSFJsY21BdVhHNGdLaTljYmx4dVJXMXBkSFJsY2loVGIyTnJaWFF1Y0hKdmRHOTBlWEJsS1R0Y2JseHVMeW9xWEc0Z0tpQlFjbTkwYjJOdmJDQjJaWEp6YVc5dUxseHVJQ3BjYmlBcUlFQmhjR2tnY0hWaWJHbGpYRzRnS2k5Y2JseHVVMjlqYTJWMExuQnliM1J2WTI5c0lEMGdjR0Z5YzJWeUxuQnliM1J2WTI5c095QXZMeUIwYUdseklHbHpJR0Z1SUdsdWRGeHVYRzR2S2lwY2JpQXFJRVY0Y0c5elpTQmtaWEJ6SUdadmNpQnNaV2RoWTNrZ1kyOXRjR0YwYVdKcGJHbDBlVnh1SUNvZ1lXNWtJSE4wWVc1a1lXeHZibVVnWW5KdmQzTmxjaUJoWTJObGMzTXVYRzRnS2k5Y2JseHVVMjlqYTJWMExsTnZZMnRsZENBOUlGTnZZMnRsZER0Y2JsTnZZMnRsZEM1VWNtRnVjM0J2Y25RZ1BTQnlaWEYxYVhKbEtDY3VMM1J5WVc1emNHOXlkQ2NwTzF4dVUyOWphMlYwTG5SeVlXNXpjRzl5ZEhNZ1BTQnlaWEYxYVhKbEtDY3VMM1J5WVc1emNHOXlkSE1uS1R0Y2JsTnZZMnRsZEM1d1lYSnpaWElnUFNCeVpYRjFhWEpsS0NkbGJtZHBibVV1YVc4dGNHRnljMlZ5SnlrN1hHNWNiaThxS2x4dUlDb2dRM0psWVhSbGN5QjBjbUZ1YzNCdmNuUWdiMllnZEdobElHZHBkbVZ1SUhSNWNHVXVYRzRnS2x4dUlDb2dRSEJoY21GdElIdFRkSEpwYm1kOUlIUnlZVzV6Y0c5eWRDQnVZVzFsWEc0Z0tpQkFjbVYwZFhKdUlIdFVjbUZ1YzNCdmNuUjlYRzRnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFxTDF4dVhHNVRiMk5yWlhRdWNISnZkRzkwZVhCbExtTnlaV0YwWlZSeVlXNXpjRzl5ZENBOUlHWjFibU4wYVc5dUlDaHVZVzFsS1NCN1hHNGdJR1JsWW5WbktDZGpjbVZoZEdsdVp5QjBjbUZ1YzNCdmNuUWdYQ0lsYzF3aUp5d2dibUZ0WlNrN1hHNGdJSFpoY2lCeGRXVnllU0E5SUdOc2IyNWxLSFJvYVhNdWNYVmxjbmtwTzF4dVhHNGdJQzh2SUdGd2NHVnVaQ0JsYm1kcGJtVXVhVzhnY0hKdmRHOWpiMndnYVdSbGJuUnBabWxsY2x4dUlDQnhkV1Z5ZVM1RlNVOGdQU0J3WVhKelpYSXVjSEp2ZEc5amIydzdYRzVjYmlBZ0x5OGdkSEpoYm5Od2IzSjBJRzVoYldWY2JpQWdjWFZsY25rdWRISmhibk53YjNKMElEMGdibUZ0WlR0Y2JseHVJQ0F2THlCelpYTnphVzl1SUdsa0lHbG1JSGRsSUdGc2NtVmhaSGtnYUdGMlpTQnZibVZjYmlBZ2FXWWdLSFJvYVhNdWFXUXBJSEYxWlhKNUxuTnBaQ0E5SUhSb2FYTXVhV1E3WEc1Y2JpQWdkbUZ5SUhSeVlXNXpjRzl5ZENBOUlHNWxkeUIwY21GdWMzQnZjblJ6VzI1aGJXVmRLSHRjYmlBZ0lDQmhaMlZ1ZERvZ2RHaHBjeTVoWjJWdWRDeGNiaUFnSUNCb2IzTjBibUZ0WlRvZ2RHaHBjeTVvYjNOMGJtRnRaU3hjYmlBZ0lDQndiM0owT2lCMGFHbHpMbkJ2Y25Rc1hHNGdJQ0FnYzJWamRYSmxPaUIwYUdsekxuTmxZM1Z5WlN4Y2JpQWdJQ0J3WVhSb09pQjBhR2x6TG5CaGRHZ3NYRzRnSUNBZ2NYVmxjbms2SUhGMVpYSjVMRnh1SUNBZ0lHWnZjbU5sU2xOUFRsQTZJSFJvYVhNdVptOXlZMlZLVTA5T1VDeGNiaUFnSUNCcWMyOXVjRG9nZEdocGN5NXFjMjl1Y0N4Y2JpQWdJQ0JtYjNKalpVSmhjMlUyTkRvZ2RHaHBjeTVtYjNKalpVSmhjMlUyTkN4Y2JpQWdJQ0JsYm1GaWJHVnpXRVJTT2lCMGFHbHpMbVZ1WVdKc1pYTllSRklzWEc0Z0lDQWdkR2x0WlhOMFlXMXdVbVZ4ZFdWemRITTZJSFJvYVhNdWRHbHRaWE4wWVcxd1VtVnhkV1Z6ZEhNc1hHNGdJQ0FnZEdsdFpYTjBZVzF3VUdGeVlXMDZJSFJvYVhNdWRHbHRaWE4wWVcxd1VHRnlZVzBzWEc0Z0lDQWdjRzlzYVdONVVHOXlkRG9nZEdocGN5NXdiMnhwWTNsUWIzSjBMRnh1SUNBZ0lITnZZMnRsZERvZ2RHaHBjeXhjYmlBZ0lDQndabmc2SUhSb2FYTXVjR1o0TEZ4dUlDQWdJR3RsZVRvZ2RHaHBjeTVyWlhrc1hHNGdJQ0FnY0dGemMzQm9jbUZ6WlRvZ2RHaHBjeTV3WVhOemNHaHlZWE5sTEZ4dUlDQWdJR05sY25RNklIUm9hWE11WTJWeWRDeGNiaUFnSUNCallUb2dkR2hwY3k1allTeGNiaUFnSUNCamFYQm9aWEp6T2lCMGFHbHpMbU5wY0dobGNuTXNYRzRnSUNBZ2NtVnFaV04wVlc1aGRYUm9iM0pwZW1Wa09pQjBhR2x6TG5KbGFtVmpkRlZ1WVhWMGFHOXlhWHBsWkZ4dUlDQjlLVHRjYmx4dUlDQnlaWFIxY200Z2RISmhibk53YjNKME8xeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z1kyeHZibVVnS0c5aWFpa2dlMXh1SUNCMllYSWdieUE5SUh0OU8xeHVJQ0JtYjNJZ0tIWmhjaUJwSUdsdUlHOWlhaWtnZTF4dUlDQWdJR2xtSUNodlltb3VhR0Z6VDNkdVVISnZjR1Z5ZEhrb2FTa3BJSHRjYmlBZ0lDQWdJRzliYVYwZ1BTQnZZbXBiYVYwN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUhKbGRIVnliaUJ2TzF4dWZWeHVYRzR2S2lwY2JpQXFJRWx1YVhScFlXeHBlbVZ6SUhSeVlXNXpjRzl5ZENCMGJ5QjFjMlVnWVc1a0lITjBZWEowY3lCd2NtOWlaUzVjYmlBcVhHNGdLaUJBWVhCcElIQnlhWFpoZEdWY2JpQXFMMXh1VTI5amEyVjBMbkJ5YjNSdmRIbHdaUzV2Y0dWdUlEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQjJZWElnZEhKaGJuTndiM0owTzF4dUlDQnBaaUFvZEdocGN5NXlaVzFsYldKbGNsVndaM0poWkdVZ0ppWWdVMjlqYTJWMExuQnlhVzl5VjJWaWMyOWphMlYwVTNWalkyVnpjeUFtSmlCMGFHbHpMblJ5WVc1emNHOXlkSE11YVc1a1pYaFBaaWduZDJWaWMyOWphMlYwSnlrZ0lUMGdMVEVwSUh0Y2JpQWdJQ0IwY21GdWMzQnZjblFnUFNBbmQyVmljMjlqYTJWMEp6dGNiaUFnZlNCbGJITmxJR2xtSUNnd0lEMDlJSFJvYVhNdWRISmhibk53YjNKMGN5NXNaVzVuZEdncElIdGNiaUFnSUNBdkx5QkZiV2wwSUdWeWNtOXlJRzl1SUc1bGVIUWdkR2xqYXlCemJ5QnBkQ0JqWVc0Z1ltVWdiR2x6ZEdWdVpXUWdkRzljYmlBZ0lDQjJZWElnYzJWc1ppQTlJSFJvYVhNN1hHNGdJQ0FnYzJWMFZHbHRaVzkxZENobWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lITmxiR1l1WlcxcGRDZ25aWEp5YjNJbkxDQW5UbThnZEhKaGJuTndiM0owY3lCaGRtRnBiR0ZpYkdVbktUdGNiaUFnSUNCOUxDQXdLVHRjYmlBZ0lDQnlaWFIxY200N1hHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2RISmhibk53YjNKMElEMGdkR2hwY3k1MGNtRnVjM0J2Y25Seld6QmRPMXh1SUNCOVhHNGdJSFJvYVhNdWNtVmhaSGxUZEdGMFpTQTlJQ2R2Y0dWdWFXNW5KenRjYmx4dUlDQXZMeUJTWlhSeWVTQjNhWFJvSUhSb1pTQnVaWGgwSUhSeVlXNXpjRzl5ZENCcFppQjBhR1VnZEhKaGJuTndiM0owSUdseklHUnBjMkZpYkdWa0lDaHFjMjl1Y0RvZ1ptRnNjMlVwWEc0Z0lIWmhjaUIwY21GdWMzQnZjblE3WEc0Z0lIUnllU0I3WEc0Z0lDQWdkSEpoYm5Od2IzSjBJRDBnZEdocGN5NWpjbVZoZEdWVWNtRnVjM0J2Y25Rb2RISmhibk53YjNKMEtUdGNiaUFnZlNCallYUmphQ0FvWlNrZ2UxeHVJQ0FnSUhSb2FYTXVkSEpoYm5Od2IzSjBjeTV6YUdsbWRDZ3BPMXh1SUNBZ0lIUm9hWE11YjNCbGJpZ3BPMXh1SUNBZ0lISmxkSFZ5Ymp0Y2JpQWdmVnh1WEc0Z0lIUnlZVzV6Y0c5eWRDNXZjR1Z1S0NrN1hHNGdJSFJvYVhNdWMyVjBWSEpoYm5Od2IzSjBLSFJ5WVc1emNHOXlkQ2s3WEc1OU8xeHVYRzR2S2lwY2JpQXFJRk5sZEhNZ2RHaGxJR04xY25KbGJuUWdkSEpoYm5Od2IzSjBMaUJFYVhOaFlteGxjeUIwYUdVZ1pYaHBjM1JwYm1jZ2IyNWxJQ2hwWmlCaGJua3BMbHh1SUNwY2JpQXFJRUJoY0drZ2NISnBkbUYwWlZ4dUlDb3ZYRzVjYmxOdlkydGxkQzV3Y205MGIzUjVjR1V1YzJWMFZISmhibk53YjNKMElEMGdablZ1WTNScGIyNG9kSEpoYm5Od2IzSjBLWHRjYmlBZ1pHVmlkV2NvSjNObGRIUnBibWNnZEhKaGJuTndiM0owSUNWekp5d2dkSEpoYm5Od2IzSjBMbTVoYldVcE8xeHVJQ0IyWVhJZ2MyVnNaaUE5SUhSb2FYTTdYRzVjYmlBZ2FXWWdLSFJvYVhNdWRISmhibk53YjNKMEtTQjdYRzRnSUNBZ1pHVmlkV2NvSjJOc1pXRnlhVzVuSUdWNGFYTjBhVzVuSUhSeVlXNXpjRzl5ZENBbGN5Y3NJSFJvYVhNdWRISmhibk53YjNKMExtNWhiV1VwTzF4dUlDQWdJSFJvYVhNdWRISmhibk53YjNKMExuSmxiVzkyWlVGc2JFeHBjM1JsYm1WeWN5Z3BPMXh1SUNCOVhHNWNiaUFnTHk4Z2MyVjBJSFZ3SUhSeVlXNXpjRzl5ZEZ4dUlDQjBhR2x6TG5SeVlXNXpjRzl5ZENBOUlIUnlZVzV6Y0c5eWREdGNibHh1SUNBdkx5QnpaWFFnZFhBZ2RISmhibk53YjNKMElHeHBjM1JsYm1WeWMxeHVJQ0IwY21GdWMzQnZjblJjYmlBZ0xtOXVLQ2RrY21GcGJpY3NJR1oxYm1OMGFXOXVLQ2w3WEc0Z0lDQWdjMlZzWmk1dmJrUnlZV2x1S0NrN1hHNGdJSDBwWEc0Z0lDNXZiaWduY0dGamEyVjBKeXdnWm5WdVkzUnBiMjRvY0dGamEyVjBLWHRjYmlBZ0lDQnpaV3htTG05dVVHRmphMlYwS0hCaFkydGxkQ2s3WEc0Z0lIMHBYRzRnSUM1dmJpZ25aWEp5YjNJbkxDQm1kVzVqZEdsdmJpaGxLWHRjYmlBZ0lDQnpaV3htTG05dVJYSnliM0lvWlNrN1hHNGdJSDBwWEc0Z0lDNXZiaWduWTJ4dmMyVW5MQ0JtZFc1amRHbHZiaWdwZTF4dUlDQWdJSE5sYkdZdWIyNURiRzl6WlNnbmRISmhibk53YjNKMElHTnNiM05sSnlrN1hHNGdJSDBwTzF4dWZUdGNibHh1THlvcVhHNGdLaUJRY205aVpYTWdZU0IwY21GdWMzQnZjblF1WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRUZEhKcGJtZDlJSFJ5WVc1emNHOXlkQ0J1WVcxbFhHNGdLaUJBWVhCcElIQnlhWFpoZEdWY2JpQXFMMXh1WEc1VGIyTnJaWFF1Y0hKdmRHOTBlWEJsTG5CeWIySmxJRDBnWm5WdVkzUnBiMjRnS0c1aGJXVXBJSHRjYmlBZ1pHVmlkV2NvSjNCeWIySnBibWNnZEhKaGJuTndiM0owSUZ3aUpYTmNJaWNzSUc1aGJXVXBPMXh1SUNCMllYSWdkSEpoYm5Od2IzSjBJRDBnZEdocGN5NWpjbVZoZEdWVWNtRnVjM0J2Y25Rb2JtRnRaU3dnZXlCd2NtOWlaVG9nTVNCOUtWeHVJQ0FnSUN3Z1ptRnBiR1ZrSUQwZ1ptRnNjMlZjYmlBZ0lDQXNJSE5sYkdZZ1BTQjBhR2x6TzF4dVhHNGdJRk52WTJ0bGRDNXdjbWx2Y2xkbFluTnZZMnRsZEZOMVkyTmxjM01nUFNCbVlXeHpaVHRjYmx4dUlDQm1kVzVqZEdsdmJpQnZibFJ5WVc1emNHOXlkRTl3Wlc0b0tYdGNiaUFnSUNCcFppQW9jMlZzWmk1dmJteDVRbWx1WVhKNVZYQm5jbUZrWlhNcElIdGNiaUFnSUNBZ0lIWmhjaUIxY0dkeVlXUmxURzl6WlhOQ2FXNWhjbmtnUFNBaGRHaHBjeTV6ZFhCd2IzSjBjMEpwYm1GeWVTQW1KaUJ6Wld4bUxuUnlZVzV6Y0c5eWRDNXpkWEJ3YjNKMGMwSnBibUZ5ZVR0Y2JpQWdJQ0FnSUdaaGFXeGxaQ0E5SUdaaGFXeGxaQ0I4ZkNCMWNHZHlZV1JsVEc5elpYTkNhVzVoY25rN1hHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNobVlXbHNaV1FwSUhKbGRIVnlianRjYmx4dUlDQWdJR1JsWW5WbktDZHdjbTlpWlNCMGNtRnVjM0J2Y25RZ1hDSWxjMXdpSUc5d1pXNWxaQ2NzSUc1aGJXVXBPMXh1SUNBZ0lIUnlZVzV6Y0c5eWRDNXpaVzVrS0Z0N0lIUjVjR1U2SUNkd2FXNW5KeXdnWkdGMFlUb2dKM0J5YjJKbEp5QjlYU2s3WEc0Z0lDQWdkSEpoYm5Od2IzSjBMbTl1WTJVb0ozQmhZMnRsZENjc0lHWjFibU4wYVc5dUlDaHRjMmNwSUh0Y2JpQWdJQ0FnSUdsbUlDaG1ZV2xzWldRcElISmxkSFZ5Ymp0Y2JpQWdJQ0FnSUdsbUlDZ25jRzl1WnljZ1BUMGdiWE5uTG5SNWNHVWdKaVlnSjNCeWIySmxKeUE5UFNCdGMyY3VaR0YwWVNrZ2UxeHVJQ0FnSUNBZ0lDQmtaV0oxWnlnbmNISnZZbVVnZEhKaGJuTndiM0owSUZ3aUpYTmNJaUJ3YjI1bkp5d2dibUZ0WlNrN1hHNGdJQ0FnSUNBZ0lITmxiR1l1ZFhCbmNtRmthVzVuSUQwZ2RISjFaVHRjYmlBZ0lDQWdJQ0FnYzJWc1ppNWxiV2wwS0NkMWNHZHlZV1JwYm1jbkxDQjBjbUZ1YzNCdmNuUXBPMXh1SUNBZ0lDQWdJQ0JwWmlBb0lYUnlZVzV6Y0c5eWRDa2djbVYwZFhKdU8xeHVJQ0FnSUNBZ0lDQlRiMk5yWlhRdWNISnBiM0pYWldKemIyTnJaWFJUZFdOalpYTnpJRDBnSjNkbFluTnZZMnRsZENjZ1BUMGdkSEpoYm5Od2IzSjBMbTVoYldVN1hHNWNiaUFnSUNBZ0lDQWdaR1ZpZFdjb0ozQmhkWE5wYm1jZ1kzVnljbVZ1ZENCMGNtRnVjM0J2Y25RZ1hDSWxjMXdpSnl3Z2MyVnNaaTUwY21GdWMzQnZjblF1Ym1GdFpTazdYRzRnSUNBZ0lDQWdJSE5sYkdZdWRISmhibk53YjNKMExuQmhkWE5sS0daMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lDQWdJQ0JwWmlBb1ptRnBiR1ZrS1NCeVpYUjFjbTQ3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLQ2RqYkc5elpXUW5JRDA5SUhObGJHWXVjbVZoWkhsVGRHRjBaU2tnY21WMGRYSnVPMXh1SUNBZ0lDQWdJQ0FnSUdSbFluVm5LQ2RqYUdGdVoybHVaeUIwY21GdWMzQnZjblFnWVc1a0lITmxibVJwYm1jZ2RYQm5jbUZrWlNCd1lXTnJaWFFuS1R0Y2JseHVJQ0FnSUNBZ0lDQWdJR05zWldGdWRYQW9LVHRjYmx4dUlDQWdJQ0FnSUNBZ0lITmxiR1l1YzJWMFZISmhibk53YjNKMEtIUnlZVzV6Y0c5eWRDazdYRzRnSUNBZ0lDQWdJQ0FnZEhKaGJuTndiM0owTG5ObGJtUW9XM3NnZEhsd1pUb2dKM1Z3WjNKaFpHVW5JSDFkS1R0Y2JpQWdJQ0FnSUNBZ0lDQnpaV3htTG1WdGFYUW9KM1Z3WjNKaFpHVW5MQ0IwY21GdWMzQnZjblFwTzF4dUlDQWdJQ0FnSUNBZ0lIUnlZVzV6Y0c5eWRDQTlJRzUxYkd3N1hHNGdJQ0FnSUNBZ0lDQWdjMlZzWmk1MWNHZHlZV1JwYm1jZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0FnSUNBZ0lDQnpaV3htTG1ac2RYTm9LQ2s3WEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ1pHVmlkV2NvSjNCeWIySmxJSFJ5WVc1emNHOXlkQ0JjSWlWelhDSWdabUZwYkdWa0p5d2dibUZ0WlNrN1hHNGdJQ0FnSUNBZ0lIWmhjaUJsY25JZ1BTQnVaWGNnUlhKeWIzSW9KM0J5YjJKbElHVnljbTl5SnlrN1hHNGdJQ0FnSUNBZ0lHVnljaTUwY21GdWMzQnZjblFnUFNCMGNtRnVjM0J2Y25RdWJtRnRaVHRjYmlBZ0lDQWdJQ0FnYzJWc1ppNWxiV2wwS0NkMWNHZHlZV1JsUlhKeWIzSW5MQ0JsY25JcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdabkpsWlhwbFZISmhibk53YjNKMEtDa2dlMXh1SUNBZ0lHbG1JQ2htWVdsc1pXUXBJSEpsZEhWeWJqdGNibHh1SUNBZ0lDOHZJRUZ1ZVNCallXeHNZbUZqYXlCallXeHNaV1FnWW5rZ2RISmhibk53YjNKMElITm9iM1ZzWkNCaVpTQnBaMjV2Y21Wa0lITnBibU5sSUc1dmQxeHVJQ0FnSUdaaGFXeGxaQ0E5SUhSeWRXVTdYRzVjYmlBZ0lDQmpiR1ZoYm5Wd0tDazdYRzVjYmlBZ0lDQjBjbUZ1YzNCdmNuUXVZMnh2YzJVb0tUdGNiaUFnSUNCMGNtRnVjM0J2Y25RZ1BTQnVkV3hzTzF4dUlDQjlYRzVjYmlBZ0x5OUlZVzVrYkdVZ1lXNTVJR1Z5Y205eUlIUm9ZWFFnYUdGd2NHVnVjeUIzYUdsc1pTQndjbTlpYVc1blhHNGdJR1oxYm1OMGFXOXVJRzl1WlhKeWIzSW9aWEp5S1NCN1hHNGdJQ0FnZG1GeUlHVnljbTl5SUQwZ2JtVjNJRVZ5Y205eUtDZHdjbTlpWlNCbGNuSnZjam9nSnlBcklHVnljaWs3WEc0Z0lDQWdaWEp5YjNJdWRISmhibk53YjNKMElEMGdkSEpoYm5Od2IzSjBMbTVoYldVN1hHNWNiaUFnSUNCbWNtVmxlbVZVY21GdWMzQnZjblFvS1R0Y2JseHVJQ0FnSUdSbFluVm5LQ2R3Y205aVpTQjBjbUZ1YzNCdmNuUWdYQ0lsYzF3aUlHWmhhV3hsWkNCaVpXTmhkWE5sSUc5bUlHVnljbTl5T2lBbGN5Y3NJRzVoYldVc0lHVnljaWs3WEc1Y2JpQWdJQ0J6Wld4bUxtVnRhWFFvSjNWd1ozSmhaR1ZGY25KdmNpY3NJR1Z5Y205eUtUdGNiaUFnZlZ4dVhHNGdJR1oxYm1OMGFXOXVJRzl1VkhKaGJuTndiM0owUTJ4dmMyVW9LWHRjYmlBZ0lDQnZibVZ5Y205eUtGd2lkSEpoYm5Od2IzSjBJR05zYjNObFpGd2lLVHRjYmlBZ2ZWeHVYRzRnSUM4dlYyaGxiaUIwYUdVZ2MyOWphMlYwSUdseklHTnNiM05sWkNCM2FHbHNaU0IzWlNkeVpTQndjbTlpYVc1blhHNGdJR1oxYm1OMGFXOXVJRzl1WTJ4dmMyVW9LWHRjYmlBZ0lDQnZibVZ5Y205eUtGd2ljMjlqYTJWMElHTnNiM05sWkZ3aUtUdGNiaUFnZlZ4dVhHNGdJQzh2VjJobGJpQjBhR1VnYzI5amEyVjBJR2x6SUhWd1ozSmhaR1ZrSUhkb2FXeGxJSGRsSjNKbElIQnliMkpwYm1kY2JpQWdablZ1WTNScGIyNGdiMjUxY0dkeVlXUmxLSFJ2S1h0Y2JpQWdJQ0JwWmlBb2RISmhibk53YjNKMElDWW1JSFJ2TG01aGJXVWdJVDBnZEhKaGJuTndiM0owTG01aGJXVXBJSHRjYmlBZ0lDQWdJR1JsWW5WbktDZGNJaVZ6WENJZ2QyOXlhM01nTFNCaFltOXlkR2x1WnlCY0lpVnpYQ0luTENCMGJ5NXVZVzFsTENCMGNtRnVjM0J2Y25RdWJtRnRaU2s3WEc0Z0lDQWdJQ0JtY21WbGVtVlVjbUZ1YzNCdmNuUW9LVHRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0F2TDFKbGJXOTJaU0JoYkd3Z2JHbHpkR1Z1WlhKeklHOXVJSFJvWlNCMGNtRnVjM0J2Y25RZ1lXNWtJRzl1SUhObGJHWmNiaUFnWm5WdVkzUnBiMjRnWTJ4bFlXNTFjQ2dwZTF4dUlDQWdJSFJ5WVc1emNHOXlkQzV5WlcxdmRtVk1hWE4wWlc1bGNpZ25iM0JsYmljc0lHOXVWSEpoYm5Od2IzSjBUM0JsYmlrN1hHNGdJQ0FnZEhKaGJuTndiM0owTG5KbGJXOTJaVXhwYzNSbGJtVnlLQ2RsY25KdmNpY3NJRzl1WlhKeWIzSXBPMXh1SUNBZ0lIUnlZVzV6Y0c5eWRDNXlaVzF2ZG1WTWFYTjBaVzVsY2lnblkyeHZjMlVuTENCdmJsUnlZVzV6Y0c5eWRFTnNiM05sS1R0Y2JpQWdJQ0J6Wld4bUxuSmxiVzkyWlV4cGMzUmxibVZ5S0NkamJHOXpaU2NzSUc5dVkyeHZjMlVwTzF4dUlDQWdJSE5sYkdZdWNtVnRiM1psVEdsemRHVnVaWElvSjNWd1ozSmhaR2x1Wnljc0lHOXVkWEJuY21Ga1pTazdYRzRnSUgxY2JseHVJQ0IwY21GdWMzQnZjblF1YjI1alpTZ25iM0JsYmljc0lHOXVWSEpoYm5Od2IzSjBUM0JsYmlrN1hHNGdJSFJ5WVc1emNHOXlkQzV2Ym1ObEtDZGxjbkp2Y2ljc0lHOXVaWEp5YjNJcE8xeHVJQ0IwY21GdWMzQnZjblF1YjI1alpTZ25ZMnh2YzJVbkxDQnZibFJ5WVc1emNHOXlkRU5zYjNObEtUdGNibHh1SUNCMGFHbHpMbTl1WTJVb0oyTnNiM05sSnl3Z2IyNWpiRzl6WlNrN1hHNGdJSFJvYVhNdWIyNWpaU2duZFhCbmNtRmthVzVuSnl3Z2IyNTFjR2R5WVdSbEtUdGNibHh1SUNCMGNtRnVjM0J2Y25RdWIzQmxiaWdwTzF4dVhHNTlPMXh1WEc0dktpcGNiaUFxSUVOaGJHeGxaQ0IzYUdWdUlHTnZibTVsWTNScGIyNGdhWE1nWkdWbGJXVmtJRzl3Wlc0dVhHNGdLbHh1SUNvZ1FHRndhU0J3ZFdKc2FXTmNiaUFxTDF4dVhHNVRiMk5yWlhRdWNISnZkRzkwZVhCbExtOXVUM0JsYmlBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ1pHVmlkV2NvSjNOdlkydGxkQ0J2Y0dWdUp5azdYRzRnSUhSb2FYTXVjbVZoWkhsVGRHRjBaU0E5SUNkdmNHVnVKenRjYmlBZ1UyOWphMlYwTG5CeWFXOXlWMlZpYzI5amEyVjBVM1ZqWTJWemN5QTlJQ2QzWldKemIyTnJaWFFuSUQwOUlIUm9hWE11ZEhKaGJuTndiM0owTG01aGJXVTdYRzRnSUhSb2FYTXVaVzFwZENnbmIzQmxiaWNwTzF4dUlDQjBhR2x6TG1ac2RYTm9LQ2s3WEc1Y2JpQWdMeThnZDJVZ1kyaGxZMnNnWm05eUlHQnlaV0ZrZVZOMFlYUmxZQ0JwYmlCallYTmxJR0Z1SUdCdmNHVnVZRnh1SUNBdkx5QnNhWE4wWlc1bGNpQmhiSEpsWVdSNUlHTnNiM05sWkNCMGFHVWdjMjlqYTJWMFhHNGdJR2xtSUNnbmIzQmxiaWNnUFQwZ2RHaHBjeTV5WldGa2VWTjBZWFJsSUNZbUlIUm9hWE11ZFhCbmNtRmtaU0FtSmlCMGFHbHpMblJ5WVc1emNHOXlkQzV3WVhWelpTa2dlMXh1SUNBZ0lHUmxZblZuS0NkemRHRnlkR2x1WnlCMWNHZHlZV1JsSUhCeWIySmxjeWNwTzF4dUlDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd0xDQnNJRDBnZEdocGN5NTFjR2R5WVdSbGN5NXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQWdJSFJvYVhNdWNISnZZbVVvZEdocGN5NTFjR2R5WVdSbGMxdHBYU2s3WEc0Z0lDQWdmVnh1SUNCOVhHNTlPMXh1WEc0dktpcGNiaUFxSUVoaGJtUnNaWE1nWVNCd1lXTnJaWFF1WEc0Z0tseHVJQ29nUUdGd2FTQndjbWwyWVhSbFhHNGdLaTljYmx4dVUyOWphMlYwTG5CeWIzUnZkSGx3WlM1dmJsQmhZMnRsZENBOUlHWjFibU4wYVc5dUlDaHdZV05yWlhRcElIdGNiaUFnYVdZZ0tDZHZjR1Z1YVc1bkp5QTlQU0IwYUdsekxuSmxZV1I1VTNSaGRHVWdmSHdnSjI5d1pXNG5JRDA5SUhSb2FYTXVjbVZoWkhsVGRHRjBaU2tnZTF4dUlDQWdJR1JsWW5WbktDZHpiMk5yWlhRZ2NtVmpaV2wyWlRvZ2RIbHdaU0JjSWlWelhDSXNJR1JoZEdFZ1hDSWxjMXdpSnl3Z2NHRmphMlYwTG5SNWNHVXNJSEJoWTJ0bGRDNWtZWFJoS1R0Y2JseHVJQ0FnSUhSb2FYTXVaVzFwZENnbmNHRmphMlYwSnl3Z2NHRmphMlYwS1R0Y2JseHVJQ0FnSUM4dklGTnZZMnRsZENCcGN5QnNhWFpsSUMwZ1lXNTVJSEJoWTJ0bGRDQmpiM1Z1ZEhOY2JpQWdJQ0IwYUdsekxtVnRhWFFvSjJobFlYSjBZbVZoZENjcE8xeHVYRzRnSUNBZ2MzZHBkR05vSUNod1lXTnJaWFF1ZEhsd1pTa2dlMXh1SUNBZ0lDQWdZMkZ6WlNBbmIzQmxiaWM2WEc0Z0lDQWdJQ0FnSUhSb2FYTXViMjVJWVc1a2MyaGhhMlVvY0dGeWMyVnFjMjl1S0hCaFkydGxkQzVrWVhSaEtTazdYRzRnSUNBZ0lDQWdJR0p5WldGck8xeHVYRzRnSUNBZ0lDQmpZWE5sSUNkd2IyNW5KenBjYmlBZ0lDQWdJQ0FnZEdocGN5NXpaWFJRYVc1bktDazdYRzRnSUNBZ0lDQWdJR0p5WldGck8xeHVYRzRnSUNBZ0lDQmpZWE5sSUNkbGNuSnZjaWM2WEc0Z0lDQWdJQ0FnSUhaaGNpQmxjbklnUFNCdVpYY2dSWEp5YjNJb0ozTmxjblpsY2lCbGNuSnZjaWNwTzF4dUlDQWdJQ0FnSUNCbGNuSXVZMjlrWlNBOUlIQmhZMnRsZEM1a1lYUmhPMXh1SUNBZ0lDQWdJQ0IwYUdsekxtVnRhWFFvSjJWeWNtOXlKeXdnWlhKeUtUdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNWNiaUFnSUNBZ0lHTmhjMlVnSjIxbGMzTmhaMlVuT2x4dUlDQWdJQ0FnSUNCMGFHbHpMbVZ0YVhRb0oyUmhkR0VuTENCd1lXTnJaWFF1WkdGMFlTazdYRzRnSUNBZ0lDQWdJSFJvYVhNdVpXMXBkQ2duYldWemMyRm5aU2NzSUhCaFkydGxkQzVrWVhSaEtUdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNGdJQ0FnZlZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdSbFluVm5LQ2R3WVdOclpYUWdjbVZqWldsMlpXUWdkMmwwYUNCemIyTnJaWFFnY21WaFpIbFRkR0YwWlNCY0lpVnpYQ0luTENCMGFHbHpMbkpsWVdSNVUzUmhkR1VwTzF4dUlDQjlYRzU5TzF4dVhHNHZLaXBjYmlBcUlFTmhiR3hsWkNCMWNHOXVJR2hoYm1SemFHRnJaU0JqYjIxd2JHVjBhVzl1TGx4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0JvWVc1a2MyaGhhMlVnYjJKcVhHNGdLaUJBWVhCcElIQnlhWFpoZEdWY2JpQXFMMXh1WEc1VGIyTnJaWFF1Y0hKdmRHOTBlWEJsTG05dVNHRnVaSE5vWVd0bElEMGdablZ1WTNScGIyNGdLR1JoZEdFcElIdGNiaUFnZEdocGN5NWxiV2wwS0Nkb1lXNWtjMmhoYTJVbkxDQmtZWFJoS1R0Y2JpQWdkR2hwY3k1cFpDQTlJR1JoZEdFdWMybGtPMXh1SUNCMGFHbHpMblJ5WVc1emNHOXlkQzV4ZFdWeWVTNXphV1FnUFNCa1lYUmhMbk5wWkR0Y2JpQWdkR2hwY3k1MWNHZHlZV1JsY3lBOUlIUm9hWE11Wm1sc2RHVnlWWEJuY21Ga1pYTW9aR0YwWVM1MWNHZHlZV1JsY3lrN1hHNGdJSFJvYVhNdWNHbHVaMGx1ZEdWeWRtRnNJRDBnWkdGMFlTNXdhVzVuU1c1MFpYSjJZV3c3WEc0Z0lIUm9hWE11Y0dsdVoxUnBiV1Z2ZFhRZ1BTQmtZWFJoTG5CcGJtZFVhVzFsYjNWME8xeHVJQ0IwYUdsekxtOXVUM0JsYmlncE8xeHVJQ0F2THlCSmJpQmpZWE5sSUc5d1pXNGdhR0Z1Wkd4bGNpQmpiRzl6WlhNZ2MyOWphMlYwWEc0Z0lHbG1JQ0FvSjJOc2IzTmxaQ2NnUFQwZ2RHaHBjeTV5WldGa2VWTjBZWFJsS1NCeVpYUjFjbTQ3WEc0Z0lIUm9hWE11YzJWMFVHbHVaeWdwTzF4dVhHNGdJQzh2SUZCeWIyeHZibWNnYkdsMlpXNWxjM01nYjJZZ2MyOWphMlYwSUc5dUlHaGxZWEowWW1WaGRGeHVJQ0IwYUdsekxuSmxiVzkyWlV4cGMzUmxibVZ5S0Nkb1pXRnlkR0psWVhRbkxDQjBhR2x6TG05dVNHVmhjblJpWldGMEtUdGNiaUFnZEdocGN5NXZiaWduYUdWaGNuUmlaV0YwSnl3Z2RHaHBjeTV2YmtobFlYSjBZbVZoZENrN1hHNTlPMXh1WEc0dktpcGNiaUFxSUZKbGMyVjBjeUJ3YVc1bklIUnBiV1Z2ZFhRdVhHNGdLbHh1SUNvZ1FHRndhU0J3Y21sMllYUmxYRzRnS2k5Y2JseHVVMjlqYTJWMExuQnliM1J2ZEhsd1pTNXZia2hsWVhKMFltVmhkQ0E5SUdaMWJtTjBhVzl1SUNoMGFXMWxiM1YwS1NCN1hHNGdJR05zWldGeVZHbHRaVzkxZENoMGFHbHpMbkJwYm1kVWFXMWxiM1YwVkdsdFpYSXBPMXh1SUNCMllYSWdjMlZzWmlBOUlIUm9hWE03WEc0Z0lITmxiR1l1Y0dsdVoxUnBiV1Z2ZFhSVWFXMWxjaUE5SUhObGRGUnBiV1Z2ZFhRb1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lHbG1JQ2duWTJ4dmMyVmtKeUE5UFNCelpXeG1MbkpsWVdSNVUzUmhkR1VwSUhKbGRIVnlianRjYmlBZ0lDQnpaV3htTG05dVEyeHZjMlVvSjNCcGJtY2dkR2x0Wlc5MWRDY3BPMXh1SUNCOUxDQjBhVzFsYjNWMElIeDhJQ2h6Wld4bUxuQnBibWRKYm5SbGNuWmhiQ0FySUhObGJHWXVjR2x1WjFScGJXVnZkWFFwS1R0Y2JuMDdYRzVjYmk4cUtseHVJQ29nVUdsdVozTWdjMlZ5ZG1WeUlHVjJaWEo1SUdCMGFHbHpMbkJwYm1kSmJuUmxjblpoYkdBZ1lXNWtJR1Y0Y0dWamRITWdjbVZ6Y0c5dWMyVmNiaUFxSUhkcGRHaHBiaUJnZEdocGN5NXdhVzVuVkdsdFpXOTFkR0FnYjNJZ1kyeHZjMlZ6SUdOdmJtNWxZM1JwYjI0dVhHNGdLbHh1SUNvZ1FHRndhU0J3Y21sMllYUmxYRzRnS2k5Y2JseHVVMjlqYTJWMExuQnliM1J2ZEhsd1pTNXpaWFJRYVc1bklEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQjJZWElnYzJWc1ppQTlJSFJvYVhNN1hHNGdJR05zWldGeVZHbHRaVzkxZENoelpXeG1MbkJwYm1kSmJuUmxjblpoYkZScGJXVnlLVHRjYmlBZ2MyVnNaaTV3YVc1blNXNTBaWEoyWVd4VWFXMWxjaUE5SUhObGRGUnBiV1Z2ZFhRb1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lHUmxZblZuS0NkM2NtbDBhVzVuSUhCcGJtY2djR0ZqYTJWMElDMGdaWGh3WldOMGFXNW5JSEJ2Ym1jZ2QybDBhR2x1SUNWemJYTW5MQ0J6Wld4bUxuQnBibWRVYVcxbGIzVjBLVHRjYmlBZ0lDQnpaV3htTG5CcGJtY29LVHRjYmlBZ0lDQnpaV3htTG05dVNHVmhjblJpWldGMEtITmxiR1l1Y0dsdVoxUnBiV1Z2ZFhRcE8xeHVJQ0I5TENCelpXeG1MbkJwYm1kSmJuUmxjblpoYkNrN1hHNTlPMXh1WEc0dktpcGNiaW9nVTJWdVpITWdZU0J3YVc1bklIQmhZMnRsZEM1Y2JpcGNiaW9nUUdGd2FTQndkV0pzYVdOY2Jpb3ZYRzVjYmxOdlkydGxkQzV3Y205MGIzUjVjR1V1Y0dsdVp5QTlJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdkR2hwY3k1elpXNWtVR0ZqYTJWMEtDZHdhVzVuSnlrN1hHNTlPMXh1WEc0dktpcGNiaUFxSUVOaGJHeGxaQ0J2YmlCZ1pISmhhVzVnSUdWMlpXNTBYRzRnS2x4dUlDb2dRR0Z3YVNCd2NtbDJZWFJsWEc0Z0tpOWNibHh1VTI5amEyVjBMbkJ5YjNSdmRIbHdaUzV2YmtSeVlXbHVJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnZEdocGN5NXdjbVYyUW5WbVptVnlUR1Z1T3lCcEt5c3BJSHRjYmlBZ0lDQnBaaUFvZEdocGN5NWpZV3hzWW1GamEwSjFabVpsY2x0cFhTa2dlMXh1SUNBZ0lDQWdkR2hwY3k1allXeHNZbUZqYTBKMVptWmxjbHRwWFNncE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lIUm9hWE11ZDNKcGRHVkNkV1ptWlhJdWMzQnNhV05sS0RBc0lIUm9hWE11Y0hKbGRrSjFabVpsY2t4bGJpazdYRzRnSUhSb2FYTXVZMkZzYkdKaFkydENkV1ptWlhJdWMzQnNhV05sS0RBc0lIUm9hWE11Y0hKbGRrSjFabVpsY2t4bGJpazdYRzVjYmlBZ0x5OGdjMlYwZEdsdVp5QndjbVYyUW5WbVptVnlUR1Z1SUQwZ01DQnBjeUIyWlhKNUlHbHRjRzl5ZEdGdWRGeHVJQ0F2THlCbWIzSWdaWGhoYlhCc1pTd2dkMmhsYmlCMWNHZHlZV1JwYm1jc0lIVndaM0poWkdVZ2NHRmphMlYwSUdseklITmxiblFnYjNabGNpeGNiaUFnTHk4Z1lXNWtJR0VnYm05dWVtVnlieUJ3Y21WMlFuVm1abVZ5VEdWdUlHTnZkV3hrSUdOaGRYTmxJSEJ5YjJKc1pXMXpJRzl1SUdCa2NtRnBibUJjYmlBZ2RHaHBjeTV3Y21WMlFuVm1abVZ5VEdWdUlEMGdNRHRjYmx4dUlDQnBaaUFvZEdocGN5NTNjbWwwWlVKMVptWmxjaTVzWlc1bmRHZ2dQVDBnTUNrZ2UxeHVJQ0FnSUhSb2FYTXVaVzFwZENnblpISmhhVzRuS1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCMGFHbHpMbVpzZFhOb0tDazdYRzRnSUgxY2JuMDdYRzVjYmk4cUtseHVJQ29nUm14MWMyZ2dkM0pwZEdVZ1luVm1abVZ5Y3k1Y2JpQXFYRzRnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFxTDF4dVhHNVRiMk5yWlhRdWNISnZkRzkwZVhCbExtWnNkWE5vSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNCcFppQW9KMk5zYjNObFpDY2dJVDBnZEdocGN5NXlaV0ZrZVZOMFlYUmxJQ1ltSUhSb2FYTXVkSEpoYm5Od2IzSjBMbmR5YVhSaFlteGxJQ1ltWEc0Z0lDQWdJWFJvYVhNdWRYQm5jbUZrYVc1bklDWW1JSFJvYVhNdWQzSnBkR1ZDZFdabVpYSXViR1Z1WjNSb0tTQjdYRzRnSUNBZ1pHVmlkV2NvSjJac2RYTm9hVzVuSUNWa0lIQmhZMnRsZEhNZ2FXNGdjMjlqYTJWMEp5d2dkR2hwY3k1M2NtbDBaVUoxWm1abGNpNXNaVzVuZEdncE8xeHVJQ0FnSUhSb2FYTXVkSEpoYm5Od2IzSjBMbk5sYm1Rb2RHaHBjeTUzY21sMFpVSjFabVpsY2lrN1hHNGdJQ0FnTHk4Z2EyVmxjQ0IwY21GamF5QnZaaUJqZFhKeVpXNTBJR3hsYm1kMGFDQnZaaUIzY21sMFpVSjFabVpsY2x4dUlDQWdJQzh2SUhOd2JHbGpaU0IzY21sMFpVSjFabVpsY2lCaGJtUWdZMkZzYkdKaFkydENkV1ptWlhJZ2IyNGdZR1J5WVdsdVlGeHVJQ0FnSUhSb2FYTXVjSEpsZGtKMVptWmxja3hsYmlBOUlIUm9hWE11ZDNKcGRHVkNkV1ptWlhJdWJHVnVaM1JvTzF4dUlDQWdJSFJvYVhNdVpXMXBkQ2duWm14MWMyZ25LVHRjYmlBZ2ZWeHVmVHRjYmx4dUx5b3FYRzRnS2lCVFpXNWtjeUJoSUcxbGMzTmhaMlV1WEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRUZEhKcGJtZDlJRzFsYzNOaFoyVXVYRzRnS2lCQWNHRnlZVzBnZTBaMWJtTjBhVzl1ZlNCallXeHNZbUZqYXlCbWRXNWpkR2x2Ymk1Y2JpQXFJRUJ5WlhSMWNtNGdlMU52WTJ0bGRIMGdabTl5SUdOb1lXbHVhVzVuTGx4dUlDb2dRR0Z3YVNCd2RXSnNhV05jYmlBcUwxeHVYRzVUYjJOclpYUXVjSEp2ZEc5MGVYQmxMbmR5YVhSbElEMWNibE52WTJ0bGRDNXdjbTkwYjNSNWNHVXVjMlZ1WkNBOUlHWjFibU4wYVc5dUlDaHRjMmNzSUdadUtTQjdYRzRnSUhSb2FYTXVjMlZ1WkZCaFkydGxkQ2duYldWemMyRm5aU2NzSUcxelp5d2dabTRwTzF4dUlDQnlaWFIxY200Z2RHaHBjenRjYm4wN1hHNWNiaThxS2x4dUlDb2dVMlZ1WkhNZ1lTQndZV05yWlhRdVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0VGRISnBibWQ5SUhCaFkydGxkQ0IwZVhCbExseHVJQ29nUUhCaGNtRnRJSHRUZEhKcGJtZDlJR1JoZEdFdVhHNGdLaUJBY0dGeVlXMGdlMFoxYm1OMGFXOXVmU0JqWVd4c1ltRmpheUJtZFc1amRHbHZiaTVjYmlBcUlFQmhjR2tnY0hKcGRtRjBaVnh1SUNvdlhHNWNibE52WTJ0bGRDNXdjbTkwYjNSNWNHVXVjMlZ1WkZCaFkydGxkQ0E5SUdaMWJtTjBhVzl1SUNoMGVYQmxMQ0JrWVhSaExDQm1iaWtnZTF4dUlDQnBaaUFvSjJOc2IzTnBibWNuSUQwOUlIUm9hWE11Y21WaFpIbFRkR0YwWlNCOGZDQW5ZMnh2YzJWa0p5QTlQU0IwYUdsekxuSmxZV1I1VTNSaGRHVXBJSHRjYmlBZ0lDQnlaWFIxY200N1hHNGdJSDFjYmx4dUlDQjJZWElnY0dGamEyVjBJRDBnZXlCMGVYQmxPaUIwZVhCbExDQmtZWFJoT2lCa1lYUmhJSDA3WEc0Z0lIUm9hWE11WlcxcGRDZ25jR0ZqYTJWMFEzSmxZWFJsSnl3Z2NHRmphMlYwS1R0Y2JpQWdkR2hwY3k1M2NtbDBaVUoxWm1abGNpNXdkWE5vS0hCaFkydGxkQ2s3WEc0Z0lIUm9hWE11WTJGc2JHSmhZMnRDZFdabVpYSXVjSFZ6YUNobWJpazdYRzRnSUhSb2FYTXVabXgxYzJnb0tUdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1EyeHZjMlZ6SUhSb1pTQmpiMjV1WldOMGFXOXVMbHh1SUNwY2JpQXFJRUJoY0drZ2NISnBkbUYwWlZ4dUlDb3ZYRzVjYmxOdlkydGxkQzV3Y205MGIzUjVjR1V1WTJ4dmMyVWdQU0JtZFc1amRHbHZiaUFvS1NCN1hHNGdJR2xtSUNnbmIzQmxibWx1WnljZ1BUMGdkR2hwY3k1eVpXRmtlVk4wWVhSbElIeDhJQ2R2Y0dWdUp5QTlQU0IwYUdsekxuSmxZV1I1VTNSaGRHVXBJSHRjYmlBZ0lDQjBhR2x6TG5KbFlXUjVVM1JoZEdVZ1BTQW5ZMnh2YzJsdVp5YzdYRzVjYmlBZ0lDQjJZWElnYzJWc1ppQTlJSFJvYVhNN1hHNWNiaUFnSUNCbWRXNWpkR2x2YmlCamJHOXpaU2dwSUh0Y2JpQWdJQ0FnSUhObGJHWXViMjVEYkc5elpTZ25abTl5WTJWa0lHTnNiM05sSnlrN1hHNGdJQ0FnSUNCa1pXSjFaeWduYzI5amEyVjBJR05zYjNOcGJtY2dMU0IwWld4c2FXNW5JSFJ5WVc1emNHOXlkQ0IwYnlCamJHOXpaU2NwTzF4dUlDQWdJQ0FnYzJWc1ppNTBjbUZ1YzNCdmNuUXVZMnh2YzJVb0tUdGNiaUFnSUNCOVhHNWNiaUFnSUNCbWRXNWpkR2x2YmlCamJHVmhiblZ3UVc1a1EyeHZjMlVvS1NCN1hHNGdJQ0FnSUNCelpXeG1MbkpsYlc5MlpVeHBjM1JsYm1WeUtDZDFjR2R5WVdSbEp5d2dZMnhsWVc1MWNFRnVaRU5zYjNObEtUdGNiaUFnSUNBZ0lITmxiR1l1Y21WdGIzWmxUR2x6ZEdWdVpYSW9KM1Z3WjNKaFpHVkZjbkp2Y2ljc0lHTnNaV0Z1ZFhCQmJtUkRiRzl6WlNrN1hHNGdJQ0FnSUNCamJHOXpaU2dwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR1oxYm1OMGFXOXVJSGRoYVhSR2IzSlZjR2R5WVdSbEtDa2dlMXh1SUNBZ0lDQWdMeThnZDJGcGRDQm1iM0lnZFhCbmNtRmtaU0IwYnlCbWFXNXBjMmdnYzJsdVkyVWdkMlVnWTJGdUozUWdjMlZ1WkNCd1lXTnJaWFJ6SUhkb2FXeGxJSEJoZFhOcGJtY2dZU0IwY21GdWMzQnZjblJjYmlBZ0lDQWdJSE5sYkdZdWIyNWpaU2duZFhCbmNtRmtaU2NzSUdOc1pXRnVkWEJCYm1SRGJHOXpaU2s3WEc0Z0lDQWdJQ0J6Wld4bUxtOXVZMlVvSjNWd1ozSmhaR1ZGY25KdmNpY3NJR05zWldGdWRYQkJibVJEYkc5elpTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLSFJvYVhNdWQzSnBkR1ZDZFdabVpYSXViR1Z1WjNSb0tTQjdYRzRnSUNBZ0lDQjBhR2x6TG05dVkyVW9KMlJ5WVdsdUp5d2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDaDBhR2x6TG5Wd1ozSmhaR2x1WnlrZ2UxeHVJQ0FnSUNBZ0lDQWdJSGRoYVhSR2IzSlZjR2R5WVdSbEtDazdYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnWTJ4dmMyVW9LVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnZlNCbGJITmxJR2xtSUNoMGFHbHpMblZ3WjNKaFpHbHVaeWtnZTF4dUlDQWdJQ0FnZDJGcGRFWnZjbFZ3WjNKaFpHVW9LVHRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ1kyeHZjMlVvS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZEdocGN6dGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1EyRnNiR1ZrSUhWd2IyNGdkSEpoYm5Od2IzSjBJR1Z5Y205eVhHNGdLbHh1SUNvZ1FHRndhU0J3Y21sMllYUmxYRzRnS2k5Y2JseHVVMjlqYTJWMExuQnliM1J2ZEhsd1pTNXZia1Z5Y205eUlEMGdablZ1WTNScGIyNGdLR1Z5Y2lrZ2UxeHVJQ0JrWldKMVp5Z25jMjlqYTJWMElHVnljbTl5SUNWcUp5d2daWEp5S1R0Y2JpQWdVMjlqYTJWMExuQnlhVzl5VjJWaWMyOWphMlYwVTNWalkyVnpjeUE5SUdaaGJITmxPMXh1SUNCMGFHbHpMbVZ0YVhRb0oyVnljbTl5Snl3Z1pYSnlLVHRjYmlBZ2RHaHBjeTV2YmtOc2IzTmxLQ2QwY21GdWMzQnZjblFnWlhKeWIzSW5MQ0JsY25JcE8xeHVmVHRjYmx4dUx5b3FYRzRnS2lCRFlXeHNaV1FnZFhCdmJpQjBjbUZ1YzNCdmNuUWdZMnh2YzJVdVhHNGdLbHh1SUNvZ1FHRndhU0J3Y21sMllYUmxYRzRnS2k5Y2JseHVVMjlqYTJWMExuQnliM1J2ZEhsd1pTNXZia05zYjNObElEMGdablZ1WTNScGIyNGdLSEpsWVhOdmJpd2daR1Z6WXlrZ2UxeHVJQ0JwWmlBb0oyOXdaVzVwYm1jbklEMDlJSFJvYVhNdWNtVmhaSGxUZEdGMFpTQjhmQ0FuYjNCbGJpY2dQVDBnZEdocGN5NXlaV0ZrZVZOMFlYUmxJSHg4SUNkamJHOXphVzVuSnlBOVBTQjBhR2x6TG5KbFlXUjVVM1JoZEdVcElIdGNiaUFnSUNCa1pXSjFaeWduYzI5amEyVjBJR05zYjNObElIZHBkR2dnY21WaGMyOXVPaUJjSWlWelhDSW5MQ0J5WldGemIyNHBPMXh1SUNBZ0lIWmhjaUJ6Wld4bUlEMGdkR2hwY3p0Y2JseHVJQ0FnSUM4dklHTnNaV0Z5SUhScGJXVnljMXh1SUNBZ0lHTnNaV0Z5VkdsdFpXOTFkQ2gwYUdsekxuQnBibWRKYm5SbGNuWmhiRlJwYldWeUtUdGNiaUFnSUNCamJHVmhjbFJwYldWdmRYUW9kR2hwY3k1d2FXNW5WR2x0Wlc5MWRGUnBiV1Z5S1R0Y2JseHVJQ0FnSUM4dklHTnNaV0Z1SUdKMVptWmxjbk1nYVc0Z2JtVjRkQ0IwYVdOckxDQnpieUJrWlhabGJHOXdaWEp6SUdOaGJpQnpkR2xzYkZ4dUlDQWdJQzh2SUdkeVlXSWdkR2hsSUdKMVptWmxjbk1nYjI0Z1lHTnNiM05sWUNCbGRtVnVkRnh1SUNBZ0lITmxkRlJwYldWdmRYUW9ablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J6Wld4bUxuZHlhWFJsUW5WbVptVnlJRDBnVzEwN1hHNGdJQ0FnSUNCelpXeG1MbU5oYkd4aVlXTnJRblZtWm1WeUlEMGdXMTA3WEc0Z0lDQWdJQ0J6Wld4bUxuQnlaWFpDZFdabVpYSk1aVzRnUFNBd08xeHVJQ0FnSUgwc0lEQXBPMXh1WEc0Z0lDQWdMeThnYzNSdmNDQmxkbVZ1ZENCbWNtOXRJR1pwY21sdVp5QmhaMkZwYmlCbWIzSWdkSEpoYm5Od2IzSjBYRzRnSUNBZ2RHaHBjeTUwY21GdWMzQnZjblF1Y21WdGIzWmxRV3hzVEdsemRHVnVaWEp6S0NkamJHOXpaU2NwTzF4dVhHNGdJQ0FnTHk4Z1pXNXpkWEpsSUhSeVlXNXpjRzl5ZENCM2IyNG5kQ0J6ZEdGNUlHOXdaVzVjYmlBZ0lDQjBhR2x6TG5SeVlXNXpjRzl5ZEM1amJHOXpaU2dwTzF4dVhHNGdJQ0FnTHk4Z2FXZHViM0psSUdaMWNuUm9aWElnZEhKaGJuTndiM0owSUdOdmJXMTFibWxqWVhScGIyNWNiaUFnSUNCMGFHbHpMblJ5WVc1emNHOXlkQzV5WlcxdmRtVkJiR3hNYVhOMFpXNWxjbk1vS1R0Y2JseHVJQ0FnSUM4dklITmxkQ0J5WldGa2VTQnpkR0YwWlZ4dUlDQWdJSFJvYVhNdWNtVmhaSGxUZEdGMFpTQTlJQ2RqYkc5elpXUW5PMXh1WEc0Z0lDQWdMeThnWTJ4bFlYSWdjMlZ6YzJsdmJpQnBaRnh1SUNBZ0lIUm9hWE11YVdRZ1BTQnVkV3hzTzF4dVhHNGdJQ0FnTHk4Z1pXMXBkQ0JqYkc5elpTQmxkbVZ1ZEZ4dUlDQWdJSFJvYVhNdVpXMXBkQ2duWTJ4dmMyVW5MQ0J5WldGemIyNHNJR1JsYzJNcE8xeHVJQ0I5WEc1OU8xeHVYRzR2S2lwY2JpQXFJRVpwYkhSbGNuTWdkWEJuY21Ga1pYTXNJSEpsZEhWeWJtbHVaeUJ2Ym14NUlIUm9iM05sSUcxaGRHTm9hVzVuSUdOc2FXVnVkQ0IwY21GdWMzQnZjblJ6TGx4dUlDcGNiaUFxSUVCd1lYSmhiU0I3UVhKeVlYbDlJSE5sY25abGNpQjFjR2R5WVdSbGMxeHVJQ29nUUdGd2FTQndjbWwyWVhSbFhHNGdLbHh1SUNvdlhHNWNibE52WTJ0bGRDNXdjbTkwYjNSNWNHVXVabWxzZEdWeVZYQm5jbUZrWlhNZ1BTQm1kVzVqZEdsdmJpQW9kWEJuY21Ga1pYTXBJSHRjYmlBZ2RtRnlJR1pwYkhSbGNtVmtWWEJuY21Ga1pYTWdQU0JiWFR0Y2JpQWdabTl5SUNoMllYSWdhU0E5SURBc0lHb2dQU0IxY0dkeVlXUmxjeTVzWlc1bmRHZzdJR2s4YWpzZ2FTc3JLU0I3WEc0Z0lDQWdhV1lnS0g1cGJtUmxlQ2gwYUdsekxuUnlZVzV6Y0c5eWRITXNJSFZ3WjNKaFpHVnpXMmxkS1NrZ1ptbHNkR1Z5WldSVmNHZHlZV1JsY3k1d2RYTm9LSFZ3WjNKaFpHVnpXMmxkS1R0Y2JpQWdmVnh1SUNCeVpYUjFjbTRnWm1sc2RHVnlaV1JWY0dkeVlXUmxjenRjYm4wN1hHNGlYWDA9IiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBBIGNvdW50ZXIgdXNlZCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgaW4gdGhlIHRpbWVzdGFtcHMgdXNlZFxuICogZm9yIGNhY2hlIGJ1c3RpbmcuXG4gKi9cblxuVHJhbnNwb3J0LnRpbWVzdGFtcHMgPSAwO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpO1xudmFyIFhIUiA9IHJlcXVpcmUoJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IHJlcXVpcmUoJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyhvcHRzKXtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5bGJtZHBibVV1YVc4dFkyeHBaVzUwTDJ4cFlpOTBjbUZ1YzNCdmNuUnpMMmx1WkdWNExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cUtseHVJQ29nVFc5a2RXeGxJR1JsY0dWdVpHVnVZMmxsYzF4dUlDb3ZYRzVjYm5aaGNpQllUVXhJZEhSd1VtVnhkV1Z6ZENBOUlISmxjWFZwY21Vb0ozaHRiR2gwZEhCeVpYRjFaWE4wSnlrN1hHNTJZWElnV0VoU0lEMGdjbVZ4ZFdseVpTZ25MaTl3YjJ4c2FXNW5MWGhvY2ljcE8xeHVkbUZ5SUVwVFQwNVFJRDBnY21WeGRXbHlaU2duTGk5d2IyeHNhVzVuTFdwemIyNXdKeWs3WEc1MllYSWdkMlZpYzI5amEyVjBJRDBnY21WeGRXbHlaU2duTGk5M1pXSnpiMk5yWlhRbktUdGNibHh1THlvcVhHNGdLaUJGZUhCdmNuUWdkSEpoYm5Od2IzSjBjeTVjYmlBcUwxeHVYRzVsZUhCdmNuUnpMbkJ2Ykd4cGJtY2dQU0J3YjJ4c2FXNW5PMXh1Wlhod2IzSjBjeTUzWldKemIyTnJaWFFnUFNCM1pXSnpiMk5yWlhRN1hHNWNiaThxS2x4dUlDb2dVRzlzYkdsdVp5QjBjbUZ1YzNCdmNuUWdjRzlzZVcxdmNuQm9hV01nWTI5dWMzUnlkV04wYjNJdVhHNGdLaUJFWldOcFpHVnpJRzl1SUhob2NpQjJjeUJxYzI5dWNDQmlZWE5sWkNCdmJpQm1aV0YwZFhKbElHUmxkR1ZqZEdsdmJpNWNiaUFxWEc0Z0tpQkFZWEJwSUhCeWFYWmhkR1ZjYmlBcUwxeHVYRzVtZFc1amRHbHZiaUJ3YjJ4c2FXNW5LRzl3ZEhNcGUxeHVJQ0IyWVhJZ2VHaHlPMXh1SUNCMllYSWdlR1FnUFNCbVlXeHpaVHRjYmlBZ2RtRnlJSGh6SUQwZ1ptRnNjMlU3WEc0Z0lIWmhjaUJxYzI5dWNDQTlJR1poYkhObElDRTlQU0J2Y0hSekxtcHpiMjV3TzF4dVhHNGdJR2xtSUNobmJHOWlZV3d1Ykc5allYUnBiMjRwSUh0Y2JpQWdJQ0IyWVhJZ2FYTlRVMHdnUFNBbmFIUjBjSE02SnlBOVBTQnNiMk5oZEdsdmJpNXdjbTkwYjJOdmJEdGNiaUFnSUNCMllYSWdjRzl5ZENBOUlHeHZZMkYwYVc5dUxuQnZjblE3WEc1Y2JpQWdJQ0F2THlCemIyMWxJSFZ6WlhJZ1lXZGxiblJ6SUdoaGRtVWdaVzF3ZEhrZ1lHeHZZMkYwYVc5dUxuQnZjblJnWEc0Z0lDQWdhV1lnS0NGd2IzSjBLU0I3WEc0Z0lDQWdJQ0J3YjNKMElEMGdhWE5UVTB3Z1B5QTBORE1nT2lBNE1EdGNiaUFnSUNCOVhHNWNiaUFnSUNCNFpDQTlJRzl3ZEhNdWFHOXpkRzVoYldVZ0lUMGdiRzlqWVhScGIyNHVhRzl6ZEc1aGJXVWdmSHdnY0c5eWRDQWhQU0J2Y0hSekxuQnZjblE3WEc0Z0lDQWdlSE1nUFNCdmNIUnpMbk5sWTNWeVpTQWhQU0JwYzFOVFREdGNiaUFnZlZ4dVhHNGdJRzl3ZEhNdWVHUnZiV0ZwYmlBOUlIaGtPMXh1SUNCdmNIUnpMbmh6WTJobGJXVWdQU0I0Y3p0Y2JpQWdlR2h5SUQwZ2JtVjNJRmhOVEVoMGRIQlNaWEYxWlhOMEtHOXdkSE1wTzF4dVhHNGdJR2xtSUNnbmIzQmxiaWNnYVc0Z2VHaHlJQ1ltSUNGdmNIUnpMbVp2Y21ObFNsTlBUbEFwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdibVYzSUZoSVVpaHZjSFJ6S1R0Y2JpQWdmU0JsYkhObElIdGNiaUFnSUNCcFppQW9JV3B6YjI1d0tTQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owcFRUMDVRSUdScGMyRmliR1ZrSnlrN1hHNGdJQ0FnY21WMGRYSnVJRzVsZHlCS1UwOU9VQ2h2Y0hSektUdGNiaUFnZlZ4dWZWeHVJbDE5IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJysgc2VsZi5pZnJhbWVJZCArJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5bGJtZHBibVV1YVc4dFkyeHBaVzUwTDJ4cFlpOTBjbUZ1YzNCdmNuUnpMM0J2Ykd4cGJtY3Rhbk52Ym5BdWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWEc0dktpcGNiaUFxSUUxdlpIVnNaU0J5WlhGMWFYSmxiV1Z1ZEhNdVhHNGdLaTljYmx4dWRtRnlJRkJ2Ykd4cGJtY2dQU0J5WlhGMWFYSmxLQ2N1TDNCdmJHeHBibWNuS1R0Y2JuWmhjaUJwYm1obGNtbDBJRDBnY21WeGRXbHlaU2duWTI5dGNHOXVaVzUwTFdsdWFHVnlhWFFuS1R0Y2JseHVMeW9xWEc0Z0tpQk5iMlIxYkdVZ1pYaHdiM0owY3k1Y2JpQXFMMXh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUVwVFQwNVFVRzlzYkdsdVp6dGNibHh1THlvcVhHNGdLaUJEWVdOb1pXUWdjbVZuZFd4aGNpQmxlSEJ5WlhOemFXOXVjeTVjYmlBcUwxeHVYRzUyWVhJZ2NrNWxkMnhwYm1VZ1BTQXZYRnh1TDJjN1hHNTJZWElnY2tWelkyRndaV1JPWlhkc2FXNWxJRDBnTDF4Y1hGeHVMMmM3WEc1Y2JpOHFLbHh1SUNvZ1IyeHZZbUZzSUVwVFQwNVFJR05oYkd4aVlXTnJjeTVjYmlBcUwxeHVYRzUyWVhJZ1kyRnNiR0poWTJ0ek8xeHVYRzR2S2lwY2JpQXFJRU5oYkd4aVlXTnJjeUJqYjNWdWRDNWNiaUFxTDF4dVhHNTJZWElnYVc1a1pYZ2dQU0F3TzF4dVhHNHZLaXBjYmlBcUlFNXZiM0F1WEc0Z0tpOWNibHh1Wm5WdVkzUnBiMjRnWlcxd2RIa2dLQ2tnZXlCOVhHNWNiaThxS2x4dUlDb2dTbE5QVGxBZ1VHOXNiR2x1WnlCamIyNXpkSEoxWTNSdmNpNWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2IzQjBjeTVjYmlBcUlFQmhjR2tnY0hWaWJHbGpYRzRnS2k5Y2JseHVablZ1WTNScGIyNGdTbE5QVGxCUWIyeHNhVzVuSUNodmNIUnpLU0I3WEc0Z0lGQnZiR3hwYm1jdVkyRnNiQ2gwYUdsekxDQnZjSFJ6S1R0Y2JseHVJQ0IwYUdsekxuRjFaWEo1SUQwZ2RHaHBjeTV4ZFdWeWVTQjhmQ0I3ZlR0Y2JseHVJQ0F2THlCa1pXWnBibVVnWjJ4dlltRnNJR05oYkd4aVlXTnJjeUJoY25KaGVTQnBaaUJ1YjNRZ2NISmxjMlZ1ZEZ4dUlDQXZMeUIzWlNCa2J5QjBhR2x6SUdobGNtVWdLR3hoZW1sc2VTa2dkRzhnWVhadmFXUWdkVzV1WldWa1pXUWdaMnh2WW1Gc0lIQnZiR3gxZEdsdmJseHVJQ0JwWmlBb0lXTmhiR3hpWVdOcmN5a2dlMXh1SUNBZ0lDOHZJSGRsSUc1bFpXUWdkRzhnWTI5dWMybGtaWElnYlhWc2RHbHdiR1VnWlc1bmFXNWxjeUJwYmlCMGFHVWdjMkZ0WlNCd1lXZGxYRzRnSUNBZ2FXWWdLQ0ZuYkc5aVlXd3VYMTlmWldsdktTQm5iRzlpWVd3dVgxOWZaV2x2SUQwZ1cxMDdYRzRnSUNBZ1kyRnNiR0poWTJ0eklEMGdaMnh2WW1Gc0xsOWZYMlZwYnp0Y2JpQWdmVnh1WEc0Z0lDOHZJR05oYkd4aVlXTnJJR2xrWlc1MGFXWnBaWEpjYmlBZ2RHaHBjeTVwYm1SbGVDQTlJR05oYkd4aVlXTnJjeTVzWlc1bmRHZzdYRzVjYmlBZ0x5OGdZV1JrSUdOaGJHeGlZV05ySUhSdklHcHpiMjV3SUdkc2IySmhiRnh1SUNCMllYSWdjMlZzWmlBOUlIUm9hWE03WEc0Z0lHTmhiR3hpWVdOcmN5NXdkWE5vS0daMWJtTjBhVzl1SUNodGMyY3BJSHRjYmlBZ0lDQnpaV3htTG05dVJHRjBZU2h0YzJjcE8xeHVJQ0I5S1R0Y2JseHVJQ0F2THlCaGNIQmxibVFnZEc4Z2NYVmxjbmtnYzNSeWFXNW5YRzRnSUhSb2FYTXVjWFZsY25rdWFpQTlJSFJvYVhNdWFXNWtaWGc3WEc1Y2JpQWdMeThnY0hKbGRtVnVkQ0J6Y0hWeWFXOTFjeUJsY25KdmNuTWdabkp2YlNCaVpXbHVaeUJsYldsMGRHVmtJSGRvWlc0Z2RHaGxJSGRwYm1SdmR5QnBjeUIxYm14dllXUmxaRnh1SUNCcFppQW9aMnh2WW1Gc0xtUnZZM1Z0Wlc1MElDWW1JR2RzYjJKaGJDNWhaR1JGZG1WdWRFeHBjM1JsYm1WeUtTQjdYRzRnSUNBZ1oyeHZZbUZzTG1Ga1pFVjJaVzUwVEdsemRHVnVaWElvSjJKbFptOXlaWFZ1Ykc5aFpDY3NJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0FnSUdsbUlDaHpaV3htTG5OamNtbHdkQ2tnYzJWc1ppNXpZM0pwY0hRdWIyNWxjbkp2Y2lBOUlHVnRjSFI1TzF4dUlDQWdJSDBzSUdaaGJITmxLVHRjYmlBZ2ZWeHVmVnh1WEc0dktpcGNiaUFxSUVsdWFHVnlhWFJ6SUdaeWIyMGdVRzlzYkdsdVp5NWNiaUFxTDF4dVhHNXBibWhsY21sMEtFcFRUMDVRVUc5c2JHbHVaeXdnVUc5c2JHbHVaeWs3WEc1Y2JpOHFYRzRnS2lCS1UwOU9VQ0J2Ym14NUlITjFjSEJ2Y25SeklHSnBibUZ5ZVNCaGN5QmlZWE5sTmpRZ1pXNWpiMlJsWkNCemRISnBibWR6WEc0Z0tpOWNibHh1U2xOUFRsQlFiMnhzYVc1bkxuQnliM1J2ZEhsd1pTNXpkWEJ3YjNKMGMwSnBibUZ5ZVNBOUlHWmhiSE5sTzF4dVhHNHZLaXBjYmlBcUlFTnNiM05sY3lCMGFHVWdjMjlqYTJWMExseHVJQ3BjYmlBcUlFQmhjR2tnY0hKcGRtRjBaVnh1SUNvdlhHNWNia3BUVDA1UVVHOXNiR2x1Wnk1d2NtOTBiM1I1Y0dVdVpHOURiRzl6WlNBOUlHWjFibU4wYVc5dUlDZ3BJSHRjYmlBZ2FXWWdLSFJvYVhNdWMyTnlhWEIwS1NCN1hHNGdJQ0FnZEdocGN5NXpZM0pwY0hRdWNHRnlaVzUwVG05a1pTNXlaVzF2ZG1WRGFHbHNaQ2gwYUdsekxuTmpjbWx3ZENrN1hHNGdJQ0FnZEdocGN5NXpZM0pwY0hRZ1BTQnVkV3hzTzF4dUlDQjlYRzVjYmlBZ2FXWWdLSFJvYVhNdVptOXliU2tnZTF4dUlDQWdJSFJvYVhNdVptOXliUzV3WVhKbGJuUk9iMlJsTG5KbGJXOTJaVU5vYVd4a0tIUm9hWE11Wm05eWJTazdYRzRnSUNBZ2RHaHBjeTVtYjNKdElEMGdiblZzYkR0Y2JpQWdJQ0IwYUdsekxtbG1jbUZ0WlNBOUlHNTFiR3c3WEc0Z0lIMWNibHh1SUNCUWIyeHNhVzVuTG5CeWIzUnZkSGx3WlM1a2IwTnNiM05sTG1OaGJHd29kR2hwY3lrN1hHNTlPMXh1WEc0dktpcGNiaUFxSUZOMFlYSjBjeUJoSUhCdmJHd2dZM2xqYkdVdVhHNGdLbHh1SUNvZ1FHRndhU0J3Y21sMllYUmxYRzRnS2k5Y2JseHVTbE5QVGxCUWIyeHNhVzVuTG5CeWIzUnZkSGx3WlM1a2IxQnZiR3dnUFNCbWRXNWpkR2x2YmlBb0tTQjdYRzRnSUhaaGNpQnpaV3htSUQwZ2RHaHBjenRjYmlBZ2RtRnlJSE5qY21sd2RDQTlJR1J2WTNWdFpXNTBMbU55WldGMFpVVnNaVzFsYm5Rb0ozTmpjbWx3ZENjcE8xeHVYRzRnSUdsbUlDaDBhR2x6TG5OamNtbHdkQ2tnZTF4dUlDQWdJSFJvYVhNdWMyTnlhWEIwTG5CaGNtVnVkRTV2WkdVdWNtVnRiM1psUTJocGJHUW9kR2hwY3k1elkzSnBjSFFwTzF4dUlDQWdJSFJvYVhNdWMyTnlhWEIwSUQwZ2JuVnNiRHRjYmlBZ2ZWeHVYRzRnSUhOamNtbHdkQzVoYzNsdVl5QTlJSFJ5ZFdVN1hHNGdJSE5qY21sd2RDNXpjbU1nUFNCMGFHbHpMblZ5YVNncE8xeHVJQ0J6WTNKcGNIUXViMjVsY25KdmNpQTlJR1oxYm1OMGFXOXVLR1VwZTF4dUlDQWdJSE5sYkdZdWIyNUZjbkp2Y2lnbmFuTnZibkFnY0c5c2JDQmxjbkp2Y2ljc1pTazdYRzRnSUgwN1hHNWNiaUFnZG1GeUlHbHVjMlZ5ZEVGMElEMGdaRzlqZFcxbGJuUXVaMlYwUld4bGJXVnVkSE5DZVZSaFowNWhiV1VvSjNOamNtbHdkQ2NwV3pCZE8xeHVJQ0JwYm5ObGNuUkJkQzV3WVhKbGJuUk9iMlJsTG1sdWMyVnlkRUpsWm05eVpTaHpZM0pwY0hRc0lHbHVjMlZ5ZEVGMEtUdGNiaUFnZEdocGN5NXpZM0pwY0hRZ1BTQnpZM0pwY0hRN1hHNWNiaUFnZG1GeUlHbHpWVUZuWldOcmJ5QTlJQ2QxYm1SbFptbHVaV1FuSUNFOUlIUjVjR1Z2WmlCdVlYWnBaMkYwYjNJZ0ppWWdMMmRsWTJ0dkwya3VkR1Z6ZENodVlYWnBaMkYwYjNJdWRYTmxja0ZuWlc1MEtUdGNiaUFnWEc0Z0lHbG1JQ2hwYzFWQloyVmphMjhwSUh0Y2JpQWdJQ0J6WlhSVWFXMWxiM1YwS0daMWJtTjBhVzl1SUNncElIdGNiaUFnSUNBZ0lIWmhjaUJwWm5KaGJXVWdQU0JrYjJOMWJXVnVkQzVqY21WaGRHVkZiR1Z0Wlc1MEtDZHBabkpoYldVbktUdGNiaUFnSUNBZ0lHUnZZM1Z0Wlc1MExtSnZaSGt1WVhCd1pXNWtRMmhwYkdRb2FXWnlZVzFsS1R0Y2JpQWdJQ0FnSUdSdlkzVnRaVzUwTG1KdlpIa3VjbVZ0YjNabFEyaHBiR1FvYVdaeVlXMWxLVHRjYmlBZ0lDQjlMQ0F4TURBcE8xeHVJQ0I5WEc1OU8xeHVYRzR2S2lwY2JpQXFJRmR5YVhSbGN5QjNhWFJvSUdFZ2FHbGtaR1Z1SUdsbWNtRnRaUzVjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMU4wY21sdVozMGdaR0YwWVNCMGJ5QnpaVzVrWEc0Z0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQmpZV3hzWldRZ2RYQnZiaUJtYkhWemFDNWNiaUFxSUVCaGNHa2djSEpwZG1GMFpWeHVJQ292WEc1Y2JrcFRUMDVRVUc5c2JHbHVaeTV3Y205MGIzUjVjR1V1Wkc5WGNtbDBaU0E5SUdaMWJtTjBhVzl1SUNoa1lYUmhMQ0JtYmlrZ2UxeHVJQ0IyWVhJZ2MyVnNaaUE5SUhSb2FYTTdYRzVjYmlBZ2FXWWdLQ0YwYUdsekxtWnZjbTBwSUh0Y2JpQWdJQ0IyWVhJZ1ptOXliU0E5SUdSdlkzVnRaVzUwTG1OeVpXRjBaVVZzWlcxbGJuUW9KMlp2Y20wbktUdGNiaUFnSUNCMllYSWdZWEpsWVNBOUlHUnZZM1Z0Wlc1MExtTnlaV0YwWlVWc1pXMWxiblFvSjNSbGVIUmhjbVZoSnlrN1hHNGdJQ0FnZG1GeUlHbGtJRDBnZEdocGN5NXBabkpoYldWSlpDQTlJQ2RsYVc5ZmFXWnlZVzFsWHljZ0t5QjBhR2x6TG1sdVpHVjRPMXh1SUNBZ0lIWmhjaUJwWm5KaGJXVTdYRzVjYmlBZ0lDQm1iM0p0TG1Oc1lYTnpUbUZ0WlNBOUlDZHpiMk5yWlhScGJ5YzdYRzRnSUNBZ1ptOXliUzV6ZEhsc1pTNXdiM05wZEdsdmJpQTlJQ2RoWW5OdmJIVjBaU2M3WEc0Z0lDQWdabTl5YlM1emRIbHNaUzUwYjNBZ1BTQW5MVEV3TURCd2VDYzdYRzRnSUNBZ1ptOXliUzV6ZEhsc1pTNXNaV1owSUQwZ0p5MHhNREF3Y0hnbk8xeHVJQ0FnSUdadmNtMHVkR0Z5WjJWMElEMGdhV1E3WEc0Z0lDQWdabTl5YlM1dFpYUm9iMlFnUFNBblVFOVRWQ2M3WEc0Z0lDQWdabTl5YlM1elpYUkJkSFJ5YVdKMWRHVW9KMkZqWTJWd2RDMWphR0Z5YzJWMEp5d2dKM1YwWmkwNEp5azdYRzRnSUNBZ1lYSmxZUzV1WVcxbElEMGdKMlFuTzF4dUlDQWdJR1p2Y20wdVlYQndaVzVrUTJocGJHUW9ZWEpsWVNrN1hHNGdJQ0FnWkc5amRXMWxiblF1WW05a2VTNWhjSEJsYm1SRGFHbHNaQ2htYjNKdEtUdGNibHh1SUNBZ0lIUm9hWE11Wm05eWJTQTlJR1p2Y20wN1hHNGdJQ0FnZEdocGN5NWhjbVZoSUQwZ1lYSmxZVHRjYmlBZ2ZWeHVYRzRnSUhSb2FYTXVabTl5YlM1aFkzUnBiMjRnUFNCMGFHbHpMblZ5YVNncE8xeHVYRzRnSUdaMWJtTjBhVzl1SUdOdmJYQnNaWFJsSUNncElIdGNiaUFnSUNCcGJtbDBTV1p5WVcxbEtDazdYRzRnSUNBZ1ptNG9LVHRjYmlBZ2ZWeHVYRzRnSUdaMWJtTjBhVzl1SUdsdWFYUkpabkpoYldVZ0tDa2dlMXh1SUNBZ0lHbG1JQ2h6Wld4bUxtbG1jbUZ0WlNrZ2UxeHVJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnYzJWc1ppNW1iM0p0TG5KbGJXOTJaVU5vYVd4a0tITmxiR1l1YVdaeVlXMWxLVHRjYmlBZ0lDQWdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0FnSUNBZ2MyVnNaaTV2YmtWeWNtOXlLQ2RxYzI5dWNDQndiMnhzYVc1bklHbG1jbUZ0WlNCeVpXMXZkbUZzSUdWeWNtOXlKeXdnWlNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dVhHNGdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDOHZJR2xsTmlCa2VXNWhiV2xqSUdsbWNtRnRaWE1nZDJsMGFDQjBZWEpuWlhROVhDSmNJaUJ6ZFhCd2IzSjBJQ2gwYUdGdWEzTWdRMmh5YVhNZ1RHRnRZbUZqYUdWeUtWeHVJQ0FnSUNBZ2RtRnlJR2gwYld3Z1BTQW5QR2xtY21GdFpTQnpjbU05WENKcVlYWmhjMk55YVhCME9qQmNJaUJ1WVcxbFBWd2lKeXNnYzJWc1ppNXBabkpoYldWSlpDQXJKMXdpUGljN1hHNGdJQ0FnSUNCcFpuSmhiV1VnUFNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLR2gwYld3cE8xeHVJQ0FnSUgwZ1kyRjBZMmdnS0dVcElIdGNiaUFnSUNBZ0lHbG1jbUZ0WlNBOUlHUnZZM1Z0Wlc1MExtTnlaV0YwWlVWc1pXMWxiblFvSjJsbWNtRnRaU2NwTzF4dUlDQWdJQ0FnYVdaeVlXMWxMbTVoYldVZ1BTQnpaV3htTG1sbWNtRnRaVWxrTzF4dUlDQWdJQ0FnYVdaeVlXMWxMbk55WXlBOUlDZHFZWFpoYzJOeWFYQjBPakFuTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtY21GdFpTNXBaQ0E5SUhObGJHWXVhV1p5WVcxbFNXUTdYRzVjYmlBZ0lDQnpaV3htTG1admNtMHVZWEJ3Wlc1a1EyaHBiR1FvYVdaeVlXMWxLVHRjYmlBZ0lDQnpaV3htTG1sbWNtRnRaU0E5SUdsbWNtRnRaVHRjYmlBZ2ZWeHVYRzRnSUdsdWFYUkpabkpoYldVb0tUdGNibHh1SUNBdkx5QmxjMk5oY0dVZ1hGeHVJSFJ2SUhCeVpYWmxiblFnYVhRZ1puSnZiU0JpWldsdVp5QmpiMjUyWlhKMFpXUWdhVzUwYnlCY1hISmNYRzRnWW5rZ2MyOXRaU0JWUVhOY2JpQWdMeThnWkc5MVlteGxJR1Z6WTJGd2FXNW5JR2x6SUhKbGNYVnBjbVZrSUdadmNpQmxjMk5oY0dWa0lHNWxkeUJzYVc1bGN5QmlaV05oZFhObElIVnVaWE5qWVhCcGJtY2diMllnYm1WM0lHeHBibVZ6SUdOaGJpQmlaU0JrYjI1bElITmhabVZzZVNCdmJpQnpaWEoyWlhJdGMybGtaVnh1SUNCa1lYUmhJRDBnWkdGMFlTNXlaWEJzWVdObEtISkZjMk5oY0dWa1RtVjNiR2x1WlN3Z0oxeGNYRnhjWEc0bktUdGNiaUFnZEdocGN5NWhjbVZoTG5aaGJIVmxJRDBnWkdGMFlTNXlaWEJzWVdObEtISk9aWGRzYVc1bExDQW5YRnhjWEc0bktUdGNibHh1SUNCMGNua2dlMXh1SUNBZ0lIUm9hWE11Wm05eWJTNXpkV0p0YVhRb0tUdGNiaUFnZlNCallYUmphQ2hsS1NCN2ZWeHVYRzRnSUdsbUlDaDBhR2x6TG1sbWNtRnRaUzVoZEhSaFkyaEZkbVZ1ZENrZ2UxeHVJQ0FnSUhSb2FYTXVhV1p5WVcxbExtOXVjbVZoWkhsemRHRjBaV05vWVc1blpTQTlJR1oxYm1OMGFXOXVLQ2w3WEc0Z0lDQWdJQ0JwWmlBb2MyVnNaaTVwWm5KaGJXVXVjbVZoWkhsVGRHRjBaU0E5UFNBblkyOXRjR3hsZEdVbktTQjdYRzRnSUNBZ0lDQWdJR052YlhCc1pYUmxLQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVHRjYmlBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0IwYUdsekxtbG1jbUZ0WlM1dmJteHZZV1FnUFNCamIyMXdiR1YwWlR0Y2JpQWdmVnh1ZlR0Y2JpSmRmUT09IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGZuKXtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3Qob3B0cyl7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gJ29rJztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcbiAgUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlsYm1kcGJtVXVhVzh0WTJ4cFpXNTBMMnhwWWk5MGNtRnVjM0J2Y25SekwzQnZiR3hwYm1jdGVHaHlMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5b3FYRzRnS2lCTmIyUjFiR1VnY21WeGRXbHlaVzFsYm5SekxseHVJQ292WEc1Y2JuWmhjaUJZVFV4SWRIUndVbVZ4ZFdWemRDQTlJSEpsY1hWcGNtVW9KM2h0YkdoMGRIQnlaWEYxWlhOMEp5azdYRzUyWVhJZ1VHOXNiR2x1WnlBOUlISmxjWFZwY21Vb0p5NHZjRzlzYkdsdVp5Y3BPMXh1ZG1GeUlFVnRhWFIwWlhJZ1BTQnlaWEYxYVhKbEtDZGpiMjF3YjI1bGJuUXRaVzFwZEhSbGNpY3BPMXh1ZG1GeUlHbHVhR1Z5YVhRZ1BTQnlaWEYxYVhKbEtDZGpiMjF3YjI1bGJuUXRhVzVvWlhKcGRDY3BPMXh1ZG1GeUlHUmxZblZuSUQwZ2NtVnhkV2x5WlNnblpHVmlkV2NuS1NnblpXNW5hVzVsTG1sdkxXTnNhV1Z1ZERwd2IyeHNhVzVuTFhob2NpY3BPMXh1WEc0dktpcGNiaUFxSUUxdlpIVnNaU0JsZUhCdmNuUnpMbHh1SUNvdlhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdXRWhTTzF4dWJXOWtkV3hsTG1WNGNHOXlkSE11VW1WeGRXVnpkQ0E5SUZKbGNYVmxjM1E3WEc1Y2JpOHFLbHh1SUNvZ1JXMXdkSGtnWm5WdVkzUnBiMjVjYmlBcUwxeHVYRzVtZFc1amRHbHZiaUJsYlhCMGVTZ3BlMzFjYmx4dUx5b3FYRzRnS2lCWVNGSWdVRzlzYkdsdVp5QmpiMjV6ZEhKMVkzUnZjaTVjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdiM0IwYzF4dUlDb2dRR0Z3YVNCd2RXSnNhV05jYmlBcUwxeHVYRzVtZFc1amRHbHZiaUJZU0ZJb2IzQjBjeWw3WEc0Z0lGQnZiR3hwYm1jdVkyRnNiQ2gwYUdsekxDQnZjSFJ6S1R0Y2JseHVJQ0JwWmlBb1oyeHZZbUZzTG14dlkyRjBhVzl1S1NCN1hHNGdJQ0FnZG1GeUlHbHpVMU5NSUQwZ0oyaDBkSEJ6T2ljZ1BUMGdiRzlqWVhScGIyNHVjSEp2ZEc5amIydzdYRzRnSUNBZ2RtRnlJSEJ2Y25RZ1BTQnNiMk5oZEdsdmJpNXdiM0owTzF4dVhHNGdJQ0FnTHk4Z2MyOXRaU0IxYzJWeUlHRm5aVzUwY3lCb1lYWmxJR1Z0Y0hSNUlHQnNiMk5oZEdsdmJpNXdiM0owWUZ4dUlDQWdJR2xtSUNnaGNHOXlkQ2tnZTF4dUlDQWdJQ0FnY0c5eWRDQTlJR2x6VTFOTUlEOGdORFF6SURvZ09EQTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2RHaHBjeTU0WkNBOUlHOXdkSE11YUc5emRHNWhiV1VnSVQwZ1oyeHZZbUZzTG14dlkyRjBhVzl1TG1odmMzUnVZVzFsSUh4OFhHNGdJQ0FnSUNCd2IzSjBJQ0U5SUc5d2RITXVjRzl5ZER0Y2JpQWdJQ0IwYUdsekxuaHpJRDBnYjNCMGN5NXpaV04xY21VZ0lUMGdhWE5UVTB3N1hHNGdJSDFjYm4xY2JseHVMeW9xWEc0Z0tpQkpibWhsY21sMGN5Qm1jbTl0SUZCdmJHeHBibWN1WEc0Z0tpOWNibHh1YVc1b1pYSnBkQ2hZU0ZJc0lGQnZiR3hwYm1jcE8xeHVYRzR2S2lwY2JpQXFJRmhJVWlCemRYQndiM0owY3lCaWFXNWhjbmxjYmlBcUwxeHVYRzVZU0ZJdWNISnZkRzkwZVhCbExuTjFjSEJ2Y25SelFtbHVZWEo1SUQwZ2RISjFaVHRjYmx4dUx5b3FYRzRnS2lCRGNtVmhkR1Z6SUdFZ2NtVnhkV1Z6ZEM1Y2JpQXFYRzRnS2lCQWNHRnlZVzBnZTFOMGNtbHVaMzBnYldWMGFHOWtYRzRnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFxTDF4dVhHNVlTRkl1Y0hKdmRHOTBlWEJsTG5KbGNYVmxjM1FnUFNCbWRXNWpkR2x2YmlodmNIUnpLWHRjYmlBZ2IzQjBjeUE5SUc5d2RITWdmSHdnZTMwN1hHNGdJRzl3ZEhNdWRYSnBJRDBnZEdocGN5NTFjbWtvS1R0Y2JpQWdiM0IwY3k1NFpDQTlJSFJvYVhNdWVHUTdYRzRnSUc5d2RITXVlSE1nUFNCMGFHbHpMbmh6TzF4dUlDQnZjSFJ6TG1GblpXNTBJRDBnZEdocGN5NWhaMlZ1ZENCOGZDQm1ZV3h6WlR0Y2JpQWdiM0IwY3k1emRYQndiM0owYzBKcGJtRnllU0E5SUhSb2FYTXVjM1Z3Y0c5eWRITkNhVzVoY25rN1hHNGdJRzl3ZEhNdVpXNWhZbXhsYzFoRVVpQTlJSFJvYVhNdVpXNWhZbXhsYzFoRVVqdGNibHh1SUNBdkx5QlRVMHdnYjNCMGFXOXVjeUJtYjNJZ1RtOWtaUzVxY3lCamJHbGxiblJjYmlBZ2IzQjBjeTV3Wm5nZ1BTQjBhR2x6TG5CbWVEdGNiaUFnYjNCMGN5NXJaWGtnUFNCMGFHbHpMbXRsZVR0Y2JpQWdiM0IwY3k1d1lYTnpjR2h5WVhObElEMGdkR2hwY3k1d1lYTnpjR2h5WVhObE8xeHVJQ0J2Y0hSekxtTmxjblFnUFNCMGFHbHpMbU5sY25RN1hHNGdJRzl3ZEhNdVkyRWdQU0IwYUdsekxtTmhPMXh1SUNCdmNIUnpMbU5wY0dobGNuTWdQU0IwYUdsekxtTnBjR2hsY25NN1hHNGdJRzl3ZEhNdWNtVnFaV04wVlc1aGRYUm9iM0pwZW1Wa0lEMGdkR2hwY3k1eVpXcGxZM1JWYm1GMWRHaHZjbWw2WldRN1hHNWNiaUFnY21WMGRYSnVJRzVsZHlCU1pYRjFaWE4wS0c5d2RITXBPMXh1ZlR0Y2JseHVMeW9xWEc0Z0tpQlRaVzVrY3lCa1lYUmhMbHh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdVM1J5YVc1bmZTQmtZWFJoSUhSdklITmxibVF1WEc0Z0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQmpZV3hzWldRZ2RYQnZiaUJtYkhWemFDNWNiaUFxSUVCaGNHa2djSEpwZG1GMFpWeHVJQ292WEc1Y2JsaElVaTV3Y205MGIzUjVjR1V1Wkc5WGNtbDBaU0E5SUdaMWJtTjBhVzl1S0dSaGRHRXNJR1p1S1h0Y2JpQWdkbUZ5SUdselFtbHVZWEo1SUQwZ2RIbHdaVzltSUdSaGRHRWdJVDA5SUNkemRISnBibWNuSUNZbUlHUmhkR0VnSVQwOUlIVnVaR1ZtYVc1bFpEdGNiaUFnZG1GeUlISmxjU0E5SUhSb2FYTXVjbVZ4ZFdWemRDaDdJRzFsZEdodlpEb2dKMUJQVTFRbkxDQmtZWFJoT2lCa1lYUmhMQ0JwYzBKcGJtRnllVG9nYVhOQ2FXNWhjbmtnZlNrN1hHNGdJSFpoY2lCelpXeG1JRDBnZEdocGN6dGNiaUFnY21WeExtOXVLQ2R6ZFdOalpYTnpKeXdnWm00cE8xeHVJQ0J5WlhFdWIyNG9KMlZ5Y205eUp5d2dablZ1WTNScGIyNG9aWEp5S1h0Y2JpQWdJQ0J6Wld4bUxtOXVSWEp5YjNJb0ozaG9jaUJ3YjNOMElHVnljbTl5Snl3Z1pYSnlLVHRjYmlBZ2ZTazdYRzRnSUhSb2FYTXVjMlZ1WkZob2NpQTlJSEpsY1R0Y2JuMDdYRzVjYmk4cUtseHVJQ29nVTNSaGNuUnpJR0VnY0c5c2JDQmplV05zWlM1Y2JpQXFYRzRnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFxTDF4dVhHNVlTRkl1Y0hKdmRHOTBlWEJsTG1SdlVHOXNiQ0E5SUdaMWJtTjBhVzl1S0NsN1hHNGdJR1JsWW5WbktDZDRhSElnY0c5c2JDY3BPMXh1SUNCMllYSWdjbVZ4SUQwZ2RHaHBjeTV5WlhGMVpYTjBLQ2s3WEc0Z0lIWmhjaUJ6Wld4bUlEMGdkR2hwY3p0Y2JpQWdjbVZ4TG05dUtDZGtZWFJoSnl3Z1puVnVZM1JwYjI0b1pHRjBZU2w3WEc0Z0lDQWdjMlZzWmk1dmJrUmhkR0VvWkdGMFlTazdYRzRnSUgwcE8xeHVJQ0J5WlhFdWIyNG9KMlZ5Y205eUp5d2dablZ1WTNScGIyNG9aWEp5S1h0Y2JpQWdJQ0J6Wld4bUxtOXVSWEp5YjNJb0ozaG9jaUJ3YjJ4c0lHVnljbTl5Snl3Z1pYSnlLVHRjYmlBZ2ZTazdYRzRnSUhSb2FYTXVjRzlzYkZob2NpQTlJSEpsY1R0Y2JuMDdYRzVjYmk4cUtseHVJQ29nVW1WeGRXVnpkQ0JqYjI1emRISjFZM1J2Y2x4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VDJKcVpXTjBmU0J2Y0hScGIyNXpYRzRnS2lCQVlYQnBJSEIxWW14cFkxeHVJQ292WEc1Y2JtWjFibU4wYVc5dUlGSmxjWFZsYzNRb2IzQjBjeWw3WEc0Z0lIUm9hWE11YldWMGFHOWtJRDBnYjNCMGN5NXRaWFJvYjJRZ2ZId2dKMGRGVkNjN1hHNGdJSFJvYVhNdWRYSnBJRDBnYjNCMGN5NTFjbWs3WEc0Z0lIUm9hWE11ZUdRZ1BTQWhJVzl3ZEhNdWVHUTdYRzRnSUhSb2FYTXVlSE1nUFNBaElXOXdkSE11ZUhNN1hHNGdJSFJvYVhNdVlYTjVibU1nUFNCbVlXeHpaU0FoUFQwZ2IzQjBjeTVoYzNsdVl6dGNiaUFnZEdocGN5NWtZWFJoSUQwZ2RXNWtaV1pwYm1Wa0lDRTlJRzl3ZEhNdVpHRjBZU0EvSUc5d2RITXVaR0YwWVNBNklHNTFiR3c3WEc0Z0lIUm9hWE11WVdkbGJuUWdQU0J2Y0hSekxtRm5aVzUwTzF4dUlDQjBhR2x6TG1selFtbHVZWEo1SUQwZ2IzQjBjeTVwYzBKcGJtRnllVHRjYmlBZ2RHaHBjeTV6ZFhCd2IzSjBjMEpwYm1GeWVTQTlJRzl3ZEhNdWMzVndjRzl5ZEhOQ2FXNWhjbms3WEc0Z0lIUm9hWE11Wlc1aFlteGxjMWhFVWlBOUlHOXdkSE11Wlc1aFlteGxjMWhFVWp0Y2JseHVJQ0F2THlCVFUwd2diM0IwYVc5dWN5Qm1iM0lnVG05a1pTNXFjeUJqYkdsbGJuUmNiaUFnZEdocGN5NXdabmdnUFNCdmNIUnpMbkJtZUR0Y2JpQWdkR2hwY3k1clpYa2dQU0J2Y0hSekxtdGxlVHRjYmlBZ2RHaHBjeTV3WVhOemNHaHlZWE5sSUQwZ2IzQjBjeTV3WVhOemNHaHlZWE5sTzF4dUlDQjBhR2x6TG1ObGNuUWdQU0J2Y0hSekxtTmxjblE3WEc0Z0lIUm9hWE11WTJFZ1BTQnZjSFJ6TG1OaE8xeHVJQ0IwYUdsekxtTnBjR2hsY25NZ1BTQnZjSFJ6TG1OcGNHaGxjbk03WEc0Z0lIUm9hWE11Y21WcVpXTjBWVzVoZFhSb2IzSnBlbVZrSUQwZ2IzQjBjeTV5WldwbFkzUlZibUYxZEdodmNtbDZaV1E3WEc1Y2JpQWdkR2hwY3k1amNtVmhkR1VvS1R0Y2JuMWNibHh1THlvcVhHNGdLaUJOYVhnZ2FXNGdZRVZ0YVhSMFpYSmdMbHh1SUNvdlhHNWNia1Z0YVhSMFpYSW9VbVZ4ZFdWemRDNXdjbTkwYjNSNWNHVXBPMXh1WEc0dktpcGNiaUFxSUVOeVpXRjBaWE1nZEdobElGaElVaUJ2WW1wbFkzUWdZVzVrSUhObGJtUnpJSFJvWlNCeVpYRjFaWE4wTGx4dUlDcGNiaUFxSUVCaGNHa2djSEpwZG1GMFpWeHVJQ292WEc1Y2JsSmxjWFZsYzNRdWNISnZkRzkwZVhCbExtTnlaV0YwWlNBOUlHWjFibU4wYVc5dUtDbDdYRzRnSUhaaGNpQnZjSFJ6SUQwZ2V5QmhaMlZ1ZERvZ2RHaHBjeTVoWjJWdWRDd2dlR1J2YldGcGJqb2dkR2hwY3k1NFpDd2dlSE5qYUdWdFpUb2dkR2hwY3k1NGN5d2daVzVoWW14bGMxaEVVam9nZEdocGN5NWxibUZpYkdWeldFUlNJSDA3WEc1Y2JpQWdMeThnVTFOTUlHOXdkR2x2Ym5NZ1ptOXlJRTV2WkdVdWFuTWdZMnhwWlc1MFhHNGdJRzl3ZEhNdWNHWjRJRDBnZEdocGN5NXdabmc3WEc0Z0lHOXdkSE11YTJWNUlEMGdkR2hwY3k1clpYazdYRzRnSUc5d2RITXVjR0Z6YzNCb2NtRnpaU0E5SUhSb2FYTXVjR0Z6YzNCb2NtRnpaVHRjYmlBZ2IzQjBjeTVqWlhKMElEMGdkR2hwY3k1alpYSjBPMXh1SUNCdmNIUnpMbU5oSUQwZ2RHaHBjeTVqWVR0Y2JpQWdiM0IwY3k1amFYQm9aWEp6SUQwZ2RHaHBjeTVqYVhCb1pYSnpPMXh1SUNCdmNIUnpMbkpsYW1WamRGVnVZWFYwYUc5eWFYcGxaQ0E5SUhSb2FYTXVjbVZxWldOMFZXNWhkWFJvYjNKcGVtVmtPMXh1WEc0Z0lIWmhjaUI0YUhJZ1BTQjBhR2x6TG5ob2NpQTlJRzVsZHlCWVRVeElkSFJ3VW1WeGRXVnpkQ2h2Y0hSektUdGNiaUFnZG1GeUlITmxiR1lnUFNCMGFHbHpPMXh1WEc0Z0lIUnllU0I3WEc0Z0lDQWdaR1ZpZFdjb0ozaG9jaUJ2Y0dWdUlDVnpPaUFsY3ljc0lIUm9hWE11YldWMGFHOWtMQ0IwYUdsekxuVnlhU2s3WEc0Z0lDQWdlR2h5TG05d1pXNG9kR2hwY3k1dFpYUm9iMlFzSUhSb2FYTXVkWEpwTENCMGFHbHpMbUZ6ZVc1aktUdGNiaUFnSUNCcFppQW9kR2hwY3k1emRYQndiM0owYzBKcGJtRnllU2tnZTF4dUlDQWdJQ0FnTHk4Z1ZHaHBjeUJvWVhNZ2RHOGdZbVVnWkc5dVpTQmhablJsY2lCdmNHVnVJR0psWTJGMWMyVWdSbWx5WldadmVDQnBjeUJ6ZEhWd2FXUmNiaUFnSUNBZ0lDOHZJR2gwZEhBNkx5OXpkR0ZqYTI5MlpYSm1iRzkzTG1OdmJTOXhkV1Z6ZEdsdmJuTXZNVE15TVRZNU1ETXZaMlYwTFdKcGJtRnllUzFrWVhSaExYZHBkR2d0ZUcxc2FIUjBjSEpsY1hWbGMzUXRhVzR0WVMxbWFYSmxabTk0TFdWNGRHVnVjMmx2Ymx4dUlDQWdJQ0FnZUdoeUxuSmxjM0J2Ym5ObFZIbHdaU0E5SUNkaGNuSmhlV0oxWm1abGNpYzdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLQ2RRVDFOVUp5QTlQU0IwYUdsekxtMWxkR2h2WkNrZ2UxeHVJQ0FnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJQ0FnYVdZZ0tIUm9hWE11YVhOQ2FXNWhjbmtwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjRhSEl1YzJWMFVtVnhkV1Z6ZEVobFlXUmxjaWduUTI5dWRHVnVkQzEwZVhCbEp5d2dKMkZ3Y0d4cFkyRjBhVzl1TDI5amRHVjBMWE4wY21WaGJTY3BPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUhob2NpNXpaWFJTWlhGMVpYTjBTR1ZoWkdWeUtDZERiMjUwWlc1MExYUjVjR1VuTENBbmRHVjRkQzl3YkdGcGJqdGphR0Z5YzJWMFBWVlVSaTA0SnlrN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMGdZMkYwWTJnZ0tHVXBJSHQ5WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnYVdVMklHTm9aV05yWEc0Z0lDQWdhV1lnS0NkM2FYUm9RM0psWkdWdWRHbGhiSE1uSUdsdUlIaG9jaWtnZTF4dUlDQWdJQ0FnZUdoeUxuZHBkR2hEY21Wa1pXNTBhV0ZzY3lBOUlIUnlkV1U3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdhV1lnS0hSb2FYTXVhR0Z6V0VSU0tDa3BJSHRjYmlBZ0lDQWdJSGhvY2k1dmJteHZZV1FnUFNCbWRXNWpkR2x2YmlncGUxeHVJQ0FnSUNBZ0lDQnpaV3htTG05dVRHOWhaQ2dwTzF4dUlDQWdJQ0FnZlR0Y2JpQWdJQ0FnSUhob2NpNXZibVZ5Y205eUlEMGdablZ1WTNScGIyNG9LWHRjYmlBZ0lDQWdJQ0FnYzJWc1ppNXZia1Z5Y205eUtIaG9jaTV5WlhOd2IyNXpaVlJsZUhRcE8xeHVJQ0FnSUNBZ2ZUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnZUdoeUxtOXVjbVZoWkhsemRHRjBaV05vWVc1blpTQTlJR1oxYm1OMGFXOXVLQ2w3WEc0Z0lDQWdJQ0FnSUdsbUlDZzBJQ0U5SUhob2NpNXlaV0ZrZVZOMFlYUmxLU0J5WlhSMWNtNDdYRzRnSUNBZ0lDQWdJR2xtSUNneU1EQWdQVDBnZUdoeUxuTjBZWFIxY3lCOGZDQXhNakl6SUQwOUlIaG9jaTV6ZEdGMGRYTXBJSHRjYmlBZ0lDQWdJQ0FnSUNCelpXeG1MbTl1VEc5aFpDZ3BPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUM4dklHMWhhMlVnYzNWeVpTQjBhR1VnWUdWeWNtOXlZQ0JsZG1WdWRDQm9ZVzVrYkdWeUlIUm9ZWFFuY3lCMWMyVnlMWE5sZEZ4dUlDQWdJQ0FnSUNBZ0lDOHZJR1J2WlhNZ2JtOTBJSFJvY205M0lHbHVJSFJvWlNCellXMWxJSFJwWTJzZ1lXNWtJR2RsZEhNZ1kyRjFaMmgwSUdobGNtVmNiaUFnSUNBZ0lDQWdJQ0J6WlhSVWFXMWxiM1YwS0daMWJtTjBhVzl1S0NsN1hHNGdJQ0FnSUNBZ0lDQWdJQ0J6Wld4bUxtOXVSWEp5YjNJb2VHaHlMbk4wWVhSMWN5azdYRzRnSUNBZ0lDQWdJQ0FnZlN3Z01DazdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDA3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdaR1ZpZFdjb0ozaG9jaUJrWVhSaElDVnpKeXdnZEdocGN5NWtZWFJoS1R0Y2JpQWdJQ0I0YUhJdWMyVnVaQ2gwYUdsekxtUmhkR0VwTzF4dUlDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdMeThnVG1WbFpDQjBieUJrWldabGNpQnphVzVqWlNBdVkzSmxZWFJsS0NrZ2FYTWdZMkZzYkdWa0lHUnBjbVZqZEd4NUlHWm9jbTl0SUhSb1pTQmpiMjV6ZEhKMVkzUnZjbHh1SUNBZ0lDOHZJR0Z1WkNCMGFIVnpJSFJvWlNBblpYSnliM0luSUdWMlpXNTBJR05oYmlCdmJteDVJR0psSUc5dWJIa2dZbTkxYm1RZ0ttRm1kR1Z5S2lCMGFHbHpJR1Y0WTJWd2RHbHZibHh1SUNBZ0lDOHZJRzlqWTNWeWN5NGdJRlJvWlhKbFptOXlaU3dnWVd4emJ5d2dkMlVnWTJGdWJtOTBJSFJvY205M0lHaGxjbVVnWVhRZ1lXeHNMbHh1SUNBZ0lITmxkRlJwYldWdmRYUW9ablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J6Wld4bUxtOXVSWEp5YjNJb1pTazdYRzRnSUNBZ2ZTd2dNQ2s3WEc0Z0lDQWdjbVYwZFhKdU8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0dkc2IySmhiQzVrYjJOMWJXVnVkQ2tnZTF4dUlDQWdJSFJvYVhNdWFXNWtaWGdnUFNCU1pYRjFaWE4wTG5KbGNYVmxjM1J6UTI5MWJuUXJLenRjYmlBZ0lDQlNaWEYxWlhOMExuSmxjWFZsYzNSelczUm9hWE11YVc1a1pYaGRJRDBnZEdocGN6dGNiaUFnZlZ4dWZUdGNibHh1THlvcVhHNGdLaUJEWVd4c1pXUWdkWEJ2YmlCemRXTmpaWE56Wm5Wc0lISmxjM0J2Ym5ObExseHVJQ3BjYmlBcUlFQmhjR2tnY0hKcGRtRjBaVnh1SUNvdlhHNWNibEpsY1hWbGMzUXVjSEp2ZEc5MGVYQmxMbTl1VTNWalkyVnpjeUE5SUdaMWJtTjBhVzl1S0NsN1hHNGdJSFJvYVhNdVpXMXBkQ2duYzNWalkyVnpjeWNwTzF4dUlDQjBhR2x6TG1Oc1pXRnVkWEFvS1R0Y2JuMDdYRzVjYmk4cUtseHVJQ29nUTJGc2JHVmtJR2xtSUhkbElHaGhkbVVnWkdGMFlTNWNiaUFxWEc0Z0tpQkFZWEJwSUhCeWFYWmhkR1ZjYmlBcUwxeHVYRzVTWlhGMVpYTjBMbkJ5YjNSdmRIbHdaUzV2YmtSaGRHRWdQU0JtZFc1amRHbHZiaWhrWVhSaEtYdGNiaUFnZEdocGN5NWxiV2wwS0Nka1lYUmhKeXdnWkdGMFlTazdYRzRnSUhSb2FYTXViMjVUZFdOalpYTnpLQ2s3WEc1OU8xeHVYRzR2S2lwY2JpQXFJRU5oYkd4bFpDQjFjRzl1SUdWeWNtOXlMbHh1SUNwY2JpQXFJRUJoY0drZ2NISnBkbUYwWlZ4dUlDb3ZYRzVjYmxKbGNYVmxjM1F1Y0hKdmRHOTBlWEJsTG05dVJYSnliM0lnUFNCbWRXNWpkR2x2YmlobGNuSXBlMXh1SUNCMGFHbHpMbVZ0YVhRb0oyVnljbTl5Snl3Z1pYSnlLVHRjYmlBZ2RHaHBjeTVqYkdWaGJuVndLSFJ5ZFdVcE8xeHVmVHRjYmx4dUx5b3FYRzRnS2lCRGJHVmhibk1nZFhBZ2FHOTFjMlV1WEc0Z0tseHVJQ29nUUdGd2FTQndjbWwyWVhSbFhHNGdLaTljYmx4dVVtVnhkV1Z6ZEM1d2NtOTBiM1I1Y0dVdVkyeGxZVzUxY0NBOUlHWjFibU4wYVc5dUtHWnliMjFGY25KdmNpbDdYRzRnSUdsbUlDZ25kVzVrWldacGJtVmtKeUE5UFNCMGVYQmxiMllnZEdocGN5NTRhSElnZkh3Z2JuVnNiQ0E5UFQwZ2RHaHBjeTU0YUhJcElIdGNiaUFnSUNCeVpYUjFjbTQ3WEc0Z0lIMWNiaUFnTHk4Z2VHMXNhSFIwY0hKbGNYVmxjM1JjYmlBZ2FXWWdLSFJvYVhNdWFHRnpXRVJTS0NrcElIdGNiaUFnSUNCMGFHbHpMbmhvY2k1dmJteHZZV1FnUFNCMGFHbHpMbmhvY2k1dmJtVnljbTl5SUQwZ1pXMXdkSGs3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnZEdocGN5NTRhSEl1YjI1eVpXRmtlWE4wWVhSbFkyaGhibWRsSUQwZ1pXMXdkSGs3WEc0Z0lIMWNibHh1SUNCcFppQW9abkp2YlVWeWNtOXlLU0I3WEc0Z0lDQWdkSEo1SUh0Y2JpQWdJQ0FnSUhSb2FYTXVlR2h5TG1GaWIzSjBLQ2s3WEc0Z0lDQWdmU0JqWVhSamFDaGxLU0I3ZlZ4dUlDQjlYRzVjYmlBZ2FXWWdLR2RzYjJKaGJDNWtiMk4xYldWdWRDa2dlMXh1SUNBZ0lHUmxiR1YwWlNCU1pYRjFaWE4wTG5KbGNYVmxjM1J6VzNSb2FYTXVhVzVrWlhoZE8xeHVJQ0I5WEc1Y2JpQWdkR2hwY3k1NGFISWdQU0J1ZFd4c08xeHVmVHRjYmx4dUx5b3FYRzRnS2lCRFlXeHNaV1FnZFhCdmJpQnNiMkZrTGx4dUlDcGNiaUFxSUVCaGNHa2djSEpwZG1GMFpWeHVJQ292WEc1Y2JsSmxjWFZsYzNRdWNISnZkRzkwZVhCbExtOXVURzloWkNBOUlHWjFibU4wYVc5dUtDbDdYRzRnSUhaaGNpQmtZWFJoTzF4dUlDQjBjbmtnZTF4dUlDQWdJSFpoY2lCamIyNTBaVzUwVkhsd1pUdGNiaUFnSUNCMGNua2dlMXh1SUNBZ0lDQWdZMjl1ZEdWdWRGUjVjR1VnUFNCMGFHbHpMbmhvY2k1blpYUlNaWE53YjI1elpVaGxZV1JsY2lnblEyOXVkR1Z1ZEMxVWVYQmxKeWt1YzNCc2FYUW9KenNuS1Zzd1hUdGNiaUFnSUNCOUlHTmhkR05vSUNobEtTQjdmVnh1SUNBZ0lHbG1JQ2hqYjI1MFpXNTBWSGx3WlNBOVBUMGdKMkZ3Y0d4cFkyRjBhVzl1TDI5amRHVjBMWE4wY21WaGJTY3BJSHRjYmlBZ0lDQWdJR1JoZEdFZ1BTQjBhR2x6TG5ob2NpNXlaWE53YjI1elpUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnYVdZZ0tDRjBhR2x6TG5OMWNIQnZjblJ6UW1sdVlYSjVLU0I3WEc0Z0lDQWdJQ0FnSUdSaGRHRWdQU0IwYUdsekxuaG9jaTV5WlhOd2IyNXpaVlJsZUhRN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCa1lYUmhJRDBnSjI5ckp6dGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDBnWTJGMFkyZ2dLR1VwSUh0Y2JpQWdJQ0IwYUdsekxtOXVSWEp5YjNJb1pTazdYRzRnSUgxY2JpQWdhV1lnS0c1MWJHd2dJVDBnWkdGMFlTa2dlMXh1SUNBZ0lIUm9hWE11YjI1RVlYUmhLR1JoZEdFcE8xeHVJQ0I5WEc1OU8xeHVYRzR2S2lwY2JpQXFJRU5vWldOcklHbG1JR2wwSUdoaGN5QllSRzl0WVdsdVVtVnhkV1Z6ZEM1Y2JpQXFYRzRnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFxTDF4dVhHNVNaWEYxWlhOMExuQnliM1J2ZEhsd1pTNW9ZWE5ZUkZJZ1BTQm1kVzVqZEdsdmJpZ3BlMXh1SUNCeVpYUjFjbTRnSjNWdVpHVm1hVzVsWkNjZ0lUMDlJSFI1Y0dWdlppQm5iRzlpWVd3dVdFUnZiV0ZwYmxKbGNYVmxjM1FnSmlZZ0lYUm9hWE11ZUhNZ0ppWWdkR2hwY3k1bGJtRmliR1Z6V0VSU08xeHVmVHRjYmx4dUx5b3FYRzRnS2lCQlltOXlkSE1nZEdobElISmxjWFZsYzNRdVhHNGdLbHh1SUNvZ1FHRndhU0J3ZFdKc2FXTmNiaUFxTDF4dVhHNVNaWEYxWlhOMExuQnliM1J2ZEhsd1pTNWhZbTl5ZENBOUlHWjFibU4wYVc5dUtDbDdYRzRnSUhSb2FYTXVZMnhsWVc1MWNDZ3BPMXh1ZlR0Y2JseHVMeW9xWEc0Z0tpQkJZbTl5ZEhNZ2NHVnVaR2x1WnlCeVpYRjFaWE4wY3lCM2FHVnVJSFZ1Ykc5aFpHbHVaeUIwYUdVZ2QybHVaRzkzTGlCVWFHbHpJR2x6SUc1bFpXUmxaQ0IwYnlCd2NtVjJaVzUwWEc0Z0tpQnRaVzF2Y25rZ2JHVmhhM01nS0dVdVp5NGdkMmhsYmlCMWMybHVaeUJKUlNrZ1lXNWtJSFJ2SUdWdWMzVnlaU0IwYUdGMElHNXZJSE53ZFhKcGIzVnpJR1Z5Y205eUlHbHpYRzRnS2lCbGJXbDBkR1ZrTGx4dUlDb3ZYRzVjYm1sbUlDaG5iRzlpWVd3dVpHOWpkVzFsYm5RcElIdGNiaUFnVW1WeGRXVnpkQzV5WlhGMVpYTjBjME52ZFc1MElEMGdNRHRjYmlBZ1VtVnhkV1Z6ZEM1eVpYRjFaWE4wY3lBOUlIdDlPMXh1SUNCcFppQW9aMnh2WW1Gc0xtRjBkR0ZqYUVWMlpXNTBLU0I3WEc0Z0lDQWdaMnh2WW1Gc0xtRjBkR0ZqYUVWMlpXNTBLQ2R2Ym5WdWJHOWhaQ2NzSUhWdWJHOWhaRWhoYm1Sc1pYSXBPMXh1SUNCOUlHVnNjMlVnYVdZZ0tHZHNiMkpoYkM1aFpHUkZkbVZ1ZEV4cGMzUmxibVZ5S1NCN1hHNGdJQ0FnWjJ4dlltRnNMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9KMkpsWm05eVpYVnViRzloWkNjc0lIVnViRzloWkVoaGJtUnNaWElzSUdaaGJITmxLVHRjYmlBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCMWJteHZZV1JJWVc1a2JHVnlLQ2tnZTF4dUlDQm1iM0lnS0haaGNpQnBJR2x1SUZKbGNYVmxjM1F1Y21WeGRXVnpkSE1wSUh0Y2JpQWdJQ0JwWmlBb1VtVnhkV1Z6ZEM1eVpYRjFaWE4wY3k1b1lYTlBkMjVRY205d1pYSjBlU2hwS1NrZ2UxeHVJQ0FnSUNBZ1VtVnhkV1Z6ZEM1eVpYRjFaWE4wYzF0cFhTNWhZbTl5ZENncE8xeHVJQ0FnSUgxY2JpQWdmVnh1ZlZ4dUlsMTkiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0gK25ldyBEYXRlICsgJy0nICsgVHJhbnNwb3J0LnRpbWVzdGFtcHMrKztcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyB0aGlzLmhvc3RuYW1lICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXG4vKipcbiAqIGB3c2AgZXhwb3NlcyBhIFdlYlNvY2tldC1jb21wYXRpYmxlIGludGVyZmFjZSBpblxuICogTm9kZSwgb3IgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyLlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldil7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5pZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9O1xufVxuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFja2V0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldHNbaV0sIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIC8vU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgLy9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH1cbiAgLy8gZmFrZSBkcmFpblxuICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gIHNldFRpbWVvdXQob25kcmFpbiwgMCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MylcbiAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9ICtuZXcgRGF0ZTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgdGhpcy5ob3N0bmFtZSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaChlKSB7IH1cbiAgfVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgsXG4gIC8vIHdoZXJlIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2YgY29uc29sZVxuICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhbFN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBsb2NhbFN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuIiwiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gICAgdmFyIHNyYyA9IHN0cixcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxuICAgICAgICB1cmkgPSB7fSxcbiAgICAgICAgaSA9IDE0O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1cmk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBzdXBwb3J0c0JpbmFyeSkge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dGY4ZW5jb2RlKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlsYm1kcGJtVXVhVzh0Y0dGeWMyVnlMMnhwWWk5aWNtOTNjMlZ5TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5b3FYRzRnS2lCTmIyUjFiR1VnWkdWd1pXNWtaVzVqYVdWekxseHVJQ292WEc1Y2JuWmhjaUJyWlhseklEMGdjbVZ4ZFdseVpTZ25MaTlyWlhsekp5azdYRzUyWVhJZ2FHRnpRbWx1WVhKNUlEMGdjbVZ4ZFdseVpTZ25hR0Z6TFdKcGJtRnllU2NwTzF4dWRtRnlJSE5zYVdObFFuVm1abVZ5SUQwZ2NtVnhkV2x5WlNnbllYSnlZWGxpZFdabVpYSXVjMnhwWTJVbktUdGNiblpoY2lCaVlYTmxOalJsYm1OdlpHVnlJRDBnY21WeGRXbHlaU2duWW1GelpUWTBMV0Z5Y21GNVluVm1abVZ5SnlrN1hHNTJZWElnWVdaMFpYSWdQU0J5WlhGMWFYSmxLQ2RoWm5SbGNpY3BPMXh1ZG1GeUlIVjBaamdnUFNCeVpYRjFhWEpsS0NkMWRHWTRKeWs3WEc1Y2JpOHFLbHh1SUNvZ1EyaGxZMnNnYVdZZ2QyVWdZWEpsSUhKMWJtNXBibWNnWVc0Z1lXNWtjbTlwWkNCaWNtOTNjMlZ5TGlCVWFHRjBJSEpsY1hWcGNtVnpJSFZ6SUhSdklIVnpaVnh1SUNvZ1FYSnlZWGxDZFdabVpYSWdkMmwwYUNCd2IyeHNhVzVuSUhSeVlXNXpjRzl5ZEhNdUxpNWNiaUFxWEc0Z0tpQm9kSFJ3T2k4dloyaHBibVJoTG01bGRDOXFjR1ZuTFdKc2IySXRZV3BoZUMxaGJtUnliMmxrTDF4dUlDb3ZYRzVjYm5aaGNpQnBjMEZ1WkhKdmFXUWdQU0J1WVhacFoyRjBiM0l1ZFhObGNrRm5aVzUwTG0xaGRHTm9LQzlCYm1SeWIybGtMMmtwTzF4dVhHNHZLaXBjYmlBcUlFTm9aV05ySUdsbUlIZGxJR0Z5WlNCeWRXNXVhVzVuSUdsdUlGQm9ZVzUwYjIxS1V5NWNiaUFxSUZWd2JHOWhaR2x1WnlCaElFSnNiMklnZDJsMGFDQlFhR0Z1ZEc5dFNsTWdaRzlsY3lCdWIzUWdkMjl5YXlCamIzSnlaV04wYkhrc0lHRnpJSEpsY0c5eWRHVmtJR2hsY21VNlhHNGdLaUJvZEhSd2N6b3ZMMmRwZEdoMVlpNWpiMjB2WVhKcGVXRXZjR2hoYm5SdmJXcHpMMmx6YzNWbGN5OHhNVE01TlZ4dUlDb2dRSFI1Y0dVZ1ltOXZiR1ZoYmx4dUlDb3ZYRzUyWVhJZ2FYTlFhR0Z1ZEc5dFNsTWdQU0F2VUdoaGJuUnZiVXBUTDJrdWRHVnpkQ2h1WVhacFoyRjBiM0l1ZFhObGNrRm5aVzUwS1R0Y2JseHVMeW9xWEc0Z0tpQlhhR1Z1SUhSeWRXVXNJR0YyYjJsa2N5QjFjMmx1WnlCQ2JHOWljeUIwYnlCbGJtTnZaR1VnY0dGNWJHOWhaSE11WEc0Z0tpQkFkSGx3WlNCaWIyOXNaV0Z1WEc0Z0tpOWNiblpoY2lCa2IyNTBVMlZ1WkVKc2IySnpJRDBnYVhOQmJtUnliMmxrSUh4OElHbHpVR2hoYm5SdmJVcFRPMXh1WEc0dktpcGNiaUFxSUVOMWNuSmxiblFnY0hKdmRHOWpiMndnZG1WeWMybHZiaTVjYmlBcUwxeHVYRzVsZUhCdmNuUnpMbkJ5YjNSdlkyOXNJRDBnTXp0Y2JseHVMeW9xWEc0Z0tpQlFZV05yWlhRZ2RIbHdaWE11WEc0Z0tpOWNibHh1ZG1GeUlIQmhZMnRsZEhNZ1BTQmxlSEJ2Y25SekxuQmhZMnRsZEhNZ1BTQjdYRzRnSUNBZ2IzQmxiam9nSUNBZ0lEQWdJQ0FnTHk4Z2JtOXVMWGR6WEc0Z0lDd2dZMnh2YzJVNklDQWdJREVnSUNBZ0x5OGdibTl1TFhkelhHNGdJQ3dnY0dsdVp6b2dJQ0FnSURKY2JpQWdMQ0J3YjI1bk9pQWdJQ0FnTTF4dUlDQXNJRzFsYzNOaFoyVTZJQ0EwWEc0Z0lDd2dkWEJuY21Ga1pUb2dJRFZjYmlBZ0xDQnViMjl3T2lBZ0lDQWdObHh1ZlR0Y2JseHVkbUZ5SUhCaFkydGxkSE5zYVhOMElEMGdhMlY1Y3lod1lXTnJaWFJ6S1R0Y2JseHVMeW9xWEc0Z0tpQlFjbVZ0WVdSbElHVnljbTl5SUhCaFkydGxkQzVjYmlBcUwxeHVYRzUyWVhJZ1pYSnlJRDBnZXlCMGVYQmxPaUFuWlhKeWIzSW5MQ0JrWVhSaE9pQW5jR0Z5YzJWeUlHVnljbTl5SnlCOU8xeHVYRzR2S2lwY2JpQXFJRU55WldGMFpTQmhJR0pzYjJJZ1lYQnBJR1YyWlc0Z1ptOXlJR0pzYjJJZ1luVnBiR1JsY2lCM2FHVnVJSFpsYm1SdmNpQndjbVZtYVhobGN5QmxlR2x6ZEZ4dUlDb3ZYRzVjYm5aaGNpQkNiRzlpSUQwZ2NtVnhkV2x5WlNnbllteHZZaWNwTzF4dVhHNHZLaXBjYmlBcUlFVnVZMjlrWlhNZ1lTQndZV05yWlhRdVhHNGdLbHh1SUNvZ0lDQWdJRHh3WVdOclpYUWdkSGx3WlNCcFpENGdXeUE4WkdGMFlUNGdYVnh1SUNwY2JpQXFJRVY0WVcxd2JHVTZYRzRnS2x4dUlDb2dJQ0FnSURWb1pXeHNieUIzYjNKc1pGeHVJQ29nSUNBZ0lETmNiaUFxSUNBZ0lDQTBYRzRnS2x4dUlDb2dRbWx1WVhKNUlHbHpJR1Z1WTI5a1pXUWdhVzRnWVc0Z2FXUmxiblJwWTJGc0lIQnlhVzVqYVhCc1pWeHVJQ3BjYmlBcUlFQmhjR2tnY0hKcGRtRjBaVnh1SUNvdlhHNWNibVY0Y0c5eWRITXVaVzVqYjJSbFVHRmphMlYwSUQwZ1puVnVZM1JwYjI0Z0tIQmhZMnRsZEN3Z2MzVndjRzl5ZEhOQ2FXNWhjbmtzSUhWMFpqaGxibU52WkdVc0lHTmhiR3hpWVdOcktTQjdYRzRnSUdsbUlDZ25ablZ1WTNScGIyNG5JRDA5SUhSNWNHVnZaaUJ6ZFhCd2IzSjBjMEpwYm1GeWVTa2dlMXh1SUNBZ0lHTmhiR3hpWVdOcklEMGdjM1Z3Y0c5eWRITkNhVzVoY25rN1hHNGdJQ0FnYzNWd2NHOXlkSE5DYVc1aGNua2dQU0JtWVd4elpUdGNiaUFnZlZ4dVhHNGdJR2xtSUNnblpuVnVZM1JwYjI0bklEMDlJSFI1Y0dWdlppQjFkR1k0Wlc1amIyUmxLU0I3WEc0Z0lDQWdZMkZzYkdKaFkyc2dQU0IxZEdZNFpXNWpiMlJsTzF4dUlDQWdJSFYwWmpobGJtTnZaR1VnUFNCdWRXeHNPMXh1SUNCOVhHNWNiaUFnZG1GeUlHUmhkR0VnUFNBb2NHRmphMlYwTG1SaGRHRWdQVDA5SUhWdVpHVm1hVzVsWkNsY2JpQWdJQ0EvSUhWdVpHVm1hVzVsWkZ4dUlDQWdJRG9nY0dGamEyVjBMbVJoZEdFdVluVm1abVZ5SUh4OElIQmhZMnRsZEM1a1lYUmhPMXh1WEc0Z0lHbG1JQ2huYkc5aVlXd3VRWEp5WVhsQ2RXWm1aWElnSmlZZ1pHRjBZU0JwYm5OMFlXNWpaVzltSUVGeWNtRjVRblZtWm1WeUtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdWdVkyOWtaVUZ5Y21GNVFuVm1abVZ5S0hCaFkydGxkQ3dnYzNWd2NHOXlkSE5DYVc1aGNua3NJR05oYkd4aVlXTnJLVHRjYmlBZ2ZTQmxiSE5sSUdsbUlDaENiRzlpSUNZbUlHUmhkR0VnYVc1emRHRnVZMlZ2WmlCbmJHOWlZV3d1UW14dllpa2dlMXh1SUNBZ0lISmxkSFZ5YmlCbGJtTnZaR1ZDYkc5aUtIQmhZMnRsZEN3Z2MzVndjRzl5ZEhOQ2FXNWhjbmtzSUdOaGJHeGlZV05yS1R0Y2JpQWdmVnh1WEc0Z0lDOHZJRzFwWjJoMElHSmxJR0Z1SUc5aWFtVmpkQ0IzYVhSb0lIc2dZbUZ6WlRZME9pQjBjblZsTENCa1lYUmhPaUJrWVhSaFFYTkNZWE5sTmpSVGRISnBibWNnZlZ4dUlDQnBaaUFvWkdGMFlTQW1KaUJrWVhSaExtSmhjMlUyTkNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJsYm1OdlpHVkNZWE5sTmpSUFltcGxZM1FvY0dGamEyVjBMQ0JqWVd4c1ltRmpheWs3WEc0Z0lIMWNibHh1SUNBdkx5QlRaVzVrYVc1bklHUmhkR0VnWVhNZ1lTQjFkR1l0T0NCemRISnBibWRjYmlBZ2RtRnlJR1Z1WTI5a1pXUWdQU0J3WVdOclpYUnpXM0JoWTJ0bGRDNTBlWEJsWFR0Y2JseHVJQ0F2THlCa1lYUmhJR1p5WVdkdFpXNTBJR2x6SUc5d2RHbHZibUZzWEc0Z0lHbG1JQ2gxYm1SbFptbHVaV1FnSVQwOUlIQmhZMnRsZEM1a1lYUmhLU0I3WEc0Z0lDQWdaVzVqYjJSbFpDQXJQU0IxZEdZNFpXNWpiMlJsSUQ4Z2RYUm1PQzVsYm1OdlpHVW9VM1J5YVc1bktIQmhZMnRsZEM1a1lYUmhLU2tnT2lCVGRISnBibWNvY0dGamEyVjBMbVJoZEdFcE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHTmhiR3hpWVdOcktDY25JQ3NnWlc1amIyUmxaQ2s3WEc1Y2JuMDdYRzVjYm1aMWJtTjBhVzl1SUdWdVkyOWtaVUpoYzJVMk5FOWlhbVZqZENod1lXTnJaWFFzSUdOaGJHeGlZV05yS1NCN1hHNGdJQzh2SUhCaFkydGxkQ0JrWVhSaElHbHpJR0Z1SUc5aWFtVmpkQ0I3SUdKaGMyVTJORG9nZEhKMVpTd2daR0YwWVRvZ1pHRjBZVUZ6UW1GelpUWTBVM1J5YVc1bklIMWNiaUFnZG1GeUlHMWxjM05oWjJVZ1BTQW5ZaWNnS3lCbGVIQnZjblJ6TG5CaFkydGxkSE5iY0dGamEyVjBMblI1Y0dWZElDc2djR0ZqYTJWMExtUmhkR0V1WkdGMFlUdGNiaUFnY21WMGRYSnVJR05oYkd4aVlXTnJLRzFsYzNOaFoyVXBPMXh1ZlZ4dVhHNHZLaXBjYmlBcUlFVnVZMjlrWlNCd1lXTnJaWFFnYUdWc2NHVnljeUJtYjNJZ1ltbHVZWEo1SUhSNWNHVnpYRzRnS2k5Y2JseHVablZ1WTNScGIyNGdaVzVqYjJSbFFYSnlZWGxDZFdabVpYSW9jR0ZqYTJWMExDQnpkWEJ3YjNKMGMwSnBibUZ5ZVN3Z1kyRnNiR0poWTJzcElIdGNiaUFnYVdZZ0tDRnpkWEJ3YjNKMGMwSnBibUZ5ZVNrZ2UxeHVJQ0FnSUhKbGRIVnliaUJsZUhCdmNuUnpMbVZ1WTI5a1pVSmhjMlUyTkZCaFkydGxkQ2h3WVdOclpYUXNJR05oYkd4aVlXTnJLVHRjYmlBZ2ZWeHVYRzRnSUhaaGNpQmtZWFJoSUQwZ2NHRmphMlYwTG1SaGRHRTdYRzRnSUhaaGNpQmpiMjUwWlc1MFFYSnlZWGtnUFNCdVpYY2dWV2x1ZERoQmNuSmhlU2hrWVhSaEtUdGNiaUFnZG1GeUlISmxjM1ZzZEVKMVptWmxjaUE5SUc1bGR5QlZhVzUwT0VGeWNtRjVLREVnS3lCa1lYUmhMbUo1ZEdWTVpXNW5kR2dwTzF4dVhHNGdJSEpsYzNWc2RFSjFabVpsY2xzd1hTQTlJSEJoWTJ0bGRITmJjR0ZqYTJWMExuUjVjR1ZkTzF4dUlDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR052Ym5SbGJuUkJjbkpoZVM1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lISmxjM1ZzZEVKMVptWmxjbHRwS3pGZElEMGdZMjl1ZEdWdWRFRnljbUY1VzJsZE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHTmhiR3hpWVdOcktISmxjM1ZzZEVKMVptWmxjaTVpZFdabVpYSXBPMXh1ZlZ4dVhHNW1kVzVqZEdsdmJpQmxibU52WkdWQ2JHOWlRWE5CY25KaGVVSjFabVpsY2lod1lXTnJaWFFzSUhOMWNIQnZjblJ6UW1sdVlYSjVMQ0JqWVd4c1ltRmpheWtnZTF4dUlDQnBaaUFvSVhOMWNIQnZjblJ6UW1sdVlYSjVLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHVjRjRzl5ZEhNdVpXNWpiMlJsUW1GelpUWTBVR0ZqYTJWMEtIQmhZMnRsZEN3Z1kyRnNiR0poWTJzcE8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUdaeUlEMGdibVYzSUVacGJHVlNaV0ZrWlhJb0tUdGNiaUFnWm5JdWIyNXNiMkZrSUQwZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ2NHRmphMlYwTG1SaGRHRWdQU0JtY2k1eVpYTjFiSFE3WEc0Z0lDQWdaWGh3YjNKMGN5NWxibU52WkdWUVlXTnJaWFFvY0dGamEyVjBMQ0J6ZFhCd2IzSjBjMEpwYm1GeWVTd2dkSEoxWlN3Z1kyRnNiR0poWTJzcE8xeHVJQ0I5TzF4dUlDQnlaWFIxY200Z1puSXVjbVZoWkVGelFYSnlZWGxDZFdabVpYSW9jR0ZqYTJWMExtUmhkR0VwTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJsYm1OdlpHVkNiRzlpS0hCaFkydGxkQ3dnYzNWd2NHOXlkSE5DYVc1aGNua3NJR05oYkd4aVlXTnJLU0I3WEc0Z0lHbG1JQ2doYzNWd2NHOXlkSE5DYVc1aGNua3BJSHRjYmlBZ0lDQnlaWFIxY200Z1pYaHdiM0owY3k1bGJtTnZaR1ZDWVhObE5qUlFZV05yWlhRb2NHRmphMlYwTENCallXeHNZbUZqYXlrN1hHNGdJSDFjYmx4dUlDQnBaaUFvWkc5dWRGTmxibVJDYkc5aWN5a2dlMXh1SUNBZ0lISmxkSFZ5YmlCbGJtTnZaR1ZDYkc5aVFYTkJjbkpoZVVKMVptWmxjaWh3WVdOclpYUXNJSE4xY0hCdmNuUnpRbWx1WVhKNUxDQmpZV3hzWW1GamF5azdYRzRnSUgxY2JseHVJQ0IyWVhJZ2JHVnVaM1JvSUQwZ2JtVjNJRlZwYm5RNFFYSnlZWGtvTVNrN1hHNGdJR3hsYm1kMGFGc3dYU0E5SUhCaFkydGxkSE5iY0dGamEyVjBMblI1Y0dWZE8xeHVJQ0IyWVhJZ1lteHZZaUE5SUc1bGR5QkNiRzlpS0Z0c1pXNW5kR2d1WW5WbVptVnlMQ0J3WVdOclpYUXVaR0YwWVYwcE8xeHVYRzRnSUhKbGRIVnliaUJqWVd4c1ltRmpheWhpYkc5aUtUdGNibjFjYmx4dUx5b3FYRzRnS2lCRmJtTnZaR1Z6SUdFZ2NHRmphMlYwSUhkcGRHZ2dZbWx1WVhKNUlHUmhkR0VnYVc0Z1lTQmlZWE5sTmpRZ2MzUnlhVzVuWEc0Z0tseHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJSEJoWTJ0bGRDd2dhR0Z6SUdCMGVYQmxZQ0JoYm1RZ1lHUmhkR0ZnWEc0Z0tpQkFjbVYwZFhKdUlIdFRkSEpwYm1kOUlHSmhjMlUyTkNCbGJtTnZaR1ZrSUcxbGMzTmhaMlZjYmlBcUwxeHVYRzVsZUhCdmNuUnpMbVZ1WTI5a1pVSmhjMlUyTkZCaFkydGxkQ0E5SUdaMWJtTjBhVzl1S0hCaFkydGxkQ3dnWTJGc2JHSmhZMnNwSUh0Y2JpQWdkbUZ5SUcxbGMzTmhaMlVnUFNBbllpY2dLeUJsZUhCdmNuUnpMbkJoWTJ0bGRITmJjR0ZqYTJWMExuUjVjR1ZkTzF4dUlDQnBaaUFvUW14dllpQW1KaUJ3WVdOclpYUXVaR0YwWVNCcGJuTjBZVzVqWlc5bUlFSnNiMklwSUh0Y2JpQWdJQ0IyWVhJZ1puSWdQU0J1WlhjZ1JtbHNaVkpsWVdSbGNpZ3BPMXh1SUNBZ0lHWnlMbTl1Ykc5aFpDQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnZG1GeUlHSTJOQ0E5SUdaeUxuSmxjM1ZzZEM1emNHeHBkQ2duTENjcFd6RmRPMXh1SUNBZ0lDQWdZMkZzYkdKaFkyc29iV1Z6YzJGblpTQXJJR0kyTkNrN1hHNGdJQ0FnZlR0Y2JpQWdJQ0J5WlhSMWNtNGdabkl1Y21WaFpFRnpSR0YwWVZWU1RDaHdZV05yWlhRdVpHRjBZU2s3WEc0Z0lIMWNibHh1SUNCMllYSWdZalkwWkdGMFlUdGNiaUFnZEhKNUlIdGNiaUFnSUNCaU5qUmtZWFJoSUQwZ1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pTNWhjSEJzZVNodWRXeHNMQ0J1WlhjZ1ZXbHVkRGhCY25KaGVTaHdZV05yWlhRdVpHRjBZU2twTzF4dUlDQjlJR05oZEdOb0lDaGxLU0I3WEc0Z0lDQWdMeThnYVZCb2IyNWxJRk5oWm1GeWFTQmtiMlZ6YmlkMElHeGxkQ0I1YjNVZ1lYQndiSGtnZDJsMGFDQjBlWEJsWkNCaGNuSmhlWE5jYmlBZ0lDQjJZWElnZEhsd1pXUWdQU0J1WlhjZ1ZXbHVkRGhCY25KaGVTaHdZV05yWlhRdVpHRjBZU2s3WEc0Z0lDQWdkbUZ5SUdKaGMybGpJRDBnYm1WM0lFRnljbUY1S0hSNWNHVmtMbXhsYm1kMGFDazdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQjBlWEJsWkM1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdZbUZ6YVdOYmFWMGdQU0IwZVhCbFpGdHBYVHRjYmlBZ0lDQjlYRzRnSUNBZ1lqWTBaR0YwWVNBOUlGTjBjbWx1Wnk1bWNtOXRRMmhoY2tOdlpHVXVZWEJ3Ykhrb2JuVnNiQ3dnWW1GemFXTXBPMXh1SUNCOVhHNGdJRzFsYzNOaFoyVWdLejBnWjJ4dlltRnNMbUowYjJFb1lqWTBaR0YwWVNrN1hHNGdJSEpsZEhWeWJpQmpZV3hzWW1GamF5aHRaWE56WVdkbEtUdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1JHVmpiMlJsY3lCaElIQmhZMnRsZEM0Z1EyaGhibWRsY3lCbWIzSnRZWFFnZEc4Z1FteHZZaUJwWmlCeVpYRjFaWE4wWldRdVhHNGdLbHh1SUNvZ1FISmxkSFZ5YmlCN1QySnFaV04wZlNCM2FYUm9JR0IwZVhCbFlDQmhibVFnWUdSaGRHRmdJQ2hwWmlCaGJua3BYRzRnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFxTDF4dVhHNWxlSEJ2Y25SekxtUmxZMjlrWlZCaFkydGxkQ0E5SUdaMWJtTjBhVzl1SUNoa1lYUmhMQ0JpYVc1aGNubFVlWEJsTENCMWRHWTRaR1ZqYjJSbEtTQjdYRzRnSUM4dklGTjBjbWx1WnlCa1lYUmhYRzRnSUdsbUlDaDBlWEJsYjJZZ1pHRjBZU0E5UFNBbmMzUnlhVzVuSnlCOGZDQmtZWFJoSUQwOVBTQjFibVJsWm1sdVpXUXBJSHRjYmlBZ0lDQnBaaUFvWkdGMFlTNWphR0Z5UVhRb01Da2dQVDBnSjJJbktTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1pYaHdiM0owY3k1a1pXTnZaR1ZDWVhObE5qUlFZV05yWlhRb1pHRjBZUzV6ZFdKemRISW9NU2tzSUdKcGJtRnllVlI1Y0dVcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUdsbUlDaDFkR1k0WkdWamIyUmxLU0I3WEc0Z0lDQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ0lDQmtZWFJoSUQwZ2RYUm1PQzVrWldOdlpHVW9aR0YwWVNrN1hHNGdJQ0FnSUNCOUlHTmhkR05vSUNobEtTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmxjbkk3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNBZ0lIWmhjaUIwZVhCbElEMGdaR0YwWVM1amFHRnlRWFFvTUNrN1hHNWNiaUFnSUNCcFppQW9UblZ0WW1WeUtIUjVjR1VwSUNFOUlIUjVjR1VnZkh3Z0lYQmhZMnRsZEhOc2FYTjBXM1I1Y0dWZEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1pYSnlPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2hrWVhSaExteGxibWQwYUNBK0lERXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQjdJSFI1Y0dVNklIQmhZMnRsZEhOc2FYTjBXM1I1Y0dWZExDQmtZWFJoT2lCa1lYUmhMbk4xWW5OMGNtbHVaeWd4S1NCOU8xeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdleUIwZVhCbE9pQndZV05yWlhSemJHbHpkRnQwZVhCbFhTQjlPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSFpoY2lCaGMwRnljbUY1SUQwZ2JtVjNJRlZwYm5RNFFYSnlZWGtvWkdGMFlTazdYRzRnSUhaaGNpQjBlWEJsSUQwZ1lYTkJjbkpoZVZzd1hUdGNiaUFnZG1GeUlISmxjM1FnUFNCemJHbGpaVUoxWm1abGNpaGtZWFJoTENBeEtUdGNiaUFnYVdZZ0tFSnNiMklnSmlZZ1ltbHVZWEo1Vkhsd1pTQTlQVDBnSjJKc2IySW5LU0I3WEc0Z0lDQWdjbVZ6ZENBOUlHNWxkeUJDYkc5aUtGdHlaWE4wWFNrN1hHNGdJSDFjYmlBZ2NtVjBkWEp1SUhzZ2RIbHdaVG9nY0dGamEyVjBjMnhwYzNSYmRIbHdaVjBzSUdSaGRHRTZJSEpsYzNRZ2ZUdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1JHVmpiMlJsY3lCaElIQmhZMnRsZENCbGJtTnZaR1ZrSUdsdUlHRWdZbUZ6WlRZMElITjBjbWx1WjF4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0JpWVhObE5qUWdaVzVqYjJSbFpDQnRaWE56WVdkbFhHNGdLaUJBY21WMGRYSnVJSHRQWW1wbFkzUjlJSGRwZEdnZ1lIUjVjR1ZnSUdGdVpDQmdaR0YwWVdBZ0tHbG1JR0Z1ZVNsY2JpQXFMMXh1WEc1bGVIQnZjblJ6TG1SbFkyOWtaVUpoYzJVMk5GQmhZMnRsZENBOUlHWjFibU4wYVc5dUtHMXpaeXdnWW1sdVlYSjVWSGx3WlNrZ2UxeHVJQ0IyWVhJZ2RIbHdaU0E5SUhCaFkydGxkSE5zYVhOMFcyMXpaeTVqYUdGeVFYUW9NQ2xkTzF4dUlDQnBaaUFvSVdkc2IySmhiQzVCY25KaGVVSjFabVpsY2lrZ2UxeHVJQ0FnSUhKbGRIVnliaUI3SUhSNWNHVTZJSFI1Y0dVc0lHUmhkR0U2SUhzZ1ltRnpaVFkwT2lCMGNuVmxMQ0JrWVhSaE9pQnRjMmN1YzNWaWMzUnlLREVwSUgwZ2ZUdGNiaUFnZlZ4dVhHNGdJSFpoY2lCa1lYUmhJRDBnWW1GelpUWTBaVzVqYjJSbGNpNWtaV052WkdVb2JYTm5Mbk4xWW5OMGNpZ3hLU2s3WEc1Y2JpQWdhV1lnS0dKcGJtRnllVlI1Y0dVZ1BUMDlJQ2RpYkc5aUp5QW1KaUJDYkc5aUtTQjdYRzRnSUNBZ1pHRjBZU0E5SUc1bGR5QkNiRzlpS0Z0a1lYUmhYU2s3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZXlCMGVYQmxPaUIwZVhCbExDQmtZWFJoT2lCa1lYUmhJSDA3WEc1OU8xeHVYRzR2S2lwY2JpQXFJRVZ1WTI5a1pYTWdiWFZzZEdsd2JHVWdiV1Z6YzJGblpYTWdLSEJoZVd4dllXUXBMbHh1SUNwY2JpQXFJQ0FnSUNBOGJHVnVaM1JvUGpwa1lYUmhYRzRnS2x4dUlDb2dSWGhoYlhCc1pUcGNiaUFxWEc0Z0tpQWdJQ0FnTVRFNmFHVnNiRzhnZDI5eWJHUXlPbWhwWEc0Z0tseHVJQ29nU1dZZ1lXNTVJR052Ym5SbGJuUnpJR0Z5WlNCaWFXNWhjbmtzSUhSb1pYa2dkMmxzYkNCaVpTQmxibU52WkdWa0lHRnpJR0poYzJVMk5DQnpkSEpwYm1kekxpQkNZWE5sTmpSY2JpQXFJR1Z1WTI5a1pXUWdjM1J5YVc1bmN5QmhjbVVnYldGeWEyVmtJSGRwZEdnZ1lTQmlJR0psWm05eVpTQjBhR1VnYkdWdVozUm9JSE53WldOcFptbGxjbHh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdRWEp5WVhsOUlIQmhZMnRsZEhOY2JpQXFJRUJoY0drZ2NISnBkbUYwWlZ4dUlDb3ZYRzVjYm1WNGNHOXlkSE11Wlc1amIyUmxVR0Y1Ykc5aFpDQTlJR1oxYm1OMGFXOXVJQ2h3WVdOclpYUnpMQ0J6ZFhCd2IzSjBjMEpwYm1GeWVTd2dZMkZzYkdKaFkyc3BJSHRjYmlBZ2FXWWdLSFI1Y0dWdlppQnpkWEJ3YjNKMGMwSnBibUZ5ZVNBOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdZMkZzYkdKaFkyc2dQU0J6ZFhCd2IzSjBjMEpwYm1GeWVUdGNiaUFnSUNCemRYQndiM0owYzBKcGJtRnllU0E5SUc1MWJHdzdYRzRnSUgxY2JseHVJQ0IyWVhJZ2FYTkNhVzVoY25rZ1BTQm9ZWE5DYVc1aGNua29jR0ZqYTJWMGN5azdYRzVjYmlBZ2FXWWdLSE4xY0hCdmNuUnpRbWx1WVhKNUlDWW1JR2x6UW1sdVlYSjVLU0I3WEc0Z0lDQWdhV1lnS0VKc2IySWdKaVlnSVdSdmJuUlRaVzVrUW14dlluTXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmxlSEJ2Y25SekxtVnVZMjlrWlZCaGVXeHZZV1JCYzBKc2IySW9jR0ZqYTJWMGN5d2dZMkZzYkdKaFkyc3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkSFZ5YmlCbGVIQnZjblJ6TG1WdVkyOWtaVkJoZVd4dllXUkJjMEZ5Y21GNVFuVm1abVZ5S0hCaFkydGxkSE1zSUdOaGJHeGlZV05yS1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2doY0dGamEyVjBjeTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQnlaWFIxY200Z1kyRnNiR0poWTJzb0p6QTZKeWs3WEc0Z0lIMWNibHh1SUNCbWRXNWpkR2x2YmlCelpYUk1aVzVuZEdoSVpXRmtaWElvYldWemMyRm5aU2tnZTF4dUlDQWdJSEpsZEhWeWJpQnRaWE56WVdkbExteGxibWQwYUNBcklDYzZKeUFySUcxbGMzTmhaMlU3WEc0Z0lIMWNibHh1SUNCbWRXNWpkR2x2YmlCbGJtTnZaR1ZQYm1Vb2NHRmphMlYwTENCa2IyNWxRMkZzYkdKaFkyc3BJSHRjYmlBZ0lDQmxlSEJ2Y25SekxtVnVZMjlrWlZCaFkydGxkQ2h3WVdOclpYUXNJQ0ZwYzBKcGJtRnllU0EvSUdaaGJITmxJRG9nYzNWd2NHOXlkSE5DYVc1aGNua3NJSFJ5ZFdVc0lHWjFibU4wYVc5dUtHMWxjM05oWjJVcElIdGNiaUFnSUNBZ0lHUnZibVZEWVd4c1ltRmpheWh1ZFd4c0xDQnpaWFJNWlc1bmRHaElaV0ZrWlhJb2JXVnpjMkZuWlNrcE8xeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1Y2JpQWdiV0Z3S0hCaFkydGxkSE1zSUdWdVkyOWtaVTl1WlN3Z1puVnVZM1JwYjI0b1pYSnlMQ0J5WlhOMWJIUnpLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHTmhiR3hpWVdOcktISmxjM1ZzZEhNdWFtOXBiaWduSnlrcE8xeHVJQ0I5S1R0Y2JuMDdYRzVjYmk4cUtseHVJQ29nUVhONWJtTWdZWEp5WVhrZ2JXRndJSFZ6YVc1bklHRm1kR1Z5WEc0Z0tpOWNibHh1Wm5WdVkzUnBiMjRnYldGd0tHRnllU3dnWldGamFDd2daRzl1WlNrZ2UxeHVJQ0IyWVhJZ2NtVnpkV3gwSUQwZ2JtVjNJRUZ5Y21GNUtHRnllUzVzWlc1bmRHZ3BPMXh1SUNCMllYSWdibVY0ZENBOUlHRm1kR1Z5S0dGeWVTNXNaVzVuZEdnc0lHUnZibVVwTzF4dVhHNGdJSFpoY2lCbFlXTm9WMmwwYUVsdVpHVjRJRDBnWm5WdVkzUnBiMjRvYVN3Z1pXd3NJR05pS1NCN1hHNGdJQ0FnWldGamFDaGxiQ3dnWm5WdVkzUnBiMjRvWlhKeWIzSXNJRzF6WnlrZ2UxeHVJQ0FnSUNBZ2NtVnpkV3gwVzJsZElEMGdiWE5uTzF4dUlDQWdJQ0FnWTJJb1pYSnliM0lzSUhKbGMzVnNkQ2s3WEc0Z0lDQWdmU2s3WEc0Z0lIMDdYRzVjYmlBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQmhjbmt1YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNCbFlXTm9WMmwwYUVsdVpHVjRLR2tzSUdGeWVWdHBYU3dnYm1WNGRDazdYRzRnSUgxY2JuMWNibHh1THlwY2JpQXFJRVJsWTI5a1pYTWdaR0YwWVNCM2FHVnVJR0VnY0dGNWJHOWhaQ0JwY3lCdFlYbGlaU0JsZUhCbFkzUmxaQzRnVUc5emMybGliR1VnWW1sdVlYSjVJR052Ym5SbGJuUnpJR0Z5WlZ4dUlDb2daR1ZqYjJSbFpDQm1jbTl0SUhSb1pXbHlJR0poYzJVMk5DQnlaWEJ5WlhObGJuUmhkR2x2Ymx4dUlDcGNiaUFxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0JrWVhSaExDQmpZV3hzWW1GamF5QnRaWFJvYjJSY2JpQXFJRUJoY0drZ2NIVmliR2xqWEc0Z0tpOWNibHh1Wlhod2IzSjBjeTVrWldOdlpHVlFZWGxzYjJGa0lEMGdablZ1WTNScGIyNGdLR1JoZEdFc0lHSnBibUZ5ZVZSNWNHVXNJR05oYkd4aVlXTnJLU0I3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdaR0YwWVNBaFBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lISmxkSFZ5YmlCbGVIQnZjblJ6TG1SbFkyOWtaVkJoZVd4dllXUkJjMEpwYm1GeWVTaGtZWFJoTENCaWFXNWhjbmxVZVhCbExDQmpZV3hzWW1GamF5azdYRzRnSUgxY2JseHVJQ0JwWmlBb2RIbHdaVzltSUdKcGJtRnllVlI1Y0dVZ1BUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0JqWVd4c1ltRmpheUE5SUdKcGJtRnllVlI1Y0dVN1hHNGdJQ0FnWW1sdVlYSjVWSGx3WlNBOUlHNTFiR3c3WEc0Z0lIMWNibHh1SUNCMllYSWdjR0ZqYTJWME8xeHVJQ0JwWmlBb1pHRjBZU0E5UFNBbkp5a2dlMXh1SUNBZ0lDOHZJSEJoY25ObGNpQmxjbkp2Y2lBdElHbG5ibTl5YVc1bklIQmhlV3h2WVdSY2JpQWdJQ0J5WlhSMWNtNGdZMkZzYkdKaFkyc29aWEp5TENBd0xDQXhLVHRjYmlBZ2ZWeHVYRzRnSUhaaGNpQnNaVzVuZEdnZ1BTQW5KMXh1SUNBZ0lDd2diaXdnYlhObk8xeHVYRzRnSUdadmNpQW9kbUZ5SUdrZ1BTQXdMQ0JzSUQwZ1pHRjBZUzVzWlc1bmRHZzdJR2tnUENCc095QnBLeXNwSUh0Y2JpQWdJQ0IyWVhJZ1kyaHlJRDBnWkdGMFlTNWphR0Z5UVhRb2FTazdYRzVjYmlBZ0lDQnBaaUFvSnpvbklDRTlJR05vY2lrZ2UxeHVJQ0FnSUNBZ2JHVnVaM1JvSUNzOUlHTm9janRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2FXWWdLQ2NuSUQwOUlHeGxibWQwYUNCOGZDQW9iR1Z1WjNSb0lDRTlJQ2h1SUQwZ1RuVnRZbVZ5S0d4bGJtZDBhQ2twS1NrZ2UxeHVJQ0FnSUNBZ0lDQXZMeUJ3WVhKelpYSWdaWEp5YjNJZ0xTQnBaMjV2Y21sdVp5QndZWGxzYjJGa1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCallXeHNZbUZqYXlobGNuSXNJREFzSURFcE8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnRjMmNnUFNCa1lYUmhMbk4xWW5OMGNpaHBJQ3NnTVN3Z2JpazdYRzVjYmlBZ0lDQWdJR2xtSUNoc1pXNW5kR2dnSVQwZ2JYTm5MbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdJQ0F2THlCd1lYSnpaWElnWlhKeWIzSWdMU0JwWjI1dmNtbHVaeUJ3WVhsc2IyRmtYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmpZV3hzWW1GamF5aGxjbklzSURBc0lERXBPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JwWmlBb2JYTm5MbXhsYm1kMGFDa2dlMXh1SUNBZ0lDQWdJQ0J3WVdOclpYUWdQU0JsZUhCdmNuUnpMbVJsWTI5a1pWQmhZMnRsZENodGMyY3NJR0pwYm1GeWVWUjVjR1VzSUhSeWRXVXBPMXh1WEc0Z0lDQWdJQ0FnSUdsbUlDaGxjbkl1ZEhsd1pTQTlQU0J3WVdOclpYUXVkSGx3WlNBbUppQmxjbkl1WkdGMFlTQTlQU0J3WVdOclpYUXVaR0YwWVNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQzh2SUhCaGNuTmxjaUJsY25KdmNpQnBiaUJwYm1ScGRtbGtkV0ZzSUhCaFkydGxkQ0F0SUdsbmJtOXlhVzVuSUhCaGVXeHZZV1JjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnWTJGc2JHSmhZMnNvWlhKeUxDQXdMQ0F4S1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJSFpoY2lCeVpYUWdQU0JqWVd4c1ltRmpheWh3WVdOclpYUXNJR2tnS3lCdUxDQnNLVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHWmhiSE5sSUQwOVBTQnlaWFFwSUhKbGRIVnlianRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1lXUjJZVzVqWlNCamRYSnpiM0pjYmlBZ0lDQWdJR2tnS3owZ2JqdGNiaUFnSUNBZ0lHeGxibWQwYUNBOUlDY25PMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJR2xtSUNoc1pXNW5kR2dnSVQwZ0p5Y3BJSHRjYmlBZ0lDQXZMeUJ3WVhKelpYSWdaWEp5YjNJZ0xTQnBaMjV2Y21sdVp5QndZWGxzYjJGa1hHNGdJQ0FnY21WMGRYSnVJR05oYkd4aVlXTnJLR1Z5Y2l3Z01Dd2dNU2s3WEc0Z0lIMWNibHh1ZlR0Y2JseHVMeW9xWEc0Z0tpQkZibU52WkdWeklHMTFiSFJwY0d4bElHMWxjM05oWjJWeklDaHdZWGxzYjJGa0tTQmhjeUJpYVc1aGNua3VYRzRnS2x4dUlDb2dQREVnUFNCaWFXNWhjbmtzSURBZ1BTQnpkSEpwYm1jK1BHNTFiV0psY2lCbWNtOXRJREF0T1Q0OGJuVnRZbVZ5SUdaeWIyMGdNQzA1UGxzdUxpNWRQRzUxYldKbGNseHVJQ29nTWpVMVBqeGtZWFJoUGx4dUlDcGNiaUFxSUVWNFlXMXdiR1U2WEc0Z0tpQXhJRE1nTWpVMUlERWdNaUF6TENCcFppQjBhR1VnWW1sdVlYSjVJR052Ym5SbGJuUnpJR0Z5WlNCcGJuUmxjbkJ5WlhSbFpDQmhjeUE0SUdKcGRDQnBiblJsWjJWeWMxeHVJQ3BjYmlBcUlFQndZWEpoYlNCN1FYSnlZWGw5SUhCaFkydGxkSE5jYmlBcUlFQnlaWFIxY200Z2UwRnljbUY1UW5WbVptVnlmU0JsYm1OdlpHVmtJSEJoZVd4dllXUmNiaUFxSUVCaGNHa2djSEpwZG1GMFpWeHVJQ292WEc1Y2JtVjRjRzl5ZEhNdVpXNWpiMlJsVUdGNWJHOWhaRUZ6UVhKeVlYbENkV1ptWlhJZ1BTQm1kVzVqZEdsdmJpaHdZV05yWlhSekxDQmpZV3hzWW1GamF5a2dlMXh1SUNCcFppQW9JWEJoWTJ0bGRITXViR1Z1WjNSb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUdOaGJHeGlZV05yS0c1bGR5QkJjbkpoZVVKMVptWmxjaWd3S1NrN1hHNGdJSDFjYmx4dUlDQm1kVzVqZEdsdmJpQmxibU52WkdWUGJtVW9jR0ZqYTJWMExDQmtiMjVsUTJGc2JHSmhZMnNwSUh0Y2JpQWdJQ0JsZUhCdmNuUnpMbVZ1WTI5a1pWQmhZMnRsZENod1lXTnJaWFFzSUhSeWRXVXNJSFJ5ZFdVc0lHWjFibU4wYVc5dUtHUmhkR0VwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJrYjI1bFEyRnNiR0poWTJzb2JuVnNiQ3dnWkdGMFlTazdYRzRnSUNBZ2ZTazdYRzRnSUgxY2JseHVJQ0J0WVhBb2NHRmphMlYwY3l3Z1pXNWpiMlJsVDI1bExDQm1kVzVqZEdsdmJpaGxjbklzSUdWdVkyOWtaV1JRWVdOclpYUnpLU0I3WEc0Z0lDQWdkbUZ5SUhSdmRHRnNUR1Z1WjNSb0lEMGdaVzVqYjJSbFpGQmhZMnRsZEhNdWNtVmtkV05sS0daMWJtTjBhVzl1S0dGall5d2djQ2tnZTF4dUlDQWdJQ0FnZG1GeUlHeGxianRjYmlBZ0lDQWdJR2xtSUNoMGVYQmxiMllnY0NBOVBUMGdKM04wY21sdVp5Y3BlMXh1SUNBZ0lDQWdJQ0JzWlc0Z1BTQndMbXhsYm1kMGFEdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lHeGxiaUE5SUhBdVlubDBaVXhsYm1kMGFEdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxkSFZ5YmlCaFkyTWdLeUJzWlc0dWRHOVRkSEpwYm1jb0tTNXNaVzVuZEdnZ0t5QnNaVzRnS3lBeU95QXZMeUJ6ZEhKcGJtY3ZZbWx1WVhKNUlHbGtaVzUwYVdacFpYSWdLeUJ6WlhCaGNtRjBiM0lnUFNBeVhHNGdJQ0FnZlN3Z01DazdYRzVjYmlBZ0lDQjJZWElnY21WemRXeDBRWEp5WVhrZ1BTQnVaWGNnVldsdWREaEJjbkpoZVNoMGIzUmhiRXhsYm1kMGFDazdYRzVjYmlBZ0lDQjJZWElnWW5WbVptVnlTVzVrWlhnZ1BTQXdPMXh1SUNBZ0lHVnVZMjlrWldSUVlXTnJaWFJ6TG1admNrVmhZMmdvWm5WdVkzUnBiMjRvY0NrZ2UxeHVJQ0FnSUNBZ2RtRnlJR2x6VTNSeWFXNW5JRDBnZEhsd1pXOW1JSEFnUFQwOUlDZHpkSEpwYm1jbk8xeHVJQ0FnSUNBZ2RtRnlJR0ZpSUQwZ2NEdGNiaUFnSUNBZ0lHbG1JQ2hwYzFOMGNtbHVaeWtnZTF4dUlDQWdJQ0FnSUNCMllYSWdkbWxsZHlBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0hBdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQndMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkbWxsZDF0cFhTQTlJSEF1WTJoaGNrTnZaR1ZCZENocEtUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JoWWlBOUlIWnBaWGN1WW5WbVptVnlPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JwWmlBb2FYTlRkSEpwYm1jcElIc2dMeThnYm05MElIUnlkV1VnWW1sdVlYSjVYRzRnSUNBZ0lDQWdJSEpsYzNWc2RFRnljbUY1VzJKMVptWmxja2x1WkdWNEt5dGRJRDBnTUR0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0I3SUM4dklIUnlkV1VnWW1sdVlYSjVYRzRnSUNBZ0lDQWdJSEpsYzNWc2RFRnljbUY1VzJKMVptWmxja2x1WkdWNEt5dGRJRDBnTVR0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2RtRnlJR3hsYmxOMGNpQTlJR0ZpTG1KNWRHVk1aVzVuZEdndWRHOVRkSEpwYm1jb0tUdGNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2diR1Z1VTNSeUxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0FnSUhKbGMzVnNkRUZ5Y21GNVcySjFabVpsY2tsdVpHVjRLeXRkSUQwZ2NHRnljMlZKYm5Rb2JHVnVVM1J5VzJsZEtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lISmxjM1ZzZEVGeWNtRjVXMkoxWm1abGNrbHVaR1Y0S3l0ZElEMGdNalUxTzF4dVhHNGdJQ0FnSUNCMllYSWdkbWxsZHlBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0dGaUtUdGNiaUFnSUNBZ0lHWnZjaUFvZG1GeUlHa2dQU0F3T3lCcElEd2dkbWxsZHk1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdJQ0J5WlhOMWJIUkJjbkpoZVZ0aWRXWm1aWEpKYm1SbGVDc3JYU0E5SUhacFpYZGJhVjA3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU2s3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdZMkZzYkdKaFkyc29jbVZ6ZFd4MFFYSnlZWGt1WW5WbVptVnlLVHRjYmlBZ2ZTazdYRzU5TzF4dVhHNHZLaXBjYmlBcUlFVnVZMjlrWlNCaGN5QkNiRzlpWEc0Z0tpOWNibHh1Wlhod2IzSjBjeTVsYm1OdlpHVlFZWGxzYjJGa1FYTkNiRzlpSUQwZ1puVnVZM1JwYjI0b2NHRmphMlYwY3l3Z1kyRnNiR0poWTJzcElIdGNiaUFnWm5WdVkzUnBiMjRnWlc1amIyUmxUMjVsS0hCaFkydGxkQ3dnWkc5dVpVTmhiR3hpWVdOcktTQjdYRzRnSUNBZ1pYaHdiM0owY3k1bGJtTnZaR1ZRWVdOclpYUW9jR0ZqYTJWMExDQjBjblZsTENCMGNuVmxMQ0JtZFc1amRHbHZiaWhsYm1OdlpHVmtLU0I3WEc0Z0lDQWdJQ0IyWVhJZ1ltbHVZWEo1U1dSbGJuUnBabWxsY2lBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0RFcE8xeHVJQ0FnSUNBZ1ltbHVZWEo1U1dSbGJuUnBabWxsY2xzd1hTQTlJREU3WEc0Z0lDQWdJQ0JwWmlBb2RIbHdaVzltSUdWdVkyOWtaV1FnUFQwOUlDZHpkSEpwYm1jbktTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCMmFXVjNJRDBnYm1WM0lGVnBiblE0UVhKeVlYa29aVzVqYjJSbFpDNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJR1Z1WTI5a1pXUXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ0lDQjJhV1YzVzJsZElEMGdaVzVqYjJSbFpDNWphR0Z5UTI5a1pVRjBLR2twTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lHVnVZMjlrWldRZ1BTQjJhV1YzTG1KMVptWmxjanRjYmlBZ0lDQWdJQ0FnWW1sdVlYSjVTV1JsYm5ScFptbGxjbHN3WFNBOUlEQTdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSFpoY2lCc1pXNGdQU0FvWlc1amIyUmxaQ0JwYm5OMFlXNWpaVzltSUVGeWNtRjVRblZtWm1WeUtWeHVJQ0FnSUNBZ0lDQS9JR1Z1WTI5a1pXUXVZbmwwWlV4bGJtZDBhRnh1SUNBZ0lDQWdJQ0E2SUdWdVkyOWtaV1F1YzJsNlpUdGNibHh1SUNBZ0lDQWdkbUZ5SUd4bGJsTjBjaUE5SUd4bGJpNTBiMU4wY21sdVp5Z3BPMXh1SUNBZ0lDQWdkbUZ5SUd4bGJtZDBhRUZ5ZVNBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0d4bGJsTjBjaTVzWlc1bmRHZ2dLeUF4S1R0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2JHVnVVM1J5TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJR3hsYm1kMGFFRnllVnRwWFNBOUlIQmhjbk5sU1c1MEtHeGxibE4wY2x0cFhTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnNaVzVuZEdoQmNubGJiR1Z1VTNSeUxteGxibWQwYUYwZ1BTQXlOVFU3WEc1Y2JpQWdJQ0FnSUdsbUlDaENiRzlpS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJpYkc5aUlEMGdibVYzSUVKc2IySW9XMkpwYm1GeWVVbGtaVzUwYVdacFpYSXVZblZtWm1WeUxDQnNaVzVuZEdoQmNua3VZblZtWm1WeUxDQmxibU52WkdWa1hTazdYRzRnSUNBZ0lDQWdJR1J2Ym1WRFlXeHNZbUZqYXlodWRXeHNMQ0JpYkc5aUtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOUtUdGNiaUFnZlZ4dVhHNGdJRzFoY0Nod1lXTnJaWFJ6TENCbGJtTnZaR1ZQYm1Vc0lHWjFibU4wYVc5dUtHVnljaXdnY21WemRXeDBjeWtnZTF4dUlDQWdJSEpsZEhWeWJpQmpZV3hzWW1GamF5aHVaWGNnUW14dllpaHlaWE4xYkhSektTazdYRzRnSUgwcE8xeHVmVHRjYmx4dUx5cGNiaUFxSUVSbFkyOWtaWE1nWkdGMFlTQjNhR1Z1SUdFZ2NHRjViRzloWkNCcGN5QnRZWGxpWlNCbGVIQmxZM1JsWkM0Z1UzUnlhVzVuY3lCaGNtVWdaR1ZqYjJSbFpDQmllVnh1SUNvZ2FXNTBaWEp3Y21WMGFXNW5JR1ZoWTJnZ1lubDBaU0JoY3lCaElHdGxlU0JqYjJSbElHWnZjaUJsYm5SeWFXVnpJRzFoY210bFpDQjBieUJ6ZEdGeWRDQjNhWFJvSURBdUlGTmxaVnh1SUNvZ1pHVnpZM0pwY0hScGIyNGdiMllnWlc1amIyUmxVR0Y1Ykc5aFpFRnpRbWx1WVhKNVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0QmNuSmhlVUoxWm1abGNuMGdaR0YwWVN3Z1kyRnNiR0poWTJzZ2JXVjBhRzlrWEc0Z0tpQkFZWEJwSUhCMVlteHBZMXh1SUNvdlhHNWNibVY0Y0c5eWRITXVaR1ZqYjJSbFVHRjViRzloWkVGelFtbHVZWEo1SUQwZ1puVnVZM1JwYjI0Z0tHUmhkR0VzSUdKcGJtRnllVlI1Y0dVc0lHTmhiR3hpWVdOcktTQjdYRzRnSUdsbUlDaDBlWEJsYjJZZ1ltbHVZWEo1Vkhsd1pTQTlQVDBnSjJaMWJtTjBhVzl1SnlrZ2UxeHVJQ0FnSUdOaGJHeGlZV05ySUQwZ1ltbHVZWEo1Vkhsd1pUdGNiaUFnSUNCaWFXNWhjbmxVZVhCbElEMGdiblZzYkR0Y2JpQWdmVnh1WEc0Z0lIWmhjaUJpZFdabVpYSlVZV2xzSUQwZ1pHRjBZVHRjYmlBZ2RtRnlJR0oxWm1abGNuTWdQU0JiWFR0Y2JseHVJQ0IyWVhJZ2JuVnRZbVZ5Vkc5dlRHOXVaeUE5SUdaaGJITmxPMXh1SUNCM2FHbHNaU0FvWW5WbVptVnlWR0ZwYkM1aWVYUmxUR1Z1WjNSb0lENGdNQ2tnZTF4dUlDQWdJSFpoY2lCMFlXbHNRWEp5WVhrZ1BTQnVaWGNnVldsdWREaEJjbkpoZVNoaWRXWm1aWEpVWVdsc0tUdGNiaUFnSUNCMllYSWdhWE5UZEhKcGJtY2dQU0IwWVdsc1FYSnlZWGxiTUYwZ1BUMDlJREE3WEc0Z0lDQWdkbUZ5SUcxeloweGxibWQwYUNBOUlDY25PMXh1WEc0Z0lDQWdabTl5SUNoMllYSWdhU0E5SURFN0lEc2dhU3NyS1NCN1hHNGdJQ0FnSUNCcFppQW9kR0ZwYkVGeWNtRjVXMmxkSUQwOUlESTFOU2tnWW5KbFlXczdYRzVjYmlBZ0lDQWdJR2xtSUNodGMyZE1aVzVuZEdndWJHVnVaM1JvSUQ0Z016RXdLU0I3WEc0Z0lDQWdJQ0FnSUc1MWJXSmxjbFJ2YjB4dmJtY2dQU0IwY25WbE8xeHVJQ0FnSUNBZ0lDQmljbVZoYXp0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2JYTm5UR1Z1WjNSb0lDczlJSFJoYVd4QmNuSmhlVnRwWFR0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JwWmlodWRXMWlaWEpVYjI5TWIyNW5LU0J5WlhSMWNtNGdZMkZzYkdKaFkyc29aWEp5TENBd0xDQXhLVHRjYmx4dUlDQWdJR0oxWm1abGNsUmhhV3dnUFNCemJHbGpaVUoxWm1abGNpaGlkV1ptWlhKVVlXbHNMQ0F5SUNzZ2JYTm5UR1Z1WjNSb0xteGxibWQwYUNrN1hHNGdJQ0FnYlhOblRHVnVaM1JvSUQwZ2NHRnljMlZKYm5Rb2JYTm5UR1Z1WjNSb0tUdGNibHh1SUNBZ0lIWmhjaUJ0YzJjZ1BTQnpiR2xqWlVKMVptWmxjaWhpZFdabVpYSlVZV2xzTENBd0xDQnRjMmRNWlc1bmRHZ3BPMXh1SUNBZ0lHbG1JQ2hwYzFOMGNtbHVaeWtnZTF4dUlDQWdJQ0FnZEhKNUlIdGNiaUFnSUNBZ0lDQWdiWE5uSUQwZ1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pTNWhjSEJzZVNodWRXeHNMQ0J1WlhjZ1ZXbHVkRGhCY25KaGVTaHRjMmNwS1R0Y2JpQWdJQ0FnSUgwZ1kyRjBZMmdnS0dVcElIdGNiaUFnSUNBZ0lDQWdMeThnYVZCb2IyNWxJRk5oWm1GeWFTQmtiMlZ6YmlkMElHeGxkQ0I1YjNVZ1lYQndiSGtnZEc4Z2RIbHdaV1FnWVhKeVlYbHpYRzRnSUNBZ0lDQWdJSFpoY2lCMGVYQmxaQ0E5SUc1bGR5QlZhVzUwT0VGeWNtRjVLRzF6WnlrN1hHNGdJQ0FnSUNBZ0lHMXpaeUE5SUNjbk8xeHVJQ0FnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJSFI1Y0dWa0xteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2JYTm5JQ3M5SUZOMGNtbHVaeTVtY205dFEyaGhja052WkdVb2RIbHdaV1JiYVYwcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ1luVm1abVZ5Y3k1d2RYTm9LRzF6WnlrN1hHNGdJQ0FnWW5WbVptVnlWR0ZwYkNBOUlITnNhV05sUW5WbVptVnlLR0oxWm1abGNsUmhhV3dzSUcxeloweGxibWQwYUNrN1hHNGdJSDFjYmx4dUlDQjJZWElnZEc5MFlXd2dQU0JpZFdabVpYSnpMbXhsYm1kMGFEdGNiaUFnWW5WbVptVnljeTVtYjNKRllXTm9LR1oxYm1OMGFXOXVLR0oxWm1abGNpd2dhU2tnZTF4dUlDQWdJR05oYkd4aVlXTnJLR1Y0Y0c5eWRITXVaR1ZqYjJSbFVHRmphMlYwS0dKMVptWmxjaXdnWW1sdVlYSjVWSGx3WlN3Z2RISjFaU2tzSUdrc0lIUnZkR0ZzS1R0Y2JpQWdmU2s3WEc1OU8xeHVJbDE5IiwiXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIlxuLyoqXG4gKiBSZXR1cm5zIGB0aGlzYC4gRXhlY3V0ZSB0aGlzIHdpdGhvdXQgYSBcImNvbnRleHRcIiAoaS5lLiB3aXRob3V0IGl0IGJlaW5nXG4gKiBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIGxlZnQtaGFuZCBzaWRlKSwgYW5kIGB0aGlzYCBwb2ludHMgdG8gdGhlXG4gKiBcImdsb2JhbFwiIHNjb3BlIG9mIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIGlmIChvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OW9ZWE10WW1sdVlYSjVMMmx1WkdWNExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQklpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjYmk4cVhHNGdLaUJOYjJSMWJHVWdjbVZ4ZFdseVpXMWxiblJ6TGx4dUlDb3ZYRzVjYm5aaGNpQnBjMEZ5Y21GNUlEMGdjbVZ4ZFdseVpTZ25hWE5oY25KaGVTY3BPMXh1WEc0dktpcGNiaUFxSUUxdlpIVnNaU0JsZUhCdmNuUnpMbHh1SUNvdlhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdhR0Z6UW1sdVlYSjVPMXh1WEc0dktpcGNiaUFxSUVOb1pXTnJjeUJtYjNJZ1ltbHVZWEo1SUdSaGRHRXVYRzRnS2x4dUlDb2dVbWxuYUhRZ2JtOTNJRzl1YkhrZ1FuVm1abVZ5SUdGdVpDQkJjbkpoZVVKMVptWmxjaUJoY21VZ2MzVndjRzl5ZEdWa0xpNWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ1lXNTVkR2hwYm1kY2JpQXFJRUJoY0drZ2NIVmliR2xqWEc0Z0tpOWNibHh1Wm5WdVkzUnBiMjRnYUdGelFtbHVZWEo1S0dSaGRHRXBJSHRjYmx4dUlDQm1kVzVqZEdsdmJpQmZhR0Z6UW1sdVlYSjVLRzlpYWlrZ2UxeHVJQ0FnSUdsbUlDZ2hiMkpxS1NCeVpYUjFjbTRnWm1Gc2MyVTdYRzVjYmlBZ0lDQnBaaUFvSUNobmJHOWlZV3d1UW5WbVptVnlJQ1ltSUdkc2IySmhiQzVDZFdabVpYSXVhWE5DZFdabVpYSW9iMkpxS1NrZ2ZIeGNiaUFnSUNBZ0lDQWdJQ2huYkc5aVlXd3VRWEp5WVhsQ2RXWm1aWElnSmlZZ2IySnFJR2x1YzNSaGJtTmxiMllnUVhKeVlYbENkV1ptWlhJcElIeDhYRzRnSUNBZ0lDQWdJQ0FvWjJ4dlltRnNMa0pzYjJJZ0ppWWdiMkpxSUdsdWMzUmhibU5sYjJZZ1FteHZZaWtnZkh4Y2JpQWdJQ0FnSUNBZ0lDaG5iRzlpWVd3dVJtbHNaU0FtSmlCdlltb2dhVzV6ZEdGdVkyVnZaaUJHYVd4bEtWeHVJQ0FnSUNBZ0lDQXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQjBjblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNocGMwRnljbUY1S0c5aWFpa3BJSHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYjJKcUxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLRjlvWVhOQ2FXNWhjbmtvYjJKcVcybGRLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZTQmxiSE5sSUdsbUlDaHZZbW9nSmlZZ0oyOWlhbVZqZENjZ1BUMGdkSGx3Wlc5bUlHOWlhaWtnZTF4dUlDQWdJQ0FnYVdZZ0tHOWlhaTUwYjBwVFQwNHBJSHRjYmlBZ0lDQWdJQ0FnYjJKcUlEMGdiMkpxTG5SdlNsTlBUaWdwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCbWIzSWdLSFpoY2lCclpYa2dhVzRnYjJKcUtTQjdYRzRnSUNBZ0lDQWdJR2xtSUNoUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG1oaGMwOTNibEJ5YjNCbGNuUjVMbU5oYkd3b2IySnFMQ0JyWlhrcElDWW1JRjlvWVhOQ2FXNWhjbmtvYjJKcVcydGxlVjBwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z1gyaGhjMEpwYm1GeWVTaGtZWFJoS1R0Y2JuMWNiaUpkZlE9PSIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCdnbG9iYWwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9ICdYTUxIdHRwUmVxdWVzdCcgaW4gZ2xvYmFsICYmXG4gICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBCdWZmZXJcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIGpRdWVyeS5xcmNvZGUgMC4xMi4wIC0gaHR0cDovL2xhcnNqdW5nLmRlL2pxdWVyeS1xcmNvZGUvIC0gdXNlcyAvL2dpdGh1Yi5jb20va2F6dWhpa29hcmFzZS9xcmNvZGUtZ2VuZXJhdG9yIChNSVQpICovXG4oZnVuY3Rpb24gKHFyY29kZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciAkID0galF1ZXJ5O1xuXG4gICAgLy8gV3JhcHBlciBmb3IgdGhlIG9yaWdpbmFsIFFSIGNvZGUgZ2VuZXJhdG9yLlxuICAgIGZ1bmN0aW9uIFFSQ29kZSh0ZXh0LCBsZXZlbCwgdmVyc2lvbiwgcXVpZXQpIHtcblxuICAgICAgICB2YXIgcXIgPSBxcmNvZGUodmVyc2lvbiwgbGV2ZWwpO1xuICAgICAgICBxci5hZGREYXRhKHRleHQpO1xuICAgICAgICBxci5tYWtlKCk7XG5cbiAgICAgICAgcXVpZXQgPSBxdWlldCB8fCAwO1xuXG4gICAgICAgIHZhciBxck1vZHVsZUNvdW50ID0gcXIuZ2V0TW9kdWxlQ291bnQoKTtcbiAgICAgICAgdmFyIHF1aWV0TW9kdWxlQ291bnQgPSBxci5nZXRNb2R1bGVDb3VudCgpICsgMiAqIHF1aWV0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzRGFyayhyb3csIGNvbCkge1xuXG4gICAgICAgICAgICByb3cgLT0gcXVpZXQ7XG4gICAgICAgICAgICBjb2wgLT0gcXVpZXQ7XG5cbiAgICAgICAgICAgIGlmIChyb3cgPCAwIHx8IHJvdyA+PSBxck1vZHVsZUNvdW50IHx8IGNvbCA8IDAgfHwgY29sID49IHFyTW9kdWxlQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBxci5pc0Rhcmsocm93LCBjb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFkZEJsYW5rID0gZnVuY3Rpb24gKGwsIHQsIHIsIGIpIHtcblxuICAgICAgICAgICAgdmFyIHByZXZJc0RhcmsgPSB0aGlzLmlzRGFyaztcbiAgICAgICAgICAgIHZhciBtb2R1bGVTaXplID0gMSAvIHF1aWV0TW9kdWxlQ291bnQ7XG5cbiAgICAgICAgICAgIHRoaXMuaXNEYXJrID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWwgPSBjb2wgKiBtb2R1bGVTaXplO1xuICAgICAgICAgICAgICAgIHZhciBtdCA9IHJvdyAqIG1vZHVsZVNpemU7XG4gICAgICAgICAgICAgICAgdmFyIG1yID0gbWwgKyBtb2R1bGVTaXplO1xuICAgICAgICAgICAgICAgIHZhciBtYiA9IG10ICsgbW9kdWxlU2l6ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SXNEYXJrKHJvdywgY29sKSAmJiAobCA+IG1yIHx8IG1sID4gciB8fCB0ID4gbWIgfHwgbXQgPiBiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm1vZHVsZUNvdW50ID0gcXVpZXRNb2R1bGVDb3VudDtcbiAgICAgICAgdGhpcy5pc0RhcmsgPSBpc0Rhcms7XG4gICAgICAgIHRoaXMuYWRkQmxhbmsgPSBhZGRCbGFuaztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjYW52YXMgaXMgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyIChhcyBNb2Rlcm5penIgZG9lcylcbiAgICB2YXIgaGFzQ2FudmFzID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICB9KCkpO1xuICAgIHZhciBoYXNBcmNUbyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cub3BlcmEpICE9PSAnW29iamVjdCBPcGVyYV0nO1xuXG4gICAgLy8gUmV0dXJucyBhIG1pbmltYWwgUVIgY29kZSBmb3IgdGhlIGdpdmVuIHRleHQgc3RhcnRpbmcgd2l0aCB2ZXJzaW9uIGBtaW5WZXJzaW9uYC5cbiAgICAvLyBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIGB0ZXh0YCBpcyB0b28gbG9uZyB0byBiZSBlbmNvZGVkIGluIGBtYXhWZXJzaW9uYC5cbiAgICBmdW5jdGlvbiBjcmVhdGVRUkNvZGUodGV4dCwgbGV2ZWwsIG1pblZlcnNpb24sIG1heFZlcnNpb24sIHF1aWV0KSB7XG5cbiAgICAgICAgbWluVmVyc2lvbiA9IE1hdGgubWF4KDEsIG1pblZlcnNpb24gfHwgMSk7XG4gICAgICAgIG1heFZlcnNpb24gPSBNYXRoLm1pbig0MCwgbWF4VmVyc2lvbiB8fCA0MCk7XG4gICAgICAgIGZvciAodmFyIHZlcnNpb24gPSBtaW5WZXJzaW9uOyB2ZXJzaW9uIDw9IG1heFZlcnNpb247IHZlcnNpb24gKz0gMSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFFSQ29kZSh0ZXh0LCBsZXZlbCwgdmVyc2lvbiwgcXVpZXQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmRMYWJlbChxciwgY29udGV4dCwgc2V0dGluZ3MpIHtcblxuICAgICAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLnNpemU7XG4gICAgICAgIHZhciBmb250ID0gJ2JvbGQgJyArIChzZXR0aW5ncy5tU2l6ZSAqIHNpemUpICsgJ3B4ICcgKyBzZXR0aW5ncy5mb250bmFtZTtcbiAgICAgICAgdmFyIGN0eCA9ICQoJzxjYW52YXMvPicpWzBdLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgY3R4LmZvbnQgPSBmb250O1xuXG4gICAgICAgIHZhciB3ID0gY3R4Lm1lYXN1cmVUZXh0KHNldHRpbmdzLmxhYmVsKS53aWR0aDtcbiAgICAgICAgdmFyIHNoID0gc2V0dGluZ3MubVNpemU7XG4gICAgICAgIHZhciBzdyA9IHcgLyBzaXplO1xuICAgICAgICB2YXIgc2wgPSAoMSAtIHN3KSAqIHNldHRpbmdzLm1Qb3NYO1xuICAgICAgICB2YXIgc3QgPSAoMSAtIHNoKSAqIHNldHRpbmdzLm1Qb3NZO1xuICAgICAgICB2YXIgc3IgPSBzbCArIHN3O1xuICAgICAgICB2YXIgc2IgPSBzdCArIHNoO1xuICAgICAgICB2YXIgcGFkID0gMC4wMTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MubW9kZSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gU3RyaXBcbiAgICAgICAgICAgIHFyLmFkZEJsYW5rKDAsIHN0IC0gcGFkLCBzaXplLCBzYiArIHBhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCb3hcbiAgICAgICAgICAgIHFyLmFkZEJsYW5rKHNsIC0gcGFkLCBzdCAtIHBhZCwgc3IgKyBwYWQsIHNiICsgcGFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MuZm9udGNvbG9yO1xuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHNldHRpbmdzLmxhYmVsLCBzbCAqIHNpemUsIHN0ICogc2l6ZSArIDAuNzUgKiBzZXR0aW5ncy5tU2l6ZSAqIHNpemUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kSW1hZ2UocXIsIGNvbnRleHQsIHNldHRpbmdzKSB7XG5cbiAgICAgICAgdmFyIHNpemUgPSBzZXR0aW5ncy5zaXplO1xuICAgICAgICB2YXIgdyA9IHNldHRpbmdzLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAxO1xuICAgICAgICB2YXIgaCA9IHNldHRpbmdzLmltYWdlLm5hdHVyYWxIZWlnaHQgfHwgMTtcbiAgICAgICAgdmFyIHNoID0gc2V0dGluZ3MubVNpemU7XG4gICAgICAgIHZhciBzdyA9IHNoICogdyAvIGg7XG4gICAgICAgIHZhciBzbCA9ICgxIC0gc3cpICogc2V0dGluZ3MubVBvc1g7XG4gICAgICAgIHZhciBzdCA9ICgxIC0gc2gpICogc2V0dGluZ3MubVBvc1k7XG4gICAgICAgIHZhciBzciA9IHNsICsgc3c7XG4gICAgICAgIHZhciBzYiA9IHN0ICsgc2g7XG4gICAgICAgIHZhciBwYWQgPSAwLjAxO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5tb2RlID09PSAzKSB7XG4gICAgICAgICAgICAvLyBTdHJpcFxuICAgICAgICAgICAgcXIuYWRkQmxhbmsoMCwgc3QgLSBwYWQsIHNpemUsIHNiICsgcGFkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEJveFxuICAgICAgICAgICAgcXIuYWRkQmxhbmsoc2wgLSBwYWQsIHN0IC0gcGFkLCBzciArIHBhZCwgc2IgKyBwYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2Uoc2V0dGluZ3MuaW1hZ2UsIHNsICogc2l6ZSwgc3QgKiBzaXplLCBzdyAqIHNpemUsIHNoICogc2l6ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmQocXIsIGNvbnRleHQsIHNldHRpbmdzKSB7XG5cbiAgICAgICAgaWYgKCQoc2V0dGluZ3MuYmFja2dyb3VuZCkuaXMoJ2ltZycpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShzZXR0aW5ncy5iYWNrZ3JvdW5kLCAwLCAwLCBzZXR0aW5ncy5zaXplLCBzZXR0aW5ncy5zaXplKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5iYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLmJhY2tncm91bmQ7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHNldHRpbmdzLmxlZnQsIHNldHRpbmdzLnRvcCwgc2V0dGluZ3Muc2l6ZSwgc2V0dGluZ3Muc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kZSA9IHNldHRpbmdzLm1vZGU7XG4gICAgICAgIGlmIChtb2RlID09PSAxIHx8IG1vZGUgPT09IDIpIHtcbiAgICAgICAgICAgIGRyYXdCYWNrZ3JvdW5kTGFiZWwocXIsIGNvbnRleHQsIHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAzIHx8IG1vZGUgPT09IDQpIHtcbiAgICAgICAgICAgIGRyYXdCYWNrZ3JvdW5kSW1hZ2UocXIsIGNvbnRleHQsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdNb2R1bGVEZWZhdWx0KHFyLCBjb250ZXh0LCBzZXR0aW5ncywgbGVmdCwgdG9wLCB3aWR0aCwgcm93LCBjb2wpIHtcblxuICAgICAgICBpZiAocXIuaXNEYXJrKHJvdywgY29sKSkge1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KGxlZnQsIHRvcCwgd2lkdGgsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdNb2R1bGVSb3VuZGVkRGFyayhjdHgsIGwsIHQsIHIsIGIsIHJhZCwgbncsIG5lLCBzZSwgc3cpIHtcblxuICAgICAgICBpZiAobncpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8obCArIHJhZCwgdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGwsIHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHIgLSByYWQsIHQpO1xuICAgICAgICAgICAgY3R4LmFyY1RvKHIsIHQsIHIsIGIsIHJhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHIsIHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHIsIGIgLSByYWQpO1xuICAgICAgICAgICAgY3R4LmFyY1RvKHIsIGIsIGwsIGIsIHJhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHIsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3KSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGwgKyByYWQsIGIpO1xuICAgICAgICAgICAgY3R4LmFyY1RvKGwsIGIsIGwsIHQsIHJhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGwsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG53KSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGwsIHQgKyByYWQpO1xuICAgICAgICAgICAgY3R4LmFyY1RvKGwsIHQsIHIsIHQsIHJhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGwsIHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd01vZHVsZVJvdW5kZW5kTGlnaHQoY3R4LCBsLCB0LCByLCBiLCByYWQsIG53LCBuZSwgc2UsIHN3KSB7XG5cbiAgICAgICAgaWYgKG53KSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGwgKyByYWQsIHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhsLCB0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8obCwgdCArIHJhZCk7XG4gICAgICAgICAgICBjdHguYXJjVG8obCwgdCwgbCArIHJhZCwgdCwgcmFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhyIC0gcmFkLCB0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ociwgdCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHIsIHQgKyByYWQpO1xuICAgICAgICAgICAgY3R4LmFyY1RvKHIsIHQsIHIgLSByYWQsIHQsIHJhZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2UpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8ociAtIHJhZCwgYik7XG4gICAgICAgICAgICBjdHgubGluZVRvKHIsIGIpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhyLCBiIC0gcmFkKTtcbiAgICAgICAgICAgIGN0eC5hcmNUbyhyLCBiLCByIC0gcmFkLCBiLCByYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3KSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGwgKyByYWQsIGIpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhsLCBiKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8obCwgYiAtIHJhZCk7XG4gICAgICAgICAgICBjdHguYXJjVG8obCwgYiwgbCArIHJhZCwgYiwgcmFkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdNb2R1bGVSb3VuZGVkKHFyLCBjb250ZXh0LCBzZXR0aW5ncywgbGVmdCwgdG9wLCB3aWR0aCwgcm93LCBjb2wpIHtcblxuICAgICAgICB2YXIgaXNEYXJrID0gcXIuaXNEYXJrO1xuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgIHZhciBib3R0b20gPSB0b3AgKyB3aWR0aDtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHNldHRpbmdzLnJhZGl1cyAqIHdpZHRoO1xuICAgICAgICB2YXIgcm93VCA9IHJvdyAtIDE7XG4gICAgICAgIHZhciByb3dCID0gcm93ICsgMTtcbiAgICAgICAgdmFyIGNvbEwgPSBjb2wgLSAxO1xuICAgICAgICB2YXIgY29sUiA9IGNvbCArIDE7XG4gICAgICAgIHZhciBjZW50ZXIgPSBpc0Rhcmsocm93LCBjb2wpO1xuICAgICAgICB2YXIgbm9ydGh3ZXN0ID0gaXNEYXJrKHJvd1QsIGNvbEwpO1xuICAgICAgICB2YXIgbm9ydGggPSBpc0Rhcmsocm93VCwgY29sKTtcbiAgICAgICAgdmFyIG5vcnRoZWFzdCA9IGlzRGFyayhyb3dULCBjb2xSKTtcbiAgICAgICAgdmFyIGVhc3QgPSBpc0Rhcmsocm93LCBjb2xSKTtcbiAgICAgICAgdmFyIHNvdXRoZWFzdCA9IGlzRGFyayhyb3dCLCBjb2xSKTtcbiAgICAgICAgdmFyIHNvdXRoID0gaXNEYXJrKHJvd0IsIGNvbCk7XG4gICAgICAgIHZhciBzb3V0aHdlc3QgPSBpc0Rhcmsocm93QiwgY29sTCk7XG4gICAgICAgIHZhciB3ZXN0ID0gaXNEYXJrKHJvdywgY29sTCk7XG5cbiAgICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICAgICAgZHJhd01vZHVsZVJvdW5kZWREYXJrKGNvbnRleHQsIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSwgcmFkaXVzLCAhbm9ydGggJiYgIXdlc3QsICFub3J0aCAmJiAhZWFzdCwgIXNvdXRoICYmICFlYXN0LCAhc291dGggJiYgIXdlc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd01vZHVsZVJvdW5kZW5kTGlnaHQoY29udGV4dCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCByYWRpdXMsIG5vcnRoICYmIHdlc3QgJiYgbm9ydGh3ZXN0LCBub3J0aCAmJiBlYXN0ICYmIG5vcnRoZWFzdCwgc291dGggJiYgZWFzdCAmJiBzb3V0aGVhc3QsIHNvdXRoICYmIHdlc3QgJiYgc291dGh3ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdNb2R1bGVzKHFyLCBjb250ZXh0LCBzZXR0aW5ncykge1xuXG4gICAgICAgIHZhciBtb2R1bGVDb3VudCA9IHFyLm1vZHVsZUNvdW50O1xuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHNldHRpbmdzLnNpemUgLyBtb2R1bGVDb3VudDtcbiAgICAgICAgdmFyIGZuID0gZHJhd01vZHVsZURlZmF1bHQ7XG4gICAgICAgIHZhciByb3c7XG4gICAgICAgIHZhciBjb2w7XG5cbiAgICAgICAgaWYgKGhhc0FyY1RvICYmIHNldHRpbmdzLnJhZGl1cyA+IDAgJiYgc2V0dGluZ3MucmFkaXVzIDw9IDAuNSkge1xuICAgICAgICAgICAgZm4gPSBkcmF3TW9kdWxlUm91bmRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBzZXR0aW5ncy5sZWZ0ICsgY29sICogbW9kdWxlU2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHNldHRpbmdzLnRvcCArIHJvdyAqIG1vZHVsZVNpemU7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBtb2R1bGVTaXplO1xuXG4gICAgICAgICAgICAgICAgZm4ocXIsIGNvbnRleHQsIHNldHRpbmdzLCBsLCB0LCB3LCByb3csIGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCQoc2V0dGluZ3MuZmlsbCkuaXMoJ2ltZycpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMC41KSc7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgdmFyIHByZXYgPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcHJldjtcblxuICAgICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShzZXR0aW5ncy5maWxsLCAwLCAwLCBzZXR0aW5ncy5zaXplLCBzZXR0aW5ncy5zaXplKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5maWxsO1xuICAgICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3cyBRUiBjb2RlIHRvIHRoZSBnaXZlbiBgY2FudmFzYCBhbmQgcmV0dXJucyBpdC5cbiAgICBmdW5jdGlvbiBkcmF3T25DYW52YXMoY2FudmFzLCBzZXR0aW5ncykge1xuXG4gICAgICAgIHZhciBxciA9IGNyZWF0ZVFSQ29kZShzZXR0aW5ncy50ZXh0LCBzZXR0aW5ncy5lY0xldmVsLCBzZXR0aW5ncy5taW5WZXJzaW9uLCBzZXR0aW5ncy5tYXhWZXJzaW9uLCBzZXR0aW5ncy5xdWlldCk7XG4gICAgICAgIGlmICghcXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRjYW52YXMgPSAkKGNhbnZhcykuZGF0YSgncXJjb2RlJywgcXIpO1xuICAgICAgICB2YXIgY29udGV4dCA9ICRjYW52YXNbMF0uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBkcmF3QmFja2dyb3VuZChxciwgY29udGV4dCwgc2V0dGluZ3MpO1xuICAgICAgICBkcmF3TW9kdWxlcyhxciwgY29udGV4dCwgc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiAkY2FudmFzO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBgY2FudmFzYCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgUVIgY29kZSBmb3IgdGhlIGdpdmVuIHNldHRpbmdzLlxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyhzZXR0aW5ncykge1xuXG4gICAgICAgIHZhciAkY2FudmFzID0gJCgnPGNhbnZhcy8+JykuYXR0cignd2lkdGgnLCBzZXR0aW5ncy5zaXplKS5hdHRyKCdoZWlnaHQnLCBzZXR0aW5ncy5zaXplKTtcbiAgICAgICAgcmV0dXJuIGRyYXdPbkNhbnZhcygkY2FudmFzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhbiBgaW1hZ2VgIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBRUiBjb2RlIGZvciB0aGUgZ2l2ZW4gc2V0dGluZ3MuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW1hZ2Uoc2V0dGluZ3MpIHtcblxuICAgICAgICByZXR1cm4gJCgnPGltZy8+JykuYXR0cignc3JjJywgY3JlYXRlQ2FudmFzKHNldHRpbmdzKVswXS50b0RhdGFVUkwoJ2ltYWdlL3BuZycpKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgYGRpdmAgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIFFSIGNvZGUgZm9yIHRoZSBnaXZlbiBzZXR0aW5ncy5cbiAgICBmdW5jdGlvbiBjcmVhdGVEaXYoc2V0dGluZ3MpIHtcblxuICAgICAgICB2YXIgcXIgPSBjcmVhdGVRUkNvZGUoc2V0dGluZ3MudGV4dCwgc2V0dGluZ3MuZWNMZXZlbCwgc2V0dGluZ3MubWluVmVyc2lvbiwgc2V0dGluZ3MubWF4VmVyc2lvbiwgc2V0dGluZ3MucXVpZXQpO1xuICAgICAgICBpZiAoIXFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNvbWUgc2hvcnRjdXRzIHRvIGltcHJvdmUgY29tcHJlc3Npb25cbiAgICAgICAgdmFyIHNldHRpbmdzX3NpemUgPSBzZXR0aW5ncy5zaXplO1xuICAgICAgICB2YXIgc2V0dGluZ3NfYmdDb2xvciA9IHNldHRpbmdzLmJhY2tncm91bmQ7XG4gICAgICAgIHZhciBtYXRoX2Zsb29yID0gTWF0aC5mbG9vcjtcblxuICAgICAgICB2YXIgbW9kdWxlQ291bnQgPSBxci5tb2R1bGVDb3VudDtcbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSBtYXRoX2Zsb29yKHNldHRpbmdzX3NpemUgLyBtb2R1bGVDb3VudCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBtYXRoX2Zsb29yKDAuNSAqIChzZXR0aW5nc19zaXplIC0gbW9kdWxlU2l6ZSAqIG1vZHVsZUNvdW50KSk7XG5cbiAgICAgICAgdmFyIHJvdztcbiAgICAgICAgdmFyIGNvbDtcblxuICAgICAgICB2YXIgY29udGFpbmVyQ1NTID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzZXR0aW5nc19zaXplLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2V0dGluZ3Nfc2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIGRhcmtDU1MgPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1vZHVsZVNpemUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtb2R1bGVTaXplLFxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogc2V0dGluZ3MuZmlsbFxuICAgICAgICAgICAgfTtcblxuICAgICAgICB2YXIgJGRpdiA9ICQoJzxkaXYvPicpLmRhdGEoJ3FyY29kZScsIHFyKS5jc3MoY29udGFpbmVyQ1NTKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3NfYmdDb2xvcikge1xuICAgICAgICAgICAgJGRpdi5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBzZXR0aW5nc19iZ0NvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChxci5pc0Rhcmsocm93LCBjb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3NzKGRhcmtDU1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXQgKyBjb2wgKiBtb2R1bGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0ICsgcm93ICogbW9kdWxlU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygkZGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGRpdjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIVE1MKHNldHRpbmdzKSB7XG5cbiAgICAgICAgaWYgKGhhc0NhbnZhcyAmJiBzZXR0aW5ncy5yZW5kZXIgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FudmFzKHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDYW52YXMgJiYgc2V0dGluZ3MucmVuZGVyID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2Uoc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZURpdihzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLy8gUGx1Z2luXG4gICAgLy8gPT09PT09XG5cbiAgICAvLyBEZWZhdWx0IHNldHRpbmdzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBkZWZhdWx0cyA9IHtcblxuICAgICAgICAvLyByZW5kZXIgbWV0aG9kOiBgJ2NhbnZhcydgLCBgJ2ltYWdlJ2Agb3IgYCdkaXYnYFxuICAgICAgICByZW5kZXI6ICdjYW52YXMnLFxuXG4gICAgICAgIC8vIHZlcnNpb24gcmFuZ2Ugc29tZXdoZXJlIGluIDEgLi4gNDBcbiAgICAgICAgbWluVmVyc2lvbjogMSxcbiAgICAgICAgbWF4VmVyc2lvbjogNDAsXG5cbiAgICAgICAgLy8gZXJyb3IgY29ycmVjdGlvbiBsZXZlbDogYCdMJ2AsIGAnTSdgLCBgJ1EnYCBvciBgJ0gnYFxuICAgICAgICBlY0xldmVsOiAnTCcsXG5cbiAgICAgICAgLy8gb2Zmc2V0IGluIHBpeGVsIGlmIGRyYXduIG9udG8gZXhpc3RpbmcgY2FudmFzXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcblxuICAgICAgICAvLyBzaXplIGluIHBpeGVsXG4gICAgICAgIHNpemU6IDIwMCxcblxuICAgICAgICAvLyBjb2RlIGNvbG9yIG9yIGltYWdlIGVsZW1lbnRcbiAgICAgICAgZmlsbDogJyMwMDAnLFxuXG4gICAgICAgIC8vIGJhY2tncm91bmQgY29sb3Igb3IgaW1hZ2UgZWxlbWVudCwgYG51bGxgIGZvciB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kXG4gICAgICAgIGJhY2tncm91bmQ6IG51bGwsXG5cbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICB0ZXh0OiAnbm8gdGV4dCcsXG5cbiAgICAgICAgLy8gY29ybmVyIHJhZGl1cyByZWxhdGl2ZSB0byBtb2R1bGUgd2lkdGg6IDAuMCAuLiAwLjVcbiAgICAgICAgcmFkaXVzOiAwLFxuXG4gICAgICAgIC8vIHF1aWV0IHpvbmUgaW4gbW9kdWxlc1xuICAgICAgICBxdWlldDogMCxcblxuICAgICAgICAvLyBtb2Rlc1xuICAgICAgICAvLyAwOiBub3JtYWxcbiAgICAgICAgLy8gMTogbGFiZWwgc3RyaXBcbiAgICAgICAgLy8gMjogbGFiZWwgYm94XG4gICAgICAgIC8vIDM6IGltYWdlIHN0cmlwXG4gICAgICAgIC8vIDQ6IGltYWdlIGJveFxuICAgICAgICBtb2RlOiAwLFxuXG4gICAgICAgIG1TaXplOiAwLjEsXG4gICAgICAgIG1Qb3NYOiAwLjUsXG4gICAgICAgIG1Qb3NZOiAwLjUsXG5cbiAgICAgICAgbGFiZWw6ICdubyBsYWJlbCcsXG4gICAgICAgIGZvbnRuYW1lOiAnc2FucycsXG4gICAgICAgIGZvbnRjb2xvcjogJyMwMDAnLFxuXG4gICAgICAgIGltYWdlOiBudWxsXG4gICAgfTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBwbHVnaW5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgJC5mbi5xcmNvZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICAgICAgZHJhd09uQ2FudmFzKHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hcHBlbmQoY3JlYXRlSFRNTChzZXR0aW5ncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufShmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBgcXJjb2RlYCBpcyB0aGUgc2luZ2xlIHB1YmxpYyBmdW5jdGlvbiBkZWZpbmVkIGJ5IHRoZSBgUVIgQ29kZSBHZW5lcmF0b3JgXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIFFSIENvZGUgR2VuZXJhdG9yIGZvciBKYXZhU2NyaXB0XG4gICAgLy9cbiAgICAvLyBDb3B5cmlnaHQgKGMpIDIwMDkgS2F6dWhpa28gQXJhc2VcbiAgICAvL1xuICAgIC8vIFVSTDogaHR0cDovL3d3dy5kLXByb2plY3QuY29tL1xuICAgIC8vXG4gICAgLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICAgIC8vICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICAgIC8vXG4gICAgLy8gVGhlIHdvcmQgJ1FSIENvZGUnIGlzIHJlZ2lzdGVyZWQgdHJhZGVtYXJrIG9mXG4gICAgLy8gREVOU08gV0FWRSBJTkNPUlBPUkFURURcbiAgICAvLyAgaHR0cDovL3d3dy5kZW5zby13YXZlLmNvbS9xcmNvZGUvZmFxcGF0ZW50LWUuaHRtbFxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBxcmNvZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIHFyY29kZVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgLyoqXG4gICAgICAgKiBxcmNvZGVcbiAgICAgICAqIEBwYXJhbSB0eXBlTnVtYmVyIDEgdG8gNDBcbiAgICAgICAqIEBwYXJhbSBlcnJvckNvcnJlY3RMZXZlbCAnTCcsJ00nLCdRJywnSCdcbiAgICAgICAqL1xuICAgICAgdmFyIHFyY29kZSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKSB7XG5cbiAgICAgICAgdmFyIFBBRDAgPSAweEVDO1xuICAgICAgICB2YXIgUEFEMSA9IDB4MTE7XG5cbiAgICAgICAgdmFyIF90eXBlTnVtYmVyID0gdHlwZU51bWJlcjtcbiAgICAgICAgdmFyIF9lcnJvckNvcnJlY3RMZXZlbCA9IFFSRXJyb3JDb3JyZWN0TGV2ZWxbZXJyb3JDb3JyZWN0TGV2ZWxdO1xuICAgICAgICB2YXIgX21vZHVsZXMgPSBudWxsO1xuICAgICAgICB2YXIgX21vZHVsZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIF9kYXRhQ2FjaGUgPSBudWxsO1xuICAgICAgICB2YXIgX2RhdGFMaXN0ID0gbmV3IEFycmF5KCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgdmFyIG1ha2VJbXBsID0gZnVuY3Rpb24odGVzdCwgbWFza1BhdHRlcm4pIHtcblxuICAgICAgICAgIF9tb2R1bGVDb3VudCA9IF90eXBlTnVtYmVyICogNCArIDE3O1xuICAgICAgICAgIF9tb2R1bGVzID0gZnVuY3Rpb24obW9kdWxlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBtb2R1bGVzID0gbmV3IEFycmF5KG1vZHVsZUNvdW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgICBtb2R1bGVzW3Jvd10gPSBuZXcgQXJyYXkobW9kdWxlQ291bnQpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVzW3Jvd11bY29sXSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVzO1xuICAgICAgICAgIH0oX21vZHVsZUNvdW50KTtcblxuICAgICAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgMCk7XG4gICAgICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybihfbW9kdWxlQ291bnQgLSA3LCAwKTtcbiAgICAgICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIF9tb2R1bGVDb3VudCAtIDcpO1xuICAgICAgICAgIHNldHVwUG9zaXRpb25BZGp1c3RQYXR0ZXJuKCk7XG4gICAgICAgICAgc2V0dXBUaW1pbmdQYXR0ZXJuKCk7XG4gICAgICAgICAgc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybik7XG5cbiAgICAgICAgICBpZiAoX3R5cGVOdW1iZXIgPj0gNykge1xuICAgICAgICAgICAgc2V0dXBUeXBlTnVtYmVyKHRlc3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfZGF0YUNhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIF9kYXRhQ2FjaGUgPSBjcmVhdGVEYXRhKF90eXBlTnVtYmVyLCBfZXJyb3JDb3JyZWN0TGV2ZWwsIF9kYXRhTGlzdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFwRGF0YShfZGF0YUNhY2hlLCBtYXNrUGF0dGVybik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4gPSBmdW5jdGlvbihyb3csIGNvbCkge1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDc7IHIgKz0gMSkge1xuXG4gICAgICAgICAgICBpZiAocm93ICsgciA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gcm93ICsgcikgY29udGludWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSA3OyBjICs9IDEpIHtcblxuICAgICAgICAgICAgICBpZiAoY29sICsgYyA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gY29sICsgYykgY29udGludWU7XG5cbiAgICAgICAgICAgICAgaWYgKCAoMCA8PSByICYmIHIgPD0gNiAmJiAoYyA9PSAwIHx8IGMgPT0gNikgKVxuICAgICAgICAgICAgICAgICAgfHwgKDAgPD0gYyAmJiBjIDw9IDYgJiYgKHIgPT0gMCB8fCByID09IDYpIClcbiAgICAgICAgICAgICAgICAgIHx8ICgyIDw9IHIgJiYgciA8PSA0ICYmIDIgPD0gYyAmJiBjIDw9IDQpICkge1xuICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRCZXN0TWFza1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciBtaW5Mb3N0UG9pbnQgPSAwO1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG5cbiAgICAgICAgICAgIG1ha2VJbXBsKHRydWUsIGkpO1xuXG4gICAgICAgICAgICB2YXIgbG9zdFBvaW50ID0gUVJVdGlsLmdldExvc3RQb2ludChfdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChpID09IDAgfHwgbWluTG9zdFBvaW50ID4gbG9zdFBvaW50KSB7XG4gICAgICAgICAgICAgIG1pbkxvc3RQb2ludCA9IGxvc3RQb2ludDtcbiAgICAgICAgICAgICAgcGF0dGVybiA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNldHVwVGltaW5nUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IDg7IHIgPCBfbW9kdWxlQ291bnQgLSA4OyByICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21vZHVsZXNbcl1bNl0gPSAociAlIDIgPT0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDg7IGMgPCBfbW9kdWxlQ291bnQgLSA4OyBjICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChfbW9kdWxlc1s2XVtjXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21vZHVsZXNbNl1bY10gPSAoYyAlIDIgPT0gMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIHBvcyA9IFFSVXRpbC5nZXRQYXR0ZXJuUG9zaXRpb24oX3R5cGVOdW1iZXIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3MubGVuZ3RoOyBpICs9IDEpIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqICs9IDEpIHtcblxuICAgICAgICAgICAgICB2YXIgcm93ID0gcG9zW2ldO1xuICAgICAgICAgICAgICB2YXIgY29sID0gcG9zW2pdO1xuXG4gICAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgciA9IC0yOyByIDw9IDI7IHIgKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IC0yOyBjIDw9IDI7IGMgKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgICBpZiAociA9PSAtMiB8fCByID09IDIgfHwgYyA9PSAtMiB8fCBjID09IDJcbiAgICAgICAgICAgICAgICAgICAgICB8fCAociA9PSAwICYmIGMgPT0gMCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZXR1cFR5cGVOdW1iZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG5cbiAgICAgICAgICB2YXIgYml0cyA9IFFSVXRpbC5nZXRCQ0hUeXBlTnVtYmVyKF90eXBlTnVtYmVyKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG4gICAgICAgICAgICBfbW9kdWxlc1tNYXRoLmZsb29yKGkgLyAzKV1baSAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM10gPSBtb2Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxODsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcbiAgICAgICAgICAgIF9tb2R1bGVzW2kgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdW01hdGguZmxvb3IoaSAvIDMpXSA9IG1vZDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNldHVwVHlwZUluZm8gPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuXG4gICAgICAgICAgdmFyIGRhdGEgPSAoX2Vycm9yQ29ycmVjdExldmVsIDw8IDMpIHwgbWFza1BhdHRlcm47XG4gICAgICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZUluZm8oZGF0YSk7XG5cbiAgICAgICAgICAvLyB2ZXJ0aWNhbFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkgKz0gMSkge1xuXG4gICAgICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIF9tb2R1bGVzW2ldWzhdID0gbW9kO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgICBfbW9kdWxlc1tpICsgMV1bOF0gPSBtb2Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfbW9kdWxlc1tfbW9kdWxlQ291bnQgLSAxNSArIGldWzhdID0gbW9kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGhvcml6b250YWxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpICs9IDEpIHtcblxuICAgICAgICAgICAgdmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG5cbiAgICAgICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgICAgICBfbW9kdWxlc1s4XVtfbW9kdWxlQ291bnQgLSBpIC0gMV0gPSBtb2Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA5KSB7XG4gICAgICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaSAtIDEgKyAxXSA9IG1vZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaSAtIDFdID0gbW9kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZpeGVkIG1vZHVsZVxuICAgICAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDhdWzhdID0gKCF0ZXN0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgICAgICB2YXIgaW5jID0gLTE7XG4gICAgICAgICAgdmFyIHJvdyA9IF9tb2R1bGVDb3VudCAtIDE7XG4gICAgICAgICAgdmFyIGJpdEluZGV4ID0gNztcbiAgICAgICAgICB2YXIgYnl0ZUluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgbWFza0Z1bmMgPSBRUlV0aWwuZ2V0TWFza0Z1bmN0aW9uKG1hc2tQYXR0ZXJuKTtcblxuICAgICAgICAgIGZvciAodmFyIGNvbCA9IF9tb2R1bGVDb3VudCAtIDE7IGNvbCA+IDA7IGNvbCAtPSAyKSB7XG5cbiAgICAgICAgICAgIGlmIChjb2wgPT0gNikgY29sIC09IDE7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjICs9IDEpIHtcblxuICAgICAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbCAtIGNdID09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgdmFyIGRhcmsgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVJbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhcmsgPSAoICggKGRhdGFbYnl0ZUluZGV4XSA+Pj4gYml0SW5kZXgpICYgMSkgPT0gMSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBtYXNrID0gbWFza0Z1bmMocm93LCBjb2wgLSBjKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGFyayA9ICFkYXJrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3ddW2NvbCAtIGNdID0gZGFyaztcbiAgICAgICAgICAgICAgICAgIGJpdEluZGV4IC09IDE7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChiaXRJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBieXRlSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYml0SW5kZXggPSA3O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJvdyArPSBpbmM7XG5cbiAgICAgICAgICAgICAgaWYgKHJvdyA8IDAgfHwgX21vZHVsZUNvdW50IDw9IHJvdykge1xuICAgICAgICAgICAgICAgIHJvdyAtPSBpbmM7XG4gICAgICAgICAgICAgICAgaW5jID0gLWluYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3JlYXRlQnl0ZXMgPSBmdW5jdGlvbihidWZmZXIsIHJzQmxvY2tzKSB7XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgIHZhciBtYXhEY0NvdW50ID0gMDtcbiAgICAgICAgICB2YXIgbWF4RWNDb3VudCA9IDA7XG5cbiAgICAgICAgICB2YXIgZGNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuXG4gICAgICAgICAgICB2YXIgZGNDb3VudCA9IHJzQmxvY2tzW3JdLmRhdGFDb3VudDtcbiAgICAgICAgICAgIHZhciBlY0NvdW50ID0gcnNCbG9ja3Nbcl0udG90YWxDb3VudCAtIGRjQ291bnQ7XG5cbiAgICAgICAgICAgIG1heERjQ291bnQgPSBNYXRoLm1heChtYXhEY0NvdW50LCBkY0NvdW50KTtcbiAgICAgICAgICAgIG1heEVjQ291bnQgPSBNYXRoLm1heChtYXhFY0NvdW50LCBlY0NvdW50KTtcblxuICAgICAgICAgICAgZGNkYXRhW3JdID0gbmV3IEFycmF5KGRjQ291bnQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRjZGF0YVtyXS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBkY2RhdGFbcl1baV0gPSAweGZmICYgYnVmZmVyLmdldEJ1ZmZlcigpW2kgKyBvZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGRjQ291bnQ7XG5cbiAgICAgICAgICAgIHZhciByc1BvbHkgPSBRUlV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcbiAgICAgICAgICAgIHZhciByYXdQb2x5ID0gcXJQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG5cbiAgICAgICAgICAgIHZhciBtb2RQb2x5ID0gcmF3UG9seS5tb2QocnNQb2x5KTtcbiAgICAgICAgICAgIGVjZGF0YVtyXSA9IG5ldyBBcnJheShyc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWNkYXRhW3JdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBtb2RJbmRleCA9IGkgKyBtb2RQb2x5LmdldExlbmd0aCgpIC0gZWNkYXRhW3JdLmxlbmd0aDtcbiAgICAgICAgICAgICAgZWNkYXRhW3JdW2ldID0gKG1vZEluZGV4ID49IDApPyBtb2RQb2x5LmdldEF0KG1vZEluZGV4KSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRvdGFsQ29kZUNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0b3RhbENvZGVDb3VudCArPSByc0Jsb2Nrc1tpXS50b3RhbENvdW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkYXRhID0gbmV3IEFycmF5KHRvdGFsQ29kZUNvdW50KTtcbiAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhEY0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKGkgPCBkY2RhdGFbcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBkY2RhdGFbcl1baV07XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RWNDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChpIDwgZWNkYXRhW3JdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZWNkYXRhW3JdW2ldO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3JlYXRlRGF0YSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsLCBkYXRhTGlzdCkge1xuXG4gICAgICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKTtcblxuICAgICAgICAgIHZhciBidWZmZXIgPSBxckJpdEJ1ZmZlcigpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtpXTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRNb2RlKCksIDQpO1xuICAgICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBRUlV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEuZ2V0TW9kZSgpLCB0eXBlTnVtYmVyKSApO1xuICAgICAgICAgICAgZGF0YS53cml0ZShidWZmZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNhbGMgbnVtIG1heCBkYXRhLlxuICAgICAgICAgIHZhciB0b3RhbERhdGFDb3VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByc0Jsb2Nrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPiB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29kZSBsZW5ndGggb3ZlcmZsb3cuICgnXG4gICAgICAgICAgICAgICsgYnVmZmVyLmdldExlbmd0aEluQml0cygpXG4gICAgICAgICAgICAgICsgJz4nXG4gICAgICAgICAgICAgICsgdG90YWxEYXRhQ291bnQgKiA4XG4gICAgICAgICAgICAgICsgJyknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlbmQgY29kZVxuICAgICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dCgwLCA0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgICAgd2hpbGUgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSAlIDggIT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyLnB1dEJpdChmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcGFkZGluZ1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnB1dChQQUQwLCA4KTtcblxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIucHV0KFBBRDEsIDgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjcmVhdGVCeXRlcyhidWZmZXIsIHJzQmxvY2tzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5hZGREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHZhciBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcbiAgICAgICAgICBfZGF0YUxpc3QucHVzaChuZXdEYXRhKTtcbiAgICAgICAgICBfZGF0YUNhY2hlID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5pc0RhcmsgPSBmdW5jdGlvbihyb3csIGNvbCkge1xuICAgICAgICAgIGlmIChyb3cgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSByb3cgfHwgY29sIDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gY29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iocm93ICsgJywnICsgY29sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9tb2R1bGVzW3Jvd11bY29sXTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5nZXRNb2R1bGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfbW9kdWxlQ291bnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMubWFrZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1ha2VJbXBsKGZhbHNlLCBnZXRCZXN0TWFza1BhdHRlcm4oKSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmNyZWF0ZVRhYmxlVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbikge1xuXG4gICAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICAgICAgdmFyIHFySHRtbCA9ICcnO1xuXG4gICAgICAgICAgcXJIdG1sICs9ICc8dGFibGUgc3R5bGU9XCInO1xuICAgICAgICAgIHFySHRtbCArPSAnIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7JztcbiAgICAgICAgICBxckh0bWwgKz0gJyBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgcGFkZGluZzogMHB4OyBtYXJnaW46ICcgKyBtYXJnaW4gKyAncHg7JztcbiAgICAgICAgICBxckh0bWwgKz0gJ1wiPic7XG4gICAgICAgICAgcXJIdG1sICs9ICc8dGJvZHk+JztcblxuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgciArPSAxKSB7XG5cbiAgICAgICAgICAgIHFySHRtbCArPSAnPHRyPic7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgYyArPSAxKSB7XG4gICAgICAgICAgICAgIHFySHRtbCArPSAnPHRkIHN0eWxlPVwiJztcbiAgICAgICAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTsnO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gJyBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyc7XG4gICAgICAgICAgICAgIHFySHRtbCArPSAnIHBhZGRpbmc6IDBweDsgbWFyZ2luOiAwcHg7JztcbiAgICAgICAgICAgICAgcXJIdG1sICs9ICcgd2lkdGg6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gJyBoZWlnaHQ6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gJyBiYWNrZ3JvdW5kLWNvbG9yOiAnO1xuICAgICAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMpPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZic7XG4gICAgICAgICAgICAgIHFySHRtbCArPSAnOyc7XG4gICAgICAgICAgICAgIHFySHRtbCArPSAnXCIvPic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHFySHRtbCArPSAnPC90cj4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHFySHRtbCArPSAnPC90Ym9keT4nO1xuICAgICAgICAgIHFySHRtbCArPSAnPC90YWJsZT4nO1xuXG4gICAgICAgICAgcmV0dXJuIHFySHRtbDtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5jcmVhdGVJbWdUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cbiAgICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG5cbiAgICAgICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICAgICAgdmFyIG1pbiA9IG1hcmdpbjtcbiAgICAgICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVJbWdUYWcoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgaWYgKG1pbiA8PSB4ICYmIHggPCBtYXggJiYgbWluIDw9IHkgJiYgeSA8IG1heCkge1xuICAgICAgICAgICAgICB2YXIgYyA9IE1hdGguZmxvb3IoICh4IC0gbWluKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCAoeSAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0RhcmsociwgYyk/IDAgOiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBxcmNvZGUuc3RyaW5nVG9CeXRlc1xuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgcXJjb2RlLnN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBieXRlcy5wdXNoKGMgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICB9O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gcXJjb2RlLmNyZWF0ZVN0cmluZ1RvQnl0ZXNcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHVuaWNvZGVEYXRhIGJhc2U2NCBzdHJpbmcgb2YgYnl0ZSBhcnJheS5cbiAgICAgICAqIFsxNmJpdCBVbmljb2RlXSxbMTZiaXQgQnl0ZXNdLCAuLi5cbiAgICAgICAqIEBwYXJhbSBudW1DaGFyc1xuICAgICAgICovXG4gICAgICBxcmNvZGUuY3JlYXRlU3RyaW5nVG9CeXRlcyA9IGZ1bmN0aW9uKHVuaWNvZGVEYXRhLCBudW1DaGFycykge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBjb252ZXJzaW9uIG1hcC5cblxuICAgICAgICB2YXIgdW5pY29kZU1hcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgdmFyIGJpbiA9IGJhc2U2NERlY29kZUlucHV0U3RyZWFtKHVuaWNvZGVEYXRhKTtcbiAgICAgICAgICB2YXIgcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGIgPSBiaW4ucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGIgPT0gLTEpIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgdmFyIHVuaWNvZGVNYXAgPSB7fTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGIwID0gYmluLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChiMCA9PSAtMSkgYnJlYWs7XG4gICAgICAgICAgICB2YXIgYjEgPSByZWFkKCk7XG4gICAgICAgICAgICB2YXIgYjIgPSByZWFkKCk7XG4gICAgICAgICAgICB2YXIgYjMgPSByZWFkKCk7XG4gICAgICAgICAgICB2YXIgayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoIChiMCA8PCA4KSB8IGIxKTtcbiAgICAgICAgICAgIHZhciB2ID0gKGIyIDw8IDgpIHwgYjM7XG4gICAgICAgICAgICB1bmljb2RlTWFwW2tdID0gdjtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3VudCAhPSBudW1DaGFycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvdW50ICsgJyAhPSAnICsgbnVtQ2hhcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB1bmljb2RlTWFwO1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgdmFyIHVua25vd25DaGFyID0gJz8nLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgICAgYnl0ZXMucHVzaChjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBiID0gdW5pY29kZU1hcFtzLmNoYXJBdChpKV07XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGlmICggKGIgJiAweGZmKSA9PSBiKSB7XG4gICAgICAgICAgICAgICAgICAvLyAxYnl0ZVxuICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gMmJ5dGVzXG4gICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGIgPj4+IDgpO1xuICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiICYgMHhmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2godW5rbm93bkNoYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBRUk1vZGVcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIHZhciBRUk1vZGUgPSB7XG4gICAgICAgIE1PREVfTlVNQkVSIDogICAgMSA8PCAwLFxuICAgICAgICBNT0RFX0FMUEhBX05VTSA6IDEgPDwgMSxcbiAgICAgICAgTU9ERV84QklUX0JZVEUgOiAxIDw8IDIsXG4gICAgICAgIE1PREVfS0FOSkkgOiAgICAgMSA8PCAzXG4gICAgICB9O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gUVJFcnJvckNvcnJlY3RMZXZlbFxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgdmFyIFFSRXJyb3JDb3JyZWN0TGV2ZWwgPSB7XG4gICAgICAgIEwgOiAxLFxuICAgICAgICBNIDogMCxcbiAgICAgICAgUSA6IDMsXG4gICAgICAgIEggOiAyXG4gICAgICB9O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gUVJNYXNrUGF0dGVyblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgdmFyIFFSTWFza1BhdHRlcm4gPSB7XG4gICAgICAgIFBBVFRFUk4wMDAgOiAwLFxuICAgICAgICBQQVRURVJOMDAxIDogMSxcbiAgICAgICAgUEFUVEVSTjAxMCA6IDIsXG4gICAgICAgIFBBVFRFUk4wMTEgOiAzLFxuICAgICAgICBQQVRURVJOMTAwIDogNCxcbiAgICAgICAgUEFUVEVSTjEwMSA6IDUsXG4gICAgICAgIFBBVFRFUk4xMTAgOiA2LFxuICAgICAgICBQQVRURVJOMTExIDogN1xuICAgICAgfTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFFSVXRpbFxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgdmFyIFFSVXRpbCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBQQVRURVJOX1BPU0lUSU9OX1RBQkxFID0gW1xuICAgICAgICAgIFtdLFxuICAgICAgICAgIFs2LCAxOF0sXG4gICAgICAgICAgWzYsIDIyXSxcbiAgICAgICAgICBbNiwgMjZdLFxuICAgICAgICAgIFs2LCAzMF0sXG4gICAgICAgICAgWzYsIDM0XSxcbiAgICAgICAgICBbNiwgMjIsIDM4XSxcbiAgICAgICAgICBbNiwgMjQsIDQyXSxcbiAgICAgICAgICBbNiwgMjYsIDQ2XSxcbiAgICAgICAgICBbNiwgMjgsIDUwXSxcbiAgICAgICAgICBbNiwgMzAsIDU0XSxcbiAgICAgICAgICBbNiwgMzIsIDU4XSxcbiAgICAgICAgICBbNiwgMzQsIDYyXSxcbiAgICAgICAgICBbNiwgMjYsIDQ2LCA2Nl0sXG4gICAgICAgICAgWzYsIDI2LCA0OCwgNzBdLFxuICAgICAgICAgIFs2LCAyNiwgNTAsIDc0XSxcbiAgICAgICAgICBbNiwgMzAsIDU0LCA3OF0sXG4gICAgICAgICAgWzYsIDMwLCA1NiwgODJdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2XSxcbiAgICAgICAgICBbNiwgMzQsIDYyLCA5MF0sXG4gICAgICAgICAgWzYsIDI4LCA1MCwgNzIsIDk0XSxcbiAgICAgICAgICBbNiwgMjYsIDUwLCA3NCwgOThdLFxuICAgICAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDJdLFxuICAgICAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDZdLFxuICAgICAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTBdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTRdLFxuICAgICAgICAgIFs2LCAzNCwgNjIsIDkwLCAxMThdLFxuICAgICAgICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSxcbiAgICAgICAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjZdLFxuICAgICAgICAgIFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0sXG4gICAgICAgICAgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSxcbiAgICAgICAgICBbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0Ml0sXG4gICAgICAgICAgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSxcbiAgICAgICAgICBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0sXG4gICAgICAgICAgWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdLFxuICAgICAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSxcbiAgICAgICAgICBbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0sXG4gICAgICAgICAgWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdLFxuICAgICAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXVxuICAgICAgICBdO1xuICAgICAgICB2YXIgRzE1ID0gKDEgPDwgMTApIHwgKDEgPDwgOCkgfCAoMSA8PCA1KSB8ICgxIDw8IDQpIHwgKDEgPDwgMikgfCAoMSA8PCAxKSB8ICgxIDw8IDApO1xuICAgICAgICB2YXIgRzE4ID0gKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKTtcbiAgICAgICAgdmFyIEcxNV9NQVNLID0gKDEgPDwgMTQpIHwgKDEgPDwgMTIpIHwgKDEgPDwgMTApIHwgKDEgPDwgNCkgfCAoMSA8PCAxKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgICAgICB2YXIgZ2V0QkNIRGlnaXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgdmFyIGRpZ2l0ID0gMDtcbiAgICAgICAgICB3aGlsZSAoZGF0YSAhPSAwKSB7XG4gICAgICAgICAgICBkaWdpdCArPSAxO1xuICAgICAgICAgICAgZGF0YSA+Pj49IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaWdpdDtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5nZXRCQ0hUeXBlSW5mbyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgICAgICAgd2hpbGUgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE1KSA+PSAwKSB7XG4gICAgICAgICAgICBkIF49IChHMTUgPDwgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE1KSApICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoIChkYXRhIDw8IDEwKSB8IGQpIF4gRzE1X01BU0s7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuZ2V0QkNIVHlwZU51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICB2YXIgZCA9IGRhdGEgPDwgMTI7XG4gICAgICAgICAgd2hpbGUgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KSA+PSAwKSB7XG4gICAgICAgICAgICBkIF49IChHMTggPDwgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KSApICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoZGF0YSA8PCAxMikgfCBkO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmdldFBhdHRlcm5Qb3NpdGlvbiA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gUEFUVEVSTl9QT1NJVElPTl9UQUJMRVt0eXBlTnVtYmVyIC0gMV07XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuZ2V0TWFza0Z1bmN0aW9uID0gZnVuY3Rpb24obWFza1BhdHRlcm4pIHtcblxuICAgICAgICAgIHN3aXRjaCAobWFza1BhdHRlcm4pIHtcblxuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAwIDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoaSArIGopICUgMiA9PSAwOyB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAxIDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiBpICUgMiA9PSAwOyB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDEwIDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiBqICUgMyA9PSAwOyB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDExIDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoaSArIGopICUgMyA9PSAwOyB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAwIDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoTWF0aC5mbG9vcihpIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSApICUgMiA9PSAwOyB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAxIDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoaSAqIGopICUgMiArIChpICogaikgJSAzID09IDA7IH07XG4gICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTAgOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuICggKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMykgJSAyID09IDA7IH07XG4gICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTEgOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuICggKGkgKiBqKSAlIDMgKyAoaSArIGopICUgMikgJSAyID09IDA7IH07XG5cbiAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIG1hc2tQYXR0ZXJuOicgKyBtYXNrUGF0dGVybik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwgPSBmdW5jdGlvbihlcnJvckNvcnJlY3RMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgYSA9IHFyUG9seW5vbWlhbChbMV0sIDApO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JDb3JyZWN0TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGEgPSBhLm11bHRpcGx5KHFyUG9seW5vbWlhbChbMSwgUVJNYXRoLmdleHAoaSldLCAwKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5nZXRMZW5ndGhJbkJpdHMgPSBmdW5jdGlvbihtb2RlLCB0eXBlKSB7XG5cbiAgICAgICAgICBpZiAoMSA8PSB0eXBlICYmIHR5cGUgPCAxMCkge1xuXG4gICAgICAgICAgICAvLyAxIC0gOVxuXG4gICAgICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVIgICAgOiByZXR1cm4gMTA7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTSA6IHJldHVybiA5O1xuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV84QklUX0JZVEUgOiByZXR1cm4gODtcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkkgICAgIDogcmV0dXJuIDg7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA8IDI3KSB7XG5cbiAgICAgICAgICAgIC8vIDEwIC0gMjZcblxuICAgICAgICAgICAgc3dpdGNoKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSICAgIDogcmV0dXJuIDEyO1xuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU0gOiByZXR1cm4gMTE7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURSA6IHJldHVybiAxNjtcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkkgICAgIDogcmV0dXJuIDEwO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZTonICsgbW9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPCA0MSkge1xuXG4gICAgICAgICAgICAvLyAyNyAtIDQwXG5cbiAgICAgICAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUiAgICA6IHJldHVybiAxNDtcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNIDogcmV0dXJuIDEzO1xuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV84QklUX0JZVEUgOiByZXR1cm4gMTY7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJICAgICA6IHJldHVybiAxMjtcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGU6JyArIG1vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZTonICsgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmdldExvc3RQb2ludCA9IGZ1bmN0aW9uKHFyY29kZSkge1xuXG4gICAgICAgICAgdmFyIG1vZHVsZUNvdW50ID0gcXJjb2RlLmdldE1vZHVsZUNvdW50KCk7XG5cbiAgICAgICAgICB2YXIgbG9zdFBvaW50ID0gMDtcblxuICAgICAgICAgIC8vIExFVkVMMVxuXG4gICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcblxuICAgICAgICAgICAgICB2YXIgc2FtZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGRhcmsgPSBxcmNvZGUuaXNEYXJrKHJvdywgY29sKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gMTsgciArPSAxKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocm93ICsgciA8IDAgfHwgbW9kdWxlQ291bnQgPD0gcm93ICsgcikge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IC0xOyBjIDw9IDE7IGMgKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY29sICsgYyA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sICsgYykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHIgPT0gMCAmJiBjID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChkYXJrID09IHFyY29kZS5pc0Rhcmsocm93ICsgciwgY29sICsgYykgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzYW1lQ291bnQgPiA1KSB7XG4gICAgICAgICAgICAgICAgbG9zdFBvaW50ICs9ICgzICsgc2FtZUNvdW50IC0gNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gTEVWRUwyXG5cbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDE7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDE7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKSApIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCkgKSBjb3VudCArPSAxO1xuICAgICAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDEpICkgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sICsgMSkgKSBjb3VudCArPSAxO1xuICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMCB8fCBjb3VudCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgbG9zdFBvaW50ICs9IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBMRVZFTDNcblxuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQgLSA2OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbClcbiAgICAgICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMSlcbiAgICAgICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMilcbiAgICAgICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMylcbiAgICAgICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNClcbiAgICAgICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNSlcbiAgICAgICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNikgKSB7XG4gICAgICAgICAgICAgICAgbG9zdFBvaW50ICs9IDQwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDY7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKVxuICAgICAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sKVxuICAgICAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgMiwgY29sKVxuICAgICAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgMywgY29sKVxuICAgICAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgNCwgY29sKVxuICAgICAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93ICsgNSwgY29sKVxuICAgICAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgNiwgY29sKSApIHtcbiAgICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBMRVZFTDRcblxuICAgICAgICAgIHZhciBkYXJrQ291bnQgPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpICkge1xuICAgICAgICAgICAgICAgIGRhcmtDb3VudCArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5hYnMoMTAwICogZGFya0NvdW50IC8gbW9kdWxlQ291bnQgLyBtb2R1bGVDb3VudCAtIDUwKSAvIDU7XG4gICAgICAgICAgbG9zdFBvaW50ICs9IHJhdGlvICogMTA7XG5cbiAgICAgICAgICByZXR1cm4gbG9zdFBvaW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH0oKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIFFSTWF0aFxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgdmFyIFFSTWF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBFWFBfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgICAgdmFyIExPR19UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGFibGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgICAgICAgRVhQX1RBQkxFW2ldID0gMSA8PCBpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSA4OyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgICAgICAgICBFWFBfVEFCTEVbaV0gPSBFWFBfVEFCTEVbaSAtIDRdXG4gICAgICAgICAgICBeIEVYUF9UQUJMRVtpIC0gNV1cbiAgICAgICAgICAgIF4gRVhQX1RBQkxFW2kgLSA2XVxuICAgICAgICAgICAgXiBFWFBfVEFCTEVbaSAtIDhdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU1OyBpICs9IDEpIHtcbiAgICAgICAgICBMT0dfVEFCTEVbRVhQX1RBQkxFW2ldIF0gPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgX3RoaXMuZ2xvZyA9IGZ1bmN0aW9uKG4pIHtcblxuICAgICAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbG9nKCcgKyBuICsgJyknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gTE9HX1RBQkxFW25dO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmdleHAgPSBmdW5jdGlvbihuKSB7XG5cbiAgICAgICAgICB3aGlsZSAobiA8IDApIHtcbiAgICAgICAgICAgIG4gKz0gMjU1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChuID49IDI1Nikge1xuICAgICAgICAgICAgbiAtPSAyNTU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIEVYUF9UQUJMRVtuXTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9KCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBxclBvbHlub21pYWxcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIGZ1bmN0aW9uIHFyUG9seW5vbWlhbChudW0sIHNoaWZ0KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBudW0ubGVuZ3RoID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG51bS5sZW5ndGggKyAnLycgKyBzaGlmdCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX251bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBudW0ubGVuZ3RoICYmIG51bVtvZmZzZXRdID09IDApIHtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX251bSA9IG5ldyBBcnJheShudW0ubGVuZ3RoIC0gb2Zmc2V0ICsgc2hpZnQpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aCAtIG9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgICAgICBfbnVtW2ldID0gbnVtW2kgKyBvZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX251bTtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgICAgIF90aGlzLmdldEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gX251bVtpbmRleF07XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9udW0ubGVuZ3RoO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLm11bHRpcGx5ID0gZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgdmFyIG51bSA9IG5ldyBBcnJheShfdGhpcy5nZXRMZW5ndGgoKSArIGUuZ2V0TGVuZ3RoKCkgLSAxKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuZ2V0TGVuZ3RoKCk7IGkgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlLmdldExlbmd0aCgpOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgbnVtW2kgKyBqXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdChpKSApICsgUVJNYXRoLmdsb2coZS5nZXRBdChqKSApICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHFyUG9seW5vbWlhbChudW0sIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLm1vZCA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgIGlmIChfdGhpcy5nZXRMZW5ndGgoKSAtIGUuZ2V0TGVuZ3RoKCkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJhdGlvID0gUVJNYXRoLmdsb2coX3RoaXMuZ2V0QXQoMCkgKSAtIFFSTWF0aC5nbG9nKGUuZ2V0QXQoMCkgKTtcblxuICAgICAgICAgIHZhciBudW0gPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkgKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmdldExlbmd0aCgpOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG51bVtpXSA9IF90aGlzLmdldEF0KGkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XG4gICAgICAgICAgICBudW1baV0gXj0gUVJNYXRoLmdleHAoUVJNYXRoLmdsb2coZS5nZXRBdChpKSApICsgcmF0aW8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgcmV0dXJuIHFyUG9seW5vbWlhbChudW0sIDApLm1vZChlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gUVJSU0Jsb2NrXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICB2YXIgUVJSU0Jsb2NrID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIFJTX0JMT0NLX1RBQkxFID0gW1xuXG4gICAgICAgICAgLy8gTFxuICAgICAgICAgIC8vIE1cbiAgICAgICAgICAvLyBRXG4gICAgICAgICAgLy8gSFxuXG4gICAgICAgICAgLy8gMVxuICAgICAgICAgIFsxLCAyNiwgMTldLFxuICAgICAgICAgIFsxLCAyNiwgMTZdLFxuICAgICAgICAgIFsxLCAyNiwgMTNdLFxuICAgICAgICAgIFsxLCAyNiwgOV0sXG5cbiAgICAgICAgICAvLyAyXG4gICAgICAgICAgWzEsIDQ0LCAzNF0sXG4gICAgICAgICAgWzEsIDQ0LCAyOF0sXG4gICAgICAgICAgWzEsIDQ0LCAyMl0sXG4gICAgICAgICAgWzEsIDQ0LCAxNl0sXG5cbiAgICAgICAgICAvLyAzXG4gICAgICAgICAgWzEsIDcwLCA1NV0sXG4gICAgICAgICAgWzEsIDcwLCA0NF0sXG4gICAgICAgICAgWzIsIDM1LCAxN10sXG4gICAgICAgICAgWzIsIDM1LCAxM10sXG5cbiAgICAgICAgICAvLyA0XG4gICAgICAgICAgWzEsIDEwMCwgODBdLFxuICAgICAgICAgIFsyLCA1MCwgMzJdLFxuICAgICAgICAgIFsyLCA1MCwgMjRdLFxuICAgICAgICAgIFs0LCAyNSwgOV0sXG5cbiAgICAgICAgICAvLyA1XG4gICAgICAgICAgWzEsIDEzNCwgMTA4XSxcbiAgICAgICAgICBbMiwgNjcsIDQzXSxcbiAgICAgICAgICBbMiwgMzMsIDE1LCAyLCAzNCwgMTZdLFxuICAgICAgICAgIFsyLCAzMywgMTEsIDIsIDM0LCAxMl0sXG5cbiAgICAgICAgICAvLyA2XG4gICAgICAgICAgWzIsIDg2LCA2OF0sXG4gICAgICAgICAgWzQsIDQzLCAyN10sXG4gICAgICAgICAgWzQsIDQzLCAxOV0sXG4gICAgICAgICAgWzQsIDQzLCAxNV0sXG5cbiAgICAgICAgICAvLyA3XG4gICAgICAgICAgWzIsIDk4LCA3OF0sXG4gICAgICAgICAgWzQsIDQ5LCAzMV0sXG4gICAgICAgICAgWzIsIDMyLCAxNCwgNCwgMzMsIDE1XSxcbiAgICAgICAgICBbNCwgMzksIDEzLCAxLCA0MCwgMTRdLFxuXG4gICAgICAgICAgLy8gOFxuICAgICAgICAgIFsyLCAxMjEsIDk3XSxcbiAgICAgICAgICBbMiwgNjAsIDM4LCAyLCA2MSwgMzldLFxuICAgICAgICAgIFs0LCA0MCwgMTgsIDIsIDQxLCAxOV0sXG4gICAgICAgICAgWzQsIDQwLCAxNCwgMiwgNDEsIDE1XSxcblxuICAgICAgICAgIC8vIDlcbiAgICAgICAgICBbMiwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFszLCA1OCwgMzYsIDIsIDU5LCAzN10sXG4gICAgICAgICAgWzQsIDM2LCAxNiwgNCwgMzcsIDE3XSxcbiAgICAgICAgICBbNCwgMzYsIDEyLCA0LCAzNywgMTNdLFxuXG4gICAgICAgICAgLy8gMTBcbiAgICAgICAgICBbMiwgODYsIDY4LCAyLCA4NywgNjldLFxuICAgICAgICAgIFs0LCA2OSwgNDMsIDEsIDcwLCA0NF0sXG4gICAgICAgICAgWzYsIDQzLCAxOSwgMiwgNDQsIDIwXSxcbiAgICAgICAgICBbNiwgNDMsIDE1LCAyLCA0NCwgMTZdLFxuXG4gICAgICAgICAgLy8gMTFcbiAgICAgICAgICBbNCwgMTAxLCA4MV0sXG4gICAgICAgICAgWzEsIDgwLCA1MCwgNCwgODEsIDUxXSxcbiAgICAgICAgICBbNCwgNTAsIDIyLCA0LCA1MSwgMjNdLFxuICAgICAgICAgIFszLCAzNiwgMTIsIDgsIDM3LCAxM10sXG5cbiAgICAgICAgICAvLyAxMlxuICAgICAgICAgIFsyLCAxMTYsIDkyLCAyLCAxMTcsIDkzXSxcbiAgICAgICAgICBbNiwgNTgsIDM2LCAyLCA1OSwgMzddLFxuICAgICAgICAgIFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sXG4gICAgICAgICAgWzcsIDQyLCAxNCwgNCwgNDMsIDE1XSxcblxuICAgICAgICAgIC8vIDEzXG4gICAgICAgICAgWzQsIDEzMywgMTA3XSxcbiAgICAgICAgICBbOCwgNTksIDM3LCAxLCA2MCwgMzhdLFxuICAgICAgICAgIFs4LCA0NCwgMjAsIDQsIDQ1LCAyMV0sXG4gICAgICAgICAgWzEyLCAzMywgMTEsIDQsIDM0LCAxMl0sXG5cbiAgICAgICAgICAvLyAxNFxuICAgICAgICAgIFszLCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFs0LCA2NCwgNDAsIDUsIDY1LCA0MV0sXG4gICAgICAgICAgWzExLCAzNiwgMTYsIDUsIDM3LCAxN10sXG4gICAgICAgICAgWzExLCAzNiwgMTIsIDUsIDM3LCAxM10sXG5cbiAgICAgICAgICAvLyAxNVxuICAgICAgICAgIFs1LCAxMDksIDg3LCAxLCAxMTAsIDg4XSxcbiAgICAgICAgICBbNSwgNjUsIDQxLCA1LCA2NiwgNDJdLFxuICAgICAgICAgIFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG4gICAgICAgICAgWzExLCAzNiwgMTIsIDcsIDM3LCAxM10sXG5cbiAgICAgICAgICAvLyAxNlxuICAgICAgICAgIFs1LCAxMjIsIDk4LCAxLCAxMjMsIDk5XSxcbiAgICAgICAgICBbNywgNzMsIDQ1LCAzLCA3NCwgNDZdLFxuICAgICAgICAgIFsxNSwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuICAgICAgICAgIFszLCA0NSwgMTUsIDEzLCA0NiwgMTZdLFxuXG4gICAgICAgICAgLy8gMTdcbiAgICAgICAgICBbMSwgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcbiAgICAgICAgICBbMTAsIDc0LCA0NiwgMSwgNzUsIDQ3XSxcbiAgICAgICAgICBbMSwgNTAsIDIyLCAxNSwgNTEsIDIzXSxcbiAgICAgICAgICBbMiwgNDIsIDE0LCAxNywgNDMsIDE1XSxcblxuICAgICAgICAgIC8vIDE4XG4gICAgICAgICAgWzUsIDE1MCwgMTIwLCAxLCAxNTEsIDEyMV0sXG4gICAgICAgICAgWzksIDY5LCA0MywgNCwgNzAsIDQ0XSxcbiAgICAgICAgICBbMTcsIDUwLCAyMiwgMSwgNTEsIDIzXSxcbiAgICAgICAgICBbMiwgNDIsIDE0LCAxOSwgNDMsIDE1XSxcblxuICAgICAgICAgIC8vIDE5XG4gICAgICAgICAgWzMsIDE0MSwgMTEzLCA0LCAxNDIsIDExNF0sXG4gICAgICAgICAgWzMsIDcwLCA0NCwgMTEsIDcxLCA0NV0sXG4gICAgICAgICAgWzE3LCA0NywgMjEsIDQsIDQ4LCAyMl0sXG4gICAgICAgICAgWzksIDM5LCAxMywgMTYsIDQwLCAxNF0sXG5cbiAgICAgICAgICAvLyAyMFxuICAgICAgICAgIFszLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLFxuICAgICAgICAgIFszLCA2NywgNDEsIDEzLCA2OCwgNDJdLFxuICAgICAgICAgIFsxNSwgNTQsIDI0LCA1LCA1NSwgMjVdLFxuICAgICAgICAgIFsxNSwgNDMsIDE1LCAxMCwgNDQsIDE2XSxcblxuICAgICAgICAgIC8vIDIxXG4gICAgICAgICAgWzQsIDE0NCwgMTE2LCA0LCAxNDUsIDExN10sXG4gICAgICAgICAgWzE3LCA2OCwgNDJdLFxuICAgICAgICAgIFsxNywgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgICAgIFsxOSwgNDYsIDE2LCA2LCA0NywgMTddLFxuXG4gICAgICAgICAgLy8gMjJcbiAgICAgICAgICBbMiwgMTM5LCAxMTEsIDcsIDE0MCwgMTEyXSxcbiAgICAgICAgICBbMTcsIDc0LCA0Nl0sXG4gICAgICAgICAgWzcsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICAgICAgWzM0LCAzNywgMTNdLFxuXG4gICAgICAgICAgLy8gMjNcbiAgICAgICAgICBbNCwgMTUxLCAxMjEsIDUsIDE1MiwgMTIyXSxcbiAgICAgICAgICBbNCwgNzUsIDQ3LCAxNCwgNzYsIDQ4XSxcbiAgICAgICAgICBbMTEsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICAgICAgWzE2LCA0NSwgMTUsIDE0LCA0NiwgMTZdLFxuXG4gICAgICAgICAgLy8gMjRcbiAgICAgICAgICBbNiwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcbiAgICAgICAgICBbNiwgNzMsIDQ1LCAxNCwgNzQsIDQ2XSxcbiAgICAgICAgICBbMTEsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICAgICAgWzMwLCA0NiwgMTYsIDIsIDQ3LCAxN10sXG5cbiAgICAgICAgICAvLyAyNVxuICAgICAgICAgIFs4LCAxMzIsIDEwNiwgNCwgMTMzLCAxMDddLFxuICAgICAgICAgIFs4LCA3NSwgNDcsIDEzLCA3NiwgNDhdLFxuICAgICAgICAgIFs3LCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgICAgIFsyMiwgNDUsIDE1LCAxMywgNDYsIDE2XSxcblxuICAgICAgICAgIC8vIDI2XG4gICAgICAgICAgWzEwLCAxNDIsIDExNCwgMiwgMTQzLCAxMTVdLFxuICAgICAgICAgIFsxOSwgNzQsIDQ2LCA0LCA3NSwgNDddLFxuICAgICAgICAgIFsyOCwgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgICAgIFszMywgNDYsIDE2LCA0LCA0NywgMTddLFxuXG4gICAgICAgICAgLy8gMjdcbiAgICAgICAgICBbOCwgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcbiAgICAgICAgICBbMjIsIDczLCA0NSwgMywgNzQsIDQ2XSxcbiAgICAgICAgICBbOCwgNTMsIDIzLCAyNiwgNTQsIDI0XSxcbiAgICAgICAgICBbMTIsIDQ1LCAxNSwgMjgsIDQ2LCAxNl0sXG5cbiAgICAgICAgICAvLyAyOFxuICAgICAgICAgIFszLCAxNDcsIDExNywgMTAsIDE0OCwgMTE4XSxcbiAgICAgICAgICBbMywgNzMsIDQ1LCAyMywgNzQsIDQ2XSxcbiAgICAgICAgICBbNCwgNTQsIDI0LCAzMSwgNTUsIDI1XSxcbiAgICAgICAgICBbMTEsIDQ1LCAxNSwgMzEsIDQ2LCAxNl0sXG5cbiAgICAgICAgICAvLyAyOVxuICAgICAgICAgIFs3LCAxNDYsIDExNiwgNywgMTQ3LCAxMTddLFxuICAgICAgICAgIFsyMSwgNzMsIDQ1LCA3LCA3NCwgNDZdLFxuICAgICAgICAgIFsxLCA1MywgMjMsIDM3LCA1NCwgMjRdLFxuICAgICAgICAgIFsxOSwgNDUsIDE1LCAyNiwgNDYsIDE2XSxcblxuICAgICAgICAgIC8vIDMwXG4gICAgICAgICAgWzUsIDE0NSwgMTE1LCAxMCwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFsxOSwgNzUsIDQ3LCAxMCwgNzYsIDQ4XSxcbiAgICAgICAgICBbMTUsIDU0LCAyNCwgMjUsIDU1LCAyNV0sXG4gICAgICAgICAgWzIzLCA0NSwgMTUsIDI1LCA0NiwgMTZdLFxuXG4gICAgICAgICAgLy8gMzFcbiAgICAgICAgICBbMTMsIDE0NSwgMTE1LCAzLCAxNDYsIDExNl0sXG4gICAgICAgICAgWzIsIDc0LCA0NiwgMjksIDc1LCA0N10sXG4gICAgICAgICAgWzQyLCA1NCwgMjQsIDEsIDU1LCAyNV0sXG4gICAgICAgICAgWzIzLCA0NSwgMTUsIDI4LCA0NiwgMTZdLFxuXG4gICAgICAgICAgLy8gMzJcbiAgICAgICAgICBbMTcsIDE0NSwgMTE1XSxcbiAgICAgICAgICBbMTAsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG4gICAgICAgICAgWzEwLCA1NCwgMjQsIDM1LCA1NSwgMjVdLFxuICAgICAgICAgIFsxOSwgNDUsIDE1LCAzNSwgNDYsIDE2XSxcblxuICAgICAgICAgIC8vIDMzXG4gICAgICAgICAgWzE3LCAxNDUsIDExNSwgMSwgMTQ2LCAxMTZdLFxuICAgICAgICAgIFsxNCwgNzQsIDQ2LCAyMSwgNzUsIDQ3XSxcbiAgICAgICAgICBbMjksIDU0LCAyNCwgMTksIDU1LCAyNV0sXG4gICAgICAgICAgWzExLCA0NSwgMTUsIDQ2LCA0NiwgMTZdLFxuXG4gICAgICAgICAgLy8gMzRcbiAgICAgICAgICBbMTMsIDE0NSwgMTE1LCA2LCAxNDYsIDExNl0sXG4gICAgICAgICAgWzE0LCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuICAgICAgICAgIFs0NCwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuICAgICAgICAgIFs1OSwgNDYsIDE2LCAxLCA0NywgMTddLFxuXG4gICAgICAgICAgLy8gMzVcbiAgICAgICAgICBbMTIsIDE1MSwgMTIxLCA3LCAxNTIsIDEyMl0sXG4gICAgICAgICAgWzEyLCA3NSwgNDcsIDI2LCA3NiwgNDhdLFxuICAgICAgICAgIFszOSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgICAgICBbMjIsIDQ1LCAxNSwgNDEsIDQ2LCAxNl0sXG5cbiAgICAgICAgICAvLyAzNlxuICAgICAgICAgIFs2LCAxNTEsIDEyMSwgMTQsIDE1MiwgMTIyXSxcbiAgICAgICAgICBbNiwgNzUsIDQ3LCAzNCwgNzYsIDQ4XSxcbiAgICAgICAgICBbNDYsIDU0LCAyNCwgMTAsIDU1LCAyNV0sXG4gICAgICAgICAgWzIsIDQ1LCAxNSwgNjQsIDQ2LCAxNl0sXG5cbiAgICAgICAgICAvLyAzN1xuICAgICAgICAgIFsxNywgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcbiAgICAgICAgICBbMjksIDc0LCA0NiwgMTQsIDc1LCA0N10sXG4gICAgICAgICAgWzQ5LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuICAgICAgICAgIFsyNCwgNDUsIDE1LCA0NiwgNDYsIDE2XSxcblxuICAgICAgICAgIC8vIDM4XG4gICAgICAgICAgWzQsIDE1MiwgMTIyLCAxOCwgMTUzLCAxMjNdLFxuICAgICAgICAgIFsxMywgNzQsIDQ2LCAzMiwgNzUsIDQ3XSxcbiAgICAgICAgICBbNDgsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICAgICAgWzQyLCA0NSwgMTUsIDMyLCA0NiwgMTZdLFxuXG4gICAgICAgICAgLy8gMzlcbiAgICAgICAgICBbMjAsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sXG4gICAgICAgICAgWzQwLCA3NSwgNDcsIDcsIDc2LCA0OF0sXG4gICAgICAgICAgWzQzLCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgICAgIFsxMCwgNDUsIDE1LCA2NywgNDYsIDE2XSxcblxuICAgICAgICAgIC8vIDQwXG4gICAgICAgICAgWzE5LCAxNDgsIDExOCwgNiwgMTQ5LCAxMTldLFxuICAgICAgICAgIFsxOCwgNzUsIDQ3LCAzMSwgNzYsIDQ4XSxcbiAgICAgICAgICBbMzQsIDU0LCAyNCwgMzQsIDU1LCAyNV0sXG4gICAgICAgICAgWzIwLCA0NSwgMTUsIDYxLCA0NiwgMTZdXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIHFyUlNCbG9jayA9IGZ1bmN0aW9uKHRvdGFsQ291bnQsIGRhdGFDb3VudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgICAgIF90aGlzLnRvdGFsQ291bnQgPSB0b3RhbENvdW50O1xuICAgICAgICAgIF90aGlzLmRhdGFDb3VudCA9IGRhdGFDb3VudDtcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgdmFyIGdldFJzQmxvY2tUYWJsZSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKSB7XG5cbiAgICAgICAgICBzd2l0Y2goZXJyb3JDb3JyZWN0TGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0TGV2ZWwuTCA6XG4gICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAwXTtcbiAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0TGV2ZWwuTSA6XG4gICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAxXTtcbiAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0TGV2ZWwuUSA6XG4gICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAyXTtcbiAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0TGV2ZWwuSCA6XG4gICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAzXTtcbiAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmdldFJTQmxvY2tzID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcblxuICAgICAgICAgIHZhciByc0Jsb2NrID0gZ2V0UnNCbG9ja1RhYmxlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcnNCbG9jayA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOicgKyB0eXBlTnVtYmVyICtcbiAgICAgICAgICAgICAgICAnL2Vycm9yQ29ycmVjdExldmVsOicgKyBlcnJvckNvcnJlY3RMZXZlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcblxuICAgICAgICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cbiAgICAgICAgICAgIHZhciBjb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAwXTtcbiAgICAgICAgICAgIHZhciB0b3RhbENvdW50ID0gcnNCbG9ja1tpICogMyArIDFdO1xuICAgICAgICAgICAgdmFyIGRhdGFDb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAyXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIGxpc3QucHVzaChxclJTQmxvY2sodG90YWxDb3VudCwgZGF0YUNvdW50KSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH0oKTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIHFyQml0QnVmZmVyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICB2YXIgcXJCaXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgX2J1ZmZlciA9IG5ldyBBcnJheSgpO1xuICAgICAgICB2YXIgX2xlbmd0aCA9IDA7XG5cbiAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgX3RoaXMuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9idWZmZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgIHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcbiAgICAgICAgICByZXR1cm4gKCAoX2J1ZmZlcltidWZJbmRleF0gPj4+ICg3IC0gaW5kZXggJSA4KSApICYgMSkgPT0gMTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5wdXQgPSBmdW5jdGlvbihudW0sIGxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIF90aGlzLnB1dEJpdCggKCAobnVtID4+PiAobGVuZ3RoIC0gaSAtIDEpICkgJiAxKSA9PSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9sZW5ndGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMucHV0Qml0ID0gZnVuY3Rpb24oYml0KSB7XG5cbiAgICAgICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKF9sZW5ndGggLyA4KTtcbiAgICAgICAgICBpZiAoX2J1ZmZlci5sZW5ndGggPD0gYnVmSW5kZXgpIHtcbiAgICAgICAgICAgIF9idWZmZXIucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICBfYnVmZmVyW2J1ZkluZGV4XSB8PSAoMHg4MCA+Pj4gKF9sZW5ndGggJSA4KSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gcXI4Qml0Qnl0ZVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgdmFyIHFyOEJpdEJ5dGUgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfOEJJVF9CWVRFO1xuICAgICAgICB2YXIgX2RhdGEgPSBkYXRhO1xuICAgICAgICB2YXIgX2J5dGVzID0gcXJjb2RlLnN0cmluZ1RvQnl0ZXMoZGF0YSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gX2J5dGVzLmxlbmd0aDtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2J5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBidWZmZXIucHV0KF9ieXRlc1tpXSwgOCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAvLyBHSUYgU3VwcG9ydCBldGMuXG4gICAgICAvL1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gYnl0ZUFycmF5T3V0cHV0U3RyZWFtXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICB2YXIgYnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF9ieXRlcyA9IG5ldyBBcnJheSgpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICBfYnl0ZXMucHVzaChiICYgMHhmZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMud3JpdGVTaG9ydCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICBfdGhpcy53cml0ZUJ5dGUoaSk7XG4gICAgICAgICAgX3RoaXMud3JpdGVCeXRlKGkgPj4+IDgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLndyaXRlQnl0ZXMgPSBmdW5jdGlvbihiLCBvZmYsIGxlbikge1xuICAgICAgICAgIG9mZiA9IG9mZiB8fCAwO1xuICAgICAgICAgIGxlbiA9IGxlbiB8fCBiLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBfdGhpcy53cml0ZUJ5dGUoYltpICsgb2ZmXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLndyaXRlU3RyaW5nID0gZnVuY3Rpb24ocykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgX3RoaXMud3JpdGVCeXRlKHMuY2hhckNvZGVBdChpKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy50b0J5dGVBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfYnl0ZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICAgIHMgKz0gJ1snO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2J5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgcyArPSAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzICs9IF9ieXRlc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcyArPSAnXSc7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgdmFyIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfYnVmZmVyID0gMDtcbiAgICAgICAgdmFyIF9idWZsZW4gPSAwO1xuICAgICAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBfYmFzZTY0ID0gJyc7XG5cbiAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgdmFyIHdyaXRlRW5jb2RlZCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICBfYmFzZTY0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZW5jb2RlKGIgJiAweDNmKSApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICAvLyBlcnJvci5cbiAgICAgICAgICB9IGVsc2UgaWYgKG4gPCAyNikge1xuICAgICAgICAgICAgcmV0dXJuIDB4NDEgKyBuO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA8IDUyKSB7XG4gICAgICAgICAgICByZXR1cm4gMHg2MSArIChuIC0gMjYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA8IDYyKSB7XG4gICAgICAgICAgICByZXR1cm4gMHgzMCArIChuIC0gNTIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PSA2Mikge1xuICAgICAgICAgICAgcmV0dXJuIDB4MmI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09IDYzKSB7XG4gICAgICAgICAgICByZXR1cm4gMHgyZjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduOicgKyBuKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihuKSB7XG5cbiAgICAgICAgICBfYnVmZmVyID0gKF9idWZmZXIgPDwgOCkgfCAobiAmIDB4ZmYpO1xuICAgICAgICAgIF9idWZsZW4gKz0gODtcbiAgICAgICAgICBfbGVuZ3RoICs9IDE7XG5cbiAgICAgICAgICB3aGlsZSAoX2J1ZmxlbiA+PSA2KSB7XG4gICAgICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA+Pj4gKF9idWZsZW4gLSA2KSApO1xuICAgICAgICAgICAgX2J1ZmxlbiAtPSA2O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKF9idWZsZW4gPiAwKSB7XG4gICAgICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA8PCAoNiAtIF9idWZsZW4pICk7XG4gICAgICAgICAgICBfYnVmZmVyID0gMDtcbiAgICAgICAgICAgIF9idWZsZW4gPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfbGVuZ3RoICUgMyAhPSAwKSB7XG4gICAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgICAgICB2YXIgcGFkbGVuID0gMyAtIF9sZW5ndGggJSAzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICBfYmFzZTY0ICs9ICc9JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2Jhc2U2NDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW1cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIHZhciBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uKHN0cikge1xuXG4gICAgICAgIHZhciBfc3RyID0gc3RyO1xuICAgICAgICB2YXIgX3BvcyA9IDA7XG4gICAgICAgIHZhciBfYnVmZmVyID0gMDtcbiAgICAgICAgdmFyIF9idWZsZW4gPSAwO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgICAgIF90aGlzLnJlYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHdoaWxlIChfYnVmbGVuIDwgOCkge1xuXG4gICAgICAgICAgICBpZiAoX3BvcyA+PSBfc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoX2J1ZmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgZmlsZS4vJyArIF9idWZsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IF9zdHIuY2hhckF0KF9wb3MpO1xuICAgICAgICAgICAgX3BvcyArPSAxO1xuXG4gICAgICAgICAgICBpZiAoYyA9PSAnPScpIHtcbiAgICAgICAgICAgICAgX2J1ZmxlbiA9IDA7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy5tYXRjaCgvXlxccyQvKSApIHtcbiAgICAgICAgICAgICAgLy8gaWdub3JlIGlmIHdoaXRlc3BhY2UuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfYnVmZmVyID0gKF9idWZmZXIgPDwgNikgfCBkZWNvZGUoYy5jaGFyQ29kZUF0KDApICk7XG4gICAgICAgICAgICBfYnVmbGVuICs9IDY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG4gPSAoX2J1ZmZlciA+Pj4gKF9idWZsZW4gLSA4KSApICYgMHhmZjtcbiAgICAgICAgICBfYnVmbGVuIC09IDg7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICBpZiAoMHg0MSA8PSBjICYmIGMgPD0gMHg1YSkge1xuICAgICAgICAgICAgcmV0dXJuIGMgLSAweDQxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoMHg2MSA8PSBjICYmIGMgPD0gMHg3YSkge1xuICAgICAgICAgICAgcmV0dXJuIGMgLSAweDYxICsgMjY7XG4gICAgICAgICAgfSBlbHNlIGlmICgweDMwIDw9IGMgJiYgYyA8PSAweDM5KSB7XG4gICAgICAgICAgICByZXR1cm4gYyAtIDB4MzAgKyA1MjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT0gMHgyYikge1xuICAgICAgICAgICAgcmV0dXJuIDYyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PSAweDJmKSB7XG4gICAgICAgICAgICByZXR1cm4gNjM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYzonICsgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBnaWZJbWFnZSAoQi9XKVxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgdmFyIGdpZkltYWdlID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBfd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdmFyIF9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciBfZGF0YSA9IG5ldyBBcnJheSh3aWR0aCAqIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgX3RoaXMuc2V0UGl4ZWwgPSBmdW5jdGlvbih4LCB5LCBwaXhlbCkge1xuICAgICAgICAgIF9kYXRhW3kgKiBfd2lkdGggKyB4XSA9IHBpeGVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24ob3V0KSB7XG5cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIC8vIEdJRiBTaWduYXR1cmVcblxuICAgICAgICAgIG91dC53cml0ZVN0cmluZygnR0lGODdhJyk7XG5cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIC8vIFNjcmVlbiBEZXNjcmlwdG9yXG5cbiAgICAgICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KF9oZWlnaHQpO1xuXG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgweDgwKTsgLy8gMmJpdFxuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcblxuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgLy8gR2xvYmFsIENvbG9yIE1hcFxuXG4gICAgICAgICAgLy8gYmxhY2tcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgweDAwKTtcblxuICAgICAgICAgIC8vIHdoaXRlXG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDB4ZmYpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGUoMHhmZik7XG5cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIC8vIEltYWdlIERlc2NyaXB0b3JcblxuICAgICAgICAgIG91dC53cml0ZVN0cmluZygnLCcpO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgICAgIG91dC53cml0ZVNob3J0KF93aWR0aCk7XG4gICAgICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgwKTtcblxuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgLy8gTG9jYWwgQ29sb3IgTWFwXG5cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIC8vIFJhc3RlciBEYXRhXG5cbiAgICAgICAgICB2YXIgbHp3TWluQ29kZVNpemUgPSAyO1xuICAgICAgICAgIHZhciByYXN0ZXIgPSBnZXRMWldSYXN0ZXIobHp3TWluQ29kZVNpemUpO1xuXG4gICAgICAgICAgb3V0LndyaXRlQnl0ZShsendNaW5Db2RlU2l6ZSk7XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgIHdoaWxlIChyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0ID4gMjU1KSB7XG4gICAgICAgICAgICBvdXQud3JpdGVCeXRlKDI1NSk7XG4gICAgICAgICAgICBvdXQud3JpdGVCeXRlcyhyYXN0ZXIsIG9mZnNldCwgMjU1KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyNTU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0LndyaXRlQnl0ZShyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICBvdXQud3JpdGVCeXRlcyhyYXN0ZXIsIG9mZnNldCwgcmFzdGVyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgweDAwKTtcblxuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgLy8gR0lGIFRlcm1pbmF0b3JcbiAgICAgICAgICBvdXQud3JpdGVTdHJpbmcoJzsnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYml0T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24ob3V0KSB7XG5cbiAgICAgICAgICB2YXIgX291dCA9IG91dDtcbiAgICAgICAgICB2YXIgX2JpdExlbmd0aCA9IDA7XG4gICAgICAgICAgdmFyIF9iaXRCdWZmZXIgPSAwO1xuXG4gICAgICAgICAgdmFyIF90aGlzID0ge307XG5cbiAgICAgICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIChkYXRhID4+PiBsZW5ndGgpICE9IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb3ZlcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoX2JpdExlbmd0aCArIGxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICAgIF9vdXQud3JpdGVCeXRlKDB4ZmYgJiAoIChkYXRhIDw8IF9iaXRMZW5ndGgpIHwgX2JpdEJ1ZmZlcikgKTtcbiAgICAgICAgICAgICAgbGVuZ3RoIC09ICg4IC0gX2JpdExlbmd0aCk7XG4gICAgICAgICAgICAgIGRhdGEgPj4+PSAoOCAtIF9iaXRMZW5ndGgpO1xuICAgICAgICAgICAgICBfYml0QnVmZmVyID0gMDtcbiAgICAgICAgICAgICAgX2JpdExlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9iaXRCdWZmZXIgPSAoZGF0YSA8PCBfYml0TGVuZ3RoKSB8IF9iaXRCdWZmZXI7XG4gICAgICAgICAgICBfYml0TGVuZ3RoID0gX2JpdExlbmd0aCArIGxlbmd0aDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfYml0TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBfb3V0LndyaXRlQnl0ZShfYml0QnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRMWldSYXN0ZXIgPSBmdW5jdGlvbihsendNaW5Db2RlU2l6ZSkge1xuXG4gICAgICAgICAgdmFyIGNsZWFyQ29kZSA9IDEgPDwgbHp3TWluQ29kZVNpemU7XG4gICAgICAgICAgdmFyIGVuZENvZGUgPSAoMSA8PCBsendNaW5Db2RlU2l6ZSkgKyAxO1xuICAgICAgICAgIHZhciBiaXRMZW5ndGggPSBsendNaW5Db2RlU2l6ZSArIDE7XG5cbiAgICAgICAgICAvLyBTZXR1cCBMWldUYWJsZVxuICAgICAgICAgIHZhciB0YWJsZSA9IGx6d1RhYmxlKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsZWFyQ29kZTsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShjbGVhckNvZGUpICk7XG4gICAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kQ29kZSkgKTtcblxuICAgICAgICAgIHZhciBieXRlT3V0ID0gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgICAgICAgdmFyIGJpdE91dCA9IGJpdE91dHB1dFN0cmVhbShieXRlT3V0KTtcblxuICAgICAgICAgIC8vIGNsZWFyIGNvZGVcbiAgICAgICAgICBiaXRPdXQud3JpdGUoY2xlYXJDb2RlLCBiaXRMZW5ndGgpO1xuXG4gICAgICAgICAgdmFyIGRhdGFJbmRleCA9IDA7XG5cbiAgICAgICAgICB2YXIgcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2RhdGFbZGF0YUluZGV4XSk7XG4gICAgICAgICAgZGF0YUluZGV4ICs9IDE7XG5cbiAgICAgICAgICB3aGlsZSAoZGF0YUluZGV4IDwgX2RhdGEubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcbiAgICAgICAgICAgIGRhdGFJbmRleCArPSAxO1xuXG4gICAgICAgICAgICBpZiAodGFibGUuY29udGFpbnMocyArIGMpICkge1xuXG4gICAgICAgICAgICAgIHMgPSBzICsgYztcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzKSwgYml0TGVuZ3RoKTtcblxuICAgICAgICAgICAgICBpZiAodGFibGUuc2l6ZSgpIDwgMHhmZmYpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0YWJsZS5zaXplKCkgPT0gKDEgPDwgYml0TGVuZ3RoKSApIHtcbiAgICAgICAgICAgICAgICAgIGJpdExlbmd0aCArPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhYmxlLmFkZChzICsgYyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzKSwgYml0TGVuZ3RoKTtcblxuICAgICAgICAgIC8vIGVuZCBjb2RlXG4gICAgICAgICAgYml0T3V0LndyaXRlKGVuZENvZGUsIGJpdExlbmd0aCk7XG5cbiAgICAgICAgICBiaXRPdXQuZmx1c2goKTtcblxuICAgICAgICAgIHJldHVybiBieXRlT3V0LnRvQnl0ZUFycmF5KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGx6d1RhYmxlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgX21hcCA9IHt9O1xuICAgICAgICAgIHZhciBfc2l6ZSA9IDA7XG5cbiAgICAgICAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgICAgICAgIF90aGlzLmFkZCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRhaW5zKGtleSkgKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHVwIGtleTonICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9tYXBba2V5XSA9IF9zaXplO1xuICAgICAgICAgICAgX3NpemUgKz0gMTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5pbmRleE9mID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX21hcFtrZXldO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpcy5jb250YWlucyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBfbWFwW2tleV0gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY3JlYXRlSW1nVGFnID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgZ2V0UGl4ZWwsIGFsdCkge1xuXG4gICAgICAgIHZhciBnaWYgPSBnaWZJbWFnZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gMSkge1xuICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHggKz0gMSkge1xuICAgICAgICAgICAgZ2lmLnNldFBpeGVsKHgsIHksIGdldFBpeGVsKHgsIHkpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgZ2lmLndyaXRlKGIpO1xuXG4gICAgICAgIHZhciBiYXNlNjQgPSBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gYi50b0J5dGVBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgYmFzZTY0LndyaXRlQnl0ZShieXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZTY0LmZsdXNoKCk7XG5cbiAgICAgICAgdmFyIGltZyA9ICcnO1xuICAgICAgICBpbWcgKz0gJzxpbWcnO1xuICAgICAgICBpbWcgKz0gJ1xcdTAwMjBzcmM9XCInO1xuICAgICAgICBpbWcgKz0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCwnO1xuICAgICAgICBpbWcgKz0gYmFzZTY0O1xuICAgICAgICBpbWcgKz0gJ1wiJztcbiAgICAgICAgaW1nICs9ICdcXHUwMDIwd2lkdGg9XCInO1xuICAgICAgICBpbWcgKz0gd2lkdGg7XG4gICAgICAgIGltZyArPSAnXCInO1xuICAgICAgICBpbWcgKz0gJ1xcdTAwMjBoZWlnaHQ9XCInO1xuICAgICAgICBpbWcgKz0gaGVpZ2h0O1xuICAgICAgICBpbWcgKz0gJ1wiJztcbiAgICAgICAgaWYgKGFsdCkge1xuICAgICAgICAgIGltZyArPSAnXFx1MDAyMGFsdD1cIic7XG4gICAgICAgICAgaW1nICs9IGFsdDtcbiAgICAgICAgICBpbWcgKz0gJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBpbWcgKz0gJy8+JztcblxuICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgfTtcblxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIHJldHVybnMgcXJjb2RlIGZ1bmN0aW9uLlxuXG4gICAgICByZXR1cm4gcXJjb2RlO1xuICAgIH0oKTtcblxuICAgIChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgfVxuICAgIH0oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcXJjb2RlO1xuICAgIH0pKTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gUVIgQ29kZSBHZW5lcmF0b3IgZm9yIEphdmFTY3JpcHQgVVRGOCBTdXBwb3J0IChvcHRpb25hbClcbiAgICAvL1xuICAgIC8vIENvcHlyaWdodCAoYykgMjAxMSBLYXp1aGlrbyBBcmFzZVxuICAgIC8vXG4gICAgLy8gVVJMOiBodHRwOi8vd3d3LmQtcHJvamVjdC5jb20vXG4gICAgLy9cbiAgICAvLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gICAgLy8gIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gICAgLy9cbiAgICAvLyBUaGUgd29yZCAnUVIgQ29kZScgaXMgcmVnaXN0ZXJlZCB0cmFkZW1hcmsgb2ZcbiAgICAvLyBERU5TTyBXQVZFIElOQ09SUE9SQVRFRFxuICAgIC8vICBodHRwOi8vd3d3LmRlbnNvLXdhdmUuY29tL3FyY29kZS9mYXFwYXRlbnQtZS5odG1sXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgIWZ1bmN0aW9uKHFyY29kZSkge1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gb3ZlcndyaXRlIHFyY29kZS5zdHJpbmdUb0J5dGVzXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBxcmNvZGUuc3RyaW5nVG9CeXRlcyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG4gICAgICAgIGZ1bmN0aW9uIHRvVVRGOEFycmF5KHN0cikge1xuICAgICAgICAgIHZhciB1dGY4ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLFxuICAgICAgICAgICAgICAgICAgMHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgICB1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgLy8gVVRGLTE2IGVuY29kZXMgMHgxMDAwMC0weDEwRkZGRiBieVxuICAgICAgICAgICAgICAvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG4gICAgICAgICAgICAgIC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG4gICAgICAgICAgICAgIGNoYXJjb2RlID0gMHgxMDAwMCArICgoKGNoYXJjb2RlICYgMHgzZmYpPDwxMClcbiAgICAgICAgICAgICAgICB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICAgIHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdXRmODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9VVEY4QXJyYXkocyk7XG4gICAgICB9O1xuXG4gICAgfShxcmNvZGUpO1xuXG4gICAgcmV0dXJuIHFyY29kZTtcbn0oKSkpO1xuIiwiLyohIEpTT04gdjMuMi42IHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTMsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAod2luZG93KSB7XG4gIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gIHZhciBnZXRDbGFzcyA9IHt9LnRvU3RyaW5nLCBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gRGV0ZWN0IG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBuYXRpdmVKU09OID0gdHlwZW9mIEpTT04gPT0gXCJvYmplY3RcIiAmJiBKU09OO1xuXG4gIC8vIFNldCB1cCB0aGUgSlNPTiAzIG5hbWVzcGFjZSwgcHJlZmVycmluZyB0aGUgQ29tbW9uSlMgYGV4cG9ydHNgIG9iamVjdCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIHZhciBKU09OMyA9IHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIGlmIChKU09OMyAmJiBuYXRpdmVKU09OKSB7XG4gICAgLy8gRXhwbGljaXRseSBkZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGluIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBKU09OMy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OMy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMsIEphdmFTY3JpcHQgZW5naW5lcywgYW5kIGFzeW5jaHJvbm91cyBtb2R1bGVcbiAgICAvLyBsb2FkZXJzLCB1c2luZyB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgaWYgYXZhaWxhYmxlLlxuICAgIEpTT04zID0gd2luZG93LkpTT04gPSBuYXRpdmVKU09OIHx8IHt9O1xuICB9XG5cbiAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgdHJ5IHtcbiAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgIHZhciBzdHJpbmdpZnkgPSBKU09OMy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgIHZhciBwYXJzZSA9IEpTT04zLnBhcnNlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIGlmICghaGFzKFwianNvblwiKSkge1xuICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG4gICAgdmFyIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiO1xuICAgIHZhciBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCI7XG4gICAgdmFyIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbiAgICB2YXIgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB2YXIgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICBpZiAoIShpc1Byb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbDogQSBzZXQgb2YgcHJpbWl0aXZlIHR5cGVzIHVzZWQgYnkgYGlzSG9zdFR5cGVgLlxuICAgIHZhciBQcmltaXRpdmVUeXBlcyA9IHtcbiAgICAgICdib29sZWFuJzogMSxcbiAgICAgICdudW1iZXInOiAxLFxuICAgICAgJ3N0cmluZyc6IDEsXG4gICAgICAndW5kZWZpbmVkJzogMVxuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGBwcm9wZXJ0eWAgdmFsdWUgaXMgYVxuICAgIC8vIG5vbi1wcmltaXRpdmUuXG4gICAgdmFyIGlzSG9zdFR5cGUgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnID8gISFvYmplY3RbcHJvcGVydHldIDogIVByaW1pdGl2ZVR5cGVzW3R5cGVdO1xuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBzaXplKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSAnZnVuY3Rpb24nICYmIGlzSG9zdFR5cGUob2JqZWN0LCAnaGFzT3duUHJvcGVydHknKSA/IG9iamVjdC5oYXNPd25Qcm9wZXJ0eSA6IGlzUHJvcGVydHk7XG4gICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIGlzTGFyZ2UgPSBsZW5ndGggPiAxMCAmJiBjaGFySW5kZXhCdWdneSwgc3ltYm9scztcbiAgICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgICBzeW1ib2xzID0gdmFsdWUuc3BsaXQoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGlzTGFyZ2UgPyBzeW1ib2xzW2luZGV4XSA6IGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KGluZGV4KSA6IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgSlNPTjMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBmaWx0ZXIgPT0gXCJvYmplY3RcIiAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgSlNPTjMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSh0aGlzKSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IG5vb3AsXG4gIGhyOiAvXiggKlstKl9dKXszLH0gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgbnB0YWJsZTogbm9vcCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuICooPXwtKXsyLH0gKig/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rKFxcbig/IWRlZilbXlxcbl0rKSpcXG4qKSsvLFxuICBsaXN0OiAvXiggKikoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gIGh0bWw6IC9eICooPzpjb21tZW50ICooPzpcXG58XFxzKiQpfGNsb3NlZCAqKD86XFxuezIsfXxcXHMqJCl8Y2xvc2luZyAqKD86XFxuezIsfXxcXHMqJCkpLyxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wLFxuICBwYXJhZ3JhcGg6IC9eKCg/OlteXFxuXStcXG4/KD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfHRhZ3xkZWYpKSspXFxuKi8sXG4gIHRleHQ6IC9eW15cXG5dKy9cbn07XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGQrXFwuKS87XG5ibG9jay5pdGVtID0gL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IHJlcGxhY2UoYmxvY2suaXRlbSwgJ2dtJylcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCk7XG5cbmJsb2NrLmxpc3QgPSByZXBsYWNlKGJsb2NrLmxpc3QpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86Wy0qX10gKil7Myx9KD86XFxcXG4rfCQpKScpXG4gICgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IHJlcGxhY2UoYmxvY2suYmxvY2txdW90ZSlcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG5ibG9jay5fdGFnID0gJyg/ISg/OidcbiAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGUnXG4gICsgJ3x2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkbydcbiAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfFteXFxcXHdcXFxcc0BdKkApXFxcXGInO1xuXG5ibG9jay5odG1sID0gcmVwbGFjZShibG9jay5odG1sKVxuICAoJ2NvbW1lbnQnLCAvPCEtLVtcXHNcXFNdKj8tLT4vKVxuICAoJ2Nsb3NlZCcsIC88KHRhZylbXFxzXFxTXSs/PFxcL1xcMT4vKVxuICAoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8pXG4gICgvdGFnL2csIGJsb2NrLl90YWcpXG4gICgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCdocicsIGJsb2NrLmhyKVxuICAoJ2hlYWRpbmcnLCBibG9jay5oZWFkaW5nKVxuICAoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICgnYmxvY2txdW90ZScsIGJsb2NrLmJsb2NrcXVvdGUpXG4gICgndGFnJywgJzwnICsgYmxvY2suX3RhZylcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gbWVyZ2Uoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KVsgXFwuXSooXFxTKyk/ICpcXG4oW1xcc1xcU10qPylcXHMqXFwxICooPzpcXG4rfCQpLyxcbiAgcGFyYWdyYXBoOiAvXi8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSArKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvXG59KTtcblxuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJyg/IScsICcoPyEnXG4gICAgKyBibG9jay5nZm0uZmVuY2VzLnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMicpICsgJ3wnXG4gICAgKyBibG9jay5saXN0LnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMycpICsgJ3wnKVxuICAoKTtcblxuLyoqXG4gKiBHRk0gKyBUYWJsZXMgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLnRhYmxlcyA9IG1lcmdlKHt9LCBibG9jay5nZm0sIHtcbiAgbnB0YWJsZTogL14gKihcXFMuKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKVxcbigoPzouKlxcfC4qKD86XFxufCQpKSopXFxuKi8sXG4gIHRhYmxlOiAvXiAqXFx8KC4rKVxcbiAqXFx8KCAqWy06XStbLXwgOl0qKVxcbigoPzogKlxcfC4qKD86XFxufCQpKSopXFxuKi9cbn0pO1xuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cblxuZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2Vucy5saW5rcyA9IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5ydWxlcyA9IGJsb2NrLm5vcm1hbDtcblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFibGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2sudGFibGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2suZ2ZtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBCbG9jayBSdWxlc1xuICovXG5cbkxleGVyLnJ1bGVzID0gYmxvY2s7XG5cbi8qKlxuICogU3RhdGljIExleCBNZXRob2RcbiAqL1xuXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG59O1xuXG4vKipcbiAqIFByZXByb2Nlc3NpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHNyYyA9IHNyY1xuICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b3AsIGJxKSB7XG4gIHZhciBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpXG4gICAgLCBuZXh0XG4gICAgLCBsb29zZVxuICAgICwgY2FwXG4gICAgLCBidWxsXG4gICAgLCBiXG4gICAgLCBpdGVtXG4gICAgLCBzcGFjZVxuICAgICwgaVxuICAgICwgbDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gbmV3bGluZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLm5ld2xpbmUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdzcGFjZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBjYXAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICA6IGNhcFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXMgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5mZW5jZXMuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgbGFuZzogY2FwWzJdLFxuICAgICAgICB0ZXh0OiBjYXBbM10gfHwgJydcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IGNhcFsyXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLm5wdGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV0uc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdocidcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYmxvY2txdW90ZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrcXVvdGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfc3RhcnQnXG4gICAgICB9KTtcblxuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICAvLyBQYXNzIGB0b3BgIHRvIGtlZXAgdGhlIGN1cnJlbnRcbiAgICAgIC8vIFwidG9wbGV2ZWxcIiBzdGF0ZS4gVGhpcyBpcyBleGFjdGx5XG4gICAgICAvLyBob3cgbWFya2Rvd24ucGwgd29ya3MuXG4gICAgICB0aGlzLnRva2VuKGNhcCwgdG9wLCB0cnVlKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaXN0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGlzdC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBidWxsID0gY2FwWzJdO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBidWxsLmxlbmd0aCA+IDFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbS5cbiAgICAgIGNhcCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLml0ZW0pO1xuXG4gICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICBsID0gY2FwLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVtID0gY2FwW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG4gICAgICAgIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrXFwuKSArLywgJycpO1xuXG4gICAgICAgIC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICBzcGFjZSAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgYiA9IGJsb2NrLmJ1bGxldC5leGVjKGNhcFtpICsgMV0pWzBdO1xuICAgICAgICAgIGlmIChidWxsICE9PSBiICYmICEoYnVsbC5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICAgIHNyYyA9IGNhcC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgIC8vIGZvciBkaXNjb3VudCBiZWhhdmlvci5cbiAgICAgICAgbG9vc2UgPSBuZXh0IHx8IC9cXG5cXG4oPyFcXHMqJCkvLnRlc3QoaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgIG5leHQgPSBpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSAnXFxuJztcbiAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBsb29zZVxuICAgICAgICAgICAgPyAnbG9vc2VfaXRlbV9zdGFydCdcbiAgICAgICAgICAgIDogJ2xpc3RfaXRlbV9zdGFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgdGhpcy50b2tlbihpdGVtLCBmYWxzZSwgYnEpO1xuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fZW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBodG1sXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHRtbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgICAgPyAncGFyYWdyYXBoJ1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgJiYgKGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScpLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVmXG4gICAgaWYgKCghYnEgJiYgdG9wKSAmJiAoY2FwID0gdGhpcy5ydWxlcy5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLmxpbmtzW2NhcFsxXS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoLyg/OiAqXFx8ICopP1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldXG4gICAgICAgICAgLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKVxuICAgICAgICAgIC5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgOiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbXFxcXGAqe31cXFtcXF0oKSMrXFwtLiFfPl0pLyxcbiAgYXV0b2xpbms6IC9ePChbXiA+XSsoQHw6XFwvKVteID5dKyk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sXG4gIGxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxcKGhyZWZcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKCg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXlxcYl8oKD86W15fXXxfXykrPylfXFxifF5cXCooKD86XFwqXFwqfFtcXHNcXFNdKSs/KVxcKig/IVxcKikvLFxuICBjb2RlOiAvXihgKylcXHMqKFtcXHNcXFNdKj9bXmBdKVxccypcXDEoPyFgKS8sXG4gIGJyOiAvXiB7Mix9XFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wLFxuICB0ZXh0OiAvXltcXHNcXFNdKz8oPz1bXFxcXDwhXFxbXypgXXwgezIsfVxcbnwkKS9cbn07XG5cbmlubGluZS5faW5zaWRlID0gLyg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dfFxcXSg/PVteXFxbXSpcXF0pKSovO1xuaW5saW5lLl9ocmVmID0gL1xccyo8PyhbXFxzXFxTXSo/KT4/KD86XFxzK1snXCJdKFtcXHNcXFNdKj8pWydcIl0pP1xccyovO1xuXG5pbmxpbmUubGluayA9IHJlcGxhY2UoaW5saW5lLmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgnaHJlZicsIGlubGluZS5faHJlZilcbiAgKCk7XG5cbmlubGluZS5yZWZsaW5rID0gcmVwbGFjZShpbmxpbmUucmVmbGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLm5vcm1hbCA9IG1lcmdlKHt9LCBpbmxpbmUpO1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgc3Ryb25nOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXyl8XlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopL1xufSk7XG5cbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmdmbSA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIGVzY2FwZTogcmVwbGFjZShpbmxpbmUuZXNjYXBlKSgnXSknLCAnfnxdKScpKCksXG4gIHVybDogL14oaHR0cHM/OlxcL1xcL1teXFxzPF0rW148Liw6O1wiJylcXF1cXHNdKS8sXG4gIGRlbDogL15+fig/PVxcUykoW1xcc1xcU10qP1xcUyl+fi8sXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLnRleHQpXG4gICAgKCddfCcsICd+XXwnKVxuICAgICgnfCcsICd8aHR0cHM/Oi8vfCcpXG4gICAgKClcbn0pO1xuXG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IG1lcmdlKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gIGJyOiByZXBsYWNlKGlubGluZS5icikoJ3syLH0nLCAnKicpKCksXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLmdmbS50ZXh0KSgnezIsfScsICcqJykoKVxufSk7XG5cbi8qKlxuICogSW5saW5lIExleGVyICYgQ29tcGlsZXJcbiAqL1xuXG5mdW5jdGlvbiBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5saW5rcyA9IGxpbmtzO1xuICB0aGlzLnJ1bGVzID0gaW5saW5lLm5vcm1hbDtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBpZiAoIXRoaXMubGlua3MpIHtcbiAgICB0aHJvdyBuZXdcbiAgICAgIEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5icmVha3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuZ2ZtO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICB0aGlzLnJ1bGVzID0gaW5saW5lLnBlZGFudGljO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIElubGluZSBSdWxlc1xuICovXG5cbklubGluZUxleGVyLnJ1bGVzID0gaW5saW5lO1xuXG4vKipcbiAqIFN0YXRpYyBMZXhpbmcvQ29tcGlsaW5nIE1ldGhvZFxuICovXG5cbklubGluZUxleGVyLm91dHB1dCA9IGZ1bmN0aW9uKHNyYywgbGlua3MsIG9wdGlvbnMpIHtcbiAgdmFyIGlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucyk7XG4gIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbGlua1xuICAgICwgdGV4dFxuICAgICwgaHJlZlxuICAgICwgY2FwO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBlc2NhcGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lc2NhcGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGNhcFsxXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGF1dG9saW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYXV0b2xpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBjYXBbMV0uY2hhckF0KDYpID09PSAnOidcbiAgICAgICAgICA/IHRoaXMubWFuZ2xlKGNhcFsxXS5zdWJzdHJpbmcoNykpXG4gICAgICAgICAgOiB0aGlzLm1hbmdsZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGhpcy5tYW5nbGUoJ21haWx0bzonKSArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHVybCAoZ2ZtKVxuICAgIGlmICghdGhpcy5pbkxpbmsgJiYgKGNhcCA9IHRoaXMucnVsZXMudXJsLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICBocmVmID0gdGV4dDtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50YWcuZXhlYyhzcmMpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLCB0cnVlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBiclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWwgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5kZWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZGVsKHRoaXMub3V0cHV0KGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGV4dChlc2NhcGUodGhpcy5zbWFydHlwYW50cyhjYXBbMF0pKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb21waWxlIExpbmtcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0TGluayA9IGZ1bmN0aW9uKGNhcCwgbGluaykge1xuICB2YXIgaHJlZiA9IGVzY2FwZShsaW5rLmhyZWYpXG4gICAgLCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuXG4gIHJldHVybiBjYXBbMF0uY2hhckF0KDApICE9PSAnISdcbiAgICA/IHRoaXMucmVuZGVyZXIubGluayhocmVmLCB0aXRsZSwgdGhpcy5vdXRwdXQoY2FwWzFdKSlcbiAgICA6IHRoaXMucmVuZGVyZXIuaW1hZ2UoaHJlZiwgdGl0bGUsIGVzY2FwZShjYXBbMV0pKTtcbn07XG5cbi8qKlxuICogU21hcnR5cGFudHMgVHJhbnNmb3JtYXRpb25zXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLnNtYXJ0eXBhbnRzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zbWFydHlwYW50cykgcmV0dXJuIHRleHQ7XG4gIHJldHVybiB0ZXh0XG4gICAgLy8gZW0tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tLS9nLCAnXFx1MjAxNCcpXG4gICAgLy8gZW4tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tL2csICdcXHUyMDEzJylcbiAgICAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgJyQxXFx1MjAxOCcpXG4gICAgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAucmVwbGFjZSgvJy9nLCAnXFx1MjAxOScpXG4gICAgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csICckMVxcdTIwMWMnKVxuICAgIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MjAxZCcpXG4gICAgLy8gZWxsaXBzZXNcbiAgICAucmVwbGFjZSgvXFwuezN9L2csICdcXHUyMDI2Jyk7XG59O1xuXG4vKipcbiAqIE1hbmdsZSBMaW5rc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5tYW5nbGUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLm1hbmdsZSkgcmV0dXJuIHRleHQ7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbCA9IHRleHQubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgY2g7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbihjb2RlLCBsYW5nLCBlc2NhcGVkKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGFuZykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJ1xcbjwvY29kZT48L3ByZT4nO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICsgJ1wiPidcbiAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICArICdcXG48L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ibG9ja3F1b3RlID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uKHRleHQsIGxldmVsLCByYXcpIHtcbiAgcmV0dXJuICc8aCdcbiAgICArIGxldmVsXG4gICAgKyAnIGlkPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeFxuICAgICsgcmF3LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15cXHddKy9nLCAnLScpXG4gICAgKyAnXCI+J1xuICAgICsgdGV4dFxuICAgICsgJzwvaCdcbiAgICArIGxldmVsXG4gICAgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGJvZHksIG9yZGVyZWQpIHtcbiAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gIHJldHVybiAnPCcgKyB0eXBlICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24oaGVhZGVyLCBib2R5KSB7XG4gIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICArICc8dGhlYWQ+XFxuJ1xuICAgICsgaGVhZGVyXG4gICAgKyAnPC90aGVhZD5cXG4nXG4gICAgKyAnPHRib2R5PlxcbidcbiAgICArIGJvZHlcbiAgICArICc8L3Rib2R5PlxcbidcbiAgICArICc8L3RhYmxlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVyb3cgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZWNlbGwgPSBmdW5jdGlvbihjb250ZW50LCBmbGFncykge1xuICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICB2YXIgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICA/ICc8JyArIHR5cGUgKyAnIHN0eWxlPVwidGV4dC1hbGlnbjonICsgZmxhZ3MuYWxpZ24gKyAnXCI+J1xuICAgIDogJzwnICsgdHlwZSArICc+JztcbiAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cbi8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcblJlbmRlcmVyLnByb3RvdHlwZS5zdHJvbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZXNwYW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYnIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3Ol0vZywgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG4gIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0O1xufTtcblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucywgcmVuZGVyZXIpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucywgcmVuZGVyZXIpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zLCB0aGlzLnJlbmRlcmVyKTtcbiAgdGhpcy50b2tlbnMgPSBzcmMucmV2ZXJzZSgpO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgd2hpbGUgKHRoaXMubmV4dCgpKSB7XG4gICAgb3V0ICs9IHRoaXMudG9rKCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcblxuICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYm9keSArPSAnXFxuJyArIHRoaXMubmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS50b2sgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2FzZSAnaHInOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgIH1cbiAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCksXG4gICAgICAgIHRoaXMudG9rZW4uZGVwdGgsXG4gICAgICAgIHRoaXMudG9rZW4udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb2RlKHRoaXMudG9rZW4udGV4dCxcbiAgICAgICAgdGhpcy50b2tlbi5sYW5nLFxuICAgICAgICB0aGlzLnRva2VuLmVzY2FwZWQpO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBoZWFkZXIgPSAnJ1xuICAgICAgICAsIGJvZHkgPSAnJ1xuICAgICAgICAsIGlcbiAgICAgICAgLCByb3dcbiAgICAgICAgLCBjZWxsXG4gICAgICAgICwgZmxhZ3NcbiAgICAgICAgLCBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGNlbGwgPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9O1xuICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKSxcbiAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25bal0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdibG9ja3F1b3RlX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJ1xuICAgICAgICAsIG9yZGVyZWQgPSB0aGlzLnRva2VuLm9yZGVyZWQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkKTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rZW4udHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgPyB0aGlzLnBhcnNlVGV4dCgpXG4gICAgICAgICAgOiB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbG9vc2VfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHZhciBodG1sID0gIXRoaXMudG9rZW4ucHJlICYmICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgPyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICA6IHRoaXMudG9rZW4udGV4dDtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmh0bWwoaHRtbCk7XG4gICAgfVxuICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZVRleHQoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIHJldHVybiBodG1sXG4gICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvJihbI1xcd10rKTsvZywgZnVuY3Rpb24oXywgbikge1xuICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG4gICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgb3B0KSB7XG4gIHJlZ2V4ID0gcmVnZXguc291cmNlO1xuICBvcHQgPSBvcHQgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmKG5hbWUsIHZhbCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLyhefFteXFxbXSlcXF4vZywgJyQxJyk7XG4gICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxubm9vcC5leGVjID0gbm9vcDtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gIHZhciBpID0gMVxuICAgICwgdGFyZ2V0XG4gICAgLCBrZXk7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBNYXJrZWRcbiAqL1xuXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayB8fCB0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG5cbiAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodFxuICAgICAgLCB0b2tlbnNcbiAgICAgICwgcGVuZGluZ1xuICAgICAgLCBpID0gMDtcblxuICAgIHRyeSB7XG4gICAgICB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSh0b2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHQpIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShMZXhlci5sZXgoc3JjLCBvcHQpLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkLic7XG4gICAgaWYgKChvcHQgfHwgbWFya2VkLmRlZmF1bHRzKS5zaWxlbnQpIHtcbiAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJlZDo8L3A+PHByZT4nXG4gICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICArICc8L3ByZT4nO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG5cbm1hcmtlZC5vcHRpb25zID1cbm1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XG4gIG1lcmdlKG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgcmV0dXJuIG1hcmtlZDtcbn07XG5cbm1hcmtlZC5kZWZhdWx0cyA9IHtcbiAgZ2ZtOiB0cnVlLFxuICB0YWJsZXM6IHRydWUsXG4gIGJyZWFrczogZmFsc2UsXG4gIHBlZGFudGljOiBmYWxzZSxcbiAgc2FuaXRpemU6IGZhbHNlLFxuICBzYW5pdGl6ZXI6IG51bGwsXG4gIG1hbmdsZTogdHJ1ZSxcbiAgc21hcnRMaXN0czogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG4gIGhpZ2hsaWdodDogbnVsbCxcbiAgbGFuZ1ByZWZpeDogJ2xhbmctJyxcbiAgc21hcnR5cGFudHM6IGZhbHNlLFxuICBoZWFkZXJQcmVmaXg6ICcnLFxuICByZW5kZXJlcjogbmV3IFJlbmRlcmVyLFxuICB4aHRtbDogZmFsc2Vcbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5cbm1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyO1xuXG5tYXJrZWQuTGV4ZXIgPSBMZXhlcjtcbm1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcblxubWFya2VkLklubGluZUxleGVyID0gSW5saW5lTGV4ZXI7XG5tYXJrZWQuaW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlci5vdXRwdXQ7XG5cbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IG1hcmtlZDtcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIG1hcmtlZDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLm1hcmtlZCA9IG1hcmtlZDtcbn1cblxufSkuY2FsbChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKTtcbn0oKSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OXRZWEpyWldRdmJHbGlMMjFoY210bFpDNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeW9xWEc0Z0tpQnRZWEpyWldRZ0xTQmhJRzFoY210a2IzZHVJSEJoY25ObGNseHVJQ29nUTI5d2VYSnBaMmgwSUNoaktTQXlNREV4TFRJd01UUXNJRU5vY21semRHOXdhR1Z5SUVwbFptWnlaWGt1SUNoTlNWUWdUR2xqWlc1elpXUXBYRzRnS2lCb2RIUndjem92TDJkcGRHaDFZaTVqYjIwdlkyaHFhaTl0WVhKclpXUmNiaUFxTDF4dVhHNDdLR1oxYm1OMGFXOXVLQ2tnZTF4dVhHNHZLaXBjYmlBcUlFSnNiMk5yTFV4bGRtVnNJRWR5WVcxdFlYSmNiaUFxTDF4dVhHNTJZWElnWW14dlkyc2dQU0I3WEc0Z0lHNWxkMnhwYm1VNklDOWVYRnh1S3k4c1hHNGdJR052WkdVNklDOWVLQ0I3TkgxYlhseGNibDByWEZ4dUtpa3JMeXhjYmlBZ1ptVnVZMlZ6T2lCdWIyOXdMRnh1SUNCb2Nqb2dMMTRvSUNwYkxTcGZYU2w3TXl4OUlDb29QenBjWEc0cmZDUXBMeXhjYmlBZ2FHVmhaR2x1WnpvZ0wxNGdLaWdqZXpFc05uMHBJQ29vVzE1Y1hHNWRLejhwSUNvaktpQXFLRDg2WEZ4dUszd2tLUzhzWEc0Z0lHNXdkR0ZpYkdVNklHNXZiM0FzWEc0Z0lHeG9aV0ZrYVc1bk9pQXZYaWhiWGx4Y2JsMHJLVnhjYmlBcUtEMThMU2w3TWl4OUlDb29QenBjWEc0cmZDUXBMeXhjYmlBZ1lteHZZMnR4ZFc5MFpUb2dMMTRvSUNvK1cxNWNYRzVkS3loY1hHNG9QeUZrWldZcFcxNWNYRzVkS3lrcVhGeHVLaWtyTHl4Y2JpQWdiR2x6ZERvZ0wxNG9JQ29wS0dKMWJHd3BJRnRjWEhOY1hGTmRLejhvUHpwb2NueGtaV1o4WEZ4dWV6SXNmU2cvSVNBcEtEOGhYRnd4WW5Wc2JDQXBYRnh1S254Y1hITXFKQ2t2TEZ4dUlDQm9kRzFzT2lBdlhpQXFLRDg2WTI5dGJXVnVkQ0FxS0Q4NlhGeHVmRnhjY3lva0tYeGpiRzl6WldRZ0tpZy9PbHhjYm5zeUxIMThYRnh6S2lRcGZHTnNiM05wYm1jZ0tpZy9PbHhjYm5zeUxIMThYRnh6S2lRcEtTOHNYRzRnSUdSbFpqb2dMMTRnS2x4Y1d5aGJYbHhjWFYwcktWeGNYVG9nS2p3L0tGdGVYRnh6UGwwcktUNC9LRDg2SUN0YlhDSW9YU2hiWGx4Y2JsMHJLVnRjSWlsZEtUOGdLaWcvT2x4Y2JpdDhKQ2t2TEZ4dUlDQjBZV0pzWlRvZ2JtOXZjQ3hjYmlBZ2NHRnlZV2R5WVhCb09pQXZYaWdvUHpwYlhseGNibDByWEZ4dVB5Zy9JV2h5ZkdobFlXUnBibWQ4YkdobFlXUnBibWQ4WW14dlkydHhkVzkwWlh4MFlXZDhaR1ZtS1NrcktWeGNiaW92TEZ4dUlDQjBaWGgwT2lBdlhsdGVYRnh1WFNzdlhHNTlPMXh1WEc1aWJHOWpheTVpZFd4c1pYUWdQU0F2S0Q4Nld5b3JMVjE4WEZ4a0sxeGNMaWt2TzF4dVlteHZZMnN1YVhSbGJTQTlJQzllS0NBcUtTaGlkV3hzS1NCYlhseGNibDBxS0Q4NlhGeHVLRDhoWEZ3eFluVnNiQ0FwVzE1Y1hHNWRLaWtxTHp0Y2JtSnNiMk5yTG1sMFpXMGdQU0J5WlhCc1lXTmxLR0pzYjJOckxtbDBaVzBzSUNkbmJTY3BYRzRnSUNndlluVnNiQzluTENCaWJHOWpheTVpZFd4c1pYUXBYRzRnSUNncE8xeHVYRzVpYkc5amF5NXNhWE4wSUQwZ2NtVndiR0ZqWlNoaWJHOWpheTVzYVhOMEtWeHVJQ0FvTDJKMWJHd3ZaeXdnWW14dlkyc3VZblZzYkdWMEtWeHVJQ0FvSjJoeUp5d2dKMXhjWEZ4dUt5Zy9QVnhjWEZ3eFB5Zy9PbHN0S2w5ZElDb3Blek1zZlNnL09seGNYRnh1SzN3a0tTa25LVnh1SUNBb0oyUmxaaWNzSUNkY1hGeGNiaXNvUHowbklDc2dZbXh2WTJzdVpHVm1Mbk52ZFhKalpTQXJJQ2NwSnlsY2JpQWdLQ2s3WEc1Y2JtSnNiMk5yTG1Kc2IyTnJjWFZ2ZEdVZ1BTQnlaWEJzWVdObEtHSnNiMk5yTG1Kc2IyTnJjWFZ2ZEdVcFhHNGdJQ2duWkdWbUp5d2dZbXh2WTJzdVpHVm1LVnh1SUNBb0tUdGNibHh1WW14dlkyc3VYM1JoWnlBOUlDY29QeUVvUHpvblhHNGdJQ3NnSjJGOFpXMThjM1J5YjI1bmZITnRZV3hzZkhOOFkybDBaWHh4ZkdSbWJueGhZbUp5ZkdSaGRHRjhkR2x0Wlh4amIyUmxKMXh1SUNBcklDZDhkbUZ5ZkhOaGJYQjhhMkprZkhOMVlueHpkWEI4YVh4aWZIVjhiV0Z5YTN4eWRXSjVmSEowZkhKd2ZHSmthWHhpWkc4blhHNGdJQ3NnSjN4emNHRnVmR0p5ZkhkaWNueHBibk44WkdWc2ZHbHRaeWxjWEZ4Y1lpbGNYRnhjZHlzb1B5RTZMM3hiWGx4Y1hGeDNYRnhjWEhOQVhTcEFLVnhjWEZ4aUp6dGNibHh1WW14dlkyc3VhSFJ0YkNBOUlISmxjR3hoWTJVb1lteHZZMnN1YUhSdGJDbGNiaUFnS0NkamIyMXRaVzUwSnl3Z0x6d2hMUzFiWEZ4elhGeFRYU28vTFMwK0x5bGNiaUFnS0NkamJHOXpaV1FuTENBdlBDaDBZV2NwVzF4Y2MxeGNVMTByUHp4Y1hDOWNYREUrTHlsY2JpQWdLQ2RqYkc5emFXNW5KeXdnTHp4MFlXY29QenBjSWx0ZVhDSmRLbHdpZkNkYlhpZGRLaWQ4VzE0blhDSStYU2txUHo0dktWeHVJQ0FvTDNSaFp5OW5MQ0JpYkc5amF5NWZkR0ZuS1Z4dUlDQW9LVHRjYmx4dVlteHZZMnN1Y0dGeVlXZHlZWEJvSUQwZ2NtVndiR0ZqWlNoaWJHOWpheTV3WVhKaFozSmhjR2dwWEc0Z0lDZ25hSEluTENCaWJHOWpheTVvY2lsY2JpQWdLQ2RvWldGa2FXNW5KeXdnWW14dlkyc3VhR1ZoWkdsdVp5bGNiaUFnS0Nkc2FHVmhaR2x1Wnljc0lHSnNiMk5yTG14b1pXRmthVzVuS1Z4dUlDQW9KMkpzYjJOcmNYVnZkR1VuTENCaWJHOWpheTVpYkc5amEzRjFiM1JsS1Z4dUlDQW9KM1JoWnljc0lDYzhKeUFySUdKc2IyTnJMbDkwWVdjcFhHNGdJQ2duWkdWbUp5d2dZbXh2WTJzdVpHVm1LVnh1SUNBb0tUdGNibHh1THlvcVhHNGdLaUJPYjNKdFlXd2dRbXh2WTJzZ1IzSmhiVzFoY2x4dUlDb3ZYRzVjYm1Kc2IyTnJMbTV2Y20xaGJDQTlJRzFsY21kbEtIdDlMQ0JpYkc5amF5azdYRzVjYmk4cUtseHVJQ29nUjBaTklFSnNiMk5ySUVkeVlXMXRZWEpjYmlBcUwxeHVYRzVpYkc5amF5NW5abTBnUFNCdFpYSm5aU2g3ZlN3Z1lteHZZMnN1Ym05eWJXRnNMQ0I3WEc0Z0lHWmxibU5sY3pvZ0wxNGdLaWhnZXpNc2ZYeCtlek1zZlNsYklGeGNMbDBxS0Z4Y1V5c3BQeUFxWEZ4dUtGdGNYSE5jWEZOZEtqOHBYRnh6S2x4Y01TQXFLRDg2WEZ4dUszd2tLUzhzWEc0Z0lIQmhjbUZuY21Gd2FEb2dMMTR2TEZ4dUlDQm9aV0ZrYVc1bk9pQXZYaUFxS0NON01TdzJmU2tnS3loYlhseGNibDByUHlrZ0tpTXFJQ29vUHpwY1hHNHJmQ1FwTDF4dWZTazdYRzVjYm1Kc2IyTnJMbWRtYlM1d1lYSmhaM0poY0dnZ1BTQnlaWEJzWVdObEtHSnNiMk5yTG5CaGNtRm5jbUZ3YUNsY2JpQWdLQ2NvUHlFbkxDQW5LRDhoSjF4dUlDQWdJQ3NnWW14dlkyc3VaMlp0TG1abGJtTmxjeTV6YjNWeVkyVXVjbVZ3YkdGalpTZ25YRnhjWERFbkxDQW5YRnhjWERJbktTQXJJQ2Q4SjF4dUlDQWdJQ3NnWW14dlkyc3ViR2x6ZEM1emIzVnlZMlV1Y21Wd2JHRmpaU2duWEZ4Y1hERW5MQ0FuWEZ4Y1hETW5LU0FySUNkOEp5bGNiaUFnS0NrN1hHNWNiaThxS2x4dUlDb2dSMFpOSUNzZ1ZHRmliR1Z6SUVKc2IyTnJJRWR5WVcxdFlYSmNiaUFxTDF4dVhHNWliRzlqYXk1MFlXSnNaWE1nUFNCdFpYSm5aU2g3ZlN3Z1lteHZZMnN1WjJadExDQjdYRzRnSUc1d2RHRmliR1U2SUM5ZUlDb29YRnhUTGlwY1hId3VLaWxjWEc0Z0tpaGJMVHBkS3lBcVhGeDhXeTE4SURwZEtpbGNYRzRvS0Q4NkxpcGNYSHd1S2lnL09seGNibndrS1NrcUtWeGNiaW92TEZ4dUlDQjBZV0pzWlRvZ0wxNGdLbHhjZkNndUt5bGNYRzRnS2x4Y2ZDZ2dLbHN0T2wwcld5MThJRHBkS2lsY1hHNG9LRDg2SUNwY1hId3VLaWcvT2x4Y2Jud2tLU2txS1Z4Y2Jpb3ZYRzU5S1R0Y2JseHVMeW9xWEc0Z0tpQkNiRzlqYXlCTVpYaGxjbHh1SUNvdlhHNWNibVoxYm1OMGFXOXVJRXhsZUdWeUtHOXdkR2x2Ym5NcElIdGNiaUFnZEdocGN5NTBiMnRsYm5NZ1BTQmJYVHRjYmlBZ2RHaHBjeTUwYjJ0bGJuTXViR2x1YTNNZ1BTQjdmVHRjYmlBZ2RHaHBjeTV2Y0hScGIyNXpJRDBnYjNCMGFXOXVjeUI4ZkNCdFlYSnJaV1F1WkdWbVlYVnNkSE03WEc0Z0lIUm9hWE11Y25Wc1pYTWdQU0JpYkc5amF5NXViM0p0WVd3N1hHNWNiaUFnYVdZZ0tIUm9hWE11YjNCMGFXOXVjeTVuWm0wcElIdGNiaUFnSUNCcFppQW9kR2hwY3k1dmNIUnBiMjV6TG5SaFlteGxjeWtnZTF4dUlDQWdJQ0FnZEdocGN5NXlkV3hsY3lBOUlHSnNiMk5yTG5SaFlteGxjenRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ2RHaHBjeTV5ZFd4bGN5QTlJR0pzYjJOckxtZG1iVHRjYmlBZ0lDQjlYRzRnSUgxY2JuMWNibHh1THlvcVhHNGdLaUJGZUhCdmMyVWdRbXh2WTJzZ1VuVnNaWE5jYmlBcUwxeHVYRzVNWlhobGNpNXlkV3hsY3lBOUlHSnNiMk5yTzF4dVhHNHZLaXBjYmlBcUlGTjBZWFJwWXlCTVpYZ2dUV1YwYUc5a1hHNGdLaTljYmx4dVRHVjRaWEl1YkdWNElEMGdablZ1WTNScGIyNG9jM0pqTENCdmNIUnBiMjV6S1NCN1hHNGdJSFpoY2lCc1pYaGxjaUE5SUc1bGR5Qk1aWGhsY2lodmNIUnBiMjV6S1R0Y2JpQWdjbVYwZFhKdUlHeGxlR1Z5TG14bGVDaHpjbU1wTzF4dWZUdGNibHh1THlvcVhHNGdLaUJRY21Wd2NtOWpaWE56YVc1blhHNGdLaTljYmx4dVRHVjRaWEl1Y0hKdmRHOTBlWEJsTG14bGVDQTlJR1oxYm1OMGFXOXVLSE55WXlrZ2UxeHVJQ0J6Y21NZ1BTQnpjbU5jYmlBZ0lDQXVjbVZ3YkdGalpTZ3ZYRnh5WEZ4dWZGeGNjaTluTENBblhGeHVKeWxjYmlBZ0lDQXVjbVZ3YkdGalpTZ3ZYRngwTDJjc0lDY2dJQ0FnSnlsY2JpQWdJQ0F1Y21Wd2JHRmpaU2d2WEZ4MU1EQmhNQzluTENBbklDY3BYRzRnSUNBZ0xuSmxjR3hoWTJVb0wxeGNkVEkwTWpRdlp5d2dKMXhjYmljcE8xeHVYRzRnSUhKbGRIVnliaUIwYUdsekxuUnZhMlZ1S0hOeVl5d2dkSEoxWlNrN1hHNTlPMXh1WEc0dktpcGNiaUFxSUV4bGVHbHVaMXh1SUNvdlhHNWNia3hsZUdWeUxuQnliM1J2ZEhsd1pTNTBiMnRsYmlBOUlHWjFibU4wYVc5dUtITnlZeXdnZEc5d0xDQmljU2tnZTF4dUlDQjJZWElnYzNKaklEMGdjM0pqTG5KbGNHeGhZMlVvTDE0Z0t5UXZaMjBzSUNjbktWeHVJQ0FnSUN3Z2JtVjRkRnh1SUNBZ0lDd2diRzl2YzJWY2JpQWdJQ0FzSUdOaGNGeHVJQ0FnSUN3Z1luVnNiRnh1SUNBZ0lDd2dZbHh1SUNBZ0lDd2dhWFJsYlZ4dUlDQWdJQ3dnYzNCaFkyVmNiaUFnSUNBc0lHbGNiaUFnSUNBc0lHdzdYRzVjYmlBZ2QyaHBiR1VnS0hOeVl5a2dlMXh1SUNBZ0lDOHZJRzVsZDJ4cGJtVmNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NXVaWGRzYVc1bExtVjRaV01vYzNKaktTa2dlMXh1SUNBZ0lDQWdjM0pqSUQwZ2MzSmpMbk4xWW5OMGNtbHVaeWhqWVhCYk1GMHViR1Z1WjNSb0tUdGNiaUFnSUNBZ0lHbG1JQ2hqWVhCYk1GMHViR1Z1WjNSb0lENGdNU2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMblJ2YTJWdWN5NXdkWE5vS0h0Y2JpQWdJQ0FnSUNBZ0lDQjBlWEJsT2lBbmMzQmhZMlVuWEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklHTnZaR1ZjYmlBZ0lDQnBaaUFvWTJGd0lEMGdkR2hwY3k1eWRXeGxjeTVqYjJSbExtVjRaV01vYzNKaktTa2dlMXh1SUNBZ0lDQWdjM0pqSUQwZ2MzSmpMbk4xWW5OMGNtbHVaeWhqWVhCYk1GMHViR1Z1WjNSb0tUdGNiaUFnSUNBZ0lHTmhjQ0E5SUdOaGNGc3dYUzV5WlhCc1lXTmxLQzllSUhzMGZTOW5iU3dnSnljcE8xeHVJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNoN1hHNGdJQ0FnSUNBZ0lIUjVjR1U2SUNkamIyUmxKeXhjYmlBZ0lDQWdJQ0FnZEdWNGREb2dJWFJvYVhNdWIzQjBhVzl1Y3k1d1pXUmhiblJwWTF4dUlDQWdJQ0FnSUNBZ0lEOGdZMkZ3TG5KbGNHeGhZMlVvTDF4Y2Jpc2tMeXdnSnljcFhHNGdJQ0FnSUNBZ0lDQWdPaUJqWVhCY2JpQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1ptVnVZMlZ6SUNoblptMHBYRzRnSUNBZ2FXWWdLR05oY0NBOUlIUm9hWE11Y25Wc1pYTXVabVZ1WTJWekxtVjRaV01vYzNKaktTa2dlMXh1SUNBZ0lDQWdjM0pqSUQwZ2MzSmpMbk4xWW5OMGNtbHVaeWhqWVhCYk1GMHViR1Z1WjNSb0tUdGNiaUFnSUNBZ0lIUm9hWE11ZEc5clpXNXpMbkIxYzJnb2UxeHVJQ0FnSUNBZ0lDQjBlWEJsT2lBblkyOWtaU2NzWEc0Z0lDQWdJQ0FnSUd4aGJtYzZJR05oY0ZzeVhTeGNiaUFnSUNBZ0lDQWdkR1Y0ZERvZ1kyRndXek5kSUh4OElDY25YRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR2hsWVdScGJtZGNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NW9aV0ZrYVc1bkxtVjRaV01vYzNKaktTa2dlMXh1SUNBZ0lDQWdjM0pqSUQwZ2MzSmpMbk4xWW5OMGNtbHVaeWhqWVhCYk1GMHViR1Z1WjNSb0tUdGNiaUFnSUNBZ0lIUm9hWE11ZEc5clpXNXpMbkIxYzJnb2UxeHVJQ0FnSUNBZ0lDQjBlWEJsT2lBbmFHVmhaR2x1Wnljc1hHNGdJQ0FnSUNBZ0lHUmxjSFJvT2lCallYQmJNVjB1YkdWdVozUm9MRnh1SUNBZ0lDQWdJQ0IwWlhoME9pQmpZWEJiTWwxY2JpQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z2RHRmliR1VnYm04Z2JHVmhaR2x1WnlCd2FYQmxJQ2huWm0wcFhHNGdJQ0FnYVdZZ0tIUnZjQ0FtSmlBb1kyRndJRDBnZEdocGN5NXlkV3hsY3k1dWNIUmhZbXhsTG1WNFpXTW9jM0pqS1NrcElIdGNiaUFnSUNBZ0lITnlZeUE5SUhOeVl5NXpkV0p6ZEhKcGJtY29ZMkZ3V3pCZExteGxibWQwYUNrN1hHNWNiaUFnSUNBZ0lHbDBaVzBnUFNCN1hHNGdJQ0FnSUNBZ0lIUjVjR1U2SUNkMFlXSnNaU2NzWEc0Z0lDQWdJQ0FnSUdobFlXUmxjam9nWTJGd1d6RmRMbkpsY0d4aFkyVW9MMTRnS253Z0tseGNmQ0FxSkM5bkxDQW5KeWt1YzNCc2FYUW9MeUFxWEZ4OElDb3ZLU3hjYmlBZ0lDQWdJQ0FnWVd4cFoyNDZJR05oY0ZzeVhTNXlaWEJzWVdObEtDOWVJQ3A4WEZ4OElDb2tMMmNzSUNjbktTNXpjR3hwZENndklDcGNYSHdnS2k4cExGeHVJQ0FnSUNBZ0lDQmpaV3hzY3pvZ1kyRndXek5kTG5KbGNHeGhZMlVvTDF4Y2JpUXZMQ0FuSnlrdWMzQnNhWFFvSjF4Y2JpY3BYRzRnSUNBZ0lDQjlPMXh1WEc0Z0lDQWdJQ0JtYjNJZ0tHa2dQU0F3T3lCcElEd2dhWFJsYlM1aGJHbG5iaTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvTDE0Z0tpMHJPaUFxSkM4dWRHVnpkQ2hwZEdWdExtRnNhV2R1VzJsZEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsMFpXMHVZV3hwWjI1YmFWMGdQU0FuY21sbmFIUW5PMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0M5ZUlDbzZMU3M2SUNva0x5NTBaWE4wS0dsMFpXMHVZV3hwWjI1YmFWMHBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FYUmxiUzVoYkdsbmJsdHBYU0E5SUNkalpXNTBaWEluTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tDOWVJQ282TFNzZ0tpUXZMblJsYzNRb2FYUmxiUzVoYkdsbmJsdHBYU2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBkR1Z0TG1Gc2FXZHVXMmxkSUQwZ0oyeGxablFuTzF4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHbDBaVzB1WVd4cFoyNWJhVjBnUFNCdWRXeHNPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdadmNpQW9hU0E5SURBN0lHa2dQQ0JwZEdWdExtTmxiR3h6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJR2wwWlcwdVkyVnNiSE5iYVYwZ1BTQnBkR1Z0TG1ObGJHeHpXMmxkTG5Od2JHbDBLQzhnS2x4Y2ZDQXFMeWs3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhSb2FYTXVkRzlyWlc1ekxuQjFjMmdvYVhSbGJTazdYRzVjYmlBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR3hvWldGa2FXNW5YRzRnSUNBZ2FXWWdLR05oY0NBOUlIUm9hWE11Y25Wc1pYTXViR2hsWVdScGJtY3VaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdkR2hwY3k1MGIydGxibk11Y0hWemFDaDdYRzRnSUNBZ0lDQWdJSFI1Y0dVNklDZG9aV0ZrYVc1bkp5eGNiaUFnSUNBZ0lDQWdaR1Z3ZEdnNklHTmhjRnN5WFNBOVBUMGdKejBuSUQ4Z01TQTZJRElzWEc0Z0lDQWdJQ0FnSUhSbGVIUTZJR05oY0ZzeFhWeHVJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5Qm9jbHh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMbWh5TG1WNFpXTW9jM0pqS1NrZ2UxeHVJQ0FnSUNBZ2MzSmpJRDBnYzNKakxuTjFZbk4wY21sdVp5aGpZWEJiTUYwdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUhSb2FYTXVkRzlyWlc1ekxuQjFjMmdvZTF4dUlDQWdJQ0FnSUNCMGVYQmxPaUFuYUhJblhHNGdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lHTnZiblJwYm5WbE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklHSnNiMk5yY1hWdmRHVmNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NWliRzlqYTNGMWIzUmxMbVY0WldNb2MzSmpLU2tnZTF4dUlDQWdJQ0FnYzNKaklEMGdjM0pqTG5OMVluTjBjbWx1WnloallYQmJNRjB1YkdWdVozUm9LVHRjYmx4dUlDQWdJQ0FnZEdocGN5NTBiMnRsYm5NdWNIVnphQ2g3WEc0Z0lDQWdJQ0FnSUhSNWNHVTZJQ2RpYkc5amEzRjFiM1JsWDNOMFlYSjBKMXh1SUNBZ0lDQWdmU2s3WEc1Y2JpQWdJQ0FnSUdOaGNDQTlJR05oY0Zzd1hTNXlaWEJzWVdObEtDOWVJQ28rSUQ4dloyMHNJQ2NuS1R0Y2JseHVJQ0FnSUNBZ0x5OGdVR0Z6Y3lCZ2RHOXdZQ0IwYnlCclpXVndJSFJvWlNCamRYSnlaVzUwWEc0Z0lDQWdJQ0F2THlCY0luUnZjR3hsZG1Wc1hDSWdjM1JoZEdVdUlGUm9hWE1nYVhNZ1pYaGhZM1JzZVZ4dUlDQWdJQ0FnTHk4Z2FHOTNJRzFoY210a2IzZHVMbkJzSUhkdmNtdHpMbHh1SUNBZ0lDQWdkR2hwY3k1MGIydGxiaWhqWVhBc0lIUnZjQ3dnZEhKMVpTazdYRzVjYmlBZ0lDQWdJSFJvYVhNdWRHOXJaVzV6TG5CMWMyZ29lMXh1SUNBZ0lDQWdJQ0IwZVhCbE9pQW5ZbXh2WTJ0eGRXOTBaVjlsYm1RblhHNGdJQ0FnSUNCOUtUdGNibHh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdiR2x6ZEZ4dUlDQWdJR2xtSUNoallYQWdQU0IwYUdsekxuSjFiR1Z6TG14cGMzUXVaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdZblZzYkNBOUlHTmhjRnN5WFR0Y2JseHVJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNoN1hHNGdJQ0FnSUNBZ0lIUjVjR1U2SUNkc2FYTjBYM04wWVhKMEp5eGNiaUFnSUNBZ0lDQWdiM0prWlhKbFpEb2dZblZzYkM1c1pXNW5kR2dnUGlBeFhHNGdJQ0FnSUNCOUtUdGNibHh1SUNBZ0lDQWdMeThnUjJWMElHVmhZMmdnZEc5d0xXeGxkbVZzSUdsMFpXMHVYRzRnSUNBZ0lDQmpZWEFnUFNCallYQmJNRjB1YldGMFkyZ29kR2hwY3k1eWRXeGxjeTVwZEdWdEtUdGNibHh1SUNBZ0lDQWdibVY0ZENBOUlHWmhiSE5sTzF4dUlDQWdJQ0FnYkNBOUlHTmhjQzVzWlc1bmRHZzdYRzRnSUNBZ0lDQnBJRDBnTUR0Y2JseHVJQ0FnSUNBZ1ptOXlJQ2c3SUdrZ1BDQnNPeUJwS3lzcElIdGNiaUFnSUNBZ0lDQWdhWFJsYlNBOUlHTmhjRnRwWFR0Y2JseHVJQ0FnSUNBZ0lDQXZMeUJTWlcxdmRtVWdkR2hsSUd4cGMzUWdhWFJsYlNkeklHSjFiR3hsZEZ4dUlDQWdJQ0FnSUNBdkx5QnpieUJwZENCcGN5QnpaV1Z1SUdGeklIUm9aU0J1WlhoMElIUnZhMlZ1TGx4dUlDQWdJQ0FnSUNCemNHRmpaU0E5SUdsMFpXMHViR1Z1WjNSb08xeHVJQ0FnSUNBZ0lDQnBkR1Z0SUQwZ2FYUmxiUzV5WlhCc1lXTmxLQzllSUNvb1d5b3JMVjE4WEZ4a0sxeGNMaWtnS3k4c0lDY25LVHRjYmx4dUlDQWdJQ0FnSUNBdkx5QlBkWFJrWlc1MElIZG9ZWFJsZG1WeUlIUm9aVnh1SUNBZ0lDQWdJQ0F2THlCc2FYTjBJR2wwWlcwZ1kyOXVkR0ZwYm5NdUlFaGhZMnQ1TGx4dUlDQWdJQ0FnSUNCcFppQW9mbWwwWlcwdWFXNWtaWGhQWmlnblhGeHVJQ2NwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjM0JoWTJVZ0xUMGdhWFJsYlM1c1pXNW5kR2c3WEc0Z0lDQWdJQ0FnSUNBZ2FYUmxiU0E5SUNGMGFHbHpMbTl3ZEdsdmJuTXVjR1ZrWVc1MGFXTmNiaUFnSUNBZ0lDQWdJQ0FnSUQ4Z2FYUmxiUzV5WlhCc1lXTmxLRzVsZHlCU1pXZEZlSEFvSjE0Z2V6RXNKeUFySUhOd1lXTmxJQ3NnSjMwbkxDQW5aMjBuS1N3Z0p5Y3BYRzRnSUNBZ0lDQWdJQ0FnSUNBNklHbDBaVzB1Y21Wd2JHRmpaU2d2WGlCN01TdzBmUzluYlN3Z0p5Y3BPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0x5OGdSR1YwWlhKdGFXNWxJSGRvWlhSb1pYSWdkR2hsSUc1bGVIUWdiR2x6ZENCcGRHVnRJR0psYkc5dVozTWdhR1Z5WlM1Y2JpQWdJQ0FnSUNBZ0x5OGdRbUZqYTNCbFpHRnNJR2xtSUdsMElHUnZaWE1nYm05MElHSmxiRzl1WnlCcGJpQjBhR2x6SUd4cGMzUXVYRzRnSUNBZ0lDQWdJR2xtSUNoMGFHbHpMbTl3ZEdsdmJuTXVjMjFoY25STWFYTjBjeUFtSmlCcElDRTlQU0JzSUMwZ01Ta2dlMXh1SUNBZ0lDQWdJQ0FnSUdJZ1BTQmliRzlqYXk1aWRXeHNaWFF1WlhobFl5aGpZWEJiYVNBcklERmRLVnN3WFR0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvWW5Wc2JDQWhQVDBnWWlBbUppQWhLR0oxYkd3dWJHVnVaM1JvSUQ0Z01TQW1KaUJpTG14bGJtZDBhQ0ErSURFcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCemNtTWdQU0JqWVhBdWMyeHBZMlVvYVNBcklERXBMbXB2YVc0b0oxeGNiaWNwSUNzZ2MzSmpPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2FTQTlJR3dnTFNBeE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDOHZJRVJsZEdWeWJXbHVaU0IzYUdWMGFHVnlJR2wwWlcwZ2FYTWdiRzl2YzJVZ2IzSWdibTkwTGx4dUlDQWdJQ0FnSUNBdkx5QlZjMlU2SUM4b1hueGNYRzRwS0Q4aElDbGJYbHhjYmwwclhGeHVYRnh1S0Q4aFhGeHpLaVFwTDF4dUlDQWdJQ0FnSUNBdkx5Qm1iM0lnWkdselkyOTFiblFnWW1Wb1lYWnBiM0l1WEc0Z0lDQWdJQ0FnSUd4dmIzTmxJRDBnYm1WNGRDQjhmQ0F2WEZ4dVhGeHVLRDhoWEZ4ektpUXBMeTUwWlhOMEtHbDBaVzBwTzF4dUlDQWdJQ0FnSUNCcFppQW9hU0FoUFQwZ2JDQXRJREVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnVaWGgwSUQwZ2FYUmxiUzVqYUdGeVFYUW9hWFJsYlM1c1pXNW5kR2dnTFNBeEtTQTlQVDBnSjF4Y2JpYzdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tDRnNiMjl6WlNrZ2JHOXZjMlVnUFNCdVpYaDBPMXh1SUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNoN1hHNGdJQ0FnSUNBZ0lDQWdkSGx3WlRvZ2JHOXZjMlZjYmlBZ0lDQWdJQ0FnSUNBZ0lEOGdKMnh2YjNObFgybDBaVzFmYzNSaGNuUW5YRzRnSUNBZ0lDQWdJQ0FnSUNBNklDZHNhWE4wWDJsMFpXMWZjM1JoY25RblhHNGdJQ0FnSUNBZ0lIMHBPMXh1WEc0Z0lDQWdJQ0FnSUM4dklGSmxZM1Z5YzJVdVhHNGdJQ0FnSUNBZ0lIUm9hWE11ZEc5clpXNG9hWFJsYlN3Z1ptRnNjMlVzSUdKeEtUdGNibHh1SUNBZ0lDQWdJQ0IwYUdsekxuUnZhMlZ1Y3k1d2RYTm9LSHRjYmlBZ0lDQWdJQ0FnSUNCMGVYQmxPaUFuYkdsemRGOXBkR1Z0WDJWdVpDZGNiaUFnSUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhSb2FYTXVkRzlyWlc1ekxuQjFjMmdvZTF4dUlDQWdJQ0FnSUNCMGVYQmxPaUFuYkdsemRGOWxibVFuWEc0Z0lDQWdJQ0I5S1R0Y2JseHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z2FIUnRiRnh1SUNBZ0lHbG1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMbWgwYld3dVpYaGxZeWh6Y21NcEtTQjdYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNoN1hHNGdJQ0FnSUNBZ0lIUjVjR1U2SUhSb2FYTXViM0IwYVc5dWN5NXpZVzVwZEdsNlpWeHVJQ0FnSUNBZ0lDQWdJRDhnSjNCaGNtRm5jbUZ3YUNkY2JpQWdJQ0FnSUNBZ0lDQTZJQ2RvZEcxc0p5eGNiaUFnSUNBZ0lDQWdjSEpsT2lBaGRHaHBjeTV2Y0hScGIyNXpMbk5oYm1sMGFYcGxjbHh1SUNBZ0lDQWdJQ0FnSUNZbUlDaGpZWEJiTVYwZ1BUMDlJQ2R3Y21VbklIeDhJR05oY0ZzeFhTQTlQVDBnSjNOamNtbHdkQ2NnZkh3Z1kyRndXekZkSUQwOVBTQW5jM1I1YkdVbktTeGNiaUFnSUNBZ0lDQWdkR1Y0ZERvZ1kyRndXekJkWEc0Z0lDQWdJQ0I5S1R0Y2JpQWdJQ0FnSUdOdmJuUnBiblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUdSbFpseHVJQ0FnSUdsbUlDZ29JV0p4SUNZbUlIUnZjQ2tnSmlZZ0tHTmhjQ0E5SUhSb2FYTXVjblZzWlhNdVpHVm1MbVY0WldNb2MzSmpLU2twSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc0Z0lDQWdJQ0IwYUdsekxuUnZhMlZ1Y3k1c2FXNXJjMXRqWVhCYk1WMHVkRzlNYjNkbGNrTmhjMlVvS1YwZ1BTQjdYRzRnSUNBZ0lDQWdJR2h5WldZNklHTmhjRnN5WFN4Y2JpQWdJQ0FnSUNBZ2RHbDBiR1U2SUdOaGNGc3pYVnh1SUNBZ0lDQWdmVHRjYmlBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJSFJoWW14bElDaG5abTBwWEc0Z0lDQWdhV1lnS0hSdmNDQW1KaUFvWTJGd0lEMGdkR2hwY3k1eWRXeGxjeTUwWVdKc1pTNWxlR1ZqS0hOeVl5a3BLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1WEc0Z0lDQWdJQ0JwZEdWdElEMGdlMXh1SUNBZ0lDQWdJQ0IwZVhCbE9pQW5kR0ZpYkdVbkxGeHVJQ0FnSUNBZ0lDQm9aV0ZrWlhJNklHTmhjRnN4WFM1eVpYQnNZV05sS0M5ZUlDcDhJQ3BjWEh3Z0tpUXZaeXdnSnljcExuTndiR2wwS0M4Z0tseGNmQ0FxTHlrc1hHNGdJQ0FnSUNBZ0lHRnNhV2R1T2lCallYQmJNbDB1Y21Wd2JHRmpaU2d2WGlBcWZGeGNmQ0FxSkM5bkxDQW5KeWt1YzNCc2FYUW9MeUFxWEZ4OElDb3ZLU3hjYmlBZ0lDQWdJQ0FnWTJWc2JITTZJR05oY0ZzelhTNXlaWEJzWVdObEtDOG9Qem9nS2x4Y2ZDQXFLVDljWEc0a0x5d2dKeWNwTG5Od2JHbDBLQ2RjWEc0bktWeHVJQ0FnSUNBZ2ZUdGNibHh1SUNBZ0lDQWdabTl5SUNocElEMGdNRHNnYVNBOElHbDBaVzB1WVd4cFoyNHViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLQzllSUNvdEt6b2dLaVF2TG5SbGMzUW9hWFJsYlM1aGJHbG5ibHRwWFNrcElIdGNiaUFnSUNBZ0lDQWdJQ0JwZEdWdExtRnNhV2R1VzJsZElEMGdKM0pwWjJoMEp6dGNiaUFnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2d2WGlBcU9pMHJPaUFxSkM4dWRHVnpkQ2hwZEdWdExtRnNhV2R1VzJsZEtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsMFpXMHVZV3hwWjI1YmFWMGdQU0FuWTJWdWRHVnlKenRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNndlhpQXFPaTBySUNva0x5NTBaWE4wS0dsMFpXMHVZV3hwWjI1YmFWMHBLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2FYUmxiUzVoYkdsbmJsdHBYU0E5SUNkc1pXWjBKenRjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNCcGRHVnRMbUZzYVdkdVcybGRJRDBnYm5Wc2JEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JtYjNJZ0tHa2dQU0F3T3lCcElEd2dhWFJsYlM1alpXeHNjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQnBkR1Z0TG1ObGJHeHpXMmxkSUQwZ2FYUmxiUzVqWld4c2MxdHBYVnh1SUNBZ0lDQWdJQ0FnSUM1eVpYQnNZV05sS0M5ZUlDcGNYSHdnS253Z0tseGNmQ0FxSkM5bkxDQW5KeWxjYmlBZ0lDQWdJQ0FnSUNBdWMzQnNhWFFvTHlBcVhGeDhJQ292S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2RHaHBjeTUwYjJ0bGJuTXVjSFZ6YUNocGRHVnRLVHRjYmx4dUlDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnZEc5d0xXeGxkbVZzSUhCaGNtRm5jbUZ3YUZ4dUlDQWdJR2xtSUNoMGIzQWdKaVlnS0dOaGNDQTlJSFJvYVhNdWNuVnNaWE11Y0dGeVlXZHlZWEJvTG1WNFpXTW9jM0pqS1NrcElIdGNiaUFnSUNBZ0lITnlZeUE5SUhOeVl5NXpkV0p6ZEhKcGJtY29ZMkZ3V3pCZExteGxibWQwYUNrN1hHNGdJQ0FnSUNCMGFHbHpMblJ2YTJWdWN5NXdkWE5vS0h0Y2JpQWdJQ0FnSUNBZ2RIbHdaVG9nSjNCaGNtRm5jbUZ3YUNjc1hHNGdJQ0FnSUNBZ0lIUmxlSFE2SUdOaGNGc3hYUzVqYUdGeVFYUW9ZMkZ3V3pGZExteGxibWQwYUNBdElERXBJRDA5UFNBblhGeHVKMXh1SUNBZ0lDQWdJQ0FnSUQ4Z1kyRndXekZkTG5Oc2FXTmxLREFzSUMweEtWeHVJQ0FnSUNBZ0lDQWdJRG9nWTJGd1d6RmRYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJR052Ym5ScGJuVmxPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJSFJsZUhSY2JpQWdJQ0JwWmlBb1kyRndJRDBnZEdocGN5NXlkV3hsY3k1MFpYaDBMbVY0WldNb2MzSmpLU2tnZTF4dUlDQWdJQ0FnTHk4Z1ZHOXdMV3hsZG1Wc0lITm9iM1ZzWkNCdVpYWmxjaUJ5WldGamFDQm9aWEpsTGx4dUlDQWdJQ0FnYzNKaklEMGdjM0pqTG5OMVluTjBjbWx1WnloallYQmJNRjB1YkdWdVozUm9LVHRjYmlBZ0lDQWdJSFJvYVhNdWRHOXJaVzV6TG5CMWMyZ29lMXh1SUNBZ0lDQWdJQ0IwZVhCbE9pQW5kR1Y0ZENjc1hHNGdJQ0FnSUNBZ0lIUmxlSFE2SUdOaGNGc3dYVnh1SUNBZ0lDQWdmU2s3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnBaaUFvYzNKaktTQjdYRzRnSUNBZ0lDQjBhSEp2ZHlCdVpYZGNiaUFnSUNBZ0lDQWdSWEp5YjNJb0owbHVabWx1YVhSbElHeHZiM0FnYjI0Z1lubDBaVG9nSnlBcklITnlZeTVqYUdGeVEyOWtaVUYwS0RBcEtUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2RHaHBjeTUwYjJ0bGJuTTdYRzU5TzF4dVhHNHZLaXBjYmlBcUlFbHViR2x1WlMxTVpYWmxiQ0JIY21GdGJXRnlYRzRnS2k5Y2JseHVkbUZ5SUdsdWJHbHVaU0E5SUh0Y2JpQWdaWE5qWVhCbE9pQXZYbHhjWEZ3b1cxeGNYRnhnS250OVhGeGJYRnhkS0NraksxeGNMUzRoWHo1ZEtTOHNYRzRnSUdGMWRHOXNhVzVyT2lBdlhqd29XMTRnUGwwcktFQjhPbHhjTHlsYlhpQStYU3NwUGk4c1hHNGdJSFZ5YkRvZ2JtOXZjQ3hjYmlBZ2RHRm5PaUF2WGp3aExTMWJYRnh6WEZ4VFhTby9MUzArZkY0OFhGd3ZQMXhjZHlzb1B6cGNJbHRlWENKZEtsd2lmQ2RiWGlkZEtpZDhXMTRuWENJK1hTa3FQejR2TEZ4dUlDQnNhVzVyT2lBdlhpRS9YRnhiS0dsdWMybGtaU2xjWEYxY1hDaG9jbVZtWEZ3cEx5eGNiaUFnY21WbWJHbHVhem9nTDE0aFAxeGNXeWhwYm5OcFpHVXBYRnhkWEZ4ektseGNXeWhiWGx4Y1hWMHFLVnhjWFM4c1hHNGdJRzV2YkdsdWF6b2dMMTRoUDF4Y1d5Z29QenBjWEZ0YlhseGNYVjBxWEZ4ZGZGdGVYRnhiWEZ4ZFhTa3FLVnhjWFM4c1hHNGdJSE4wY205dVp6b2dMMTVmWHloYlhGeHpYRnhUWFNzL0tWOWZLRDhoWHlsOFhseGNLbHhjS2loYlhGeHpYRnhUWFNzL0tWeGNLbHhjS2lnL0lWeGNLaWt2TEZ4dUlDQmxiVG9nTDE1Y1hHSmZLQ2cvT2x0ZVgxMThYMThwS3o4cFgxeGNZbnhlWEZ3cUtDZy9PbHhjS2x4Y0tueGJYRnh6WEZ4VFhTa3JQeWxjWENvb1B5RmNYQ29wTHl4Y2JpQWdZMjlrWlRvZ0wxNG9ZQ3NwWEZ4ektpaGJYRnh6WEZ4VFhTby9XMTVnWFNsY1hITXFYRnd4S0Q4aFlDa3ZMRnh1SUNCaWNqb2dMMTRnZXpJc2ZWeGNiaWcvSVZ4Y2N5b2tLUzhzWEc0Z0lHUmxiRG9nYm05dmNDeGNiaUFnZEdWNGREb2dMMTViWEZ4elhGeFRYU3MvS0Q4OVcxeGNYRnc4SVZ4Y1cxOHFZRjE4SUhzeUxIMWNYRzU4SkNrdlhHNTlPMXh1WEc1cGJteHBibVV1WDJsdWMybGtaU0E5SUM4b1B6cGNYRnRiWGx4Y1hWMHFYRnhkZkZ0ZVhGeGJYRnhkWFh4Y1hGMG9QejFiWGx4Y1cxMHFYRnhkS1NrcUx6dGNibWx1YkdsdVpTNWZhSEpsWmlBOUlDOWNYSE1xUEQ4b1cxeGNjMXhjVTEwcVB5aytQeWcvT2x4Y2N5dGJKMXdpWFNoYlhGeHpYRnhUWFNvL0tWc25YQ0pkS1Q5Y1hITXFMenRjYmx4dWFXNXNhVzVsTG14cGJtc2dQU0J5WlhCc1lXTmxLR2x1YkdsdVpTNXNhVzVyS1Z4dUlDQW9KMmx1YzJsa1pTY3NJR2x1YkdsdVpTNWZhVzV6YVdSbEtWeHVJQ0FvSjJoeVpXWW5MQ0JwYm14cGJtVXVYMmh5WldZcFhHNGdJQ2dwTzF4dVhHNXBibXhwYm1VdWNtVm1iR2x1YXlBOUlISmxjR3hoWTJVb2FXNXNhVzVsTG5KbFpteHBibXNwWEc0Z0lDZ25hVzV6YVdSbEp5d2dhVzVzYVc1bExsOXBibk5wWkdVcFhHNGdJQ2dwTzF4dVhHNHZLaXBjYmlBcUlFNXZjbTFoYkNCSmJteHBibVVnUjNKaGJXMWhjbHh1SUNvdlhHNWNibWx1YkdsdVpTNXViM0p0WVd3Z1BTQnRaWEpuWlNoN2ZTd2dhVzVzYVc1bEtUdGNibHh1THlvcVhHNGdLaUJRWldSaGJuUnBZeUJKYm14cGJtVWdSM0poYlcxaGNseHVJQ292WEc1Y2JtbHViR2x1WlM1d1pXUmhiblJwWXlBOUlHMWxjbWRsS0h0OUxDQnBibXhwYm1VdWJtOXliV0ZzTENCN1hHNGdJSE4wY205dVp6b2dMMTVmWHlnL1BWeGNVeWtvVzF4Y2MxeGNVMTBxUDF4Y1V5bGZYeWcvSVY4cGZGNWNYQ3BjWENvb1B6MWNYRk1wS0Z0Y1hITmNYRk5kS2o5Y1hGTXBYRndxWEZ3cUtEOGhYRndxS1M4c1hHNGdJR1Z0T2lBdlhsOG9QejFjWEZNcEtGdGNYSE5jWEZOZEtqOWNYRk1wWHlnL0lWOHBmRjVjWENvb1B6MWNYRk1wS0Z0Y1hITmNYRk5kS2o5Y1hGTXBYRndxS0Q4aFhGd3FLUzljYm4wcE8xeHVYRzR2S2lwY2JpQXFJRWRHVFNCSmJteHBibVVnUjNKaGJXMWhjbHh1SUNvdlhHNWNibWx1YkdsdVpTNW5abTBnUFNCdFpYSm5aU2g3ZlN3Z2FXNXNhVzVsTG01dmNtMWhiQ3dnZTF4dUlDQmxjMk5oY0dVNklISmxjR3hoWTJVb2FXNXNhVzVsTG1WelkyRndaU2tvSjEwcEp5d2dKMzU4WFNrbktTZ3BMRnh1SUNCMWNtdzZJQzllS0doMGRIQnpQenBjWEM5Y1hDOWJYbHhjY3p4ZEsxdGVQQzRzT2p0Y0lpY3BYRnhkWEZ4elhTa3ZMRnh1SUNCa1pXdzZJQzllZm40b1B6MWNYRk1wS0Z0Y1hITmNYRk5kS2o5Y1hGTXBmbjR2TEZ4dUlDQjBaWGgwT2lCeVpYQnNZV05sS0dsdWJHbHVaUzUwWlhoMEtWeHVJQ0FnSUNnblhYd25MQ0FuZmwxOEp5bGNiaUFnSUNBb0ozd25MQ0FuZkdoMGRIQnpQem92TDN3bktWeHVJQ0FnSUNncFhHNTlLVHRjYmx4dUx5b3FYRzRnS2lCSFJrMGdLeUJNYVc1bElFSnlaV0ZyY3lCSmJteHBibVVnUjNKaGJXMWhjbHh1SUNvdlhHNWNibWx1YkdsdVpTNWljbVZoYTNNZ1BTQnRaWEpuWlNoN2ZTd2dhVzVzYVc1bExtZG1iU3dnZTF4dUlDQmljam9nY21Wd2JHRmpaU2hwYm14cGJtVXVZbklwS0NkN01peDlKeXdnSnlvbktTZ3BMRnh1SUNCMFpYaDBPaUJ5WlhCc1lXTmxLR2x1YkdsdVpTNW5abTB1ZEdWNGRDa29KM3N5TEgwbkxDQW5LaWNwS0NsY2JuMHBPMXh1WEc0dktpcGNiaUFxSUVsdWJHbHVaU0JNWlhobGNpQW1JRU52YlhCcGJHVnlYRzRnS2k5Y2JseHVablZ1WTNScGIyNGdTVzVzYVc1bFRHVjRaWElvYkdsdWEzTXNJRzl3ZEdsdmJuTXBJSHRjYmlBZ2RHaHBjeTV2Y0hScGIyNXpJRDBnYjNCMGFXOXVjeUI4ZkNCdFlYSnJaV1F1WkdWbVlYVnNkSE03WEc0Z0lIUm9hWE11YkdsdWEzTWdQU0JzYVc1cmN6dGNiaUFnZEdocGN5NXlkV3hsY3lBOUlHbHViR2x1WlM1dWIzSnRZV3c3WEc0Z0lIUm9hWE11Y21WdVpHVnlaWElnUFNCMGFHbHpMbTl3ZEdsdmJuTXVjbVZ1WkdWeVpYSWdmSHdnYm1WM0lGSmxibVJsY21WeU8xeHVJQ0IwYUdsekxuSmxibVJsY21WeUxtOXdkR2x2Ym5NZ1BTQjBhR2x6TG05d2RHbHZibk03WEc1Y2JpQWdhV1lnS0NGMGFHbHpMbXhwYm10ektTQjdYRzRnSUNBZ2RHaHliM2NnYm1WM1hHNGdJQ0FnSUNCRmNuSnZjaWduVkc5clpXNXpJR0Z5Y21GNUlISmxjWFZwY21WeklHRWdZR3hwYm10ellDQndjbTl3WlhKMGVTNG5LVHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaDBhR2x6TG05d2RHbHZibk11WjJadEtTQjdYRzRnSUNBZ2FXWWdLSFJvYVhNdWIzQjBhVzl1Y3k1aWNtVmhhM01wSUh0Y2JpQWdJQ0FnSUhSb2FYTXVjblZzWlhNZ1BTQnBibXhwYm1VdVluSmxZV3R6TzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQjBhR2x6TG5KMWJHVnpJRDBnYVc1c2FXNWxMbWRtYlR0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCcFppQW9kR2hwY3k1dmNIUnBiMjV6TG5CbFpHRnVkR2xqS1NCN1hHNGdJQ0FnZEdocGN5NXlkV3hsY3lBOUlHbHViR2x1WlM1d1pXUmhiblJwWXp0Y2JpQWdmVnh1ZlZ4dVhHNHZLaXBjYmlBcUlFVjRjRzl6WlNCSmJteHBibVVnVW5Wc1pYTmNiaUFxTDF4dVhHNUpibXhwYm1WTVpYaGxjaTV5ZFd4bGN5QTlJR2x1YkdsdVpUdGNibHh1THlvcVhHNGdLaUJUZEdGMGFXTWdUR1Y0YVc1bkwwTnZiWEJwYkdsdVp5Qk5aWFJvYjJSY2JpQXFMMXh1WEc1SmJteHBibVZNWlhobGNpNXZkWFJ3ZFhRZ1BTQm1kVzVqZEdsdmJpaHpjbU1zSUd4cGJtdHpMQ0J2Y0hScGIyNXpLU0I3WEc0Z0lIWmhjaUJwYm14cGJtVWdQU0J1WlhjZ1NXNXNhVzVsVEdWNFpYSW9iR2x1YTNNc0lHOXdkR2x2Ym5NcE8xeHVJQ0J5WlhSMWNtNGdhVzVzYVc1bExtOTFkSEIxZENoemNtTXBPMXh1ZlR0Y2JseHVMeW9xWEc0Z0tpQk1aWGhwYm1jdlEyOXRjR2xzYVc1blhHNGdLaTljYmx4dVNXNXNhVzVsVEdWNFpYSXVjSEp2ZEc5MGVYQmxMbTkxZEhCMWRDQTlJR1oxYm1OMGFXOXVLSE55WXlrZ2UxeHVJQ0IyWVhJZ2IzVjBJRDBnSnlkY2JpQWdJQ0FzSUd4cGJtdGNiaUFnSUNBc0lIUmxlSFJjYmlBZ0lDQXNJR2h5WldaY2JpQWdJQ0FzSUdOaGNEdGNibHh1SUNCM2FHbHNaU0FvYzNKaktTQjdYRzRnSUNBZ0x5OGdaWE5qWVhCbFhHNGdJQ0FnYVdZZ0tHTmhjQ0E5SUhSb2FYTXVjblZzWlhNdVpYTmpZWEJsTG1WNFpXTW9jM0pqS1NrZ2UxeHVJQ0FnSUNBZ2MzSmpJRDBnYzNKakxuTjFZbk4wY21sdVp5aGpZWEJiTUYwdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUc5MWRDQXJQU0JqWVhCYk1WMDdYRzRnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNCOVhHNWNiaUFnSUNBdkx5QmhkWFJ2YkdsdWExeHVJQ0FnSUdsbUlDaGpZWEFnUFNCMGFHbHpMbkoxYkdWekxtRjFkRzlzYVc1ckxtVjRaV01vYzNKaktTa2dlMXh1SUNBZ0lDQWdjM0pqSUQwZ2MzSmpMbk4xWW5OMGNtbHVaeWhqWVhCYk1GMHViR1Z1WjNSb0tUdGNiaUFnSUNBZ0lHbG1JQ2hqWVhCYk1sMGdQVDA5SUNkQUp5a2dlMXh1SUNBZ0lDQWdJQ0IwWlhoMElEMGdZMkZ3V3pGZExtTm9ZWEpCZENnMktTQTlQVDBnSnpvblhHNGdJQ0FnSUNBZ0lDQWdQeUIwYUdsekxtMWhibWRzWlNoallYQmJNVjB1YzNWaWMzUnlhVzVuS0RjcEtWeHVJQ0FnSUNBZ0lDQWdJRG9nZEdocGN5NXRZVzVuYkdVb1kyRndXekZkS1R0Y2JpQWdJQ0FnSUNBZ2FISmxaaUE5SUhSb2FYTXViV0Z1WjJ4bEtDZHRZV2xzZEc4Nkp5a2dLeUIwWlhoME8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2RHVjRkQ0E5SUdWelkyRndaU2hqWVhCYk1WMHBPMXh1SUNBZ0lDQWdJQ0JvY21WbUlEMGdkR1Y0ZER0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUc5MWRDQXJQU0IwYUdsekxuSmxibVJsY21WeUxteHBibXNvYUhKbFppd2diblZzYkN3Z2RHVjRkQ2s3WEc0Z0lDQWdJQ0JqYjI1MGFXNTFaVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUIxY213Z0tHZG1iU2xjYmlBZ0lDQnBaaUFvSVhSb2FYTXVhVzVNYVc1cklDWW1JQ2hqWVhBZ1BTQjBhR2x6TG5KMWJHVnpMblZ5YkM1bGVHVmpLSE55WXlrcEtTQjdYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2RHVjRkQ0E5SUdWelkyRndaU2hqWVhCYk1WMHBPMXh1SUNBZ0lDQWdhSEpsWmlBOUlIUmxlSFE3WEc0Z0lDQWdJQ0J2ZFhRZ0t6MGdkR2hwY3k1eVpXNWtaWEpsY2k1c2FXNXJLR2h5WldZc0lHNTFiR3dzSUhSbGVIUXBPMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdkR0ZuWEc0Z0lDQWdhV1lnS0dOaGNDQTlJSFJvYVhNdWNuVnNaWE11ZEdGbkxtVjRaV01vYzNKaktTa2dlMXh1SUNBZ0lDQWdhV1lnS0NGMGFHbHpMbWx1VEdsdWF5QW1KaUF2WGp4aElDOXBMblJsYzNRb1kyRndXekJkS1NrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG1sdVRHbHVheUE5SUhSeWRXVTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFJvYVhNdWFXNU1hVzVySUNZbUlDOWVQRnhjTDJFK0wya3VkR1Z6ZENoallYQmJNRjBwS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11YVc1TWFXNXJJRDBnWm1Gc2MyVTdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnpjbU1nUFNCemNtTXVjM1ZpYzNSeWFXNW5LR05oY0Zzd1hTNXNaVzVuZEdncE8xeHVJQ0FnSUNBZ2IzVjBJQ3M5SUhSb2FYTXViM0IwYVc5dWN5NXpZVzVwZEdsNlpWeHVJQ0FnSUNBZ0lDQS9JSFJvYVhNdWIzQjBhVzl1Y3k1ellXNXBkR2w2WlhKY2JpQWdJQ0FnSUNBZ0lDQS9JSFJvYVhNdWIzQjBhVzl1Y3k1ellXNXBkR2w2WlhJb1kyRndXekJkS1Z4dUlDQWdJQ0FnSUNBZ0lEb2daWE5qWVhCbEtHTmhjRnN3WFNsY2JpQWdJQ0FnSUNBZ09pQmpZWEJiTUYxY2JpQWdJQ0FnSUdOdmJuUnBiblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUd4cGJtdGNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NXNhVzVyTG1WNFpXTW9jM0pqS1NrZ2UxeHVJQ0FnSUNBZ2MzSmpJRDBnYzNKakxuTjFZbk4wY21sdVp5aGpZWEJiTUYwdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUhSb2FYTXVhVzVNYVc1cklEMGdkSEoxWlR0Y2JpQWdJQ0FnSUc5MWRDQXJQU0IwYUdsekxtOTFkSEIxZEV4cGJtc29ZMkZ3TENCN1hHNGdJQ0FnSUNBZ0lHaHlaV1k2SUdOaGNGc3lYU3hjYmlBZ0lDQWdJQ0FnZEdsMGJHVTZJR05oY0ZzelhWeHVJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQjBhR2x6TG1sdVRHbHVheUE5SUdaaGJITmxPMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdjbVZtYkdsdWF5d2dibTlzYVc1clhHNGdJQ0FnYVdZZ0tDaGpZWEFnUFNCMGFHbHpMbkoxYkdWekxuSmxabXhwYm1zdVpYaGxZeWh6Y21NcEtWeHVJQ0FnSUNBZ0lDQjhmQ0FvWTJGd0lEMGdkR2hwY3k1eWRXeGxjeTV1YjJ4cGJtc3VaWGhsWXloemNtTXBLU2tnZTF4dUlDQWdJQ0FnYzNKaklEMGdjM0pqTG5OMVluTjBjbWx1WnloallYQmJNRjB1YkdWdVozUm9LVHRjYmlBZ0lDQWdJR3hwYm1zZ1BTQW9ZMkZ3V3pKZElIeDhJR05oY0ZzeFhTa3VjbVZ3YkdGalpTZ3ZYRnh6S3k5bkxDQW5JQ2NwTzF4dUlDQWdJQ0FnYkdsdWF5QTlJSFJvYVhNdWJHbHVhM05iYkdsdWF5NTBiMHh2ZDJWeVEyRnpaU2dwWFR0Y2JpQWdJQ0FnSUdsbUlDZ2hiR2x1YXlCOGZDQWhiR2x1YXk1b2NtVm1LU0I3WEc0Z0lDQWdJQ0FnSUc5MWRDQXJQU0JqWVhCYk1GMHVZMmhoY2tGMEtEQXBPMXh1SUNBZ0lDQWdJQ0J6Y21NZ1BTQmpZWEJiTUYwdWMzVmljM1J5YVc1bktERXBJQ3NnYzNKak8xeHVJQ0FnSUNBZ0lDQmpiMjUwYVc1MVpUdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lIUm9hWE11YVc1TWFXNXJJRDBnZEhKMVpUdGNiaUFnSUNBZ0lHOTFkQ0FyUFNCMGFHbHpMbTkxZEhCMWRFeHBibXNvWTJGd0xDQnNhVzVyS1R0Y2JpQWdJQ0FnSUhSb2FYTXVhVzVNYVc1cklEMGdabUZzYzJVN1hHNGdJQ0FnSUNCamIyNTBhVzUxWlR0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCemRISnZibWRjYmlBZ0lDQnBaaUFvWTJGd0lEMGdkR2hwY3k1eWRXeGxjeTV6ZEhKdmJtY3VaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdiM1YwSUNzOUlIUm9hWE11Y21WdVpHVnlaWEl1YzNSeWIyNW5LSFJvYVhNdWIzVjBjSFYwS0dOaGNGc3lYU0I4ZkNCallYQmJNVjBwS1R0Y2JpQWdJQ0FnSUdOdmJuUnBiblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUdWdFhHNGdJQ0FnYVdZZ0tHTmhjQ0E5SUhSb2FYTXVjblZzWlhNdVpXMHVaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdiM1YwSUNzOUlIUm9hWE11Y21WdVpHVnlaWEl1Wlcwb2RHaHBjeTV2ZFhSd2RYUW9ZMkZ3V3pKZElIeDhJR05oY0ZzeFhTa3BPMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdZMjlrWlZ4dUlDQWdJR2xtSUNoallYQWdQU0IwYUdsekxuSjFiR1Z6TG1OdlpHVXVaWGhsWXloemNtTXBLU0I3WEc0Z0lDQWdJQ0J6Y21NZ1BTQnpjbU11YzNWaWMzUnlhVzVuS0dOaGNGc3dYUzVzWlc1bmRHZ3BPMXh1SUNBZ0lDQWdiM1YwSUNzOUlIUm9hWE11Y21WdVpHVnlaWEl1WTI5a1pYTndZVzRvWlhOallYQmxLR05oY0ZzeVhTd2dkSEoxWlNrcE8xeHVJQ0FnSUNBZ1kyOXVkR2x1ZFdVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHk4Z1luSmNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NWljaTVsZUdWaktITnlZeWtwSUh0Y2JpQWdJQ0FnSUhOeVl5QTlJSE55WXk1emRXSnpkSEpwYm1jb1kyRndXekJkTG14bGJtZDBhQ2s3WEc0Z0lDQWdJQ0J2ZFhRZ0t6MGdkR2hwY3k1eVpXNWtaWEpsY2k1aWNpZ3BPMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdaR1ZzSUNoblptMHBYRzRnSUNBZ2FXWWdLR05oY0NBOUlIUm9hWE11Y25Wc1pYTXVaR1ZzTG1WNFpXTW9jM0pqS1NrZ2UxeHVJQ0FnSUNBZ2MzSmpJRDBnYzNKakxuTjFZbk4wY21sdVp5aGpZWEJiTUYwdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUc5MWRDQXJQU0IwYUdsekxuSmxibVJsY21WeUxtUmxiQ2gwYUdsekxtOTFkSEIxZENoallYQmJNVjBwS1R0Y2JpQWdJQ0FnSUdOdmJuUnBiblZsTzF4dUlDQWdJSDFjYmx4dUlDQWdJQzh2SUhSbGVIUmNiaUFnSUNCcFppQW9ZMkZ3SUQwZ2RHaHBjeTV5ZFd4bGN5NTBaWGgwTG1WNFpXTW9jM0pqS1NrZ2UxeHVJQ0FnSUNBZ2MzSmpJRDBnYzNKakxuTjFZbk4wY21sdVp5aGpZWEJiTUYwdWJHVnVaM1JvS1R0Y2JpQWdJQ0FnSUc5MWRDQXJQU0IwYUdsekxuSmxibVJsY21WeUxuUmxlSFFvWlhOallYQmxLSFJvYVhNdWMyMWhjblI1Y0dGdWRITW9ZMkZ3V3pCZEtTa3BPMXh1SUNBZ0lDQWdZMjl1ZEdsdWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLSE55WXlrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM1hHNGdJQ0FnSUNBZ0lFVnljbTl5S0NkSmJtWnBibWwwWlNCc2IyOXdJRzl1SUdKNWRHVTZJQ2NnS3lCemNtTXVZMmhoY2tOdlpHVkJkQ2d3S1NrN1hHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUc5MWREdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1EyOXRjR2xzWlNCTWFXNXJYRzRnS2k5Y2JseHVTVzVzYVc1bFRHVjRaWEl1Y0hKdmRHOTBlWEJsTG05MWRIQjFkRXhwYm1zZ1BTQm1kVzVqZEdsdmJpaGpZWEFzSUd4cGJtc3BJSHRjYmlBZ2RtRnlJR2h5WldZZ1BTQmxjMk5oY0dVb2JHbHVheTVvY21WbUtWeHVJQ0FnSUN3Z2RHbDBiR1VnUFNCc2FXNXJMblJwZEd4bElEOGdaWE5qWVhCbEtHeHBibXN1ZEdsMGJHVXBJRG9nYm5Wc2JEdGNibHh1SUNCeVpYUjFjbTRnWTJGd1d6QmRMbU5vWVhKQmRDZ3dLU0FoUFQwZ0p5RW5YRzRnSUNBZ1B5QjBhR2x6TG5KbGJtUmxjbVZ5TG14cGJtc29hSEpsWml3Z2RHbDBiR1VzSUhSb2FYTXViM1YwY0hWMEtHTmhjRnN4WFNrcFhHNGdJQ0FnT2lCMGFHbHpMbkpsYm1SbGNtVnlMbWx0WVdkbEtHaHlaV1lzSUhScGRHeGxMQ0JsYzJOaGNHVW9ZMkZ3V3pGZEtTazdYRzU5TzF4dVhHNHZLaXBjYmlBcUlGTnRZWEowZVhCaGJuUnpJRlJ5WVc1elptOXliV0YwYVc5dWMxeHVJQ292WEc1Y2JrbHViR2x1WlV4bGVHVnlMbkJ5YjNSdmRIbHdaUzV6YldGeWRIbHdZVzUwY3lBOUlHWjFibU4wYVc5dUtIUmxlSFFwSUh0Y2JpQWdhV1lnS0NGMGFHbHpMbTl3ZEdsdmJuTXVjMjFoY25SNWNHRnVkSE1wSUhKbGRIVnliaUIwWlhoME8xeHVJQ0J5WlhSMWNtNGdkR1Y0ZEZ4dUlDQWdJQzh2SUdWdExXUmhjMmhsYzF4dUlDQWdJQzV5WlhCc1lXTmxLQzh0TFMwdlp5d2dKMXhjZFRJd01UUW5LVnh1SUNBZ0lDOHZJR1Z1TFdSaGMyaGxjMXh1SUNBZ0lDNXlaWEJzWVdObEtDOHRMUzluTENBblhGeDFNakF4TXljcFhHNGdJQ0FnTHk4Z2IzQmxibWx1WnlCemFXNW5iR1Z6WEc0Z0lDQWdMbkpsY0d4aFkyVW9MeWhlZkZzdFhGeDFNakF4TkM4b1hGeGJlMXdpWEZ4elhTa25MMmNzSUNja01WeGNkVEl3TVRnbktWeHVJQ0FnSUM4dklHTnNiM05wYm1jZ2MybHVaMnhsY3lBbUlHRndiM04wY205d2FHVnpYRzRnSUNBZ0xuSmxjR3hoWTJVb0x5Y3ZaeXdnSjF4Y2RUSXdNVGtuS1Z4dUlDQWdJQzh2SUc5d1pXNXBibWNnWkc5MVlteGxjMXh1SUNBZ0lDNXlaWEJzWVdObEtDOG9YbnhiTFZ4Y2RUSXdNVFF2S0Z4Y1czdGNYSFV5TURFNFhGeHpYU2xjSWk5bkxDQW5KREZjWEhVeU1ERmpKeWxjYmlBZ0lDQXZMeUJqYkc5emFXNW5JR1J2ZFdKc1pYTmNiaUFnSUNBdWNtVndiR0ZqWlNndlhDSXZaeXdnSjF4Y2RUSXdNV1FuS1Z4dUlDQWdJQzh2SUdWc2JHbHdjMlZ6WEc0Z0lDQWdMbkpsY0d4aFkyVW9MMXhjTG5zemZTOW5MQ0FuWEZ4MU1qQXlOaWNwTzF4dWZUdGNibHh1THlvcVhHNGdLaUJOWVc1bmJHVWdUR2x1YTNOY2JpQXFMMXh1WEc1SmJteHBibVZNWlhobGNpNXdjbTkwYjNSNWNHVXViV0Z1WjJ4bElEMGdablZ1WTNScGIyNG9kR1Y0ZENrZ2UxeHVJQ0JwWmlBb0lYUm9hWE11YjNCMGFXOXVjeTV0WVc1bmJHVXBJSEpsZEhWeWJpQjBaWGgwTzF4dUlDQjJZWElnYjNWMElEMGdKeWRjYmlBZ0lDQXNJR3dnUFNCMFpYaDBMbXhsYm1kMGFGeHVJQ0FnSUN3Z2FTQTlJREJjYmlBZ0lDQXNJR05vTzF4dVhHNGdJR1p2Y2lBb095QnBJRHdnYkRzZ2FTc3JLU0I3WEc0Z0lDQWdZMmdnUFNCMFpYaDBMbU5vWVhKRGIyUmxRWFFvYVNrN1hHNGdJQ0FnYVdZZ0tFMWhkR2d1Y21GdVpHOXRLQ2tnUGlBd0xqVXBJSHRjYmlBZ0lDQWdJR05vSUQwZ0ozZ25JQ3NnWTJndWRHOVRkSEpwYm1jb01UWXBPMXh1SUNBZ0lIMWNiaUFnSUNCdmRYUWdLejBnSnlZakp5QXJJR05vSUNzZ0p6c25PMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJRzkxZER0Y2JuMDdYRzVjYmk4cUtseHVJQ29nVW1WdVpHVnlaWEpjYmlBcUwxeHVYRzVtZFc1amRHbHZiaUJTWlc1a1pYSmxjaWh2Y0hScGIyNXpLU0I3WEc0Z0lIUm9hWE11YjNCMGFXOXVjeUE5SUc5d2RHbHZibk1nZkh3Z2UzMDdYRzU5WEc1Y2JsSmxibVJsY21WeUxuQnliM1J2ZEhsd1pTNWpiMlJsSUQwZ1puVnVZM1JwYjI0b1kyOWtaU3dnYkdGdVp5d2daWE5qWVhCbFpDa2dlMXh1SUNCcFppQW9kR2hwY3k1dmNIUnBiMjV6TG1ocFoyaHNhV2RvZENrZ2UxeHVJQ0FnSUhaaGNpQnZkWFFnUFNCMGFHbHpMbTl3ZEdsdmJuTXVhR2xuYUd4cFoyaDBLR052WkdVc0lHeGhibWNwTzF4dUlDQWdJR2xtSUNodmRYUWdJVDBnYm5Wc2JDQW1KaUJ2ZFhRZ0lUMDlJR052WkdVcElIdGNiaUFnSUNBZ0lHVnpZMkZ3WldRZ1BTQjBjblZsTzF4dUlDQWdJQ0FnWTI5a1pTQTlJRzkxZER0Y2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCcFppQW9JV3hoYm1jcElIdGNiaUFnSUNCeVpYUjFjbTRnSnp4d2NtVStQR052WkdVK0oxeHVJQ0FnSUNBZ0t5QW9aWE5qWVhCbFpDQS9JR052WkdVZ09pQmxjMk5oY0dVb1kyOWtaU3dnZEhKMVpTa3BYRzRnSUNBZ0lDQXJJQ2RjWEc0OEwyTnZaR1UrUEM5d2NtVStKenRjYmlBZ2ZWeHVYRzRnSUhKbGRIVnliaUFuUEhCeVpUNDhZMjlrWlNCamJHRnpjejFjSWlkY2JpQWdJQ0FySUhSb2FYTXViM0IwYVc5dWN5NXNZVzVuVUhKbFptbDRYRzRnSUNBZ0t5QmxjMk5oY0dVb2JHRnVaeXdnZEhKMVpTbGNiaUFnSUNBcklDZGNJajRuWEc0Z0lDQWdLeUFvWlhOallYQmxaQ0EvSUdOdlpHVWdPaUJsYzJOaGNHVW9ZMjlrWlN3Z2RISjFaU2twWEc0Z0lDQWdLeUFuWEZ4dVBDOWpiMlJsUGp3dmNISmxQbHhjYmljN1hHNTlPMXh1WEc1U1pXNWtaWEpsY2k1d2NtOTBiM1I1Y0dVdVlteHZZMnR4ZFc5MFpTQTlJR1oxYm1OMGFXOXVLSEYxYjNSbEtTQjdYRzRnSUhKbGRIVnliaUFuUEdKc2IyTnJjWFZ2ZEdVK1hGeHVKeUFySUhGMWIzUmxJQ3NnSnp3dllteHZZMnR4ZFc5MFpUNWNYRzRuTzF4dWZUdGNibHh1VW1WdVpHVnlaWEl1Y0hKdmRHOTBlWEJsTG1oMGJXd2dQU0JtZFc1amRHbHZiaWhvZEcxc0tTQjdYRzRnSUhKbGRIVnliaUJvZEcxc08xeHVmVHRjYmx4dVVtVnVaR1Z5WlhJdWNISnZkRzkwZVhCbExtaGxZV1JwYm1jZ1BTQm1kVzVqZEdsdmJpaDBaWGgwTENCc1pYWmxiQ3dnY21GM0tTQjdYRzRnSUhKbGRIVnliaUFuUEdnblhHNGdJQ0FnS3lCc1pYWmxiRnh1SUNBZ0lDc2dKeUJwWkQxY0lpZGNiaUFnSUNBcklIUm9hWE11YjNCMGFXOXVjeTVvWldGa1pYSlFjbVZtYVhoY2JpQWdJQ0FySUhKaGR5NTBiMHh2ZDJWeVEyRnpaU2dwTG5KbGNHeGhZMlVvTDF0ZVhGeDNYU3N2Wnl3Z0p5MG5LVnh1SUNBZ0lDc2dKMXdpUGlkY2JpQWdJQ0FySUhSbGVIUmNiaUFnSUNBcklDYzhMMmduWEc0Z0lDQWdLeUJzWlhabGJGeHVJQ0FnSUNzZ0p6NWNYRzRuTzF4dWZUdGNibHh1VW1WdVpHVnlaWEl1Y0hKdmRHOTBlWEJsTG1oeUlEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lISmxkSFZ5YmlCMGFHbHpMbTl3ZEdsdmJuTXVlR2gwYld3Z1B5QW5QR2h5THo1Y1hHNG5JRG9nSnp4b2NqNWNYRzRuTzF4dWZUdGNibHh1VW1WdVpHVnlaWEl1Y0hKdmRHOTBlWEJsTG14cGMzUWdQU0JtZFc1amRHbHZiaWhpYjJSNUxDQnZjbVJsY21Wa0tTQjdYRzRnSUhaaGNpQjBlWEJsSUQwZ2IzSmtaWEpsWkNBL0lDZHZiQ2NnT2lBbmRXd25PMXh1SUNCeVpYUjFjbTRnSnp3bklDc2dkSGx3WlNBcklDYytYRnh1SnlBcklHSnZaSGtnS3lBblBDOG5JQ3NnZEhsd1pTQXJJQ2MrWEZ4dUp6dGNibjA3WEc1Y2JsSmxibVJsY21WeUxuQnliM1J2ZEhsd1pTNXNhWE4wYVhSbGJTQTlJR1oxYm1OMGFXOXVLSFJsZUhRcElIdGNiaUFnY21WMGRYSnVJQ2M4YkdrK0p5QXJJSFJsZUhRZ0t5QW5QQzlzYVQ1Y1hHNG5PMXh1ZlR0Y2JseHVVbVZ1WkdWeVpYSXVjSEp2ZEc5MGVYQmxMbkJoY21GbmNtRndhQ0E5SUdaMWJtTjBhVzl1S0hSbGVIUXBJSHRjYmlBZ2NtVjBkWEp1SUNjOGNENG5JQ3NnZEdWNGRDQXJJQ2M4TDNBK1hGeHVKenRjYm4wN1hHNWNibEpsYm1SbGNtVnlMbkJ5YjNSdmRIbHdaUzUwWVdKc1pTQTlJR1oxYm1OMGFXOXVLR2hsWVdSbGNpd2dZbTlrZVNrZ2UxeHVJQ0J5WlhSMWNtNGdKengwWVdKc1pUNWNYRzRuWEc0Z0lDQWdLeUFuUEhSb1pXRmtQbHhjYmlkY2JpQWdJQ0FySUdobFlXUmxjbHh1SUNBZ0lDc2dKend2ZEdobFlXUStYRnh1SjF4dUlDQWdJQ3NnSnp4MFltOWtlVDVjWEc0blhHNGdJQ0FnS3lCaWIyUjVYRzRnSUNBZ0t5QW5QQzkwWW05a2VUNWNYRzRuWEc0Z0lDQWdLeUFuUEM5MFlXSnNaVDVjWEc0bk8xeHVmVHRjYmx4dVVtVnVaR1Z5WlhJdWNISnZkRzkwZVhCbExuUmhZbXhsY205M0lEMGdablZ1WTNScGIyNG9ZMjl1ZEdWdWRDa2dlMXh1SUNCeVpYUjFjbTRnSnp4MGNqNWNYRzRuSUNzZ1kyOXVkR1Z1ZENBcklDYzhMM1J5UGx4Y2JpYzdYRzU5TzF4dVhHNVNaVzVrWlhKbGNpNXdjbTkwYjNSNWNHVXVkR0ZpYkdWalpXeHNJRDBnWm5WdVkzUnBiMjRvWTI5dWRHVnVkQ3dnWm14aFozTXBJSHRjYmlBZ2RtRnlJSFI1Y0dVZ1BTQm1iR0ZuY3k1b1pXRmtaWElnUHlBbmRHZ25JRG9nSjNSa0p6dGNiaUFnZG1GeUlIUmhaeUE5SUdac1lXZHpMbUZzYVdkdVhHNGdJQ0FnUHlBblBDY2dLeUIwZVhCbElDc2dKeUJ6ZEhsc1pUMWNJblJsZUhRdFlXeHBaMjQ2SnlBcklHWnNZV2R6TG1Gc2FXZHVJQ3NnSjF3aVBpZGNiaUFnSUNBNklDYzhKeUFySUhSNWNHVWdLeUFuUGljN1hHNGdJSEpsZEhWeWJpQjBZV2NnS3lCamIyNTBaVzUwSUNzZ0p6d3ZKeUFySUhSNWNHVWdLeUFuUGx4Y2JpYzdYRzU5TzF4dVhHNHZMeUJ6Y0dGdUlHeGxkbVZzSUhKbGJtUmxjbVZ5WEc1U1pXNWtaWEpsY2k1d2NtOTBiM1I1Y0dVdWMzUnliMjVuSUQwZ1puVnVZM1JwYjI0b2RHVjRkQ2tnZTF4dUlDQnlaWFIxY200Z0p6eHpkSEp2Ym1jK0p5QXJJSFJsZUhRZ0t5QW5QQzl6ZEhKdmJtYytKenRjYm4wN1hHNWNibEpsYm1SbGNtVnlMbkJ5YjNSdmRIbHdaUzVsYlNBOUlHWjFibU4wYVc5dUtIUmxlSFFwSUh0Y2JpQWdjbVYwZFhKdUlDYzhaVzArSnlBcklIUmxlSFFnS3lBblBDOWxiVDRuTzF4dWZUdGNibHh1VW1WdVpHVnlaWEl1Y0hKdmRHOTBlWEJsTG1OdlpHVnpjR0Z1SUQwZ1puVnVZM1JwYjI0b2RHVjRkQ2tnZTF4dUlDQnlaWFIxY200Z0p6eGpiMlJsUGljZ0t5QjBaWGgwSUNzZ0p6d3ZZMjlrWlQ0bk8xeHVmVHRjYmx4dVVtVnVaR1Z5WlhJdWNISnZkRzkwZVhCbExtSnlJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJSEpsZEhWeWJpQjBhR2x6TG05d2RHbHZibk11ZUdoMGJXd2dQeUFuUEdKeUx6NG5JRG9nSnp4aWNqNG5PMXh1ZlR0Y2JseHVVbVZ1WkdWeVpYSXVjSEp2ZEc5MGVYQmxMbVJsYkNBOUlHWjFibU4wYVc5dUtIUmxlSFFwSUh0Y2JpQWdjbVYwZFhKdUlDYzhaR1ZzUGljZ0t5QjBaWGgwSUNzZ0p6d3ZaR1ZzUGljN1hHNTlPMXh1WEc1U1pXNWtaWEpsY2k1d2NtOTBiM1I1Y0dVdWJHbHVheUE5SUdaMWJtTjBhVzl1S0doeVpXWXNJSFJwZEd4bExDQjBaWGgwS1NCN1hHNGdJR2xtSUNoMGFHbHpMbTl3ZEdsdmJuTXVjMkZ1YVhScGVtVXBJSHRjYmlBZ0lDQjBjbmtnZTF4dUlDQWdJQ0FnZG1GeUlIQnliM1FnUFNCa1pXTnZaR1ZWVWtsRGIyMXdiMjVsYm5Rb2RXNWxjMk5oY0dVb2FISmxaaWtwWEc0Z0lDQWdJQ0FnSUM1eVpYQnNZV05sS0M5YlhseGNkenBkTDJjc0lDY25LVnh1SUNBZ0lDQWdJQ0F1ZEc5TWIzZGxja05oYzJVb0tUdGNiaUFnSUNCOUlHTmhkR05vSUNobEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z0p5YzdYRzRnSUNBZ2ZWeHVJQ0FnSUdsbUlDaHdjbTkwTG1sdVpHVjRUMllvSjJwaGRtRnpZM0pwY0hRNkp5a2dQVDA5SURBZ2ZId2djSEp2ZEM1cGJtUmxlRTltS0NkMlluTmpjbWx3ZERvbktTQTlQVDBnTUNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUNjbk8xeHVJQ0FnSUgxY2JpQWdmVnh1SUNCMllYSWdiM1YwSUQwZ0p6eGhJR2h5WldZOVhDSW5JQ3NnYUhKbFppQXJJQ2RjSWljN1hHNGdJR2xtSUNoMGFYUnNaU2tnZTF4dUlDQWdJRzkxZENBclBTQW5JSFJwZEd4bFBWd2lKeUFySUhScGRHeGxJQ3NnSjF3aUp6dGNiaUFnZlZ4dUlDQnZkWFFnS3owZ0p6NG5JQ3NnZEdWNGRDQXJJQ2M4TDJFK0p6dGNiaUFnY21WMGRYSnVJRzkxZER0Y2JuMDdYRzVjYmxKbGJtUmxjbVZ5TG5CeWIzUnZkSGx3WlM1cGJXRm5aU0E5SUdaMWJtTjBhVzl1S0doeVpXWXNJSFJwZEd4bExDQjBaWGgwS1NCN1hHNGdJSFpoY2lCdmRYUWdQU0FuUEdsdFp5QnpjbU05WENJbklDc2dhSEpsWmlBcklDZGNJaUJoYkhROVhDSW5JQ3NnZEdWNGRDQXJJQ2RjSWljN1hHNGdJR2xtSUNoMGFYUnNaU2tnZTF4dUlDQWdJRzkxZENBclBTQW5JSFJwZEd4bFBWd2lKeUFySUhScGRHeGxJQ3NnSjF3aUp6dGNiaUFnZlZ4dUlDQnZkWFFnS3owZ2RHaHBjeTV2Y0hScGIyNXpMbmhvZEcxc0lEOGdKeTgrSnlBNklDYytKenRjYmlBZ2NtVjBkWEp1SUc5MWREdGNibjA3WEc1Y2JsSmxibVJsY21WeUxuQnliM1J2ZEhsd1pTNTBaWGgwSUQwZ1puVnVZM1JwYjI0b2RHVjRkQ2tnZTF4dUlDQnlaWFIxY200Z2RHVjRkRHRjYm4wN1hHNWNiaThxS2x4dUlDb2dVR0Z5YzJsdVp5QW1JRU52YlhCcGJHbHVaMXh1SUNvdlhHNWNibVoxYm1OMGFXOXVJRkJoY25ObGNpaHZjSFJwYjI1ektTQjdYRzRnSUhSb2FYTXVkRzlyWlc1eklEMGdXMTA3WEc0Z0lIUm9hWE11ZEc5clpXNGdQU0J1ZFd4c08xeHVJQ0IwYUdsekxtOXdkR2x2Ym5NZ1BTQnZjSFJwYjI1eklIeDhJRzFoY210bFpDNWtaV1poZFd4MGN6dGNiaUFnZEdocGN5NXZjSFJwYjI1ekxuSmxibVJsY21WeUlEMGdkR2hwY3k1dmNIUnBiMjV6TG5KbGJtUmxjbVZ5SUh4OElHNWxkeUJTWlc1a1pYSmxjanRjYmlBZ2RHaHBjeTV5Wlc1a1pYSmxjaUE5SUhSb2FYTXViM0IwYVc5dWN5NXlaVzVrWlhKbGNqdGNiaUFnZEdocGN5NXlaVzVrWlhKbGNpNXZjSFJwYjI1eklEMGdkR2hwY3k1dmNIUnBiMjV6TzF4dWZWeHVYRzR2S2lwY2JpQXFJRk4wWVhScFl5QlFZWEp6WlNCTlpYUm9iMlJjYmlBcUwxeHVYRzVRWVhKelpYSXVjR0Z5YzJVZ1BTQm1kVzVqZEdsdmJpaHpjbU1zSUc5d2RHbHZibk1zSUhKbGJtUmxjbVZ5S1NCN1hHNGdJSFpoY2lCd1lYSnpaWElnUFNCdVpYY2dVR0Z5YzJWeUtHOXdkR2x2Ym5Nc0lISmxibVJsY21WeUtUdGNiaUFnY21WMGRYSnVJSEJoY25ObGNpNXdZWEp6WlNoemNtTXBPMXh1ZlR0Y2JseHVMeW9xWEc0Z0tpQlFZWEp6WlNCTWIyOXdYRzRnS2k5Y2JseHVVR0Z5YzJWeUxuQnliM1J2ZEhsd1pTNXdZWEp6WlNBOUlHWjFibU4wYVc5dUtITnlZeWtnZTF4dUlDQjBhR2x6TG1sdWJHbHVaU0E5SUc1bGR5QkpibXhwYm1WTVpYaGxjaWh6Y21NdWJHbHVhM01zSUhSb2FYTXViM0IwYVc5dWN5d2dkR2hwY3k1eVpXNWtaWEpsY2lrN1hHNGdJSFJvYVhNdWRHOXJaVzV6SUQwZ2MzSmpMbkpsZG1WeWMyVW9LVHRjYmx4dUlDQjJZWElnYjNWMElEMGdKeWM3WEc0Z0lIZG9hV3hsSUNoMGFHbHpMbTVsZUhRb0tTa2dlMXh1SUNBZ0lHOTFkQ0FyUFNCMGFHbHpMblJ2YXlncE8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHOTFkRHRjYm4wN1hHNWNiaThxS2x4dUlDb2dUbVY0ZENCVWIydGxibHh1SUNvdlhHNWNibEJoY25ObGNpNXdjbTkwYjNSNWNHVXVibVY0ZENBOUlHWjFibU4wYVc5dUtDa2dlMXh1SUNCeVpYUjFjbTRnZEdocGN5NTBiMnRsYmlBOUlIUm9hWE11ZEc5clpXNXpMbkJ2Y0NncE8xeHVmVHRjYmx4dUx5b3FYRzRnS2lCUWNtVjJhV1YzSUU1bGVIUWdWRzlyWlc1Y2JpQXFMMXh1WEc1UVlYSnpaWEl1Y0hKdmRHOTBlWEJsTG5CbFpXc2dQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdjbVYwZFhKdUlIUm9hWE11ZEc5clpXNXpXM1JvYVhNdWRHOXJaVzV6TG14bGJtZDBhQ0F0SURGZElIeDhJREE3WEc1OU8xeHVYRzR2S2lwY2JpQXFJRkJoY25ObElGUmxlSFFnVkc5clpXNXpYRzRnS2k5Y2JseHVVR0Z5YzJWeUxuQnliM1J2ZEhsd1pTNXdZWEp6WlZSbGVIUWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdkbUZ5SUdKdlpIa2dQU0IwYUdsekxuUnZhMlZ1TG5SbGVIUTdYRzVjYmlBZ2QyaHBiR1VnS0hSb2FYTXVjR1ZsYXlncExuUjVjR1VnUFQwOUlDZDBaWGgwSnlrZ2UxeHVJQ0FnSUdKdlpIa2dLejBnSjF4Y2JpY2dLeUIwYUdsekxtNWxlSFFvS1M1MFpYaDBPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJSFJvYVhNdWFXNXNhVzVsTG05MWRIQjFkQ2hpYjJSNUtUdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1VHRnljMlVnUTNWeWNtVnVkQ0JVYjJ0bGJseHVJQ292WEc1Y2JsQmhjbk5sY2k1d2NtOTBiM1I1Y0dVdWRHOXJJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJSE4zYVhSamFDQW9kR2hwY3k1MGIydGxiaTUwZVhCbEtTQjdYRzRnSUNBZ1kyRnpaU0FuYzNCaFkyVW5PaUI3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdKeWM3WEc0Z0lDQWdmVnh1SUNBZ0lHTmhjMlVnSjJoeUp6b2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WdVpHVnlaWEl1YUhJb0tUdGNiaUFnSUNCOVhHNGdJQ0FnWTJGelpTQW5hR1ZoWkdsdVp5YzZJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG5KbGJtUmxjbVZ5TG1obFlXUnBibWNvWEc0Z0lDQWdJQ0FnSUhSb2FYTXVhVzVzYVc1bExtOTFkSEIxZENoMGFHbHpMblJ2YTJWdUxuUmxlSFFwTEZ4dUlDQWdJQ0FnSUNCMGFHbHpMblJ2YTJWdUxtUmxjSFJvTEZ4dUlDQWdJQ0FnSUNCMGFHbHpMblJ2YTJWdUxuUmxlSFFwTzF4dUlDQWdJSDFjYmlBZ0lDQmpZWE5sSUNkamIyUmxKem9nZTF4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnVaR1Z5WlhJdVkyOWtaU2gwYUdsekxuUnZhMlZ1TG5SbGVIUXNYRzRnSUNBZ0lDQWdJSFJvYVhNdWRHOXJaVzR1YkdGdVp5eGNiaUFnSUNBZ0lDQWdkR2hwY3k1MGIydGxiaTVsYzJOaGNHVmtLVHRjYmlBZ0lDQjlYRzRnSUNBZ1kyRnpaU0FuZEdGaWJHVW5PaUI3WEc0Z0lDQWdJQ0IyWVhJZ2FHVmhaR1Z5SUQwZ0p5ZGNiaUFnSUNBZ0lDQWdMQ0JpYjJSNUlEMGdKeWRjYmlBZ0lDQWdJQ0FnTENCcFhHNGdJQ0FnSUNBZ0lDd2djbTkzWEc0Z0lDQWdJQ0FnSUN3Z1kyVnNiRnh1SUNBZ0lDQWdJQ0FzSUdac1lXZHpYRzRnSUNBZ0lDQWdJQ3dnYWp0Y2JseHVJQ0FnSUNBZ0x5OGdhR1ZoWkdWeVhHNGdJQ0FnSUNCalpXeHNJRDBnSnljN1hHNGdJQ0FnSUNCbWIzSWdLR2tnUFNBd095QnBJRHdnZEdocGN5NTBiMnRsYmk1b1pXRmtaWEl1YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lDQWdabXhoWjNNZ1BTQjdJR2hsWVdSbGNqb2dkSEoxWlN3Z1lXeHBaMjQ2SUhSb2FYTXVkRzlyWlc0dVlXeHBaMjViYVYwZ2ZUdGNiaUFnSUNBZ0lDQWdZMlZzYkNBclBTQjBhR2x6TG5KbGJtUmxjbVZ5TG5SaFlteGxZMlZzYkNoY2JpQWdJQ0FnSUNBZ0lDQjBhR2x6TG1sdWJHbHVaUzV2ZFhSd2RYUW9kR2hwY3k1MGIydGxiaTVvWldGa1pYSmJhVjBwTEZ4dUlDQWdJQ0FnSUNBZ0lIc2dhR1ZoWkdWeU9pQjBjblZsTENCaGJHbG5iam9nZEdocGN5NTBiMnRsYmk1aGJHbG5ibHRwWFNCOVhHNGdJQ0FnSUNBZ0lDazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQm9aV0ZrWlhJZ0t6MGdkR2hwY3k1eVpXNWtaWEpsY2k1MFlXSnNaWEp2ZHloalpXeHNLVHRjYmx4dUlDQWdJQ0FnWm05eUlDaHBJRDBnTURzZ2FTQThJSFJvYVhNdWRHOXJaVzR1WTJWc2JITXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ2NtOTNJRDBnZEdocGN5NTBiMnRsYmk1alpXeHNjMXRwWFR0Y2JseHVJQ0FnSUNBZ0lDQmpaV3hzSUQwZ0p5YzdYRzRnSUNBZ0lDQWdJR1p2Y2lBb2FpQTlJREE3SUdvZ1BDQnliM2N1YkdWdVozUm9PeUJxS3lzcElIdGNiaUFnSUNBZ0lDQWdJQ0JqWld4c0lDczlJSFJvYVhNdWNtVnVaR1Z5WlhJdWRHRmliR1ZqWld4c0tGeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXBibXhwYm1VdWIzVjBjSFYwS0hKdmQxdHFYU2tzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjdJR2hsWVdSbGNqb2dabUZzYzJVc0lHRnNhV2R1T2lCMGFHbHpMblJ2YTJWdUxtRnNhV2R1VzJwZElIMWNiaUFnSUNBZ0lDQWdJQ0FwTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdZbTlrZVNBclBTQjBhR2x6TG5KbGJtUmxjbVZ5TG5SaFlteGxjbTkzS0dObGJHd3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WdVpHVnlaWEl1ZEdGaWJHVW9hR1ZoWkdWeUxDQmliMlI1S1R0Y2JpQWdJQ0I5WEc0Z0lDQWdZMkZ6WlNBbllteHZZMnR4ZFc5MFpWOXpkR0Z5ZENjNklIdGNiaUFnSUNBZ0lIWmhjaUJpYjJSNUlEMGdKeWM3WEc1Y2JpQWdJQ0FnSUhkb2FXeGxJQ2gwYUdsekxtNWxlSFFvS1M1MGVYQmxJQ0U5UFNBbllteHZZMnR4ZFc5MFpWOWxibVFuS1NCN1hHNGdJQ0FnSUNBZ0lHSnZaSGtnS3owZ2RHaHBjeTUwYjJzb0tUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WdVpHVnlaWEl1WW14dlkydHhkVzkwWlNoaWIyUjVLVHRjYmlBZ0lDQjlYRzRnSUNBZ1kyRnpaU0FuYkdsemRGOXpkR0Z5ZENjNklIdGNiaUFnSUNBZ0lIWmhjaUJpYjJSNUlEMGdKeWRjYmlBZ0lDQWdJQ0FnTENCdmNtUmxjbVZrSUQwZ2RHaHBjeTUwYjJ0bGJpNXZjbVJsY21Wa08xeHVYRzRnSUNBZ0lDQjNhR2xzWlNBb2RHaHBjeTV1WlhoMEtDa3VkSGx3WlNBaFBUMGdKMnhwYzNSZlpXNWtKeWtnZTF4dUlDQWdJQ0FnSUNCaWIyUjVJQ3M5SUhSb2FYTXVkRzlyS0NrN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkpsYm1SbGNtVnlMbXhwYzNRb1ltOWtlU3dnYjNKa1pYSmxaQ2s3WEc0Z0lDQWdmVnh1SUNBZ0lHTmhjMlVnSjJ4cGMzUmZhWFJsYlY5emRHRnlkQ2M2SUh0Y2JpQWdJQ0FnSUhaaGNpQmliMlI1SUQwZ0p5YzdYRzVjYmlBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG01bGVIUW9LUzUwZVhCbElDRTlQU0FuYkdsemRGOXBkR1Z0WDJWdVpDY3BJSHRjYmlBZ0lDQWdJQ0FnWW05a2VTQXJQU0IwYUdsekxuUnZhMlZ1TG5SNWNHVWdQVDA5SUNkMFpYaDBKMXh1SUNBZ0lDQWdJQ0FnSUQ4Z2RHaHBjeTV3WVhKelpWUmxlSFFvS1Z4dUlDQWdJQ0FnSUNBZ0lEb2dkR2hwY3k1MGIyc29LVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWNtVnVaR1Z5WlhJdWJHbHpkR2wwWlcwb1ltOWtlU2s3WEc0Z0lDQWdmVnh1SUNBZ0lHTmhjMlVnSjJ4dmIzTmxYMmwwWlcxZmMzUmhjblFuT2lCN1hHNGdJQ0FnSUNCMllYSWdZbTlrZVNBOUlDY25PMXh1WEc0Z0lDQWdJQ0IzYUdsc1pTQW9kR2hwY3k1dVpYaDBLQ2t1ZEhsd1pTQWhQVDBnSjJ4cGMzUmZhWFJsYlY5bGJtUW5LU0I3WEc0Z0lDQWdJQ0FnSUdKdlpIa2dLejBnZEdocGN5NTBiMnNvS1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZ1WkdWeVpYSXViR2x6ZEdsMFpXMG9ZbTlrZVNrN1hHNGdJQ0FnZlZ4dUlDQWdJR05oYzJVZ0oyaDBiV3duT2lCN1hHNGdJQ0FnSUNCMllYSWdhSFJ0YkNBOUlDRjBhR2x6TG5SdmEyVnVMbkJ5WlNBbUppQWhkR2hwY3k1dmNIUnBiMjV6TG5CbFpHRnVkR2xqWEc0Z0lDQWdJQ0FnSUQ4Z2RHaHBjeTVwYm14cGJtVXViM1YwY0hWMEtIUm9hWE11ZEc5clpXNHVkR1Y0ZENsY2JpQWdJQ0FnSUNBZ09pQjBhR2x6TG5SdmEyVnVMblJsZUhRN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaVzVrWlhKbGNpNW9kRzFzS0doMGJXd3BPMXh1SUNBZ0lIMWNiaUFnSUNCallYTmxJQ2R3WVhKaFozSmhjR2duT2lCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaVzVrWlhKbGNpNXdZWEpoWjNKaGNHZ29kR2hwY3k1cGJteHBibVV1YjNWMGNIVjBLSFJvYVhNdWRHOXJaVzR1ZEdWNGRDa3BPMXh1SUNBZ0lIMWNiaUFnSUNCallYTmxJQ2QwWlhoMEp6b2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11Y21WdVpHVnlaWEl1Y0dGeVlXZHlZWEJvS0hSb2FYTXVjR0Z5YzJWVVpYaDBLQ2twTzF4dUlDQWdJSDFjYmlBZ2ZWeHVmVHRjYmx4dUx5b3FYRzRnS2lCSVpXeHdaWEp6WEc0Z0tpOWNibHh1Wm5WdVkzUnBiMjRnWlhOallYQmxLR2gwYld3c0lHVnVZMjlrWlNrZ2UxeHVJQ0J5WlhSMWNtNGdhSFJ0YkZ4dUlDQWdJQzV5WlhCc1lXTmxLQ0ZsYm1OdlpHVWdQeUF2SmlnL0lTTS9YRngzS3pzcEwyY2dPaUF2Smk5bkxDQW5KbUZ0Y0RzbktWeHVJQ0FnSUM1eVpYQnNZV05sS0M4OEwyY3NJQ2NtYkhRN0p5bGNiaUFnSUNBdWNtVndiR0ZqWlNndlBpOW5MQ0FuSm1kME95Y3BYRzRnSUNBZ0xuSmxjR3hoWTJVb0wxd2lMMmNzSUNjbWNYVnZkRHNuS1Z4dUlDQWdJQzV5WlhCc1lXTmxLQzhuTDJjc0lDY21Jek01T3ljcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCMWJtVnpZMkZ3WlNob2RHMXNLU0I3WEc0Z0lISmxkSFZ5YmlCb2RHMXNMbkpsY0d4aFkyVW9MeVlvV3lOY1hIZGRLeWs3TDJjc0lHWjFibU4wYVc5dUtGOHNJRzRwSUh0Y2JpQWdJQ0J1SUQwZ2JpNTBiMHh2ZDJWeVEyRnpaU2dwTzF4dUlDQWdJR2xtSUNodUlEMDlQU0FuWTI5c2IyNG5LU0J5WlhSMWNtNGdKem9uTzF4dUlDQWdJR2xtSUNodUxtTm9ZWEpCZENnd0tTQTlQVDBnSnlNbktTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2JpNWphR0Z5UVhRb01Ta2dQVDA5SUNkNEoxeHVJQ0FnSUNBZ0lDQS9JRk4wY21sdVp5NW1jbTl0UTJoaGNrTnZaR1VvY0dGeWMyVkpiblFvYmk1emRXSnpkSEpwYm1jb01pa3NJREUyS1NsY2JpQWdJQ0FnSUNBZ09pQlRkSEpwYm1jdVpuSnZiVU5vWVhKRGIyUmxLQ3R1TG5OMVluTjBjbWx1WnlneEtTazdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUFuSnp0Y2JpQWdmU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJSEpsY0d4aFkyVW9jbVZuWlhnc0lHOXdkQ2tnZTF4dUlDQnlaV2RsZUNBOUlISmxaMlY0TG5OdmRYSmpaVHRjYmlBZ2IzQjBJRDBnYjNCMElIeDhJQ2NuTzF4dUlDQnlaWFIxY200Z1puVnVZM1JwYjI0Z2MyVnNaaWh1WVcxbExDQjJZV3dwSUh0Y2JpQWdJQ0JwWmlBb0lXNWhiV1VwSUhKbGRIVnliaUJ1WlhjZ1VtVm5SWGh3S0hKbFoyVjRMQ0J2Y0hRcE8xeHVJQ0FnSUhaaGJDQTlJSFpoYkM1emIzVnlZMlVnZkh3Z2RtRnNPMXh1SUNBZ0lIWmhiQ0E5SUhaaGJDNXlaWEJzWVdObEtDOG9YbnhiWGx4Y1cxMHBYRnhlTDJjc0lDY2tNU2NwTzF4dUlDQWdJSEpsWjJWNElEMGdjbVZuWlhndWNtVndiR0ZqWlNodVlXMWxMQ0IyWVd3cE8xeHVJQ0FnSUhKbGRIVnliaUJ6Wld4bU8xeHVJQ0I5TzF4dWZWeHVYRzVtZFc1amRHbHZiaUJ1YjI5d0tDa2dlMzFjYm01dmIzQXVaWGhsWXlBOUlHNXZiM0E3WEc1Y2JtWjFibU4wYVc5dUlHMWxjbWRsS0c5aWFpa2dlMXh1SUNCMllYSWdhU0E5SURGY2JpQWdJQ0FzSUhSaGNtZGxkRnh1SUNBZ0lDd2dhMlY1TzF4dVhHNGdJR1p2Y2lBb095QnBJRHdnWVhKbmRXMWxiblJ6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ2RHRnlaMlYwSUQwZ1lYSm5kVzFsYm5SelcybGRPMXh1SUNBZ0lHWnZjaUFvYTJWNUlHbHVJSFJoY21kbGRDa2dlMXh1SUNBZ0lDQWdhV1lnS0U5aWFtVmpkQzV3Y205MGIzUjVjR1V1YUdGelQzZHVVSEp2Y0dWeWRIa3VZMkZzYkNoMFlYSm5aWFFzSUd0bGVTa3BJSHRjYmlBZ0lDQWdJQ0FnYjJKcVcydGxlVjBnUFNCMFlYSm5aWFJiYTJWNVhUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2IySnFPMXh1ZlZ4dVhHNWNiaThxS2x4dUlDb2dUV0Z5YTJWa1hHNGdLaTljYmx4dVpuVnVZM1JwYjI0Z2JXRnlhMlZrS0hOeVl5d2diM0IwTENCallXeHNZbUZqYXlrZ2UxeHVJQ0JwWmlBb1kyRnNiR0poWTJzZ2ZId2dkSGx3Wlc5bUlHOXdkQ0E5UFQwZ0oyWjFibU4wYVc5dUp5a2dlMXh1SUNBZ0lHbG1JQ2doWTJGc2JHSmhZMnNwSUh0Y2JpQWdJQ0FnSUdOaGJHeGlZV05ySUQwZ2IzQjBPMXh1SUNBZ0lDQWdiM0IwSUQwZ2JuVnNiRHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnZjSFFnUFNCdFpYSm5aU2g3ZlN3Z2JXRnlhMlZrTG1SbFptRjFiSFJ6TENCdmNIUWdmSHdnZTMwcE8xeHVYRzRnSUNBZ2RtRnlJR2hwWjJoc2FXZG9kQ0E5SUc5d2RDNW9hV2RvYkdsbmFIUmNiaUFnSUNBZ0lDd2dkRzlyWlc1elhHNGdJQ0FnSUNBc0lIQmxibVJwYm1kY2JpQWdJQ0FnSUN3Z2FTQTlJREE3WEc1Y2JpQWdJQ0IwY25rZ2UxeHVJQ0FnSUNBZ2RHOXJaVzV6SUQwZ1RHVjRaWEl1YkdWNEtITnlZeXdnYjNCMEtWeHVJQ0FnSUgwZ1kyRjBZMmdnS0dVcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCallXeHNZbUZqYXlobEtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCd1pXNWthVzVuSUQwZ2RHOXJaVzV6TG14bGJtZDBhRHRjYmx4dUlDQWdJSFpoY2lCa2IyNWxJRDBnWm5WdVkzUnBiMjRvWlhKeUtTQjdYRzRnSUNBZ0lDQnBaaUFvWlhKeUtTQjdYRzRnSUNBZ0lDQWdJRzl3ZEM1b2FXZG9iR2xuYUhRZ1BTQm9hV2RvYkdsbmFIUTdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmpZV3hzWW1GamF5aGxjbklwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCMllYSWdiM1YwTzF4dVhHNGdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0J2ZFhRZ1BTQlFZWEp6WlhJdWNHRnljMlVvZEc5clpXNXpMQ0J2Y0hRcE8xeHVJQ0FnSUNBZ2ZTQmpZWFJqYUNBb1pTa2dlMXh1SUNBZ0lDQWdJQ0JsY25JZ1BTQmxPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J2Y0hRdWFHbG5hR3hwWjJoMElEMGdhR2xuYUd4cFoyaDBPMXh1WEc0Z0lDQWdJQ0J5WlhSMWNtNGdaWEp5WEc0Z0lDQWdJQ0FnSUQ4Z1kyRnNiR0poWTJzb1pYSnlLVnh1SUNBZ0lDQWdJQ0E2SUdOaGJHeGlZV05yS0c1MWJHd3NJRzkxZENrN1hHNGdJQ0FnZlR0Y2JseHVJQ0FnSUdsbUlDZ2hhR2xuYUd4cFoyaDBJSHg4SUdocFoyaHNhV2RvZEM1c1pXNW5kR2dnUENBektTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1pHOXVaU2dwTzF4dUlDQWdJSDFjYmx4dUlDQWdJR1JsYkdWMFpTQnZjSFF1YUdsbmFHeHBaMmgwTzF4dVhHNGdJQ0FnYVdZZ0tDRndaVzVrYVc1bktTQnlaWFIxY200Z1pHOXVaU2dwTzF4dVhHNGdJQ0FnWm05eUlDZzdJR2tnUENCMGIydGxibk11YkdWdVozUm9PeUJwS3lzcElIdGNiaUFnSUNBZ0lDaG1kVzVqZEdsdmJpaDBiMnRsYmlrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvZEc5clpXNHVkSGx3WlNBaFBUMGdKMk52WkdVbktTQjdYRzRnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQzB0Y0dWdVpHbHVaeUI4ZkNCa2IyNWxLQ2s3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdocFoyaHNhV2RvZENoMGIydGxiaTUwWlhoMExDQjBiMnRsYmk1c1lXNW5MQ0JtZFc1amRHbHZiaWhsY25Jc0lHTnZaR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvWlhKeUtTQnlaWFIxY200Z1pHOXVaU2hsY25JcE8xeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoamIyUmxJRDA5SUc1MWJHd2dmSHdnWTI5a1pTQTlQVDBnZEc5clpXNHVkR1Y0ZENrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJQzB0Y0dWdVpHbHVaeUI4ZkNCa2IyNWxLQ2s3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSFJ2YTJWdUxuUmxlSFFnUFNCamIyUmxPMXh1SUNBZ0lDQWdJQ0FnSUhSdmEyVnVMbVZ6WTJGd1pXUWdQU0IwY25WbE8xeHVJQ0FnSUNBZ0lDQWdJQzB0Y0dWdVpHbHVaeUI4ZkNCa2IyNWxLQ2s3WEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ2ZTa29kRzlyWlc1elcybGRLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWFIxY200N1hHNGdJSDFjYmlBZ2RISjVJSHRjYmlBZ0lDQnBaaUFvYjNCMEtTQnZjSFFnUFNCdFpYSm5aU2g3ZlN3Z2JXRnlhMlZrTG1SbFptRjFiSFJ6TENCdmNIUXBPMXh1SUNBZ0lISmxkSFZ5YmlCUVlYSnpaWEl1Y0dGeWMyVW9UR1Y0WlhJdWJHVjRLSE55WXl3Z2IzQjBLU3dnYjNCMEtUdGNiaUFnZlNCallYUmphQ0FvWlNrZ2UxeHVJQ0FnSUdVdWJXVnpjMkZuWlNBclBTQW5YRnh1VUd4bFlYTmxJSEpsY0c5eWRDQjBhR2x6SUhSdklHaDBkSEJ6T2k4dloybDBhSFZpTG1OdmJTOWphR3BxTDIxaGNtdGxaQzRuTzF4dUlDQWdJR2xtSUNnb2IzQjBJSHg4SUcxaGNtdGxaQzVrWldaaGRXeDBjeWt1YzJsc1pXNTBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdKenh3UGtGdUlHVnljbTl5SUc5alkzVnlaV1E2UEM5d1BqeHdjbVUrSjF4dUlDQWdJQ0FnSUNBcklHVnpZMkZ3WlNobExtMWxjM05oWjJVZ0t5QW5KeXdnZEhKMVpTbGNiaUFnSUNBZ0lDQWdLeUFuUEM5d2NtVStKenRjYmlBZ0lDQjlYRzRnSUNBZ2RHaHliM2NnWlR0Y2JpQWdmVnh1ZlZ4dVhHNHZLaXBjYmlBcUlFOXdkR2x2Ym5OY2JpQXFMMXh1WEc1dFlYSnJaV1F1YjNCMGFXOXVjeUE5WEc1dFlYSnJaV1F1YzJWMFQzQjBhVzl1Y3lBOUlHWjFibU4wYVc5dUtHOXdkQ2tnZTF4dUlDQnRaWEpuWlNodFlYSnJaV1F1WkdWbVlYVnNkSE1zSUc5d2RDazdYRzRnSUhKbGRIVnliaUJ0WVhKclpXUTdYRzU5TzF4dVhHNXRZWEpyWldRdVpHVm1ZWFZzZEhNZ1BTQjdYRzRnSUdkbWJUb2dkSEoxWlN4Y2JpQWdkR0ZpYkdWek9pQjBjblZsTEZ4dUlDQmljbVZoYTNNNklHWmhiSE5sTEZ4dUlDQndaV1JoYm5ScFl6b2dabUZzYzJVc1hHNGdJSE5oYm1sMGFYcGxPaUJtWVd4elpTeGNiaUFnYzJGdWFYUnBlbVZ5T2lCdWRXeHNMRnh1SUNCdFlXNW5iR1U2SUhSeWRXVXNYRzRnSUhOdFlYSjBUR2x6ZEhNNklHWmhiSE5sTEZ4dUlDQnphV3hsYm5RNklHWmhiSE5sTEZ4dUlDQm9hV2RvYkdsbmFIUTZJRzUxYkd3c1hHNGdJR3hoYm1kUWNtVm1hWGc2SUNkc1lXNW5MU2NzWEc0Z0lITnRZWEowZVhCaGJuUnpPaUJtWVd4elpTeGNiaUFnYUdWaFpHVnlVSEpsWm1sNE9pQW5KeXhjYmlBZ2NtVnVaR1Z5WlhJNklHNWxkeUJTWlc1a1pYSmxjaXhjYmlBZ2VHaDBiV3c2SUdaaGJITmxYRzU5TzF4dVhHNHZLaXBjYmlBcUlFVjRjRzl6WlZ4dUlDb3ZYRzVjYm0xaGNtdGxaQzVRWVhKelpYSWdQU0JRWVhKelpYSTdYRzV0WVhKclpXUXVjR0Z5YzJWeUlEMGdVR0Z5YzJWeUxuQmhjbk5sTzF4dVhHNXRZWEpyWldRdVVtVnVaR1Z5WlhJZ1BTQlNaVzVrWlhKbGNqdGNibHh1YldGeWEyVmtMa3hsZUdWeUlEMGdUR1Y0WlhJN1hHNXRZWEpyWldRdWJHVjRaWElnUFNCTVpYaGxjaTVzWlhnN1hHNWNibTFoY210bFpDNUpibXhwYm1WTVpYaGxjaUE5SUVsdWJHbHVaVXhsZUdWeU8xeHViV0Z5YTJWa0xtbHViR2x1WlV4bGVHVnlJRDBnU1c1c2FXNWxUR1Y0WlhJdWIzVjBjSFYwTzF4dVhHNXRZWEpyWldRdWNHRnljMlVnUFNCdFlYSnJaV1E3WEc1Y2JtbG1JQ2gwZVhCbGIyWWdiVzlrZFd4bElDRTlQU0FuZFc1a1pXWnBibVZrSnlBbUppQjBlWEJsYjJZZ1pYaHdiM0owY3lBOVBUMGdKMjlpYW1WamRDY3BJSHRjYmlBZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCdFlYSnJaV1E3WEc1OUlHVnNjMlVnYVdZZ0tIUjVjR1Z2WmlCa1pXWnBibVVnUFQwOUlDZG1kVzVqZEdsdmJpY2dKaVlnWkdWbWFXNWxMbUZ0WkNrZ2UxeHVJQ0JrWldacGJtVW9ablZ1WTNScGIyNG9LU0I3SUhKbGRIVnliaUJ0WVhKclpXUTdJSDBwTzF4dWZTQmxiSE5sSUh0Y2JpQWdkR2hwY3k1dFlYSnJaV1FnUFNCdFlYSnJaV1E3WEc1OVhHNWNibjBwTG1OaGJHd29ablZ1WTNScGIyNG9LU0I3WEc0Z0lISmxkSFZ5YmlCMGFHbHpJSHg4SUNoMGVYQmxiMllnZDJsdVpHOTNJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JSGRwYm1SdmR5QTZJR2RzYjJKaGJDazdYRzU5S0NrcE8xeHVJbDE5IiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtc3xzZWNvbmRzP3xzfG1pbnV0ZXM/fG18aG91cnM/fGh8ZGF5cz98ZHx5ZWFycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiXG4vKipcbiAqIEhPUCByZWYuXG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUmV0dXJuIG93biBrZXlzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmope1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIHZhbHVlcyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmope1xuICB2YXIgdmFscyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG4vKipcbiAqIE1lcmdlIGBiYCBpbnRvIGBhYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYil7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhcy5jYWxsKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJldHVybiBsZW5ndGggb2YgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBleHBvcnRzLmtleXMob2JqKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAwID09IGV4cG9ydHMubGVuZ3RoKG9iaik7XG59OyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5d1lYSnpaV3B6YjI0dmFXNWtaWGd1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFLbHh1SUNvZ1NsTlBUaUJ3WVhKelpTNWNiaUFxWEc0Z0tpQkFjMlZsSUVKaGMyVmtJRzl1SUdwUmRXVnllU053WVhKelpVcFRUMDRnS0UxSlZDa2dZVzVrSUVwVFQwNHlYRzRnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFxTDF4dVhHNTJZWElnY25aaGJHbGtZMmhoY25NZ1BTQXZYbHRjWEYwc09udDlYRnh6WFNva0x6dGNiblpoY2lCeWRtRnNhV1JsYzJOaGNHVWdQU0F2WEZ4Y1hDZy9PbHRjSWx4Y1hGeGNYQzlpWm01eWRGMThkVnN3TFRsaExXWkJMVVpkZXpSOUtTOW5PMXh1ZG1GeUlISjJZV3hwWkhSdmEyVnVjeUE5SUM5Y0lsdGVYQ0pjWEZ4Y1hGeHVYRnh5WFNwY0lueDBjblZsZkdaaGJITmxmRzUxYkd4OExUOWNYR1FyS0Q4NlhGd3VYRnhrS2lrL0tEODZXMlZGWFZzclhGd3RYVDljWEdRcktUOHZaenRjYm5aaGNpQnlkbUZzYVdSaWNtRmpaWE1nUFNBdktEODZYbnc2ZkN3cEtEODZYRnh6S2x4Y1d5a3JMMmM3WEc1MllYSWdjblJ5YVcxTVpXWjBJRDBnTDE1Y1hITXJMenRjYm5aaGNpQnlkSEpwYlZKcFoyaDBJRDBnTDF4Y2N5c2tMenRjYmx4dWJXOWtkV3hsTG1WNGNHOXlkSE1nUFNCbWRXNWpkR2x2YmlCd1lYSnpaV3B6YjI0b1pHRjBZU2tnZTF4dUlDQnBaaUFvSjNOMGNtbHVaeWNnSVQwZ2RIbHdaVzltSUdSaGRHRWdmSHdnSVdSaGRHRXBJSHRjYmlBZ0lDQnlaWFIxY200Z2JuVnNiRHRjYmlBZ2ZWeHVYRzRnSUdSaGRHRWdQU0JrWVhSaExuSmxjR3hoWTJVb2NuUnlhVzFNWldaMExDQW5KeWt1Y21Wd2JHRmpaU2h5ZEhKcGJWSnBaMmgwTENBbkp5azdYRzVjYmlBZ0x5OGdRWFIwWlcxd2RDQjBieUJ3WVhKelpTQjFjMmx1WnlCMGFHVWdibUYwYVhabElFcFRUMDRnY0dGeWMyVnlJR1pwY25OMFhHNGdJR2xtSUNobmJHOWlZV3d1U2xOUFRpQW1KaUJLVTA5T0xuQmhjbk5sS1NCN1hHNGdJQ0FnY21WMGRYSnVJRXBUVDA0dWNHRnljMlVvWkdGMFlTazdYRzRnSUgxY2JseHVJQ0JwWmlBb2NuWmhiR2xrWTJoaGNuTXVkR1Z6ZENoa1lYUmhMbkpsY0d4aFkyVW9jblpoYkdsa1pYTmpZWEJsTENBblFDY3BYRzRnSUNBZ0lDQXVjbVZ3YkdGalpTaHlkbUZzYVdSMGIydGxibk1zSUNkZEp5bGNiaUFnSUNBZ0lDNXlaWEJzWVdObEtISjJZV3hwWkdKeVlXTmxjeXdnSnljcEtTa2dlMXh1SUNBZ0lISmxkSFZ5YmlBb2JtVjNJRVoxYm1OMGFXOXVLQ2R5WlhSMWNtNGdKeUFySUdSaGRHRXBLU2dwTzF4dUlDQjlYRzU5T3lKZGZRPT0iLCIvKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiBxcnk7XG59O1xuIiwiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnXG4gICwgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKVxuICAgICwgdXJpID0ge31cbiAgICAsIGkgPSAxNDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gIH1cblxuICByZXR1cm4gdXJpO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhbk11dGF0aW9uT2JzZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGNhbk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIGhpZGRlbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWV1ZUxpc3QgPSBxdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHF1ZXVlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgneWVzJywgJ25vJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIGlvO1xuXG4gIGlmIChvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHwgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4KSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG5cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcbiAgICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0ZWQsIHNvY2tldCkpIHtcbiAgICAgICAgc2VsZi5jb25uZWN0ZWQucHVzaChzb2NrZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oc29ja2V0KXtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RlZCwgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGVkLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgdmFyIHN1YjtcbiAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbihlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2KXtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcbiAgaWYgKGhhc0JpbihhcmdzKSkgeyBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDsgfSAvLyBiaW5hcnlcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyVHlwZSwgZGF0YTogYXJncyB9O1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGlmIChwYWNrZXQubnNwICE9IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbihpZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICB2YXIgZm4gPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgZm4uYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsKHVyaSwgbG9jKXtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICB2YXIgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3RuYW1lICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIG9iai5ob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBvYmouaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OXpiMk5yWlhRdWFXOHRZMnhwWlc1MEwyeHBZaTkxY213dWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx4dUx5b3FYRzRnS2lCTmIyUjFiR1VnWkdWd1pXNWtaVzVqYVdWekxseHVJQ292WEc1Y2JuWmhjaUJ3WVhKelpYVnlhU0E5SUhKbGNYVnBjbVVvSjNCaGNuTmxkWEpwSnlrN1hHNTJZWElnWkdWaWRXY2dQU0J5WlhGMWFYSmxLQ2RrWldKMVp5Y3BLQ2R6YjJOclpYUXVhVzh0WTJ4cFpXNTBPblZ5YkNjcE8xeHVYRzR2S2lwY2JpQXFJRTF2WkhWc1pTQmxlSEJ2Y25SekxseHVJQ292WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ2RYSnNPMXh1WEc0dktpcGNiaUFxSUZWU1RDQndZWEp6WlhJdVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUh0VGRISnBibWQ5SUhWeWJGeHVJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJRUZ1SUc5aWFtVmpkQ0J0WldGdWRDQjBieUJ0YVcxcFl5QjNhVzVrYjNjdWJHOWpZWFJwYjI0dVhHNGdLaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdSR1ZtWVhWc2RITWdkRzhnZDJsdVpHOTNMbXh2WTJGMGFXOXVMbHh1SUNvZ1FHRndhU0J3ZFdKc2FXTmNiaUFxTDF4dVhHNW1kVzVqZEdsdmJpQjFjbXdvZFhKcExDQnNiMk1wZTF4dUlDQjJZWElnYjJKcUlEMGdkWEpwTzF4dVhHNGdJQzh2SUdSbFptRjFiSFFnZEc4Z2QybHVaRzkzTG14dlkyRjBhVzl1WEc0Z0lIWmhjaUJzYjJNZ1BTQnNiMk1nZkh3Z1oyeHZZbUZzTG14dlkyRjBhVzl1TzF4dUlDQnBaaUFvYm5Wc2JDQTlQU0IxY21rcElIVnlhU0E5SUd4dll5NXdjbTkwYjJOdmJDQXJJQ2N2THljZ0t5QnNiMk11YUc5emREdGNibHh1SUNBdkx5QnlaV3hoZEdsMlpTQndZWFJvSUhOMWNIQnZjblJjYmlBZ2FXWWdLQ2R6ZEhKcGJtY25JRDA5SUhSNWNHVnZaaUIxY21rcElIdGNiaUFnSUNCcFppQW9KeThuSUQwOUlIVnlhUzVqYUdGeVFYUW9NQ2twSUh0Y2JpQWdJQ0FnSUdsbUlDZ25MeWNnUFQwZ2RYSnBMbU5vWVhKQmRDZ3hLU2tnZTF4dUlDQWdJQ0FnSUNCMWNta2dQU0JzYjJNdWNISnZkRzlqYjJ3Z0t5QjFjbWs3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0IxY21rZ1BTQnNiMk11YUc5emRHNWhiV1VnS3lCMWNtazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLQ0V2WGlob2RIUndjejk4ZDNOelB5azZYRnd2WEZ3dkx5NTBaWE4wS0hWeWFTa3BJSHRjYmlBZ0lDQWdJR1JsWW5WbktDZHdjbTkwYjJOdmJDMXNaWE56SUhWeWJDQWxjeWNzSUhWeWFTazdYRzRnSUNBZ0lDQnBaaUFvSjNWdVpHVm1hVzVsWkNjZ0lUMGdkSGx3Wlc5bUlHeHZZeWtnZTF4dUlDQWdJQ0FnSUNCMWNta2dQU0JzYjJNdWNISnZkRzlqYjJ3Z0t5QW5MeThuSUNzZ2RYSnBPMXh1SUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdkWEpwSUQwZ0oyaDBkSEJ6T2k4dkp5QXJJSFZ5YVR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCd1lYSnpaVnh1SUNBZ0lHUmxZblZuS0Nkd1lYSnpaU0FsY3ljc0lIVnlhU2s3WEc0Z0lDQWdiMkpxSUQwZ2NHRnljMlYxY21rb2RYSnBLVHRjYmlBZ2ZWeHVYRzRnSUM4dklHMWhhMlVnYzNWeVpTQjNaU0IwY21WaGRDQmdiRzlqWVd4b2IzTjBPamd3WUNCaGJtUWdZR3h2WTJGc2FHOXpkR0FnWlhGMVlXeHNlVnh1SUNCcFppQW9JVzlpYWk1d2IzSjBLU0I3WEc0Z0lDQWdhV1lnS0M5ZUtHaDBkSEI4ZDNNcEpDOHVkR1Z6ZENodlltb3VjSEp2ZEc5amIyd3BLU0I3WEc0Z0lDQWdJQ0J2WW1vdWNHOXlkQ0E5SUNjNE1DYzdYRzRnSUNBZ2ZWeHVJQ0FnSUdWc2MyVWdhV1lnS0M5ZUtHaDBkSEI4ZDNNcGN5UXZMblJsYzNRb2IySnFMbkJ5YjNSdlkyOXNLU2tnZTF4dUlDQWdJQ0FnYjJKcUxuQnZjblFnUFNBbk5EUXpKenRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0J2WW1vdWNHRjBhQ0E5SUc5aWFpNXdZWFJvSUh4OElDY3ZKenRjYmx4dUlDQXZMeUJrWldacGJtVWdkVzVwY1hWbElHbGtYRzRnSUc5aWFpNXBaQ0E5SUc5aWFpNXdjbTkwYjJOdmJDQXJJQ2M2THk4bklDc2diMkpxTG1odmMzUWdLeUFuT2ljZ0t5QnZZbW91Y0c5eWREdGNiaUFnTHk4Z1pHVm1hVzVsSUdoeVpXWmNiaUFnYjJKcUxtaHlaV1lnUFNCdlltb3VjSEp2ZEc5amIyd2dLeUFuT2k4dkp5QXJJRzlpYWk1b2IzTjBJQ3NnS0d4dll5QW1KaUJzYjJNdWNHOXlkQ0E5UFNCdlltb3VjRzl5ZENBL0lDY25JRG9nS0NjNkp5QXJJRzlpYWk1d2IzSjBLU2s3WEc1Y2JpQWdjbVYwZFhKdUlHOWlhanRjYm4xY2JpSmRmUT09IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgIHJldHVybiBidWY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5emIyTnJaWFF1YVc4dGNHRnljMlZ5TDJKcGJtRnllUzVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFaMnh2WW1Gc0lFSnNiMklzUm1sc1pTb3ZYRzVjYmk4cUtseHVJQ29nVFc5a2RXeGxJSEpsY1hWcGNtVnRaVzUwYzF4dUlDb3ZYRzVjYm5aaGNpQnBjMEZ5Y21GNUlEMGdjbVZ4ZFdseVpTZ25hWE5oY25KaGVTY3BPMXh1ZG1GeUlHbHpRblZtSUQwZ2NtVnhkV2x5WlNnbkxpOXBjeTFpZFdabVpYSW5LVHRjYmx4dUx5b3FYRzRnS2lCU1pYQnNZV05sY3lCbGRtVnllU0JDZFdabVpYSWdmQ0JCY25KaGVVSjFabVpsY2lCcGJpQndZV05yWlhRZ2QybDBhQ0JoSUc1MWJXSmxjbVZrSUhCc1lXTmxhRzlzWkdWeUxseHVJQ29nUVc1NWRHaHBibWNnZDJsMGFDQmliRzlpY3lCdmNpQm1hV3hsY3lCemFHOTFiR1FnWW1VZ1ptVmtJSFJvY205MVoyZ2djbVZ0YjNabFFteHZZbk1nWW1WbWIzSmxJR052YldsdVoxeHVJQ29nYUdWeVpTNWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ2UwOWlhbVZqZEgwZ2NHRmphMlYwSUMwZ2MyOWphMlYwTG1sdklHVjJaVzUwSUhCaFkydGxkRnh1SUNvZ1FISmxkSFZ5YmlCN1QySnFaV04wZlNCM2FYUm9JR1JsWTI5dWMzUnlkV04wWldRZ2NHRmphMlYwSUdGdVpDQnNhWE4wSUc5bUlHSjFabVpsY25OY2JpQXFJRUJoY0drZ2NIVmliR2xqWEc0Z0tpOWNibHh1Wlhod2IzSjBjeTVrWldOdmJuTjBjblZqZEZCaFkydGxkQ0E5SUdaMWJtTjBhVzl1S0hCaFkydGxkQ2w3WEc0Z0lIWmhjaUJpZFdabVpYSnpJRDBnVzEwN1hHNGdJSFpoY2lCd1lXTnJaWFJFWVhSaElEMGdjR0ZqYTJWMExtUmhkR0U3WEc1Y2JpQWdablZ1WTNScGIyNGdYMlJsWTI5dWMzUnlkV04wVUdGamEyVjBLR1JoZEdFcElIdGNiaUFnSUNCcFppQW9JV1JoZEdFcElISmxkSFZ5YmlCa1lYUmhPMXh1WEc0Z0lDQWdhV1lnS0dselFuVm1LR1JoZEdFcEtTQjdYRzRnSUNBZ0lDQjJZWElnY0d4aFkyVm9iMnhrWlhJZ1BTQjdJRjl3YkdGalpXaHZiR1JsY2pvZ2RISjFaU3dnYm5WdE9pQmlkV1ptWlhKekxteGxibWQwYUNCOU8xeHVJQ0FnSUNBZ1luVm1abVZ5Y3k1d2RYTm9LR1JoZEdFcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhCc1lXTmxhRzlzWkdWeU8xeHVJQ0FnSUgwZ1pXeHpaU0JwWmlBb2FYTkJjbkpoZVNoa1lYUmhLU2tnZTF4dUlDQWdJQ0FnZG1GeUlHNWxkMFJoZEdFZ1BTQnVaWGNnUVhKeVlYa29aR0YwWVM1c1pXNW5kR2dwTzF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCa1lYUmhMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lHNWxkMFJoZEdGYmFWMGdQU0JmWkdWamIyNXpkSEoxWTNSUVlXTnJaWFFvWkdGMFlWdHBYU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhSMWNtNGdibVYzUkdGMFlUdGNiaUFnSUNCOUlHVnNjMlVnYVdZZ0tDZHZZbXBsWTNRbklEMDlJSFI1Y0dWdlppQmtZWFJoSUNZbUlDRW9aR0YwWVNCcGJuTjBZVzVqWlc5bUlFUmhkR1VwS1NCN1hHNGdJQ0FnSUNCMllYSWdibVYzUkdGMFlTQTlJSHQ5TzF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYTJWNUlHbHVJR1JoZEdFcElIdGNiaUFnSUNBZ0lDQWdibVYzUkdGMFlWdHJaWGxkSUQwZ1gyUmxZMjl1YzNSeWRXTjBVR0ZqYTJWMEtHUmhkR0ZiYTJWNVhTazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnlaWFIxY200Z2JtVjNSR0YwWVR0Y2JpQWdJQ0I5WEc0Z0lDQWdjbVYwZFhKdUlHUmhkR0U3WEc0Z0lIMWNibHh1SUNCMllYSWdjR0ZqYXlBOUlIQmhZMnRsZER0Y2JpQWdjR0ZqYXk1a1lYUmhJRDBnWDJSbFkyOXVjM1J5ZFdOMFVHRmphMlYwS0hCaFkydGxkRVJoZEdFcE8xeHVJQ0J3WVdOckxtRjBkR0ZqYUcxbGJuUnpJRDBnWW5WbVptVnljeTVzWlc1bmRHZzdJQzh2SUc1MWJXSmxjaUJ2WmlCaWFXNWhjbmtnSjJGMGRHRmphRzFsYm5SekoxeHVJQ0J5WlhSMWNtNGdlM0JoWTJ0bGREb2djR0ZqYXl3Z1luVm1abVZ5Y3pvZ1luVm1abVZ5YzMwN1hHNTlPMXh1WEc0dktpcGNiaUFxSUZKbFkyOXVjM1J5ZFdOMGN5QmhJR0pwYm1GeWVTQndZV05yWlhRZ1puSnZiU0JwZEhNZ2NHeGhZMlZvYjJ4a1pYSWdjR0ZqYTJWMElHRnVaQ0JpZFdabVpYSnpYRzRnS2x4dUlDb2dRSEJoY21GdElIdFBZbXBsWTNSOUlIQmhZMnRsZENBdElHVjJaVzUwSUhCaFkydGxkQ0IzYVhSb0lIQnNZV05sYUc5c1pHVnljMXh1SUNvZ1FIQmhjbUZ0SUh0QmNuSmhlWDBnWW5WbVptVnljeUF0SUdKcGJtRnllU0JpZFdabVpYSnpJSFJ2SUhCMWRDQnBiaUJ3YkdGalpXaHZiR1JsY2lCd2IzTnBkR2x2Ym5OY2JpQXFJRUJ5WlhSMWNtNGdlMDlpYW1WamRIMGdjbVZqYjI1emRISjFZM1JsWkNCd1lXTnJaWFJjYmlBcUlFQmhjR2tnY0hWaWJHbGpYRzRnS2k5Y2JseHVaWGh3YjNKMGN5NXlaV052Ym5OMGNuVmpkRkJoWTJ0bGRDQTlJR1oxYm1OMGFXOXVLSEJoWTJ0bGRDd2dZblZtWm1WeWN5a2dlMXh1SUNCMllYSWdZM1Z5VUd4aFkyVkliMnhrWlhJZ1BTQXdPMXh1WEc0Z0lHWjFibU4wYVc5dUlGOXlaV052Ym5OMGNuVmpkRkJoWTJ0bGRDaGtZWFJoS1NCN1hHNGdJQ0FnYVdZZ0tHUmhkR0VnSmlZZ1pHRjBZUzVmY0d4aFkyVm9iMnhrWlhJcElIdGNiaUFnSUNBZ0lIWmhjaUJpZFdZZ1BTQmlkV1ptWlhKelcyUmhkR0V1Ym5WdFhUc2dMeThnWVhCd2NtOXdjbWxoZEdVZ1luVm1abVZ5SUNoemFHOTFiR1FnWW1VZ2JtRjBkWEpoYkNCdmNtUmxjaUJoYm5sM1lYa3BYRzRnSUNBZ0lDQnlaWFIxY200Z1luVm1PMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9hWE5CY25KaGVTaGtZWFJoS1NrZ2UxeHVJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQmtZWFJoTG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJR1JoZEdGYmFWMGdQU0JmY21WamIyNXpkSEoxWTNSUVlXTnJaWFFvWkdGMFlWdHBYU2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0J5WlhSMWNtNGdaR0YwWVR0Y2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0dSaGRHRWdKaVlnSjI5aWFtVmpkQ2NnUFQwZ2RIbHdaVzltSUdSaGRHRXBJSHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR3RsZVNCcGJpQmtZWFJoS1NCN1hHNGdJQ0FnSUNBZ0lHUmhkR0ZiYTJWNVhTQTlJRjl5WldOdmJuTjBjblZqZEZCaFkydGxkQ2hrWVhSaFcydGxlVjBwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnY21WMGRYSnVJR1JoZEdFN1hHNGdJQ0FnZlZ4dUlDQWdJSEpsZEhWeWJpQmtZWFJoTzF4dUlDQjlYRzVjYmlBZ2NHRmphMlYwTG1SaGRHRWdQU0JmY21WamIyNXpkSEoxWTNSUVlXTnJaWFFvY0dGamEyVjBMbVJoZEdFcE8xeHVJQ0J3WVdOclpYUXVZWFIwWVdOb2JXVnVkSE1nUFNCMWJtUmxabWx1WldRN0lDOHZJRzV2SUd4dmJtZGxjaUIxYzJWbWRXeGNiaUFnY21WMGRYSnVJSEJoWTJ0bGREdGNibjA3WEc1Y2JpOHFLbHh1SUNvZ1FYTjVibU5vY205dWIzVnpiSGtnY21WdGIzWmxjeUJDYkc5aWN5QnZjaUJHYVd4bGN5Qm1jbTl0SUdSaGRHRWdkbWxoWEc0Z0tpQkdhV3hsVW1WaFpHVnlKM01nY21WaFpFRnpRWEp5WVhsQ2RXWm1aWElnYldWMGFHOWtMaUJWYzJWa0lHSmxabTl5WlNCbGJtTnZaR2x1WjF4dUlDb2daR0YwWVNCaGN5QnRjMmR3WVdOckxpQkRZV3hzY3lCallXeHNZbUZqYXlCM2FYUm9JSFJvWlNCaWJHOWliR1Z6Y3lCa1lYUmhMbHh1SUNwY2JpQXFJRUJ3WVhKaGJTQjdUMkpxWldOMGZTQmtZWFJoWEc0Z0tpQkFjR0Z5WVcwZ2UwWjFibU4wYVc5dWZTQmpZV3hzWW1GamExeHVJQ29nUUdGd2FTQndjbWwyWVhSbFhHNGdLaTljYmx4dVpYaHdiM0owY3k1eVpXMXZkbVZDYkc5aWN5QTlJR1oxYm1OMGFXOXVLR1JoZEdFc0lHTmhiR3hpWVdOcktTQjdYRzRnSUdaMWJtTjBhVzl1SUY5eVpXMXZkbVZDYkc5aWN5aHZZbW9zSUdOMWNrdGxlU3dnWTI5dWRHRnBibWx1WjA5aWFtVmpkQ2tnZTF4dUlDQWdJR2xtSUNnaGIySnFLU0J5WlhSMWNtNGdiMkpxTzF4dVhHNGdJQ0FnTHk4Z1kyOXVkbVZ5ZENCaGJua2dZbXh2WWx4dUlDQWdJR2xtSUNnb1oyeHZZbUZzTGtKc2IySWdKaVlnYjJKcUlHbHVjM1JoYm1ObGIyWWdRbXh2WWlrZ2ZIeGNiaUFnSUNBZ0lDQWdLR2RzYjJKaGJDNUdhV3hsSUNZbUlHOWlhaUJwYm5OMFlXNWpaVzltSUVacGJHVXBLU0I3WEc0Z0lDQWdJQ0J3Wlc1a2FXNW5RbXh2WW5Nckt6dGNibHh1SUNBZ0lDQWdMeThnWVhONWJtTWdabWxzWlhKbFlXUmxjbHh1SUNBZ0lDQWdkbUZ5SUdacGJHVlNaV0ZrWlhJZ1BTQnVaWGNnUm1sc1pWSmxZV1JsY2lncE8xeHVJQ0FnSUNBZ1ptbHNaVkpsWVdSbGNpNXZibXh2WVdRZ1BTQm1kVzVqZEdsdmJpZ3BJSHNnTHk4Z2RHaHBjeTV5WlhOMWJIUWdQVDBnWVhKeVlYbGlkV1ptWlhKY2JpQWdJQ0FnSUNBZ2FXWWdLR052Ym5SaGFXNXBibWRQWW1wbFkzUXBJSHRjYmlBZ0lDQWdJQ0FnSUNCamIyNTBZV2x1YVc1blQySnFaV04wVzJOMWNrdGxlVjBnUFNCMGFHbHpMbkpsYzNWc2REdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0JpYkc5aWJHVnpjMFJoZEdFZ1BTQjBhR2x6TG5KbGMzVnNkRHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDOHZJR2xtSUc1dmRHaHBibWNnY0dWdVpHbHVaeUJwZEhNZ1kyRnNiR0poWTJzZ2RHbHRaVnh1SUNBZ0lDQWdJQ0JwWmlnaElDMHRjR1Z1WkdsdVowSnNiMkp6S1NCN1hHNGdJQ0FnSUNBZ0lDQWdZMkZzYkdKaFkyc29ZbXh2WW14bGMzTkVZWFJoS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZUdGNibHh1SUNBZ0lDQWdabWxzWlZKbFlXUmxjaTV5WldGa1FYTkJjbkpoZVVKMVptWmxjaWh2WW1vcE95QXZMeUJpYkc5aUlDMCtJR0Z5Y21GNVluVm1abVZ5WEc0Z0lDQWdmU0JsYkhObElHbG1JQ2hwYzBGeWNtRjVLRzlpYWlrcElIc2dMeThnYUdGdVpHeGxJR0Z5Y21GNVhHNGdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHOWlhaTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQmZjbVZ0YjNabFFteHZZbk1vYjJKcVcybGRMQ0JwTENCdlltb3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9iMkpxSUNZbUlDZHZZbXBsWTNRbklEMDlJSFI1Y0dWdlppQnZZbW9nSmlZZ0lXbHpRblZtS0c5aWFpa3BJSHNnTHk4Z1lXNWtJRzlpYW1WamRGeHVJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2EyVjVJR2x1SUc5aWFpa2dlMXh1SUNBZ0lDQWdJQ0JmY21WdGIzWmxRbXh2WW5Nb2IySnFXMnRsZVYwc0lHdGxlU3dnYjJKcUtUdGNiaUFnSUNBZ0lIMWNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQjJZWElnY0dWdVpHbHVaMEpzYjJKeklEMGdNRHRjYmlBZ2RtRnlJR0pzYjJKc1pYTnpSR0YwWVNBOUlHUmhkR0U3WEc0Z0lGOXlaVzF2ZG1WQ2JHOWljeWhpYkc5aWJHVnpjMFJoZEdFcE8xeHVJQ0JwWmlBb0lYQmxibVJwYm1kQ2JHOWljeWtnZTF4dUlDQWdJR05oYkd4aVlXTnJLR0pzYjJKc1pYTnpSR0YwWVNrN1hHNGdJSDFjYm4wN1hHNGlYWDA9IiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGpzb24gPSByZXF1aXJlKCdqc29uMycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0FDSycsXG4gICdCSU5BUllfQUNLJyxcbiAgJ0VSUk9SJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHRyeSB7XG4gICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5emIyTnJaWFF1YVc4dGNHRnljMlZ5TDJsekxXSjFabVpsY2k1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR2x6UW5WbU8xeHVYRzR2S2lwY2JpQXFJRkpsZEhWeWJuTWdkSEoxWlNCcFppQnZZbW9nYVhNZ1lTQmlkV1ptWlhJZ2IzSWdZVzRnWVhKeVlYbGlkV1ptWlhJdVhHNGdLbHh1SUNvZ1FHRndhU0J3Y21sMllYUmxYRzRnS2k5Y2JseHVablZ1WTNScGIyNGdhWE5DZFdZb2IySnFLU0I3WEc0Z0lISmxkSFZ5YmlBb1oyeHZZbUZzTGtKMVptWmxjaUFtSmlCbmJHOWlZV3d1UW5WbVptVnlMbWx6UW5WbVptVnlLRzlpYWlrcElIeDhYRzRnSUNBZ0lDQWdJQ0FvWjJ4dlltRnNMa0Z5Y21GNVFuVm1abVZ5SUNZbUlHOWlhaUJwYm5OMFlXNWpaVzltSUVGeWNtRjVRblZtWm1WeUtUdGNibjFjYmlKZGZRPT0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTl6ZEhKbFlXMHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdmNtVmhaR0ZpYkdVdGMzUnlaV0Z0TDJ4cFlpOWZjM1J5WldGdFgyUjFjR3hsZUM1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQklpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUl2THlCRGIzQjVjbWxuYUhRZ1NtOTVaVzUwTENCSmJtTXVJR0Z1WkNCdmRHaGxjaUJPYjJSbElHTnZiblJ5YVdKMWRHOXljeTVjYmk4dlhHNHZMeUJRWlhKdGFYTnphVzl1SUdseklHaGxjbVZpZVNCbmNtRnVkR1ZrTENCbWNtVmxJRzltSUdOb1lYSm5aU3dnZEc4Z1lXNTVJSEJsY25OdmJpQnZZblJoYVc1cGJtY2dZVnh1THk4Z1kyOXdlU0J2WmlCMGFHbHpJSE52Wm5SM1lYSmxJR0Z1WkNCaGMzTnZZMmxoZEdWa0lHUnZZM1Z0Wlc1MFlYUnBiMjRnWm1sc1pYTWdLSFJvWlZ4dUx5OGdYQ0pUYjJaMGQyRnlaVndpS1N3Z2RHOGdaR1ZoYkNCcGJpQjBhR1VnVTI5bWRIZGhjbVVnZDJsMGFHOTFkQ0J5WlhOMGNtbGpkR2x2Yml3Z2FXNWpiSFZrYVc1blhHNHZMeUIzYVhSb2IzVjBJR3hwYldsMFlYUnBiMjRnZEdobElISnBaMmgwY3lCMGJ5QjFjMlVzSUdOdmNIa3NJRzF2WkdsbWVTd2diV1Z5WjJVc0lIQjFZbXhwYzJnc1hHNHZMeUJrYVhOMGNtbGlkWFJsTENCemRXSnNhV05sYm5ObExDQmhibVF2YjNJZ2MyVnNiQ0JqYjNCcFpYTWdiMllnZEdobElGTnZablIzWVhKbExDQmhibVFnZEc4Z2NHVnliV2wwWEc0dkx5QndaWEp6YjI1eklIUnZJSGRvYjIwZ2RHaGxJRk52Wm5SM1lYSmxJR2x6SUdaMWNtNXBjMmhsWkNCMGJ5QmtieUJ6Ynl3Z2MzVmlhbVZqZENCMGJ5QjBhR1ZjYmk4dklHWnZiR3h2ZDJsdVp5QmpiMjVrYVhScGIyNXpPbHh1THk5Y2JpOHZJRlJvWlNCaFltOTJaU0JqYjNCNWNtbG5hSFFnYm05MGFXTmxJR0Z1WkNCMGFHbHpJSEJsY20xcGMzTnBiMjRnYm05MGFXTmxJSE5vWVd4c0lHSmxJR2x1WTJ4MVpHVmtYRzR2THlCcGJpQmhiR3dnWTI5d2FXVnpJRzl5SUhOMVluTjBZVzUwYVdGc0lIQnZjblJwYjI1eklHOW1JSFJvWlNCVGIyWjBkMkZ5WlM1Y2JpOHZYRzR2THlCVVNFVWdVMDlHVkZkQlVrVWdTVk1nVUZKUFZrbEVSVVFnWENKQlV5QkpVMXdpTENCWFNWUklUMVZVSUZkQlVsSkJUbFJaSUU5R0lFRk9XU0JMU1U1RUxDQkZXRkJTUlZOVFhHNHZMeUJQVWlCSlRWQk1TVVZFTENCSlRrTk1WVVJKVGtjZ1FsVlVJRTVQVkNCTVNVMUpWRVZFSUZSUElGUklSU0JYUVZKU1FVNVVTVVZUSUU5R1hHNHZMeUJOUlZKRFNFRk9WRUZDU1V4SlZGa3NJRVpKVkU1RlUxTWdSazlTSUVFZ1VFRlNWRWxEVlV4QlVpQlFWVkpRVDFORklFRk9SQ0JPVDA1SlRrWlNTVTVIUlUxRlRsUXVJRWxPWEc0dkx5Qk9UeUJGVmtWT1ZDQlRTRUZNVENCVVNFVWdRVlZVU0U5U1V5QlBVaUJEVDFCWlVrbEhTRlFnU0U5TVJFVlNVeUJDUlNCTVNVRkNURVVnUms5U0lFRk9XU0JEVEVGSlRTeGNiaTh2SUVSQlRVRkhSVk1nVDFJZ1QxUklSVklnVEVsQlFrbE1TVlJaTENCWFNFVlVTRVZTSUVsT0lFRk9JRUZEVkVsUFRpQlBSaUJEVDA1VVVrRkRWQ3dnVkU5U1ZDQlBVbHh1THk4Z1QxUklSVkpYU1ZORkxDQkJVa2xUU1U1SElFWlNUMDBzSUU5VlZDQlBSaUJQVWlCSlRpQkRUMDVPUlVOVVNVOU9JRmRKVkVnZ1ZFaEZJRk5QUmxSWFFWSkZJRTlTSUZSSVJWeHVMeThnVlZORklFOVNJRTlVU0VWU0lFUkZRVXhKVGtkVElFbE9JRlJJUlNCVFQwWlVWMEZTUlM1Y2JseHVMeThnWVNCa2RYQnNaWGdnYzNSeVpXRnRJR2x6SUdwMWMzUWdZU0J6ZEhKbFlXMGdkR2hoZENCcGN5QmliM1JvSUhKbFlXUmhZbXhsSUdGdVpDQjNjbWwwWVdKc1pTNWNiaTh2SUZOcGJtTmxJRXBUSUdSdlpYTnVKM1FnYUdGMlpTQnRkV3gwYVhCc1pTQndjbTkwYjNSNWNHRnNJR2x1YUdWeWFYUmhibU5sTENCMGFHbHpJR05zWVhOelhHNHZMeUJ3Y205MGIzUjVjR0ZzYkhrZ2FXNW9aWEpwZEhNZ1puSnZiU0JTWldGa1lXSnNaU3dnWVc1a0lIUm9aVzRnY0dGeVlYTnBkR2xqWVd4c2VTQm1jbTl0WEc0dkx5QlhjbWwwWVdKc1pTNWNibHh1Ylc5a2RXeGxMbVY0Y0c5eWRITWdQU0JFZFhCc1pYZzdYRzVjYmk4cVBISmxjR3hoWTJWdFpXNTBQaW92WEc1MllYSWdiMkpxWldOMFMyVjVjeUE5SUU5aWFtVmpkQzVyWlhseklIeDhJR1oxYm1OMGFXOXVJQ2h2WW1vcElIdGNiaUFnZG1GeUlHdGxlWE1nUFNCYlhUdGNiaUFnWm05eUlDaDJZWElnYTJWNUlHbHVJRzlpYWlrZ2EyVjVjeTV3ZFhOb0tHdGxlU2s3WEc0Z0lISmxkSFZ5YmlCclpYbHpPMXh1ZlZ4dUx5bzhMM0psY0d4aFkyVnRaVzUwUGlvdlhHNWNibHh1THlvOGNtVndiR0ZqWlcxbGJuUStLaTljYm5aaGNpQjFkR2xzSUQwZ2NtVnhkV2x5WlNnblkyOXlaUzExZEdsc0xXbHpKeWs3WEc1MWRHbHNMbWx1YUdWeWFYUnpJRDBnY21WeGRXbHlaU2duYVc1b1pYSnBkSE1uS1R0Y2JpOHFQQzl5WlhCc1lXTmxiV1Z1ZEQ0cUwxeHVYRzUyWVhJZ1VtVmhaR0ZpYkdVZ1BTQnlaWEYxYVhKbEtDY3VMMTl6ZEhKbFlXMWZjbVZoWkdGaWJHVW5LVHRjYm5aaGNpQlhjbWwwWVdKc1pTQTlJSEpsY1hWcGNtVW9KeTR2WDNOMGNtVmhiVjkzY21sMFlXSnNaU2NwTzF4dVhHNTFkR2xzTG1sdWFHVnlhWFJ6S0VSMWNHeGxlQ3dnVW1WaFpHRmliR1VwTzF4dVhHNW1iM0pGWVdOb0tHOWlhbVZqZEV0bGVYTW9WM0pwZEdGaWJHVXVjSEp2ZEc5MGVYQmxLU3dnWm5WdVkzUnBiMjRvYldWMGFHOWtLU0I3WEc0Z0lHbG1JQ2doUkhWd2JHVjRMbkJ5YjNSdmRIbHdaVnR0WlhSb2IyUmRLVnh1SUNBZ0lFUjFjR3hsZUM1d2NtOTBiM1I1Y0dWYmJXVjBhRzlrWFNBOUlGZHlhWFJoWW14bExuQnliM1J2ZEhsd1pWdHRaWFJvYjJSZE8xeHVmU2s3WEc1Y2JtWjFibU4wYVc5dUlFUjFjR3hsZUNodmNIUnBiMjV6S1NCN1hHNGdJR2xtSUNnaEtIUm9hWE1nYVc1emRHRnVZMlZ2WmlCRWRYQnNaWGdwS1Z4dUlDQWdJSEpsZEhWeWJpQnVaWGNnUkhWd2JHVjRLRzl3ZEdsdmJuTXBPMXh1WEc0Z0lGSmxZV1JoWW14bExtTmhiR3dvZEdocGN5d2diM0IwYVc5dWN5azdYRzRnSUZkeWFYUmhZbXhsTG1OaGJHd29kR2hwY3l3Z2IzQjBhVzl1Y3lrN1hHNWNiaUFnYVdZZ0tHOXdkR2x2Ym5NZ0ppWWdiM0IwYVc5dWN5NXlaV0ZrWVdKc1pTQTlQVDBnWm1Gc2MyVXBYRzRnSUNBZ2RHaHBjeTV5WldGa1lXSnNaU0E5SUdaaGJITmxPMXh1WEc0Z0lHbG1JQ2h2Y0hScGIyNXpJQ1ltSUc5d2RHbHZibk11ZDNKcGRHRmliR1VnUFQwOUlHWmhiSE5sS1Z4dUlDQWdJSFJvYVhNdWQzSnBkR0ZpYkdVZ1BTQm1ZV3h6WlR0Y2JseHVJQ0IwYUdsekxtRnNiRzkzU0dGc1prOXdaVzRnUFNCMGNuVmxPMXh1SUNCcFppQW9iM0IwYVc5dWN5QW1KaUJ2Y0hScGIyNXpMbUZzYkc5M1NHRnNaazl3Wlc0Z1BUMDlJR1poYkhObEtWeHVJQ0FnSUhSb2FYTXVZV3hzYjNkSVlXeG1UM0JsYmlBOUlHWmhiSE5sTzF4dVhHNGdJSFJvYVhNdWIyNWpaU2duWlc1a0p5d2diMjVsYm1RcE8xeHVmVnh1WEc0dkx5QjBhR1VnYm04dGFHRnNaaTF2Y0dWdUlHVnVabTl5WTJWeVhHNW1kVzVqZEdsdmJpQnZibVZ1WkNncElIdGNiaUFnTHk4Z2FXWWdkMlVnWVd4c2IzY2dhR0ZzWmkxdmNHVnVJSE4wWVhSbExDQnZjaUJwWmlCMGFHVWdkM0pwZEdGaWJHVWdjMmxrWlNCbGJtUmxaQ3hjYmlBZ0x5OGdkR2hsYmlCM1pTZHlaU0J2YXk1Y2JpQWdhV1lnS0hSb2FYTXVZV3hzYjNkSVlXeG1UM0JsYmlCOGZDQjBhR2x6TGw5M2NtbDBZV0pzWlZOMFlYUmxMbVZ1WkdWa0tWeHVJQ0FnSUhKbGRIVnlianRjYmx4dUlDQXZMeUJ1YnlCdGIzSmxJR1JoZEdFZ1kyRnVJR0psSUhkeWFYUjBaVzR1WEc0Z0lDOHZJRUoxZENCaGJHeHZkeUJ0YjNKbElIZHlhWFJsY3lCMGJ5Qm9ZWEJ3Wlc0Z2FXNGdkR2hwY3lCMGFXTnJMbHh1SUNCd2NtOWpaWE56TG01bGVIUlVhV05yS0hSb2FYTXVaVzVrTG1KcGJtUW9kR2hwY3lrcE8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCbWIzSkZZV05vSUNoNGN5d2daaWtnZTF4dUlDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JDQTlJSGh6TG14bGJtZDBhRHNnYVNBOElHdzdJR2tyS3lrZ2UxeHVJQ0FnSUdZb2VITmJhVjBzSUdrcE8xeHVJQ0I5WEc1OVhHNGlYWDA9IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWcgPSByZXF1aXJlKCd1dGlsJyk7XG5pZiAoZGVidWcgJiYgZGVidWcuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChpc05hTihuKSB8fCB1dGlsLmlzTnVsbChuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKCF1dGlsLmlzTnVtYmVyKG4pIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHV0aWwuaXNOdWxsKHJldCkpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbChyZXQpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJyxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICAgICAgICAgIHNlbGYucmVhZCgwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgfVxuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcbiAgfVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbihzdHJlYW1baV0pICYmIHV0aWwuaXNVbmRlZmluZWQodGhpc1tpXSkpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTl6ZEhKbFlXMHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdmNtVmhaR0ZpYkdVdGMzUnlaV0Z0TDJ4cFlpOWZjM1J5WldGdFgzSmxZV1JoWW14bExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpTHk4Z1EyOXdlWEpwWjJoMElFcHZlV1Z1ZEN3Z1NXNWpMaUJoYm1RZ2IzUm9aWElnVG05a1pTQmpiMjUwY21saWRYUnZjbk11WEc0dkwxeHVMeThnVUdWeWJXbHpjMmx2YmlCcGN5Qm9aWEpsWW5rZ1ozSmhiblJsWkN3Z1puSmxaU0J2WmlCamFHRnlaMlVzSUhSdklHRnVlU0J3WlhKemIyNGdiMkowWVdsdWFXNW5JR0ZjYmk4dklHTnZjSGtnYjJZZ2RHaHBjeUJ6YjJaMGQyRnlaU0JoYm1RZ1lYTnpiMk5wWVhSbFpDQmtiMk4xYldWdWRHRjBhVzl1SUdacGJHVnpJQ2gwYUdWY2JpOHZJRndpVTI5bWRIZGhjbVZjSWlrc0lIUnZJR1JsWVd3Z2FXNGdkR2hsSUZOdlpuUjNZWEpsSUhkcGRHaHZkWFFnY21WemRISnBZM1JwYjI0c0lHbHVZMngxWkdsdVoxeHVMeThnZDJsMGFHOTFkQ0JzYVcxcGRHRjBhVzl1SUhSb1pTQnlhV2RvZEhNZ2RHOGdkWE5sTENCamIzQjVMQ0J0YjJScFpua3NJRzFsY21kbExDQndkV0pzYVhOb0xGeHVMeThnWkdsemRISnBZblYwWlN3Z2MzVmliR2xqWlc1elpTd2dZVzVrTDI5eUlITmxiR3dnWTI5d2FXVnpJRzltSUhSb1pTQlRiMlowZDJGeVpTd2dZVzVrSUhSdklIQmxjbTFwZEZ4dUx5OGdjR1Z5YzI5dWN5QjBieUIzYUc5dElIUm9aU0JUYjJaMGQyRnlaU0JwY3lCbWRYSnVhWE5vWldRZ2RHOGdaRzhnYzI4c0lITjFZbXBsWTNRZ2RHOGdkR2hsWEc0dkx5Qm1iMnhzYjNkcGJtY2dZMjl1WkdsMGFXOXVjenBjYmk4dlhHNHZMeUJVYUdVZ1lXSnZkbVVnWTI5d2VYSnBaMmgwSUc1dmRHbGpaU0JoYm1RZ2RHaHBjeUJ3WlhKdGFYTnphVzl1SUc1dmRHbGpaU0J6YUdGc2JDQmlaU0JwYm1Oc2RXUmxaRnh1THk4Z2FXNGdZV3hzSUdOdmNHbGxjeUJ2Y2lCemRXSnpkR0Z1ZEdsaGJDQndiM0owYVc5dWN5QnZaaUIwYUdVZ1UyOW1kSGRoY21VdVhHNHZMMXh1THk4Z1ZFaEZJRk5QUmxSWFFWSkZJRWxUSUZCU1QxWkpSRVZFSUZ3aVFWTWdTVk5jSWl3Z1YwbFVTRTlWVkNCWFFWSlNRVTVVV1NCUFJpQkJUbGtnUzBsT1JDd2dSVmhRVWtWVFUxeHVMeThnVDFJZ1NVMVFURWxGUkN3Z1NVNURURlZFU1U1SElFSlZWQ0JPVDFRZ1RFbE5TVlJGUkNCVVR5QlVTRVVnVjBGU1VrRk9WRWxGVXlCUFJseHVMeThnVFVWU1EwaEJUbFJCUWtsTVNWUlpMQ0JHU1ZST1JWTlRJRVpQVWlCQklGQkJVbFJKUTFWTVFWSWdVRlZTVUU5VFJTQkJUa1FnVGs5T1NVNUdVa2xPUjBWTlJVNVVMaUJKVGx4dUx5OGdUazhnUlZaRlRsUWdVMGhCVEV3Z1ZFaEZJRUZWVkVoUFVsTWdUMUlnUTA5UVdWSkpSMGhVSUVoUFRFUkZVbE1nUWtVZ1RFbEJRa3hGSUVaUFVpQkJUbGtnUTB4QlNVMHNYRzR2THlCRVFVMUJSMFZUSUU5U0lFOVVTRVZTSUV4SlFVSkpURWxVV1N3Z1YwaEZWRWhGVWlCSlRpQkJUaUJCUTFSSlQwNGdUMFlnUTA5T1ZGSkJRMVFzSUZSUFVsUWdUMUpjYmk4dklFOVVTRVZTVjBsVFJTd2dRVkpKVTBsT1J5QkdVazlOTENCUFZWUWdUMFlnVDFJZ1NVNGdRMDlPVGtWRFZFbFBUaUJYU1ZSSUlGUklSU0JUVDBaVVYwRlNSU0JQVWlCVVNFVmNiaTh2SUZWVFJTQlBVaUJQVkVoRlVpQkVSVUZNU1U1SFV5QkpUaUJVU0VVZ1UwOUdWRmRCVWtVdVhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdVbVZoWkdGaWJHVTdYRzVjYmk4cVBISmxjR3hoWTJWdFpXNTBQaW92WEc1MllYSWdhWE5CY25KaGVTQTlJSEpsY1hWcGNtVW9KMmx6WVhKeVlYa25LVHRjYmk4cVBDOXlaWEJzWVdObGJXVnVkRDRxTDF4dVhHNWNiaThxUEhKbGNHeGhZMlZ0Wlc1MFBpb3ZYRzUyWVhJZ1FuVm1abVZ5SUQwZ2NtVnhkV2x5WlNnblluVm1abVZ5SnlrdVFuVm1abVZ5TzF4dUx5bzhMM0psY0d4aFkyVnRaVzUwUGlvdlhHNWNibEpsWVdSaFlteGxMbEpsWVdSaFlteGxVM1JoZEdVZ1BTQlNaV0ZrWVdKc1pWTjBZWFJsTzF4dVhHNTJZWElnUlVVZ1BTQnlaWEYxYVhKbEtDZGxkbVZ1ZEhNbktTNUZkbVZ1ZEVWdGFYUjBaWEk3WEc1Y2JpOHFQSEpsY0d4aFkyVnRaVzUwUGlvdlhHNXBaaUFvSVVWRkxteHBjM1JsYm1WeVEyOTFiblFwSUVWRkxteHBjM1JsYm1WeVEyOTFiblFnUFNCbWRXNWpkR2x2YmlobGJXbDBkR1Z5TENCMGVYQmxLU0I3WEc0Z0lISmxkSFZ5YmlCbGJXbDBkR1Z5TG14cGMzUmxibVZ5Y3loMGVYQmxLUzVzWlc1bmRHZzdYRzU5TzF4dUx5bzhMM0psY0d4aFkyVnRaVzUwUGlvdlhHNWNiblpoY2lCVGRISmxZVzBnUFNCeVpYRjFhWEpsS0NkemRISmxZVzBuS1R0Y2JseHVMeW84Y21Wd2JHRmpaVzFsYm5RK0tpOWNiblpoY2lCMWRHbHNJRDBnY21WeGRXbHlaU2duWTI5eVpTMTFkR2xzTFdsekp5azdYRzUxZEdsc0xtbHVhR1Z5YVhSeklEMGdjbVZ4ZFdseVpTZ25hVzVvWlhKcGRITW5LVHRjYmk4cVBDOXlaWEJzWVdObGJXVnVkRDRxTDF4dVhHNTJZWElnVTNSeWFXNW5SR1ZqYjJSbGNqdGNibHh1WEc0dktqeHlaWEJzWVdObGJXVnVkRDRxTDF4dWRtRnlJR1JsWW5WbklEMGdjbVZ4ZFdseVpTZ25kWFJwYkNjcE8xeHVhV1lnS0dSbFluVm5JQ1ltSUdSbFluVm5MbVJsWW5WbmJHOW5LU0I3WEc0Z0lHUmxZblZuSUQwZ1pHVmlkV2N1WkdWaWRXZHNiMmNvSjNOMGNtVmhiU2NwTzF4dWZTQmxiSE5sSUh0Y2JpQWdaR1ZpZFdjZ1BTQm1kVzVqZEdsdmJpQW9LU0I3ZlR0Y2JuMWNiaThxUEM5eVpYQnNZV05sYldWdWRENHFMMXh1WEc1Y2JuVjBhV3d1YVc1b1pYSnBkSE1vVW1WaFpHRmliR1VzSUZOMGNtVmhiU2s3WEc1Y2JtWjFibU4wYVc5dUlGSmxZV1JoWW14bFUzUmhkR1VvYjNCMGFXOXVjeXdnYzNSeVpXRnRLU0I3WEc0Z0lIWmhjaUJFZFhCc1pYZ2dQU0J5WlhGMWFYSmxLQ2N1TDE5emRISmxZVzFmWkhWd2JHVjRKeWs3WEc1Y2JpQWdiM0IwYVc5dWN5QTlJRzl3ZEdsdmJuTWdmSHdnZTMwN1hHNWNiaUFnTHk4Z2RHaGxJSEJ2YVc1MElHRjBJSGRvYVdOb0lHbDBJSE4wYjNCeklHTmhiR3hwYm1jZ1gzSmxZV1FvS1NCMGJ5Qm1hV3hzSUhSb1pTQmlkV1ptWlhKY2JpQWdMeThnVG05MFpUb2dNQ0JwY3lCaElIWmhiR2xrSUhaaGJIVmxMQ0J0WldGdWN5QmNJbVJ2YmlkMElHTmhiR3dnWDNKbFlXUWdjSEpsWlcxd2RHbDJaV3g1SUdWMlpYSmNJbHh1SUNCMllYSWdhSGR0SUQwZ2IzQjBhVzl1Y3k1b2FXZG9WMkYwWlhKTllYSnJPMXh1SUNCMllYSWdaR1ZtWVhWc2RFaDNiU0E5SUc5d2RHbHZibk11YjJKcVpXTjBUVzlrWlNBL0lERTJJRG9nTVRZZ0tpQXhNREkwTzF4dUlDQjBhR2x6TG1ocFoyaFhZWFJsY2sxaGNtc2dQU0FvYUhkdElIeDhJR2gzYlNBOVBUMGdNQ2tnUHlCb2QyMGdPaUJrWldaaGRXeDBTSGR0TzF4dVhHNGdJQzh2SUdOaGMzUWdkRzhnYVc1MGN5NWNiaUFnZEdocGN5NW9hV2RvVjJGMFpYSk5ZWEpySUQwZ2ZuNTBhR2x6TG1ocFoyaFhZWFJsY2sxaGNtczdYRzVjYmlBZ2RHaHBjeTVpZFdabVpYSWdQU0JiWFR0Y2JpQWdkR2hwY3k1c1pXNW5kR2dnUFNBd08xeHVJQ0IwYUdsekxuQnBjR1Z6SUQwZ2JuVnNiRHRjYmlBZ2RHaHBjeTV3YVhCbGMwTnZkVzUwSUQwZ01EdGNiaUFnZEdocGN5NW1iRzkzYVc1bklEMGdiblZzYkR0Y2JpQWdkR2hwY3k1bGJtUmxaQ0E5SUdaaGJITmxPMXh1SUNCMGFHbHpMbVZ1WkVWdGFYUjBaV1FnUFNCbVlXeHpaVHRjYmlBZ2RHaHBjeTV5WldGa2FXNW5JRDBnWm1Gc2MyVTdYRzVjYmlBZ0x5OGdZU0JtYkdGbklIUnZJR0psSUdGaWJHVWdkRzhnZEdWc2JDQnBaaUIwYUdVZ2IyNTNjbWwwWlNCallpQnBjeUJqWVd4c1pXUWdhVzF0WldScFlYUmxiSGtzWEc0Z0lDOHZJRzl5SUc5dUlHRWdiR0YwWlhJZ2RHbGpheTRnSUZkbElITmxkQ0IwYUdseklIUnZJSFJ5ZFdVZ1lYUWdabWx5YzNRc0lHSmxZMkYxYzJVZ1lXNTVYRzRnSUM4dklHRmpkR2x2Ym5NZ2RHaGhkQ0J6YUc5MWJHUnVKM1FnYUdGd2NHVnVJSFZ1ZEdsc0lGd2liR0YwWlhKY0lpQnphRzkxYkdRZ1oyVnVaWEpoYkd4NUlHRnNjMjljYmlBZ0x5OGdibTkwSUdoaGNIQmxiaUJpWldadmNtVWdkR2hsSUdacGNuTjBJSGR5YVhSbElHTmhiR3d1WEc0Z0lIUm9hWE11YzNsdVl5QTlJSFJ5ZFdVN1hHNWNiaUFnTHk4Z2QyaGxibVYyWlhJZ2QyVWdjbVYwZFhKdUlHNTFiR3dzSUhSb1pXNGdkMlVnYzJWMElHRWdabXhoWnlCMGJ5QnpZWGxjYmlBZ0x5OGdkR2hoZENCM1pTZHlaU0JoZDJGcGRHbHVaeUJoSUNkeVpXRmtZV0pzWlNjZ1pYWmxiblFnWlcxcGMzTnBiMjR1WEc0Z0lIUm9hWE11Ym1WbFpGSmxZV1JoWW14bElEMGdabUZzYzJVN1hHNGdJSFJvYVhNdVpXMXBkSFJsWkZKbFlXUmhZbXhsSUQwZ1ptRnNjMlU3WEc0Z0lIUm9hWE11Y21WaFpHRmliR1ZNYVhOMFpXNXBibWNnUFNCbVlXeHpaVHRjYmx4dVhHNGdJQzh2SUc5aWFtVmpkQ0J6ZEhKbFlXMGdabXhoWnk0Z1ZYTmxaQ0IwYnlCdFlXdGxJSEpsWVdRb2Jpa2dhV2R1YjNKbElHNGdZVzVrSUhSdlhHNGdJQzh2SUcxaGEyVWdZV3hzSUhSb1pTQmlkV1ptWlhJZ2JXVnlaMmx1WnlCaGJtUWdiR1Z1WjNSb0lHTm9aV05yY3lCbmJ5QmhkMkY1WEc0Z0lIUm9hWE11YjJKcVpXTjBUVzlrWlNBOUlDRWhiM0IwYVc5dWN5NXZZbXBsWTNSTmIyUmxPMXh1WEc0Z0lHbG1JQ2h6ZEhKbFlXMGdhVzV6ZEdGdVkyVnZaaUJFZFhCc1pYZ3BYRzRnSUNBZ2RHaHBjeTV2WW1wbFkzUk5iMlJsSUQwZ2RHaHBjeTV2WW1wbFkzUk5iMlJsSUh4OElDRWhiM0IwYVc5dWN5NXlaV0ZrWVdKc1pVOWlhbVZqZEUxdlpHVTdYRzVjYmlBZ0x5OGdRM0o1Y0hSdklHbHpJR3RwYm1RZ2IyWWdiMnhrSUdGdVpDQmpjblZ6ZEhrdUlDQklhWE4wYjNKcFkyRnNiSGtzSUdsMGN5QmtaV1poZFd4MElITjBjbWx1WjF4dUlDQXZMeUJsYm1OdlpHbHVaeUJwY3lBblltbHVZWEo1SnlCemJ5QjNaU0JvWVhabElIUnZJRzFoYTJVZ2RHaHBjeUJqYjI1bWFXZDFjbUZpYkdVdVhHNGdJQzh2SUVWMlpYSjVkR2hwYm1jZ1pXeHpaU0JwYmlCMGFHVWdkVzVwZG1WeWMyVWdkWE5sY3lBbmRYUm1PQ2NzSUhSb2IzVm5hQzVjYmlBZ2RHaHBjeTVrWldaaGRXeDBSVzVqYjJScGJtY2dQU0J2Y0hScGIyNXpMbVJsWm1GMWJIUkZibU52WkdsdVp5QjhmQ0FuZFhSbU9DYzdYRzVjYmlBZ0x5OGdkMmhsYmlCd2FYQnBibWNzSUhkbElHOXViSGtnWTJGeVpTQmhZbTkxZENBbmNtVmhaR0ZpYkdVbklHVjJaVzUwY3lCMGFHRjBJR2hoY0hCbGJseHVJQ0F2THlCaFpuUmxjaUJ5WldGa0tDbHBibWNnWVd4c0lIUm9aU0JpZVhSbGN5QmhibVFnYm05MElHZGxkSFJwYm1jZ1lXNTVJSEIxYzJoaVlXTnJMbHh1SUNCMGFHbHpMbkpoYms5MWRDQTlJR1poYkhObE8xeHVYRzRnSUM4dklIUm9aU0J1ZFcxaVpYSWdiMllnZDNKcGRHVnljeUIwYUdGMElHRnlaU0JoZDJGcGRHbHVaeUJoSUdSeVlXbHVJR1YyWlc1MElHbHVJQzV3YVhCbEtDbHpYRzRnSUhSb2FYTXVZWGRoYVhSRWNtRnBiaUE5SURBN1hHNWNiaUFnTHk4Z2FXWWdkSEoxWlN3Z1lTQnRZWGxpWlZKbFlXUk5iM0psSUdoaGN5QmlaV1Z1SUhOamFHVmtkV3hsWkZ4dUlDQjBhR2x6TG5KbFlXUnBibWROYjNKbElEMGdabUZzYzJVN1hHNWNiaUFnZEdocGN5NWtaV052WkdWeUlEMGdiblZzYkR0Y2JpQWdkR2hwY3k1bGJtTnZaR2x1WnlBOUlHNTFiR3c3WEc0Z0lHbG1JQ2h2Y0hScGIyNXpMbVZ1WTI5a2FXNW5LU0I3WEc0Z0lDQWdhV1lnS0NGVGRISnBibWRFWldOdlpHVnlLVnh1SUNBZ0lDQWdVM1J5YVc1blJHVmpiMlJsY2lBOUlISmxjWFZwY21Vb0ozTjBjbWx1WjE5a1pXTnZaR1Z5THljcExsTjBjbWx1WjBSbFkyOWtaWEk3WEc0Z0lDQWdkR2hwY3k1a1pXTnZaR1Z5SUQwZ2JtVjNJRk4wY21sdVowUmxZMjlrWlhJb2IzQjBhVzl1Y3k1bGJtTnZaR2x1WnlrN1hHNGdJQ0FnZEdocGN5NWxibU52WkdsdVp5QTlJRzl3ZEdsdmJuTXVaVzVqYjJScGJtYzdYRzRnSUgxY2JuMWNibHh1Wm5WdVkzUnBiMjRnVW1WaFpHRmliR1VvYjNCMGFXOXVjeWtnZTF4dUlDQjJZWElnUkhWd2JHVjRJRDBnY21WeGRXbHlaU2duTGk5ZmMzUnlaV0Z0WDJSMWNHeGxlQ2NwTzF4dVhHNGdJR2xtSUNnaEtIUm9hWE1nYVc1emRHRnVZMlZ2WmlCU1pXRmtZV0pzWlNrcFhHNGdJQ0FnY21WMGRYSnVJRzVsZHlCU1pXRmtZV0pzWlNodmNIUnBiMjV6S1R0Y2JseHVJQ0IwYUdsekxsOXlaV0ZrWVdKc1pWTjBZWFJsSUQwZ2JtVjNJRkpsWVdSaFlteGxVM1JoZEdVb2IzQjBhVzl1Y3l3Z2RHaHBjeWs3WEc1Y2JpQWdMeThnYkdWbllXTjVYRzRnSUhSb2FYTXVjbVZoWkdGaWJHVWdQU0IwY25WbE8xeHVYRzRnSUZOMGNtVmhiUzVqWVd4c0tIUm9hWE1wTzF4dWZWeHVYRzR2THlCTllXNTFZV3hzZVNCemFHOTJaU0J6YjIxbGRHaHBibWNnYVc1MGJ5QjBhR1VnY21WaFpDZ3BJR0oxWm1abGNpNWNiaTh2SUZSb2FYTWdjbVYwZFhKdWN5QjBjblZsSUdsbUlIUm9aU0JvYVdkb1YyRjBaWEpOWVhKcklHaGhjeUJ1YjNRZ1ltVmxiaUJvYVhRZ2VXVjBMRnh1THk4Z2MybHRhV3hoY2lCMGJ5Qm9iM2NnVjNKcGRHRmliR1V1ZDNKcGRHVW9LU0J5WlhSMWNtNXpJSFJ5ZFdVZ2FXWWdlVzkxSUhOb2IzVnNaRnh1THk4Z2QzSnBkR1VvS1NCemIyMWxJRzF2Y21VdVhHNVNaV0ZrWVdKc1pTNXdjbTkwYjNSNWNHVXVjSFZ6YUNBOUlHWjFibU4wYVc5dUtHTm9kVzVyTENCbGJtTnZaR2x1WnlrZ2UxeHVJQ0IyWVhJZ2MzUmhkR1VnUFNCMGFHbHpMbDl5WldGa1lXSnNaVk4wWVhSbE8xeHVYRzRnSUdsbUlDaDFkR2xzTG1selUzUnlhVzVuS0dOb2RXNXJLU0FtSmlBaGMzUmhkR1V1YjJKcVpXTjBUVzlrWlNrZ2UxeHVJQ0FnSUdWdVkyOWthVzVuSUQwZ1pXNWpiMlJwYm1jZ2ZId2djM1JoZEdVdVpHVm1ZWFZzZEVWdVkyOWthVzVuTzF4dUlDQWdJR2xtSUNobGJtTnZaR2x1WnlBaFBUMGdjM1JoZEdVdVpXNWpiMlJwYm1jcElIdGNiaUFnSUNBZ0lHTm9kVzVySUQwZ2JtVjNJRUoxWm1abGNpaGphSFZ1YXl3Z1pXNWpiMlJwYm1jcE8xeHVJQ0FnSUNBZ1pXNWpiMlJwYm1jZ1BTQW5KenRjYmlBZ0lDQjlYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdjbVZoWkdGaWJHVkJaR1JEYUhWdWF5aDBhR2x6TENCemRHRjBaU3dnWTJoMWJtc3NJR1Z1WTI5a2FXNW5MQ0JtWVd4elpTazdYRzU5TzF4dVhHNHZMeUJWYm5Ob2FXWjBJSE5vYjNWc1pDQXFZV3gzWVhsektpQmlaU0J6YjIxbGRHaHBibWNnWkdseVpXTjBiSGtnYjNWMElHOW1JSEpsWVdRb0tWeHVVbVZoWkdGaWJHVXVjSEp2ZEc5MGVYQmxMblZ1YzJocFpuUWdQU0JtZFc1amRHbHZiaWhqYUhWdWF5a2dlMXh1SUNCMllYSWdjM1JoZEdVZ1BTQjBhR2x6TGw5eVpXRmtZV0pzWlZOMFlYUmxPMXh1SUNCeVpYUjFjbTRnY21WaFpHRmliR1ZCWkdSRGFIVnVheWgwYUdsekxDQnpkR0YwWlN3Z1kyaDFibXNzSUNjbkxDQjBjblZsS1R0Y2JuMDdYRzVjYm1aMWJtTjBhVzl1SUhKbFlXUmhZbXhsUVdSa1EyaDFibXNvYzNSeVpXRnRMQ0J6ZEdGMFpTd2dZMmgxYm1zc0lHVnVZMjlrYVc1bkxDQmhaR1JVYjBaeWIyNTBLU0I3WEc0Z0lIWmhjaUJsY2lBOUlHTm9kVzVyU1c1MllXeHBaQ2h6ZEdGMFpTd2dZMmgxYm1zcE8xeHVJQ0JwWmlBb1pYSXBJSHRjYmlBZ0lDQnpkSEpsWVcwdVpXMXBkQ2duWlhKeWIzSW5MQ0JsY2lrN1hHNGdJSDBnWld4elpTQnBaaUFvZFhScGJDNXBjMDUxYkd4UGNsVnVaR1ZtYVc1bFpDaGphSFZ1YXlrcElIdGNiaUFnSUNCemRHRjBaUzV5WldGa2FXNW5JRDBnWm1Gc2MyVTdYRzRnSUNBZ2FXWWdLQ0Z6ZEdGMFpTNWxibVJsWkNsY2JpQWdJQ0FnSUc5dVJXOW1RMmgxYm1zb2MzUnlaV0Z0TENCemRHRjBaU2s3WEc0Z0lIMGdaV3h6WlNCcFppQW9jM1JoZEdVdWIySnFaV04wVFc5a1pTQjhmQ0JqYUhWdWF5QW1KaUJqYUhWdWF5NXNaVzVuZEdnZ1BpQXdLU0I3WEc0Z0lDQWdhV1lnS0hOMFlYUmxMbVZ1WkdWa0lDWW1JQ0ZoWkdSVWIwWnliMjUwS1NCN1hHNGdJQ0FnSUNCMllYSWdaU0E5SUc1bGR5QkZjbkp2Y2lnbmMzUnlaV0Z0TG5CMWMyZ29LU0JoWm5SbGNpQkZUMFluS1R0Y2JpQWdJQ0FnSUhOMGNtVmhiUzVsYldsMEtDZGxjbkp2Y2ljc0lHVXBPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9jM1JoZEdVdVpXNWtSVzFwZEhSbFpDQW1KaUJoWkdSVWIwWnliMjUwS1NCN1hHNGdJQ0FnSUNCMllYSWdaU0E5SUc1bGR5QkZjbkp2Y2lnbmMzUnlaV0Z0TG5WdWMyaHBablFvS1NCaFpuUmxjaUJsYm1RZ1pYWmxiblFuS1R0Y2JpQWdJQ0FnSUhOMGNtVmhiUzVsYldsMEtDZGxjbkp2Y2ljc0lHVXBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCcFppQW9jM1JoZEdVdVpHVmpiMlJsY2lBbUppQWhZV1JrVkc5R2NtOXVkQ0FtSmlBaFpXNWpiMlJwYm1jcFhHNGdJQ0FnSUNBZ0lHTm9kVzVySUQwZ2MzUmhkR1V1WkdWamIyUmxjaTUzY21sMFpTaGphSFZ1YXlrN1hHNWNiaUFnSUNBZ0lHbG1JQ2doWVdSa1ZHOUdjbTl1ZENsY2JpQWdJQ0FnSUNBZ2MzUmhkR1V1Y21WaFpHbHVaeUE5SUdaaGJITmxPMXh1WEc0Z0lDQWdJQ0F2THlCcFppQjNaU0IzWVc1MElIUm9aU0JrWVhSaElHNXZkeXdnYW5WemRDQmxiV2wwSUdsMExseHVJQ0FnSUNBZ2FXWWdLSE4wWVhSbExtWnNiM2RwYm1jZ0ppWWdjM1JoZEdVdWJHVnVaM1JvSUQwOVBTQXdJQ1ltSUNGemRHRjBaUzV6ZVc1aktTQjdYRzRnSUNBZ0lDQWdJSE4wY21WaGJTNWxiV2wwS0Nka1lYUmhKeXdnWTJoMWJtc3BPMXh1SUNBZ0lDQWdJQ0J6ZEhKbFlXMHVjbVZoWkNnd0tUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDOHZJSFZ3WkdGMFpTQjBhR1VnWW5WbVptVnlJR2x1Wm04dVhHNGdJQ0FnSUNBZ0lITjBZWFJsTG14bGJtZDBhQ0FyUFNCemRHRjBaUzV2WW1wbFkzUk5iMlJsSUQ4Z01TQTZJR05vZFc1ckxteGxibWQwYUR0Y2JpQWdJQ0FnSUNBZ2FXWWdLR0ZrWkZSdlJuSnZiblFwWEc0Z0lDQWdJQ0FnSUNBZ2MzUmhkR1V1WW5WbVptVnlMblZ1YzJocFpuUW9ZMmgxYm1zcE8xeHVJQ0FnSUNBZ0lDQmxiSE5sWEc0Z0lDQWdJQ0FnSUNBZ2MzUmhkR1V1WW5WbVptVnlMbkIxYzJnb1kyaDFibXNwTzF4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2h6ZEdGMFpTNXVaV1ZrVW1WaFpHRmliR1VwWEc0Z0lDQWdJQ0FnSUNBZ1pXMXBkRkpsWVdSaFlteGxLSE4wY21WaGJTazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJRzFoZVdKbFVtVmhaRTF2Y21Vb2MzUnlaV0Z0TENCemRHRjBaU2s3WEc0Z0lDQWdmVnh1SUNCOUlHVnNjMlVnYVdZZ0tDRmhaR1JVYjBaeWIyNTBLU0I3WEc0Z0lDQWdjM1JoZEdVdWNtVmhaR2x1WnlBOUlHWmhiSE5sTzF4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUc1bFpXUk5iM0psUkdGMFlTaHpkR0YwWlNrN1hHNTlYRzVjYmx4dVhHNHZMeUJwWmlCcGRDZHpJSEJoYzNRZ2RHaGxJR2hwWjJnZ2QyRjBaWElnYldGeWF5d2dkMlVnWTJGdUlIQjFjMmdnYVc0Z2MyOXRaU0J0YjNKbExseHVMeThnUVd4emJ5d2dhV1lnZDJVZ2FHRjJaU0J1YnlCa1lYUmhJSGxsZEN3Z2QyVWdZMkZ1SUhOMFlXNWtJSE52YldWY2JpOHZJRzF2Y21VZ1lubDBaWE11SUNCVWFHbHpJR2x6SUhSdklIZHZjbXNnWVhKdmRXNWtJR05oYzJWeklIZG9aWEpsSUdoM2JUMHdMRnh1THk4Z2MzVmphQ0JoY3lCMGFHVWdjbVZ3YkM0Z0lFRnNjMjhzSUdsbUlIUm9aU0J3ZFhOb0tDa2dkSEpwWjJkbGNtVmtJR0ZjYmk4dklISmxZV1JoWW14bElHVjJaVzUwTENCaGJtUWdkR2hsSUhWelpYSWdZMkZzYkdWa0lISmxZV1FvYkdGeVoyVk9kVzFpWlhJcElITjFZMmdnZEdoaGRGeHVMeThnYm1WbFpGSmxZV1JoWW14bElIZGhjeUJ6WlhRc0lIUm9aVzRnZDJVZ2IzVm5hSFFnZEc4Z2NIVnphQ0J0YjNKbExDQnpieUIwYUdGMElHRnViM1JvWlhKY2JpOHZJQ2R5WldGa1lXSnNaU2NnWlhabGJuUWdkMmxzYkNCaVpTQjBjbWxuWjJWeVpXUXVYRzVtZFc1amRHbHZiaUJ1WldWa1RXOXlaVVJoZEdFb2MzUmhkR1VwSUh0Y2JpQWdjbVYwZFhKdUlDRnpkR0YwWlM1bGJtUmxaQ0FtSmx4dUlDQWdJQ0FnSUNBZ0tITjBZWFJsTG01bFpXUlNaV0ZrWVdKc1pTQjhmRnh1SUNBZ0lDQWdJQ0FnSUhOMFlYUmxMbXhsYm1kMGFDQThJSE4wWVhSbExtaHBaMmhYWVhSbGNrMWhjbXNnZkh4Y2JpQWdJQ0FnSUNBZ0lDQnpkR0YwWlM1c1pXNW5kR2dnUFQwOUlEQXBPMXh1ZlZ4dVhHNHZMeUJpWVdOcmQyRnlaSE1nWTI5dGNHRjBhV0pwYkdsMGVTNWNibEpsWVdSaFlteGxMbkJ5YjNSdmRIbHdaUzV6WlhSRmJtTnZaR2x1WnlBOUlHWjFibU4wYVc5dUtHVnVZeWtnZTF4dUlDQnBaaUFvSVZOMGNtbHVaMFJsWTI5a1pYSXBYRzRnSUNBZ1UzUnlhVzVuUkdWamIyUmxjaUE5SUhKbGNYVnBjbVVvSjNOMGNtbHVaMTlrWldOdlpHVnlMeWNwTGxOMGNtbHVaMFJsWTI5a1pYSTdYRzRnSUhSb2FYTXVYM0psWVdSaFlteGxVM1JoZEdVdVpHVmpiMlJsY2lBOUlHNWxkeUJUZEhKcGJtZEVaV052WkdWeUtHVnVZeWs3WEc0Z0lIUm9hWE11WDNKbFlXUmhZbXhsVTNSaGRHVXVaVzVqYjJScGJtY2dQU0JsYm1NN1hHNGdJSEpsZEhWeWJpQjBhR2x6TzF4dWZUdGNibHh1THk4Z1JHOXVKM1FnY21GcGMyVWdkR2hsSUdoM2JTQStJREV5T0UxQ1hHNTJZWElnVFVGWVgwaFhUU0E5SURCNE9EQXdNREF3TzF4dVpuVnVZM1JwYjI0Z2NtOTFibVJWY0ZSdlRtVjRkRkJ2ZDJWeVQyWXlLRzRwSUh0Y2JpQWdhV1lnS0c0Z1BqMGdUVUZZWDBoWFRTa2dlMXh1SUNBZ0lHNGdQU0JOUVZoZlNGZE5PMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJQzh2SUVkbGRDQjBhR1VnYm1WNGRDQm9hV2RvWlhOMElIQnZkMlZ5SUc5bUlESmNiaUFnSUNCdUxTMDdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ2NDQTlJREU3SUhBZ1BDQXpNanNnY0NBOFBEMGdNU2tnYmlCOFBTQnVJRDQrSUhBN1hHNGdJQ0FnYmlzck8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCdU8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCb2IzZE5kV05vVkc5U1pXRmtLRzRzSUhOMFlYUmxLU0I3WEc0Z0lHbG1JQ2h6ZEdGMFpTNXNaVzVuZEdnZ1BUMDlJREFnSmlZZ2MzUmhkR1V1Wlc1a1pXUXBYRzRnSUNBZ2NtVjBkWEp1SURBN1hHNWNiaUFnYVdZZ0tITjBZWFJsTG05aWFtVmpkRTF2WkdVcFhHNGdJQ0FnY21WMGRYSnVJRzRnUFQwOUlEQWdQeUF3SURvZ01UdGNibHh1SUNCcFppQW9hWE5PWVU0b2Jpa2dmSHdnZFhScGJDNXBjMDUxYkd3b2Jpa3BJSHRjYmlBZ0lDQXZMeUJ2Ym14NUlHWnNiM2NnYjI1bElHSjFabVpsY2lCaGRDQmhJSFJwYldWY2JpQWdJQ0JwWmlBb2MzUmhkR1V1Wm14dmQybHVaeUFtSmlCemRHRjBaUzVpZFdabVpYSXViR1Z1WjNSb0tWeHVJQ0FnSUNBZ2NtVjBkWEp1SUhOMFlYUmxMbUoxWm1abGNsc3dYUzVzWlc1bmRHZzdYRzRnSUNBZ1pXeHpaVnh1SUNBZ0lDQWdjbVYwZFhKdUlITjBZWFJsTG14bGJtZDBhRHRjYmlBZ2ZWeHVYRzRnSUdsbUlDaHVJRHc5SURBcFhHNGdJQ0FnY21WMGRYSnVJREE3WEc1Y2JpQWdMeThnU1dZZ2QyVW5jbVVnWVhOcmFXNW5JR1p2Y2lCdGIzSmxJSFJvWVc0Z2RHaGxJSFJoY21kbGRDQmlkV1ptWlhJZ2JHVjJaV3dzWEc0Z0lDOHZJSFJvWlc0Z2NtRnBjMlVnZEdobElIZGhkR1Z5SUcxaGNtc3VJQ0JDZFcxd0lIVndJSFJ2SUhSb1pTQnVaWGgwSUdocFoyaGxjM1JjYmlBZ0x5OGdjRzkzWlhJZ2IyWWdNaXdnZEc4Z2NISmxkbVZ1ZENCcGJtTnlaV0Z6YVc1bklHbDBJR1Y0WTJWemMybDJaV3g1SUdsdUlIUnBibmxjYmlBZ0x5OGdZVzF2ZFc1MGN5NWNiaUFnYVdZZ0tHNGdQaUJ6ZEdGMFpTNW9hV2RvVjJGMFpYSk5ZWEpyS1Z4dUlDQWdJSE4wWVhSbExtaHBaMmhYWVhSbGNrMWhjbXNnUFNCeWIzVnVaRlZ3Vkc5T1pYaDBVRzkzWlhKUFpqSW9iaWs3WEc1Y2JpQWdMeThnWkc5dUozUWdhR0YyWlNCMGFHRjBJRzExWTJndUlDQnlaWFIxY200Z2JuVnNiQ3dnZFc1c1pYTnpJSGRsSjNabElHVnVaR1ZrTGx4dUlDQnBaaUFvYmlBK0lITjBZWFJsTG14bGJtZDBhQ2tnZTF4dUlDQWdJR2xtSUNnaGMzUmhkR1V1Wlc1a1pXUXBJSHRjYmlBZ0lDQWdJSE4wWVhSbExtNWxaV1JTWldGa1lXSnNaU0E5SUhSeWRXVTdYRzRnSUNBZ0lDQnlaWFIxY200Z01EdGNiaUFnSUNCOUlHVnNjMlZjYmlBZ0lDQWdJSEpsZEhWeWJpQnpkR0YwWlM1c1pXNW5kR2c3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnYmp0Y2JuMWNibHh1THk4Z2VXOTFJR05oYmlCdmRtVnljbWxrWlNCbGFYUm9aWElnZEdocGN5QnRaWFJvYjJRc0lHOXlJSFJvWlNCaGMzbHVZeUJmY21WaFpDaHVLU0JpWld4dmR5NWNibEpsWVdSaFlteGxMbkJ5YjNSdmRIbHdaUzV5WldGa0lEMGdablZ1WTNScGIyNG9iaWtnZTF4dUlDQmtaV0oxWnlnbmNtVmhaQ2NzSUc0cE8xeHVJQ0IyWVhJZ2MzUmhkR1VnUFNCMGFHbHpMbDl5WldGa1lXSnNaVk4wWVhSbE8xeHVJQ0IyWVhJZ2JrOXlhV2NnUFNCdU8xeHVYRzRnSUdsbUlDZ2hkWFJwYkM1cGMwNTFiV0psY2lodUtTQjhmQ0J1SUQ0Z01DbGNiaUFnSUNCemRHRjBaUzVsYldsMGRHVmtVbVZoWkdGaWJHVWdQU0JtWVd4elpUdGNibHh1SUNBdkx5QnBaaUIzWlNkeVpTQmtiMmx1WnlCeVpXRmtLREFwSUhSdklIUnlhV2RuWlhJZ1lTQnlaV0ZrWVdKc1pTQmxkbVZ1ZEN3Z1luVjBJSGRsWEc0Z0lDOHZJR0ZzY21WaFpIa2dhR0YyWlNCaElHSjFibU5vSUc5bUlHUmhkR0VnYVc0Z2RHaGxJR0oxWm1abGNpd2dkR2hsYmlCcWRYTjBJSFJ5YVdkblpYSmNiaUFnTHk4Z2RHaGxJQ2R5WldGa1lXSnNaU2NnWlhabGJuUWdZVzVrSUcxdmRtVWdiMjR1WEc0Z0lHbG1JQ2h1SUQwOVBTQXdJQ1ltWEc0Z0lDQWdJQ0J6ZEdGMFpTNXVaV1ZrVW1WaFpHRmliR1VnSmlaY2JpQWdJQ0FnSUNoemRHRjBaUzVzWlc1bmRHZ2dQajBnYzNSaGRHVXVhR2xuYUZkaGRHVnlUV0Z5YXlCOGZDQnpkR0YwWlM1bGJtUmxaQ2twSUh0Y2JpQWdJQ0JrWldKMVp5Z25jbVZoWkRvZ1pXMXBkRkpsWVdSaFlteGxKeXdnYzNSaGRHVXViR1Z1WjNSb0xDQnpkR0YwWlM1bGJtUmxaQ2s3WEc0Z0lDQWdhV1lnS0hOMFlYUmxMbXhsYm1kMGFDQTlQVDBnTUNBbUppQnpkR0YwWlM1bGJtUmxaQ2xjYmlBZ0lDQWdJR1Z1WkZKbFlXUmhZbXhsS0hSb2FYTXBPMXh1SUNBZ0lHVnNjMlZjYmlBZ0lDQWdJR1Z0YVhSU1pXRmtZV0pzWlNoMGFHbHpLVHRjYmlBZ0lDQnlaWFIxY200Z2JuVnNiRHRjYmlBZ2ZWeHVYRzRnSUc0Z1BTQm9iM2ROZFdOb1ZHOVNaV0ZrS0c0c0lITjBZWFJsS1R0Y2JseHVJQ0F2THlCcFppQjNaU2QyWlNCbGJtUmxaQ3dnWVc1a0lIZGxKM0psSUc1dmR5QmpiR1ZoY2l3Z2RHaGxiaUJtYVc1cGMyZ2dhWFFnZFhBdVhHNGdJR2xtSUNodUlEMDlQU0F3SUNZbUlITjBZWFJsTG1WdVpHVmtLU0I3WEc0Z0lDQWdhV1lnS0hOMFlYUmxMbXhsYm1kMGFDQTlQVDBnTUNsY2JpQWdJQ0FnSUdWdVpGSmxZV1JoWW14bEtIUm9hWE1wTzF4dUlDQWdJSEpsZEhWeWJpQnVkV3hzTzF4dUlDQjlYRzVjYmlBZ0x5OGdRV3hzSUhSb1pTQmhZM1IxWVd3Z1kyaDFibXNnWjJWdVpYSmhkR2x2YmlCc2IyZHBZeUJ1WldWa2N5QjBieUJpWlZ4dUlDQXZMeUFxWW1Wc2IzY3FJSFJvWlNCallXeHNJSFJ2SUY5eVpXRmtMaUFnVkdobElISmxZWE52YmlCcGN5QjBhR0YwSUdsdUlHTmxjblJoYVc1Y2JpQWdMeThnYzNsdWRHaGxkR2xqSUhOMGNtVmhiU0JqWVhObGN5d2djM1ZqYUNCaGN5QndZWE56ZEdoeWIzVm5hQ0J6ZEhKbFlXMXpMQ0JmY21WaFpGeHVJQ0F2THlCdFlYa2dZbVVnWVNCamIyMXdiR1YwWld4NUlITjVibU5vY205dWIzVnpJRzl3WlhKaGRHbHZiaUIzYUdsamFDQnRZWGtnWTJoaGJtZGxYRzRnSUM4dklIUm9aU0J6ZEdGMFpTQnZaaUIwYUdVZ2NtVmhaQ0JpZFdabVpYSXNJSEJ5YjNacFpHbHVaeUJsYm05MVoyZ2daR0YwWVNCM2FHVnVYRzRnSUM4dklHSmxabTl5WlNCMGFHVnlaU0IzWVhNZ0ttNXZkQ29nWlc1dmRXZG9MbHh1SUNBdkwxeHVJQ0F2THlCVGJ5d2dkR2hsSUhOMFpYQnpJR0Z5WlRwY2JpQWdMeThnTVM0Z1JtbG5kWEpsSUc5MWRDQjNhR0YwSUhSb1pTQnpkR0YwWlNCdlppQjBhR2x1WjNNZ2QybHNiQ0JpWlNCaFpuUmxjaUIzWlNCa2IxeHVJQ0F2THlCaElISmxZV1FnWm5KdmJTQjBhR1VnWW5WbVptVnlMbHh1SUNBdkwxeHVJQ0F2THlBeUxpQkpaaUIwYUdGMElISmxjM1ZzZEdsdVp5QnpkR0YwWlNCM2FXeHNJSFJ5YVdkblpYSWdZU0JmY21WaFpDd2dkR2hsYmlCallXeHNJRjl5WldGa0xseHVJQ0F2THlCT2IzUmxJSFJvWVhRZ2RHaHBjeUJ0WVhrZ1ltVWdZWE41Ym1Ob2NtOXViM1Z6TENCdmNpQnplVzVqYUhKdmJtOTFjeTRnSUZsbGN5d2dhWFFnYVhOY2JpQWdMeThnWkdWbGNHeDVJSFZuYkhrZ2RHOGdkM0pwZEdVZ1FWQkpjeUIwYUdseklIZGhlU3dnWW5WMElIUm9ZWFFnYzNScGJHd2daRzlsYzI0bmRDQnRaV0Z1WEc0Z0lDOHZJSFJvWVhRZ2RHaGxJRkpsWVdSaFlteGxJR05zWVhOeklITm9iM1ZzWkNCaVpXaGhkbVVnYVcxd2NtOXdaWEpzZVN3Z1lYTWdjM1J5WldGdGN5QmhjbVZjYmlBZ0x5OGdaR1Z6YVdkdVpXUWdkRzhnWW1VZ2MzbHVZeTloYzNsdVl5QmhaMjV2YzNScFl5NWNiaUFnTHk4Z1ZHRnJaU0J1YjNSbElHbG1JSFJvWlNCZmNtVmhaQ0JqWVd4c0lHbHpJSE41Ym1NZ2IzSWdZWE41Ym1NZ0tHbGxMQ0JwWmlCMGFHVWdjbVZoWkNCallXeHNYRzRnSUM4dklHaGhjeUJ5WlhSMWNtNWxaQ0I1WlhRcExDQnpieUIwYUdGMElIZGxJR3R1YjNjZ2QyaGxkR2hsY2lCdmNpQnViM1FnYVhRbmN5QnpZV1psSUhSdklHVnRhWFJjYmlBZ0x5OGdKM0psWVdSaFlteGxKeUJsZEdNdVhHNGdJQzh2WEc0Z0lDOHZJRE11SUVGamRIVmhiR3g1SUhCMWJHd2dkR2hsSUhKbGNYVmxjM1JsWkNCamFIVnVhM01nYjNWMElHOW1JSFJvWlNCaWRXWm1aWElnWVc1a0lISmxkSFZ5Ymk1Y2JseHVJQ0F2THlCcFppQjNaU0J1WldWa0lHRWdjbVZoWkdGaWJHVWdaWFpsYm5Rc0lIUm9aVzRnZDJVZ2JtVmxaQ0IwYnlCa2J5QnpiMjFsSUhKbFlXUnBibWN1WEc0Z0lIWmhjaUJrYjFKbFlXUWdQU0J6ZEdGMFpTNXVaV1ZrVW1WaFpHRmliR1U3WEc0Z0lHUmxZblZuS0NkdVpXVmtJSEpsWVdSaFlteGxKeXdnWkc5U1pXRmtLVHRjYmx4dUlDQXZMeUJwWmlCM1pTQmpkWEp5Wlc1MGJIa2dhR0YyWlNCc1pYTnpJSFJvWVc0Z2RHaGxJR2hwWjJoWFlYUmxjazFoY21zc0lIUm9aVzRnWVd4emJ5QnlaV0ZrSUhOdmJXVmNiaUFnYVdZZ0tITjBZWFJsTG14bGJtZDBhQ0E5UFQwZ01DQjhmQ0J6ZEdGMFpTNXNaVzVuZEdnZ0xTQnVJRHdnYzNSaGRHVXVhR2xuYUZkaGRHVnlUV0Z5YXlrZ2UxeHVJQ0FnSUdSdlVtVmhaQ0E5SUhSeWRXVTdYRzRnSUNBZ1pHVmlkV2NvSjJ4bGJtZDBhQ0JzWlhOeklIUm9ZVzRnZDJGMFpYSnRZWEpySnl3Z1pHOVNaV0ZrS1R0Y2JpQWdmVnh1WEc0Z0lDOHZJR2h2ZDJWMlpYSXNJR2xtSUhkbEozWmxJR1Z1WkdWa0xDQjBhR1Z1SUhSb1pYSmxKM01nYm04Z2NHOXBiblFzSUdGdVpDQnBaaUIzWlNkeVpTQmhiSEpsWVdSNVhHNGdJQzh2SUhKbFlXUnBibWNzSUhSb1pXNGdhWFFuY3lCMWJtNWxZMlZ6YzJGeWVTNWNiaUFnYVdZZ0tITjBZWFJsTG1WdVpHVmtJSHg4SUhOMFlYUmxMbkpsWVdScGJtY3BJSHRjYmlBZ0lDQmtiMUpsWVdRZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0JrWldKMVp5Z25jbVZoWkdsdVp5QnZjaUJsYm1SbFpDY3NJR1J2VW1WaFpDazdYRzRnSUgxY2JseHVJQ0JwWmlBb1pHOVNaV0ZrS1NCN1hHNGdJQ0FnWkdWaWRXY29KMlJ2SUhKbFlXUW5LVHRjYmlBZ0lDQnpkR0YwWlM1eVpXRmthVzVuSUQwZ2RISjFaVHRjYmlBZ0lDQnpkR0YwWlM1emVXNWpJRDBnZEhKMVpUdGNiaUFnSUNBdkx5QnBaaUIwYUdVZ2JHVnVaM1JvSUdseklHTjFjbkpsYm5Sc2VTQjZaWEp2TENCMGFHVnVJSGRsSUNwdVpXVmtLaUJoSUhKbFlXUmhZbXhsSUdWMlpXNTBMbHh1SUNBZ0lHbG1JQ2h6ZEdGMFpTNXNaVzVuZEdnZ1BUMDlJREFwWEc0Z0lDQWdJQ0J6ZEdGMFpTNXVaV1ZrVW1WaFpHRmliR1VnUFNCMGNuVmxPMXh1SUNBZ0lDOHZJR05oYkd3Z2FXNTBaWEp1WVd3Z2NtVmhaQ0J0WlhSb2IyUmNiaUFnSUNCMGFHbHpMbDl5WldGa0tITjBZWFJsTG1ocFoyaFhZWFJsY2sxaGNtc3BPMXh1SUNBZ0lITjBZWFJsTG5ONWJtTWdQU0JtWVd4elpUdGNiaUFnZlZ4dVhHNGdJQzh2SUVsbUlGOXlaV0ZrSUhCMWMyaGxaQ0JrWVhSaElITjVibU5vY205dWIzVnpiSGtzSUhSb1pXNGdZSEpsWVdScGJtZGdJSGRwYkd3Z1ltVWdabUZzYzJVc1hHNGdJQzh2SUdGdVpDQjNaU0J1WldWa0lIUnZJSEpsTFdWMllXeDFZWFJsSUdodmR5QnRkV05vSUdSaGRHRWdkMlVnWTJGdUlISmxkSFZ5YmlCMGJ5QjBhR1VnZFhObGNpNWNiaUFnYVdZZ0tHUnZVbVZoWkNBbUppQWhjM1JoZEdVdWNtVmhaR2x1WnlsY2JpQWdJQ0J1SUQwZ2FHOTNUWFZqYUZSdlVtVmhaQ2h1VDNKcFp5d2djM1JoZEdVcE8xeHVYRzRnSUhaaGNpQnlaWFE3WEc0Z0lHbG1JQ2h1SUQ0Z01DbGNiaUFnSUNCeVpYUWdQU0JtY205dFRHbHpkQ2h1TENCemRHRjBaU2s3WEc0Z0lHVnNjMlZjYmlBZ0lDQnlaWFFnUFNCdWRXeHNPMXh1WEc0Z0lHbG1JQ2gxZEdsc0xtbHpUblZzYkNoeVpYUXBLU0I3WEc0Z0lDQWdjM1JoZEdVdWJtVmxaRkpsWVdSaFlteGxJRDBnZEhKMVpUdGNiaUFnSUNCdUlEMGdNRHRjYmlBZ2ZWeHVYRzRnSUhOMFlYUmxMbXhsYm1kMGFDQXRQU0J1TzF4dVhHNGdJQzh2SUVsbUlIZGxJR2hoZG1VZ2JtOTBhR2x1WnlCcGJpQjBhR1VnWW5WbVptVnlMQ0IwYUdWdUlIZGxJSGRoYm5RZ2RHOGdhMjV2ZDF4dUlDQXZMeUJoY3lCemIyOXVJR0Z6SUhkbElDcGtieW9nWjJWMElITnZiV1YwYUdsdVp5QnBiblJ2SUhSb1pTQmlkV1ptWlhJdVhHNGdJR2xtSUNoemRHRjBaUzVzWlc1bmRHZ2dQVDA5SURBZ0ppWWdJWE4wWVhSbExtVnVaR1ZrS1Z4dUlDQWdJSE4wWVhSbExtNWxaV1JTWldGa1lXSnNaU0E5SUhSeWRXVTdYRzVjYmlBZ0x5OGdTV1lnZDJVZ2RISnBaV1FnZEc4Z2NtVmhaQ2dwSUhCaGMzUWdkR2hsSUVWUFJpd2dkR2hsYmlCbGJXbDBJR1Z1WkNCdmJpQjBhR1VnYm1WNGRDQjBhV05yTGx4dUlDQnBaaUFvYms5eWFXY2dJVDA5SUc0Z0ppWWdjM1JoZEdVdVpXNWtaV1FnSmlZZ2MzUmhkR1V1YkdWdVozUm9JRDA5UFNBd0tWeHVJQ0FnSUdWdVpGSmxZV1JoWW14bEtIUm9hWE1wTzF4dVhHNGdJR2xtSUNnaGRYUnBiQzVwYzA1MWJHd29jbVYwS1NsY2JpQWdJQ0IwYUdsekxtVnRhWFFvSjJSaGRHRW5MQ0J5WlhRcE8xeHVYRzRnSUhKbGRIVnliaUJ5WlhRN1hHNTlPMXh1WEc1bWRXNWpkR2x2YmlCamFIVnVhMGx1ZG1Gc2FXUW9jM1JoZEdVc0lHTm9kVzVyS1NCN1hHNGdJSFpoY2lCbGNpQTlJRzUxYkd3N1hHNGdJR2xtSUNnaGRYUnBiQzVwYzBKMVptWmxjaWhqYUhWdWF5a2dKaVpjYmlBZ0lDQWdJQ0YxZEdsc0xtbHpVM1J5YVc1bktHTm9kVzVyS1NBbUpseHVJQ0FnSUNBZ0lYVjBhV3d1YVhOT2RXeHNUM0pWYm1SbFptbHVaV1FvWTJoMWJtc3BJQ1ltWEc0Z0lDQWdJQ0FoYzNSaGRHVXViMkpxWldOMFRXOWtaU2tnZTF4dUlDQWdJR1Z5SUQwZ2JtVjNJRlI1Y0dWRmNuSnZjaWduU1c1MllXeHBaQ0J1YjI0dGMzUnlhVzVuTDJKMVptWmxjaUJqYUhWdWF5Y3BPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQmxjanRjYm4xY2JseHVYRzVtZFc1amRHbHZiaUJ2YmtWdlprTm9kVzVyS0hOMGNtVmhiU3dnYzNSaGRHVXBJSHRjYmlBZ2FXWWdLSE4wWVhSbExtUmxZMjlrWlhJZ0ppWWdJWE4wWVhSbExtVnVaR1ZrS1NCN1hHNGdJQ0FnZG1GeUlHTm9kVzVySUQwZ2MzUmhkR1V1WkdWamIyUmxjaTVsYm1Rb0tUdGNiaUFnSUNCcFppQW9ZMmgxYm1zZ0ppWWdZMmgxYm1zdWJHVnVaM1JvS1NCN1hHNGdJQ0FnSUNCemRHRjBaUzVpZFdabVpYSXVjSFZ6YUNoamFIVnVheWs3WEc0Z0lDQWdJQ0J6ZEdGMFpTNXNaVzVuZEdnZ0t6MGdjM1JoZEdVdWIySnFaV04wVFc5a1pTQS9JREVnT2lCamFIVnVheTVzWlc1bmRHZzdYRzRnSUNBZ2ZWeHVJQ0I5WEc0Z0lITjBZWFJsTG1WdVpHVmtJRDBnZEhKMVpUdGNibHh1SUNBdkx5QmxiV2wwSUNkeVpXRmtZV0pzWlNjZ2JtOTNJSFJ2SUcxaGEyVWdjM1Z5WlNCcGRDQm5aWFJ6SUhCcFkydGxaQ0IxY0M1Y2JpQWdaVzFwZEZKbFlXUmhZbXhsS0hOMGNtVmhiU2s3WEc1OVhHNWNiaTh2SUVSdmJpZDBJR1Z0YVhRZ2NtVmhaR0ZpYkdVZ2NtbG5hSFFnWVhkaGVTQnBiaUJ6ZVc1aklHMXZaR1VzSUdKbFkyRjFjMlVnZEdocGN5QmpZVzRnZEhKcFoyZGxjbHh1THk4Z1lXNXZkR2hsY2lCeVpXRmtLQ2tnWTJGc2JDQTlQaUJ6ZEdGamF5QnZkbVZ5Wm14dmR5NGdJRlJvYVhNZ2QyRjVMQ0JwZENCdGFXZG9kQ0IwY21sbloyVnlYRzR2THlCaElHNWxlSFJVYVdOcklISmxZM1Z5YzJsdmJpQjNZWEp1YVc1bkxDQmlkWFFnZEdoaGRDZHpJRzV2ZENCemJ5QmlZV1F1WEc1bWRXNWpkR2x2YmlCbGJXbDBVbVZoWkdGaWJHVW9jM1J5WldGdEtTQjdYRzRnSUhaaGNpQnpkR0YwWlNBOUlITjBjbVZoYlM1ZmNtVmhaR0ZpYkdWVGRHRjBaVHRjYmlBZ2MzUmhkR1V1Ym1WbFpGSmxZV1JoWW14bElEMGdabUZzYzJVN1hHNGdJR2xtSUNnaGMzUmhkR1V1WlcxcGRIUmxaRkpsWVdSaFlteGxLU0I3WEc0Z0lDQWdaR1ZpZFdjb0oyVnRhWFJTWldGa1lXSnNaU2NzSUhOMFlYUmxMbVpzYjNkcGJtY3BPMXh1SUNBZ0lITjBZWFJsTG1WdGFYUjBaV1JTWldGa1lXSnNaU0E5SUhSeWRXVTdYRzRnSUNBZ2FXWWdLSE4wWVhSbExuTjVibU1wWEc0Z0lDQWdJQ0J3Y205alpYTnpMbTVsZUhSVWFXTnJLR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCbGJXbDBVbVZoWkdGaWJHVmZLSE4wY21WaGJTazdYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQmxiSE5sWEc0Z0lDQWdJQ0JsYldsMFVtVmhaR0ZpYkdWZktITjBjbVZoYlNrN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdaVzFwZEZKbFlXUmhZbXhsWHloemRISmxZVzBwSUh0Y2JpQWdaR1ZpZFdjb0oyVnRhWFFnY21WaFpHRmliR1VuS1R0Y2JpQWdjM1J5WldGdExtVnRhWFFvSjNKbFlXUmhZbXhsSnlrN1hHNGdJR1pzYjNjb2MzUnlaV0Z0S1R0Y2JuMWNibHh1WEc0dkx5QmhkQ0IwYUdseklIQnZhVzUwTENCMGFHVWdkWE5sY2lCb1lYTWdjSEpsYzNWdFlXSnNlU0J6WldWdUlIUm9aU0FuY21WaFpHRmliR1VuSUdWMlpXNTBMRnh1THk4Z1lXNWtJR05oYkd4bFpDQnlaV0ZrS0NrZ2RHOGdZMjl1YzNWdFpTQnpiMjFsSUdSaGRHRXVJQ0IwYUdGMElHMWhlU0JvWVhabElIUnlhV2RuWlhKbFpGeHVMeThnYVc0Z2RIVnliaUJoYm05MGFHVnlJRjl5WldGa0tHNHBJR05oYkd3c0lHbHVJSGRvYVdOb0lHTmhjMlVnY21WaFpHbHVaeUE5SUhSeWRXVWdhV1pjYmk4dklHbDBKM01nYVc0Z2NISnZaM0psYzNNdVhHNHZMeUJJYjNkbGRtVnlMQ0JwWmlCM1pTZHlaU0J1YjNRZ1pXNWtaV1FzSUc5eUlISmxZV1JwYm1jc0lHRnVaQ0IwYUdVZ2JHVnVaM1JvSUR3Z2FIZHRMRnh1THk4Z2RHaGxiaUJuYnlCaGFHVmhaQ0JoYm1RZ2RISjVJSFJ2SUhKbFlXUWdjMjl0WlNCdGIzSmxJSEJ5WldWdGNIUnBkbVZzZVM1Y2JtWjFibU4wYVc5dUlHMWhlV0psVW1WaFpFMXZjbVVvYzNSeVpXRnRMQ0J6ZEdGMFpTa2dlMXh1SUNCcFppQW9JWE4wWVhSbExuSmxZV1JwYm1kTmIzSmxLU0I3WEc0Z0lDQWdjM1JoZEdVdWNtVmhaR2x1WjAxdmNtVWdQU0IwY25WbE8xeHVJQ0FnSUhCeWIyTmxjM011Ym1WNGRGUnBZMnNvWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCdFlYbGlaVkpsWVdSTmIzSmxYeWh6ZEhKbFlXMHNJSE4wWVhSbEtUdGNiaUFnSUNCOUtUdGNiaUFnZlZ4dWZWeHVYRzVtZFc1amRHbHZiaUJ0WVhsaVpWSmxZV1JOYjNKbFh5aHpkSEpsWVcwc0lITjBZWFJsS1NCN1hHNGdJSFpoY2lCc1pXNGdQU0J6ZEdGMFpTNXNaVzVuZEdnN1hHNGdJSGRvYVd4bElDZ2hjM1JoZEdVdWNtVmhaR2x1WnlBbUppQWhjM1JoZEdVdVpteHZkMmx1WnlBbUppQWhjM1JoZEdVdVpXNWtaV1FnSmlaY2JpQWdJQ0FnSUNBZ0lITjBZWFJsTG14bGJtZDBhQ0E4SUhOMFlYUmxMbWhwWjJoWFlYUmxjazFoY21zcElIdGNiaUFnSUNCa1pXSjFaeWduYldGNVltVlNaV0ZrVFc5eVpTQnlaV0ZrSURBbktUdGNiaUFnSUNCemRISmxZVzB1Y21WaFpDZ3dLVHRjYmlBZ0lDQnBaaUFvYkdWdUlEMDlQU0J6ZEdGMFpTNXNaVzVuZEdncFhHNGdJQ0FnSUNBdkx5QmthV1J1SjNRZ1oyVjBJR0Z1ZVNCa1lYUmhMQ0J6ZEc5d0lITndhVzV1YVc1bkxseHVJQ0FnSUNBZ1luSmxZV3M3WEc0Z0lDQWdaV3h6WlZ4dUlDQWdJQ0FnYkdWdUlEMGdjM1JoZEdVdWJHVnVaM1JvTzF4dUlDQjlYRzRnSUhOMFlYUmxMbkpsWVdScGJtZE5iM0psSUQwZ1ptRnNjMlU3WEc1OVhHNWNiaTh2SUdGaWMzUnlZV04wSUcxbGRHaHZaQzRnSUhSdklHSmxJRzkyWlhKeWFXUmtaVzRnYVc0Z2MzQmxZMmxtYVdNZ2FXMXdiR1Z0Wlc1MFlYUnBiMjRnWTJ4aGMzTmxjeTVjYmk4dklHTmhiR3dnWTJJb1pYSXNJR1JoZEdFcElIZG9aWEpsSUdSaGRHRWdhWE1nUEQwZ2JpQnBiaUJzWlc1bmRHZ3VYRzR2THlCbWIzSWdkbWx5ZEhWaGJDQW9ibTl1TFhOMGNtbHVaeXdnYm05dUxXSjFabVpsY2lrZ2MzUnlaV0Z0Y3l3Z1hDSnNaVzVuZEdoY0lpQnBjeUJ6YjIxbGQyaGhkRnh1THk4Z1lYSmlhWFJ5WVhKNUxDQmhibVFnY0dWeWFHRndjeUJ1YjNRZ2RtVnllU0J0WldGdWFXNW5ablZzTGx4dVVtVmhaR0ZpYkdVdWNISnZkRzkwZVhCbExsOXlaV0ZrSUQwZ1puVnVZM1JwYjI0b2Jpa2dlMXh1SUNCMGFHbHpMbVZ0YVhRb0oyVnljbTl5Snl3Z2JtVjNJRVZ5Y205eUtDZHViM1FnYVcxd2JHVnRaVzUwWldRbktTazdYRzU5TzF4dVhHNVNaV0ZrWVdKc1pTNXdjbTkwYjNSNWNHVXVjR2x3WlNBOUlHWjFibU4wYVc5dUtHUmxjM1FzSUhCcGNHVlBjSFJ6S1NCN1hHNGdJSFpoY2lCemNtTWdQU0IwYUdsek8xeHVJQ0IyWVhJZ2MzUmhkR1VnUFNCMGFHbHpMbDl5WldGa1lXSnNaVk4wWVhSbE8xeHVYRzRnSUhOM2FYUmphQ0FvYzNSaGRHVXVjR2x3WlhORGIzVnVkQ2tnZTF4dUlDQWdJR05oYzJVZ01EcGNiaUFnSUNBZ0lITjBZWFJsTG5CcGNHVnpJRDBnWkdWemREdGNiaUFnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJR05oYzJVZ01UcGNiaUFnSUNBZ0lITjBZWFJsTG5CcGNHVnpJRDBnVzNOMFlYUmxMbkJwY0dWekxDQmtaWE4wWFR0Y2JpQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lHUmxabUYxYkhRNlhHNGdJQ0FnSUNCemRHRjBaUzV3YVhCbGN5NXdkWE5vS0dSbGMzUXBPMXh1SUNBZ0lDQWdZbkpsWVdzN1hHNGdJSDFjYmlBZ2MzUmhkR1V1Y0dsd1pYTkRiM1Z1ZENBclBTQXhPMXh1SUNCa1pXSjFaeWduY0dsd1pTQmpiM1Z1ZEQwbFpDQnZjSFJ6UFNWcUp5d2djM1JoZEdVdWNHbHdaWE5EYjNWdWRDd2djR2x3WlU5d2RITXBPMXh1WEc0Z0lIWmhjaUJrYjBWdVpDQTlJQ2doY0dsd1pVOXdkSE1nZkh3Z2NHbHdaVTl3ZEhNdVpXNWtJQ0U5UFNCbVlXeHpaU2tnSmlaY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnWkdWemRDQWhQVDBnY0hKdlkyVnpjeTV6ZEdSdmRYUWdKaVpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdaR1Z6ZENBaFBUMGdjSEp2WTJWemN5NXpkR1JsY25JN1hHNWNiaUFnZG1GeUlHVnVaRVp1SUQwZ1pHOUZibVFnUHlCdmJtVnVaQ0E2SUdOc1pXRnVkWEE3WEc0Z0lHbG1JQ2h6ZEdGMFpTNWxibVJGYldsMGRHVmtLVnh1SUNBZ0lIQnliMk5sYzNNdWJtVjRkRlJwWTJzb1pXNWtSbTRwTzF4dUlDQmxiSE5sWEc0Z0lDQWdjM0pqTG05dVkyVW9KMlZ1WkNjc0lHVnVaRVp1S1R0Y2JseHVJQ0JrWlhOMExtOXVLQ2QxYm5CcGNHVW5MQ0J2Ym5WdWNHbHdaU2s3WEc0Z0lHWjFibU4wYVc5dUlHOXVkVzV3YVhCbEtISmxZV1JoWW14bEtTQjdYRzRnSUNBZ1pHVmlkV2NvSjI5dWRXNXdhWEJsSnlrN1hHNGdJQ0FnYVdZZ0tISmxZV1JoWW14bElEMDlQU0J6Y21NcElIdGNiaUFnSUNBZ0lHTnNaV0Z1ZFhBb0tUdGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQm1kVzVqZEdsdmJpQnZibVZ1WkNncElIdGNiaUFnSUNCa1pXSjFaeWduYjI1bGJtUW5LVHRjYmlBZ0lDQmtaWE4wTG1WdVpDZ3BPMXh1SUNCOVhHNWNiaUFnTHk4Z2QyaGxiaUIwYUdVZ1pHVnpkQ0JrY21GcGJuTXNJR2wwSUhKbFpIVmpaWE1nZEdobElHRjNZV2wwUkhKaGFXNGdZMjkxYm5SbGNseHVJQ0F2THlCdmJpQjBhR1VnYzI5MWNtTmxMaUFnVkdocGN5QjNiM1ZzWkNCaVpTQnRiM0psSUdWc1pXZGhiblFnZDJsMGFDQmhJQzV2Ym1ObEtDbGNiaUFnTHk4Z2FHRnVaR3hsY2lCcGJpQm1iRzkzS0Nrc0lHSjFkQ0JoWkdScGJtY2dZVzVrSUhKbGJXOTJhVzVuSUhKbGNHVmhkR1ZrYkhrZ2FYTmNiaUFnTHk4Z2RHOXZJSE5zYjNjdVhHNGdJSFpoY2lCdmJtUnlZV2x1SUQwZ2NHbHdaVTl1UkhKaGFXNG9jM0pqS1R0Y2JpQWdaR1Z6ZEM1dmJpZ25aSEpoYVc0bkxDQnZibVJ5WVdsdUtUdGNibHh1SUNCbWRXNWpkR2x2YmlCamJHVmhiblZ3S0NrZ2UxeHVJQ0FnSUdSbFluVm5LQ2RqYkdWaGJuVndKeWs3WEc0Z0lDQWdMeThnWTJ4bFlXNTFjQ0JsZG1WdWRDQm9ZVzVrYkdWeWN5QnZibU5sSUhSb1pTQndhWEJsSUdseklHSnliMnRsYmx4dUlDQWdJR1JsYzNRdWNtVnRiM1psVEdsemRHVnVaWElvSjJOc2IzTmxKeXdnYjI1amJHOXpaU2s3WEc0Z0lDQWdaR1Z6ZEM1eVpXMXZkbVZNYVhOMFpXNWxjaWduWm1sdWFYTm9KeXdnYjI1bWFXNXBjMmdwTzF4dUlDQWdJR1JsYzNRdWNtVnRiM1psVEdsemRHVnVaWElvSjJSeVlXbHVKeXdnYjI1a2NtRnBiaWs3WEc0Z0lDQWdaR1Z6ZEM1eVpXMXZkbVZNYVhOMFpXNWxjaWduWlhKeWIzSW5MQ0J2Ym1WeWNtOXlLVHRjYmlBZ0lDQmtaWE4wTG5KbGJXOTJaVXhwYzNSbGJtVnlLQ2QxYm5CcGNHVW5MQ0J2Ym5WdWNHbHdaU2s3WEc0Z0lDQWdjM0pqTG5KbGJXOTJaVXhwYzNSbGJtVnlLQ2RsYm1RbkxDQnZibVZ1WkNrN1hHNGdJQ0FnYzNKakxuSmxiVzkyWlV4cGMzUmxibVZ5S0NkbGJtUW5MQ0JqYkdWaGJuVndLVHRjYmlBZ0lDQnpjbU11Y21WdGIzWmxUR2x6ZEdWdVpYSW9KMlJoZEdFbkxDQnZibVJoZEdFcE8xeHVYRzRnSUNBZ0x5OGdhV1lnZEdobElISmxZV1JsY2lCcGN5QjNZV2wwYVc1bklHWnZjaUJoSUdSeVlXbHVJR1YyWlc1MElHWnliMjBnZEdocGMxeHVJQ0FnSUM4dklITndaV05wWm1saklIZHlhWFJsY2l3Z2RHaGxiaUJwZENCM2IzVnNaQ0JqWVhWelpTQnBkQ0IwYnlCdVpYWmxjaUJ6ZEdGeWRGeHVJQ0FnSUM4dklHWnNiM2RwYm1jZ1lXZGhhVzR1WEc0Z0lDQWdMeThnVTI4c0lHbG1JSFJvYVhNZ2FYTWdZWGRoYVhScGJtY2dZU0JrY21GcGJpd2dkR2hsYmlCM1pTQnFkWE4wSUdOaGJHd2dhWFFnYm05M0xseHVJQ0FnSUM4dklFbG1JSGRsSUdSdmJpZDBJR3R1YjNjc0lIUm9aVzRnWVhOemRXMWxJSFJvWVhRZ2QyVWdZWEpsSUhkaGFYUnBibWNnWm05eUlHOXVaUzVjYmlBZ0lDQnBaaUFvYzNSaGRHVXVZWGRoYVhSRWNtRnBiaUFtSmx4dUlDQWdJQ0FnSUNBb0lXUmxjM1F1WDNkeWFYUmhZbXhsVTNSaGRHVWdmSHdnWkdWemRDNWZkM0pwZEdGaWJHVlRkR0YwWlM1dVpXVmtSSEpoYVc0cEtWeHVJQ0FnSUNBZ2IyNWtjbUZwYmlncE8xeHVJQ0I5WEc1Y2JpQWdjM0pqTG05dUtDZGtZWFJoSnl3Z2IyNWtZWFJoS1R0Y2JpQWdablZ1WTNScGIyNGdiMjVrWVhSaEtHTm9kVzVyS1NCN1hHNGdJQ0FnWkdWaWRXY29KMjl1WkdGMFlTY3BPMXh1SUNBZ0lIWmhjaUJ5WlhRZ1BTQmtaWE4wTG5keWFYUmxLR05vZFc1cktUdGNiaUFnSUNCcFppQW9abUZzYzJVZ1BUMDlJSEpsZENrZ2UxeHVJQ0FnSUNBZ1pHVmlkV2NvSjJaaGJITmxJSGR5YVhSbElISmxjM0J2Ym5ObExDQndZWFZ6WlNjc1hHNGdJQ0FnSUNBZ0lDQWdJQ0J6Y21NdVgzSmxZV1JoWW14bFUzUmhkR1V1WVhkaGFYUkVjbUZwYmlrN1hHNGdJQ0FnSUNCemNtTXVYM0psWVdSaFlteGxVM1JoZEdVdVlYZGhhWFJFY21GcGJpc3JPMXh1SUNBZ0lDQWdjM0pqTG5CaGRYTmxLQ2s3WEc0Z0lDQWdmVnh1SUNCOVhHNWNiaUFnTHk4Z2FXWWdkR2hsSUdSbGMzUWdhR0Z6SUdGdUlHVnljbTl5TENCMGFHVnVJSE4wYjNBZ2NHbHdhVzVuSUdsdWRHOGdhWFF1WEc0Z0lDOHZJR2h2ZDJWMlpYSXNJR1J2YmlkMElITjFjSEJ5WlhOeklIUm9aU0IwYUhKdmQybHVaeUJpWldoaGRtbHZjaUJtYjNJZ2RHaHBjeTVjYmlBZ1puVnVZM1JwYjI0Z2IyNWxjbkp2Y2lobGNpa2dlMXh1SUNBZ0lHUmxZblZuS0NkdmJtVnljbTl5Snl3Z1pYSXBPMXh1SUNBZ0lIVnVjR2x3WlNncE8xeHVJQ0FnSUdSbGMzUXVjbVZ0YjNabFRHbHpkR1Z1WlhJb0oyVnljbTl5Snl3Z2IyNWxjbkp2Y2lrN1hHNGdJQ0FnYVdZZ0tFVkZMbXhwYzNSbGJtVnlRMjkxYm5Rb1pHVnpkQ3dnSjJWeWNtOXlKeWtnUFQwOUlEQXBYRzRnSUNBZ0lDQmtaWE4wTG1WdGFYUW9KMlZ5Y205eUp5d2daWElwTzF4dUlDQjlYRzRnSUM4dklGUm9hWE1nYVhNZ1lTQmljblYwWVd4c2VTQjFaMng1SUdoaFkyc2dkRzhnYldGclpTQnpkWEpsSUhSb1lYUWdiM1Z5SUdWeWNtOXlJR2hoYm1Sc1pYSmNiaUFnTHk4Z2FYTWdZWFIwWVdOb1pXUWdZbVZtYjNKbElHRnVlU0IxYzJWeWJHRnVaQ0J2Ym1WekxpQWdUa1ZXUlZJZ1JFOGdWRWhKVXk1Y2JpQWdhV1lnS0NGa1pYTjBMbDlsZG1WdWRITWdmSHdnSVdSbGMzUXVYMlYyWlc1MGN5NWxjbkp2Y2lsY2JpQWdJQ0JrWlhOMExtOXVLQ2RsY25KdmNpY3NJRzl1WlhKeWIzSXBPMXh1SUNCbGJITmxJR2xtSUNocGMwRnljbUY1S0dSbGMzUXVYMlYyWlc1MGN5NWxjbkp2Y2lrcFhHNGdJQ0FnWkdWemRDNWZaWFpsYm5SekxtVnljbTl5TG5WdWMyaHBablFvYjI1bGNuSnZjaWs3WEc0Z0lHVnNjMlZjYmlBZ0lDQmtaWE4wTGw5bGRtVnVkSE11WlhKeWIzSWdQU0JiYjI1bGNuSnZjaXdnWkdWemRDNWZaWFpsYm5SekxtVnljbTl5WFR0Y2JseHVYRzVjYmlBZ0x5OGdRbTkwYUNCamJHOXpaU0JoYm1RZ1ptbHVhWE5vSUhOb2IzVnNaQ0IwY21sbloyVnlJSFZ1Y0dsd1pTd2dZblYwSUc5dWJIa2diMjVqWlM1Y2JpQWdablZ1WTNScGIyNGdiMjVqYkc5elpTZ3BJSHRjYmlBZ0lDQmtaWE4wTG5KbGJXOTJaVXhwYzNSbGJtVnlLQ2RtYVc1cGMyZ25MQ0J2Ym1acGJtbHphQ2s3WEc0Z0lDQWdkVzV3YVhCbEtDazdYRzRnSUgxY2JpQWdaR1Z6ZEM1dmJtTmxLQ2RqYkc5elpTY3NJRzl1WTJ4dmMyVXBPMXh1SUNCbWRXNWpkR2x2YmlCdmJtWnBibWx6YUNncElIdGNiaUFnSUNCa1pXSjFaeWduYjI1bWFXNXBjMmduS1R0Y2JpQWdJQ0JrWlhOMExuSmxiVzkyWlV4cGMzUmxibVZ5S0NkamJHOXpaU2NzSUc5dVkyeHZjMlVwTzF4dUlDQWdJSFZ1Y0dsd1pTZ3BPMXh1SUNCOVhHNGdJR1JsYzNRdWIyNWpaU2duWm1sdWFYTm9KeXdnYjI1bWFXNXBjMmdwTzF4dVhHNGdJR1oxYm1OMGFXOXVJSFZ1Y0dsd1pTZ3BJSHRjYmlBZ0lDQmtaV0oxWnlnbmRXNXdhWEJsSnlrN1hHNGdJQ0FnYzNKakxuVnVjR2x3WlNoa1pYTjBLVHRjYmlBZ2ZWeHVYRzRnSUM4dklIUmxiR3dnZEdobElHUmxjM1FnZEdoaGRDQnBkQ2R6SUdKbGFXNW5JSEJwY0dWa0lIUnZYRzRnSUdSbGMzUXVaVzFwZENnbmNHbHdaU2NzSUhOeVl5azdYRzVjYmlBZ0x5OGdjM1JoY25RZ2RHaGxJR1pzYjNjZ2FXWWdhWFFnYUdGemJpZDBJR0psWlc0Z2MzUmhjblJsWkNCaGJISmxZV1I1TGx4dUlDQnBaaUFvSVhOMFlYUmxMbVpzYjNkcGJtY3BJSHRjYmlBZ0lDQmtaV0oxWnlnbmNHbHdaU0J5WlhOMWJXVW5LVHRjYmlBZ0lDQnpjbU11Y21WemRXMWxLQ2s3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnWkdWemREdGNibjA3WEc1Y2JtWjFibU4wYVc5dUlIQnBjR1ZQYmtSeVlXbHVLSE55WXlrZ2UxeHVJQ0J5WlhSMWNtNGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdkbUZ5SUhOMFlYUmxJRDBnYzNKakxsOXlaV0ZrWVdKc1pWTjBZWFJsTzF4dUlDQWdJR1JsWW5WbktDZHdhWEJsVDI1RWNtRnBiaWNzSUhOMFlYUmxMbUYzWVdsMFJISmhhVzRwTzF4dUlDQWdJR2xtSUNoemRHRjBaUzVoZDJGcGRFUnlZV2x1S1Z4dUlDQWdJQ0FnYzNSaGRHVXVZWGRoYVhSRWNtRnBiaTB0TzF4dUlDQWdJR2xtSUNoemRHRjBaUzVoZDJGcGRFUnlZV2x1SUQwOVBTQXdJQ1ltSUVWRkxteHBjM1JsYm1WeVEyOTFiblFvYzNKakxDQW5aR0YwWVNjcEtTQjdYRzRnSUNBZ0lDQnpkR0YwWlM1bWJHOTNhVzVuSUQwZ2RISjFaVHRjYmlBZ0lDQWdJR1pzYjNjb2MzSmpLVHRjYmlBZ0lDQjlYRzRnSUgwN1hHNTlYRzVjYmx4dVVtVmhaR0ZpYkdVdWNISnZkRzkwZVhCbExuVnVjR2x3WlNBOUlHWjFibU4wYVc5dUtHUmxjM1FwSUh0Y2JpQWdkbUZ5SUhOMFlYUmxJRDBnZEdocGN5NWZjbVZoWkdGaWJHVlRkR0YwWlR0Y2JseHVJQ0F2THlCcFppQjNaU2R5WlNCdWIzUWdjR2x3YVc1bklHRnVlWGRvWlhKbExDQjBhR1Z1SUdSdklHNXZkR2hwYm1jdVhHNGdJR2xtSUNoemRHRjBaUzV3YVhCbGMwTnZkVzUwSUQwOVBTQXdLVnh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpPMXh1WEc0Z0lDOHZJR3AxYzNRZ2IyNWxJR1JsYzNScGJtRjBhVzl1TGlBZ2JXOXpkQ0JqYjIxdGIyNGdZMkZ6WlM1Y2JpQWdhV1lnS0hOMFlYUmxMbkJwY0dWelEyOTFiblFnUFQwOUlERXBJSHRjYmlBZ0lDQXZMeUJ3WVhOelpXUWdhVzRnYjI1bExDQmlkWFFnYVhRbmN5QnViM1FnZEdobElISnBaMmgwSUc5dVpTNWNiaUFnSUNCcFppQW9aR1Z6ZENBbUppQmtaWE4wSUNFOVBTQnpkR0YwWlM1d2FYQmxjeWxjYmlBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dVhHNGdJQ0FnYVdZZ0tDRmtaWE4wS1Z4dUlDQWdJQ0FnWkdWemRDQTlJSE4wWVhSbExuQnBjR1Z6TzF4dVhHNGdJQ0FnTHk4Z1oyOTBJR0VnYldGMFkyZ3VYRzRnSUNBZ2MzUmhkR1V1Y0dsd1pYTWdQU0J1ZFd4c08xeHVJQ0FnSUhOMFlYUmxMbkJwY0dWelEyOTFiblFnUFNBd08xeHVJQ0FnSUhOMFlYUmxMbVpzYjNkcGJtY2dQU0JtWVd4elpUdGNiaUFnSUNCcFppQW9aR1Z6ZENsY2JpQWdJQ0FnSUdSbGMzUXVaVzFwZENnbmRXNXdhWEJsSnl3Z2RHaHBjeWs3WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE03WEc0Z0lIMWNibHh1SUNBdkx5QnpiRzkzSUdOaGMyVXVJRzExYkhScGNHeGxJSEJwY0dVZ1pHVnpkR2x1WVhScGIyNXpMbHh1WEc0Z0lHbG1JQ2doWkdWemRDa2dlMXh1SUNBZ0lDOHZJSEpsYlc5MlpTQmhiR3d1WEc0Z0lDQWdkbUZ5SUdSbGMzUnpJRDBnYzNSaGRHVXVjR2x3WlhNN1hHNGdJQ0FnZG1GeUlHeGxiaUE5SUhOMFlYUmxMbkJwY0dWelEyOTFiblE3WEc0Z0lDQWdjM1JoZEdVdWNHbHdaWE1nUFNCdWRXeHNPMXh1SUNBZ0lITjBZWFJsTG5CcGNHVnpRMjkxYm5RZ1BTQXdPMXh1SUNBZ0lITjBZWFJsTG1ac2IzZHBibWNnUFNCbVlXeHpaVHRjYmx4dUlDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYkdWdU95QnBLeXNwWEc0Z0lDQWdJQ0JrWlhOMGMxdHBYUzVsYldsMEtDZDFibkJwY0dVbkxDQjBhR2x6S1R0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmVnh1WEc0Z0lDOHZJSFJ5ZVNCMGJ5Qm1hVzVrSUhSb1pTQnlhV2RvZENCdmJtVXVYRzRnSUhaaGNpQnBJRDBnYVc1a1pYaFBaaWh6ZEdGMFpTNXdhWEJsY3l3Z1pHVnpkQ2s3WEc0Z0lHbG1JQ2hwSUQwOVBTQXRNU2xjYmlBZ0lDQnlaWFIxY200Z2RHaHBjenRjYmx4dUlDQnpkR0YwWlM1d2FYQmxjeTV6Y0d4cFkyVW9hU3dnTVNrN1hHNGdJSE4wWVhSbExuQnBjR1Z6UTI5MWJuUWdMVDBnTVR0Y2JpQWdhV1lnS0hOMFlYUmxMbkJwY0dWelEyOTFiblFnUFQwOUlERXBYRzRnSUNBZ2MzUmhkR1V1Y0dsd1pYTWdQU0J6ZEdGMFpTNXdhWEJsYzFzd1hUdGNibHh1SUNCa1pYTjBMbVZ0YVhRb0ozVnVjR2x3WlNjc0lIUm9hWE1wTzF4dVhHNGdJSEpsZEhWeWJpQjBhR2x6TzF4dWZUdGNibHh1THk4Z2MyVjBJSFZ3SUdSaGRHRWdaWFpsYm5SeklHbG1JSFJvWlhrZ1lYSmxJR0Z6YTJWa0lHWnZjbHh1THk4Z1JXNXpkWEpsSUhKbFlXUmhZbXhsSUd4cGMzUmxibVZ5Y3lCbGRtVnVkSFZoYkd4NUlHZGxkQ0J6YjIxbGRHaHBibWRjYmxKbFlXUmhZbXhsTG5CeWIzUnZkSGx3WlM1dmJpQTlJR1oxYm1OMGFXOXVLR1YyTENCbWJpa2dlMXh1SUNCMllYSWdjbVZ6SUQwZ1UzUnlaV0Z0TG5CeWIzUnZkSGx3WlM1dmJpNWpZV3hzS0hSb2FYTXNJR1YyTENCbWJpazdYRzVjYmlBZ0x5OGdTV1lnYkdsemRHVnVhVzVuSUhSdklHUmhkR0VzSUdGdVpDQnBkQ0JvWVhNZ2JtOTBJR1Y0Y0d4cFkybDBiSGtnWW1WbGJpQndZWFZ6WldRc1hHNGdJQzh2SUhSb1pXNGdZMkZzYkNCeVpYTjFiV1VnZEc4Z2MzUmhjblFnZEdobElHWnNiM2NnYjJZZ1pHRjBZU0J2YmlCMGFHVWdibVY0ZENCMGFXTnJMbHh1SUNCcFppQW9aWFlnUFQwOUlDZGtZWFJoSnlBbUppQm1ZV3h6WlNBaFBUMGdkR2hwY3k1ZmNtVmhaR0ZpYkdWVGRHRjBaUzVtYkc5M2FXNW5LU0I3WEc0Z0lDQWdkR2hwY3k1eVpYTjFiV1VvS1R0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2hsZGlBOVBUMGdKM0psWVdSaFlteGxKeUFtSmlCMGFHbHpMbkpsWVdSaFlteGxLU0I3WEc0Z0lDQWdkbUZ5SUhOMFlYUmxJRDBnZEdocGN5NWZjbVZoWkdGaWJHVlRkR0YwWlR0Y2JpQWdJQ0JwWmlBb0lYTjBZWFJsTG5KbFlXUmhZbXhsVEdsemRHVnVhVzVuS1NCN1hHNGdJQ0FnSUNCemRHRjBaUzV5WldGa1lXSnNaVXhwYzNSbGJtbHVaeUE5SUhSeWRXVTdYRzRnSUNBZ0lDQnpkR0YwWlM1bGJXbDBkR1ZrVW1WaFpHRmliR1VnUFNCbVlXeHpaVHRjYmlBZ0lDQWdJSE4wWVhSbExtNWxaV1JTWldGa1lXSnNaU0E5SUhSeWRXVTdYRzRnSUNBZ0lDQnBaaUFvSVhOMFlYUmxMbkpsWVdScGJtY3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlITmxiR1lnUFNCMGFHbHpPMXh1SUNBZ0lDQWdJQ0J3Y205alpYTnpMbTVsZUhSVWFXTnJLR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lHUmxZblZuS0NkeVpXRmtZV0pzWlNCdVpYaDBkR2xqYXlCeVpXRmtJREFuS1R0Y2JpQWdJQ0FnSUNBZ0lDQnpaV3htTG5KbFlXUW9NQ2s3WEc0Z0lDQWdJQ0FnSUgwcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaHpkR0YwWlM1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUNBZ1pXMXBkRkpsWVdSaFlteGxLSFJvYVhNc0lITjBZWFJsS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnY21Wek8xeHVmVHRjYmxKbFlXUmhZbXhsTG5CeWIzUnZkSGx3WlM1aFpHUk1hWE4wWlc1bGNpQTlJRkpsWVdSaFlteGxMbkJ5YjNSdmRIbHdaUzV2Ymp0Y2JseHVMeThnY0dGMWMyVW9LU0JoYm1RZ2NtVnpkVzFsS0NrZ1lYSmxJSEpsYlc1aGJuUnpJRzltSUhSb1pTQnNaV2RoWTNrZ2NtVmhaR0ZpYkdVZ2MzUnlaV0Z0SUVGUVNWeHVMeThnU1dZZ2RHaGxJSFZ6WlhJZ2RYTmxjeUIwYUdWdExDQjBhR1Z1SUhOM2FYUmphQ0JwYm5SdklHOXNaQ0J0YjJSbExseHVVbVZoWkdGaWJHVXVjSEp2ZEc5MGVYQmxMbkpsYzNWdFpTQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQjJZWElnYzNSaGRHVWdQU0IwYUdsekxsOXlaV0ZrWVdKc1pWTjBZWFJsTzF4dUlDQnBaaUFvSVhOMFlYUmxMbVpzYjNkcGJtY3BJSHRjYmlBZ0lDQmtaV0oxWnlnbmNtVnpkVzFsSnlrN1hHNGdJQ0FnYzNSaGRHVXVabXh2ZDJsdVp5QTlJSFJ5ZFdVN1hHNGdJQ0FnYVdZZ0tDRnpkR0YwWlM1eVpXRmthVzVuS1NCN1hHNGdJQ0FnSUNCa1pXSjFaeWduY21WemRXMWxJSEpsWVdRZ01DY3BPMXh1SUNBZ0lDQWdkR2hwY3k1eVpXRmtLREFwTzF4dUlDQWdJSDFjYmlBZ0lDQnlaWE4xYldVb2RHaHBjeXdnYzNSaGRHVXBPMXh1SUNCOVhHNGdJSEpsZEhWeWJpQjBhR2x6TzF4dWZUdGNibHh1Wm5WdVkzUnBiMjRnY21WemRXMWxLSE4wY21WaGJTd2djM1JoZEdVcElIdGNiaUFnYVdZZ0tDRnpkR0YwWlM1eVpYTjFiV1ZUWTJobFpIVnNaV1FwSUh0Y2JpQWdJQ0J6ZEdGMFpTNXlaWE4xYldWVFkyaGxaSFZzWldRZ1BTQjBjblZsTzF4dUlDQWdJSEJ5YjJObGMzTXVibVY0ZEZScFkyc29ablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J5WlhOMWJXVmZLSE4wY21WaGJTd2djM1JoZEdVcE8xeHVJQ0FnSUgwcE8xeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJSEpsYzNWdFpWOG9jM1J5WldGdExDQnpkR0YwWlNrZ2UxeHVJQ0J6ZEdGMFpTNXlaWE4xYldWVFkyaGxaSFZzWldRZ1BTQm1ZV3h6WlR0Y2JpQWdjM1J5WldGdExtVnRhWFFvSjNKbGMzVnRaU2NwTzF4dUlDQm1iRzkzS0hOMGNtVmhiU2s3WEc0Z0lHbG1JQ2h6ZEdGMFpTNW1iRzkzYVc1bklDWW1JQ0Z6ZEdGMFpTNXlaV0ZrYVc1bktWeHVJQ0FnSUhOMGNtVmhiUzV5WldGa0tEQXBPMXh1ZlZ4dVhHNVNaV0ZrWVdKc1pTNXdjbTkwYjNSNWNHVXVjR0YxYzJVZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ1pHVmlkV2NvSjJOaGJHd2djR0YxYzJVZ1pteHZkMmx1WnowbGFpY3NJSFJvYVhNdVgzSmxZV1JoWW14bFUzUmhkR1V1Wm14dmQybHVaeWs3WEc0Z0lHbG1JQ2htWVd4elpTQWhQVDBnZEdocGN5NWZjbVZoWkdGaWJHVlRkR0YwWlM1bWJHOTNhVzVuS1NCN1hHNGdJQ0FnWkdWaWRXY29KM0JoZFhObEp5azdYRzRnSUNBZ2RHaHBjeTVmY21WaFpHRmliR1ZUZEdGMFpTNW1iRzkzYVc1bklEMGdabUZzYzJVN1hHNGdJQ0FnZEdocGN5NWxiV2wwS0Nkd1lYVnpaU2NwTzF4dUlDQjlYRzRnSUhKbGRIVnliaUIwYUdsek8xeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z1pteHZkeWh6ZEhKbFlXMHBJSHRjYmlBZ2RtRnlJSE4wWVhSbElEMGdjM1J5WldGdExsOXlaV0ZrWVdKc1pWTjBZWFJsTzF4dUlDQmtaV0oxWnlnblpteHZkeWNzSUhOMFlYUmxMbVpzYjNkcGJtY3BPMXh1SUNCcFppQW9jM1JoZEdVdVpteHZkMmx1WnlrZ2UxeHVJQ0FnSUdSdklIdGNiaUFnSUNBZ0lIWmhjaUJqYUhWdWF5QTlJSE4wY21WaGJTNXlaV0ZrS0NrN1hHNGdJQ0FnZlNCM2FHbHNaU0FvYm5Wc2JDQWhQVDBnWTJoMWJtc2dKaVlnYzNSaGRHVXVabXh2ZDJsdVp5azdYRzRnSUgxY2JuMWNibHh1THk4Z2QzSmhjQ0JoYmlCdmJHUXRjM1I1YkdVZ2MzUnlaV0Z0SUdGeklIUm9aU0JoYzNsdVl5QmtZWFJoSUhOdmRYSmpaUzVjYmk4dklGUm9hWE1nYVhNZ0ttNXZkQ29nY0dGeWRDQnZaaUIwYUdVZ2NtVmhaR0ZpYkdVZ2MzUnlaV0Z0SUdsdWRHVnlabUZqWlM1Y2JpOHZJRWwwSUdseklHRnVJSFZuYkhrZ2RXNW1iM0owZFc1aGRHVWdiV1Z6Y3lCdlppQm9hWE4wYjNKNUxseHVVbVZoWkdGaWJHVXVjSEp2ZEc5MGVYQmxMbmR5WVhBZ1BTQm1kVzVqZEdsdmJpaHpkSEpsWVcwcElIdGNiaUFnZG1GeUlITjBZWFJsSUQwZ2RHaHBjeTVmY21WaFpHRmliR1ZUZEdGMFpUdGNiaUFnZG1GeUlIQmhkWE5sWkNBOUlHWmhiSE5sTzF4dVhHNGdJSFpoY2lCelpXeG1JRDBnZEdocGN6dGNiaUFnYzNSeVpXRnRMbTl1S0NkbGJtUW5MQ0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0JrWldKMVp5Z25kM0poY0hCbFpDQmxibVFuS1R0Y2JpQWdJQ0JwWmlBb2MzUmhkR1V1WkdWamIyUmxjaUFtSmlBaGMzUmhkR1V1Wlc1a1pXUXBJSHRjYmlBZ0lDQWdJSFpoY2lCamFIVnVheUE5SUhOMFlYUmxMbVJsWTI5a1pYSXVaVzVrS0NrN1hHNGdJQ0FnSUNCcFppQW9ZMmgxYm1zZ0ppWWdZMmgxYm1zdWJHVnVaM1JvS1Z4dUlDQWdJQ0FnSUNCelpXeG1MbkIxYzJnb1kyaDFibXNwTzF4dUlDQWdJSDFjYmx4dUlDQWdJSE5sYkdZdWNIVnphQ2h1ZFd4c0tUdGNiaUFnZlNrN1hHNWNiaUFnYzNSeVpXRnRMbTl1S0Nka1lYUmhKeXdnWm5WdVkzUnBiMjRvWTJoMWJtc3BJSHRjYmlBZ0lDQmtaV0oxWnlnbmQzSmhjSEJsWkNCa1lYUmhKeWs3WEc0Z0lDQWdhV1lnS0hOMFlYUmxMbVJsWTI5a1pYSXBYRzRnSUNBZ0lDQmphSFZ1YXlBOUlITjBZWFJsTG1SbFkyOWtaWEl1ZDNKcGRHVW9ZMmgxYm1zcE8xeHVJQ0FnSUdsbUlDZ2hZMmgxYm1zZ2ZId2dJWE4wWVhSbExtOWlhbVZqZEUxdlpHVWdKaVlnSVdOb2RXNXJMbXhsYm1kMGFDbGNiaUFnSUNBZ0lISmxkSFZ5Ymp0Y2JseHVJQ0FnSUhaaGNpQnlaWFFnUFNCelpXeG1MbkIxYzJnb1kyaDFibXNwTzF4dUlDQWdJR2xtSUNnaGNtVjBLU0I3WEc0Z0lDQWdJQ0J3WVhWelpXUWdQU0IwY25WbE8xeHVJQ0FnSUNBZ2MzUnlaV0Z0TG5CaGRYTmxLQ2s3WEc0Z0lDQWdmVnh1SUNCOUtUdGNibHh1SUNBdkx5QndjbTk0ZVNCaGJHd2dkR2hsSUc5MGFHVnlJRzFsZEdodlpITXVYRzRnSUM4dklHbHRjRzl5ZEdGdWRDQjNhR1Z1SUhkeVlYQndhVzVuSUdacGJIUmxjbk1nWVc1a0lHUjFjR3hsZUdWekxseHVJQ0JtYjNJZ0tIWmhjaUJwSUdsdUlITjBjbVZoYlNrZ2UxeHVJQ0FnSUdsbUlDaDFkR2xzTG1selJuVnVZM1JwYjI0b2MzUnlaV0Z0VzJsZEtTQW1KaUIxZEdsc0xtbHpWVzVrWldacGJtVmtLSFJvYVhOYmFWMHBLU0I3WEc0Z0lDQWdJQ0IwYUdselcybGRJRDBnWm5WdVkzUnBiMjRvYldWMGFHOWtLU0I3SUhKbGRIVnliaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhOMGNtVmhiVnR0WlhSb2IyUmRMbUZ3Y0d4NUtITjBjbVZoYlN3Z1lYSm5kVzFsYm5SektUdGNiaUFnSUNBZ0lIMTlLR2twTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUM4dklIQnliM2g1SUdObGNuUmhhVzRnYVcxd2IzSjBZVzUwSUdWMlpXNTBjeTVjYmlBZ2RtRnlJR1YyWlc1MGN5QTlJRnNuWlhKeWIzSW5MQ0FuWTJ4dmMyVW5MQ0FuWkdWemRISnZlU2NzSUNkd1lYVnpaU2NzSUNkeVpYTjFiV1VuWFR0Y2JpQWdabTl5UldGamFDaGxkbVZ1ZEhNc0lHWjFibU4wYVc5dUtHVjJLU0I3WEc0Z0lDQWdjM1J5WldGdExtOXVLR1YyTENCelpXeG1MbVZ0YVhRdVltbHVaQ2h6Wld4bUxDQmxkaWtwTzF4dUlDQjlLVHRjYmx4dUlDQXZMeUIzYUdWdUlIZGxJSFJ5ZVNCMGJ5QmpiMjV6ZFcxbElITnZiV1VnYlc5eVpTQmllWFJsY3l3Z2MybHRjR3g1SUhWdWNHRjFjMlVnZEdobFhHNGdJQzh2SUhWdVpHVnliSGxwYm1jZ2MzUnlaV0Z0TGx4dUlDQnpaV3htTGw5eVpXRmtJRDBnWm5WdVkzUnBiMjRvYmlrZ2UxeHVJQ0FnSUdSbFluVm5LQ2QzY21Gd2NHVmtJRjl5WldGa0p5d2diaWs3WEc0Z0lDQWdhV1lnS0hCaGRYTmxaQ2tnZTF4dUlDQWdJQ0FnY0dGMWMyVmtJRDBnWm1Gc2MyVTdYRzRnSUNBZ0lDQnpkSEpsWVcwdWNtVnpkVzFsS0NrN1hHNGdJQ0FnZlZ4dUlDQjlPMXh1WEc0Z0lISmxkSFZ5YmlCelpXeG1PMXh1ZlR0Y2JseHVYRzVjYmk4dklHVjRjRzl6WldRZ1ptOXlJSFJsYzNScGJtY2djSFZ5Y0c5elpYTWdiMjVzZVM1Y2JsSmxZV1JoWW14bExsOW1jbTl0VEdsemRDQTlJR1p5YjIxTWFYTjBPMXh1WEc0dkx5QlFiSFZqYXlCdlptWWdiaUJpZVhSbGN5Qm1jbTl0SUdGdUlHRnljbUY1SUc5bUlHSjFabVpsY25NdVhHNHZMeUJNWlc1bmRHZ2dhWE1nZEdobElHTnZiV0pwYm1Wa0lHeGxibWQwYUhNZ2IyWWdZV3hzSUhSb1pTQmlkV1ptWlhKeklHbHVJSFJvWlNCc2FYTjBMbHh1Wm5WdVkzUnBiMjRnWm5KdmJVeHBjM1FvYml3Z2MzUmhkR1VwSUh0Y2JpQWdkbUZ5SUd4cGMzUWdQU0J6ZEdGMFpTNWlkV1ptWlhJN1hHNGdJSFpoY2lCc1pXNW5kR2dnUFNCemRHRjBaUzVzWlc1bmRHZzdYRzRnSUhaaGNpQnpkSEpwYm1kTmIyUmxJRDBnSVNGemRHRjBaUzVrWldOdlpHVnlPMXh1SUNCMllYSWdiMkpxWldOMFRXOWtaU0E5SUNFaGMzUmhkR1V1YjJKcVpXTjBUVzlrWlR0Y2JpQWdkbUZ5SUhKbGREdGNibHh1SUNBdkx5QnViM1JvYVc1bklHbHVJSFJvWlNCc2FYTjBMQ0JrWldacGJtbDBaV3g1SUdWdGNIUjVMbHh1SUNCcFppQW9iR2x6ZEM1c1pXNW5kR2dnUFQwOUlEQXBYRzRnSUNBZ2NtVjBkWEp1SUc1MWJHdzdYRzVjYmlBZ2FXWWdLR3hsYm1kMGFDQTlQVDBnTUNsY2JpQWdJQ0J5WlhRZ1BTQnVkV3hzTzF4dUlDQmxiSE5sSUdsbUlDaHZZbXBsWTNSTmIyUmxLVnh1SUNBZ0lISmxkQ0E5SUd4cGMzUXVjMmhwWm5Rb0tUdGNiaUFnWld4elpTQnBaaUFvSVc0Z2ZId2diaUErUFNCc1pXNW5kR2dwSUh0Y2JpQWdJQ0F2THlCeVpXRmtJR2wwSUdGc2JDd2dkSEoxYm1OaGRHVWdkR2hsSUdGeWNtRjVMbHh1SUNBZ0lHbG1JQ2h6ZEhKcGJtZE5iMlJsS1Z4dUlDQWdJQ0FnY21WMElEMGdiR2x6ZEM1cWIybHVLQ2NuS1R0Y2JpQWdJQ0JsYkhObFhHNGdJQ0FnSUNCeVpYUWdQU0JDZFdabVpYSXVZMjl1WTJGMEtHeHBjM1FzSUd4bGJtZDBhQ2s3WEc0Z0lDQWdiR2x6ZEM1c1pXNW5kR2dnUFNBd08xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDOHZJSEpsWVdRZ2FuVnpkQ0J6YjIxbElHOW1JR2wwTGx4dUlDQWdJR2xtSUNodUlEd2diR2x6ZEZzd1hTNXNaVzVuZEdncElIdGNiaUFnSUNBZ0lDOHZJR3AxYzNRZ2RHRnJaU0JoSUhCaGNuUWdiMllnZEdobElHWnBjbk4wSUd4cGMzUWdhWFJsYlM1Y2JpQWdJQ0FnSUM4dklITnNhV05sSUdseklIUm9aU0J6WVcxbElHWnZjaUJpZFdabVpYSnpJR0Z1WkNCemRISnBibWR6TGx4dUlDQWdJQ0FnZG1GeUlHSjFaaUE5SUd4cGMzUmJNRjA3WEc0Z0lDQWdJQ0J5WlhRZ1BTQmlkV1l1YzJ4cFkyVW9NQ3dnYmlrN1hHNGdJQ0FnSUNCc2FYTjBXekJkSUQwZ1luVm1Mbk5zYVdObEtHNHBPMXh1SUNBZ0lIMGdaV3h6WlNCcFppQW9iaUE5UFQwZ2JHbHpkRnN3WFM1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUM4dklHWnBjbk4wSUd4cGMzUWdhWE1nWVNCd1pYSm1aV04wSUcxaGRHTm9YRzRnSUNBZ0lDQnlaWFFnUFNCc2FYTjBMbk5vYVdaMEtDazdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUM4dklHTnZiWEJzWlhnZ1kyRnpaUzVjYmlBZ0lDQWdJQzh2SUhkbElHaGhkbVVnWlc1dmRXZG9JSFJ2SUdOdmRtVnlJR2wwTENCaWRYUWdhWFFnYzNCaGJuTWdjR0Z6ZENCMGFHVWdabWx5YzNRZ1luVm1abVZ5TGx4dUlDQWdJQ0FnYVdZZ0tITjBjbWx1WjAxdlpHVXBYRzRnSUNBZ0lDQWdJSEpsZENBOUlDY25PMXh1SUNBZ0lDQWdaV3h6WlZ4dUlDQWdJQ0FnSUNCeVpYUWdQU0J1WlhjZ1FuVm1abVZ5S0c0cE8xeHVYRzRnSUNBZ0lDQjJZWElnWXlBOUlEQTdYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnTUN3Z2JDQTlJR3hwYzNRdWJHVnVaM1JvT3lCcElEd2diQ0FtSmlCaklEd2dianNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCaWRXWWdQU0JzYVhOMFd6QmRPMXh1SUNBZ0lDQWdJQ0IyWVhJZ1kzQjVJRDBnVFdGMGFDNXRhVzRvYmlBdElHTXNJR0oxWmk1c1pXNW5kR2dwTzF4dVhHNGdJQ0FnSUNBZ0lHbG1JQ2h6ZEhKcGJtZE5iMlJsS1Z4dUlDQWdJQ0FnSUNBZ0lISmxkQ0FyUFNCaWRXWXVjMnhwWTJVb01Dd2dZM0I1S1R0Y2JpQWdJQ0FnSUNBZ1pXeHpaVnh1SUNBZ0lDQWdJQ0FnSUdKMVppNWpiM0I1S0hKbGRDd2dZeXdnTUN3Z1kzQjVLVHRjYmx4dUlDQWdJQ0FnSUNCcFppQW9ZM0I1SUR3Z1luVm1MbXhsYm1kMGFDbGNiaUFnSUNBZ0lDQWdJQ0JzYVhOMFd6QmRJRDBnWW5WbUxuTnNhV05sS0dOd2VTazdYRzRnSUNBZ0lDQWdJR1ZzYzJWY2JpQWdJQ0FnSUNBZ0lDQnNhWE4wTG5Ob2FXWjBLQ2s3WEc1Y2JpQWdJQ0FnSUNBZ1l5QXJQU0JqY0hrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dUlDQjlYRzVjYmlBZ2NtVjBkWEp1SUhKbGREdGNibjFjYmx4dVpuVnVZM1JwYjI0Z1pXNWtVbVZoWkdGaWJHVW9jM1J5WldGdEtTQjdYRzRnSUhaaGNpQnpkR0YwWlNBOUlITjBjbVZoYlM1ZmNtVmhaR0ZpYkdWVGRHRjBaVHRjYmx4dUlDQXZMeUJKWmlCM1pTQm5aWFFnYUdWeVpTQmlaV1p2Y21VZ1kyOXVjM1Z0YVc1bklHRnNiQ0IwYUdVZ1lubDBaWE1zSUhSb1pXNGdkR2hoZENCcGN5QmhYRzRnSUM4dklHSjFaeUJwYmlCdWIyUmxMaUFnVTJodmRXeGtJRzVsZG1WeUlHaGhjSEJsYmk1Y2JpQWdhV1lnS0hOMFlYUmxMbXhsYm1kMGFDQStJREFwWEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtDZGxibVJTWldGa1lXSnNaU0JqWVd4c1pXUWdiMjRnYm05dUxXVnRjSFI1SUhOMGNtVmhiU2NwTzF4dVhHNGdJR2xtSUNnaGMzUmhkR1V1Wlc1a1JXMXBkSFJsWkNrZ2UxeHVJQ0FnSUhOMFlYUmxMbVZ1WkdWa0lEMGdkSEoxWlR0Y2JpQWdJQ0J3Y205alpYTnpMbTVsZUhSVWFXTnJLR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnTHk4Z1EyaGxZMnNnZEdoaGRDQjNaU0JrYVdSdUozUWdaMlYwSUc5dVpTQnNZWE4wSUhWdWMyaHBablF1WEc0Z0lDQWdJQ0JwWmlBb0lYTjBZWFJsTG1WdVpFVnRhWFIwWldRZ0ppWWdjM1JoZEdVdWJHVnVaM1JvSUQwOVBTQXdLU0I3WEc0Z0lDQWdJQ0FnSUhOMFlYUmxMbVZ1WkVWdGFYUjBaV1FnUFNCMGNuVmxPMXh1SUNBZ0lDQWdJQ0J6ZEhKbFlXMHVjbVZoWkdGaWJHVWdQU0JtWVd4elpUdGNiaUFnSUNBZ0lDQWdjM1J5WldGdExtVnRhWFFvSjJWdVpDY3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHBPMXh1SUNCOVhHNTlYRzVjYm1aMWJtTjBhVzl1SUdadmNrVmhZMmdnS0hoekxDQm1LU0I3WEc0Z0lHWnZjaUFvZG1GeUlHa2dQU0F3TENCc0lEMGdlSE11YkdWdVozUm9PeUJwSUR3Z2JEc2dhU3NyS1NCN1hHNGdJQ0FnWmloNGMxdHBYU3dnYVNrN1hHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdhVzVrWlhoUFppQW9lSE1zSUhncElIdGNiaUFnWm05eUlDaDJZWElnYVNBOUlEQXNJR3dnUFNCNGN5NXNaVzVuZEdnN0lHa2dQQ0JzT3lCcEt5c3BJSHRjYmlBZ0lDQnBaaUFvZUhOYmFWMGdQVDA5SUhncElISmxkSFZ5YmlCcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlBdE1UdGNibjFjYmlKZGZRPT0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoZGF0YSkpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHRoaXMuX2ZsdXNoKSlcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICghdXRpbC5pc051bGwodHMud3JpdGVjaHVuaykgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihjYikpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHV0aWwuaXNTdHJpbmcoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIGlmICh1dGlsLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KVxuICAgIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtcbiAgZWxzZVxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgZWxzZSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXIpO1xuICB9XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiZcbiAgICAgICAgIXN0YXRlLmNvcmtlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGggPiAxKSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBjYnMgPSBbXTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKylcbiAgICAgIGNicy5wdXNoKHN0YXRlLmJ1ZmZlcltjXS5jYWxsYmFjayk7XG5cbiAgICAvLyBjb3VudCB0aGUgb25lIHdlIGFyZSBhZGRpbmcsIGFzIHdlbGwuXG4gICAgLy8gVE9ETyhpc2FhY3MpIGNsZWFuIHRoaXMgdXBcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgc3RhdGUuYnVmZmVyLCAnJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgICAgY2JzW2ldKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbGVhciBidWZmZXJcbiAgICBzdGF0ZS5idWZmZXIgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGMrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGggPSAwO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcblxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oY2h1bmspKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNGdW5jdGlvbihlbmNvZGluZykpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2VcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTl6ZEhKbFlXMHRZbkp2ZDNObGNtbG1lUzl1YjJSbFgyMXZaSFZzWlhNdmNtVmhaR0ZpYkdVdGMzUnlaV0Z0TDJ4cFlpOWZjM1J5WldGdFgzZHlhWFJoWW14bExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnUTI5d2VYSnBaMmgwSUVwdmVXVnVkQ3dnU1c1akxpQmhibVFnYjNSb1pYSWdUbTlrWlNCamIyNTBjbWxpZFhSdmNuTXVYRzR2TDF4dUx5OGdVR1Z5YldsemMybHZiaUJwY3lCb1pYSmxZbmtnWjNKaGJuUmxaQ3dnWm5KbFpTQnZaaUJqYUdGeVoyVXNJSFJ2SUdGdWVTQndaWEp6YjI0Z2IySjBZV2x1YVc1bklHRmNiaTh2SUdOdmNIa2diMllnZEdocGN5QnpiMlowZDJGeVpTQmhibVFnWVhOemIyTnBZWFJsWkNCa2IyTjFiV1Z1ZEdGMGFXOXVJR1pwYkdWeklDaDBhR1ZjYmk4dklGd2lVMjltZEhkaGNtVmNJaWtzSUhSdklHUmxZV3dnYVc0Z2RHaGxJRk52Wm5SM1lYSmxJSGRwZEdodmRYUWdjbVZ6ZEhKcFkzUnBiMjRzSUdsdVkyeDFaR2x1WjF4dUx5OGdkMmwwYUc5MWRDQnNhVzFwZEdGMGFXOXVJSFJvWlNCeWFXZG9kSE1nZEc4Z2RYTmxMQ0JqYjNCNUxDQnRiMlJwWm5rc0lHMWxjbWRsTENCd2RXSnNhWE5vTEZ4dUx5OGdaR2x6ZEhKcFluVjBaU3dnYzNWaWJHbGpaVzV6WlN3Z1lXNWtMMjl5SUhObGJHd2dZMjl3YVdWeklHOW1JSFJvWlNCVGIyWjBkMkZ5WlN3Z1lXNWtJSFJ2SUhCbGNtMXBkRnh1THk4Z2NHVnljMjl1Y3lCMGJ5QjNhRzl0SUhSb1pTQlRiMlowZDJGeVpTQnBjeUJtZFhKdWFYTm9aV1FnZEc4Z1pHOGdjMjhzSUhOMVltcGxZM1FnZEc4Z2RHaGxYRzR2THlCbWIyeHNiM2RwYm1jZ1kyOXVaR2wwYVc5dWN6cGNiaTh2WEc0dkx5QlVhR1VnWVdKdmRtVWdZMjl3ZVhKcFoyaDBJRzV2ZEdsalpTQmhibVFnZEdocGN5QndaWEp0YVhOemFXOXVJRzV2ZEdsalpTQnphR0ZzYkNCaVpTQnBibU5zZFdSbFpGeHVMeThnYVc0Z1lXeHNJR052Y0dsbGN5QnZjaUJ6ZFdKemRHRnVkR2xoYkNCd2IzSjBhVzl1Y3lCdlppQjBhR1VnVTI5bWRIZGhjbVV1WEc0dkwxeHVMeThnVkVoRklGTlBSbFJYUVZKRklFbFRJRkJTVDFaSlJFVkVJRndpUVZNZ1NWTmNJaXdnVjBsVVNFOVZWQ0JYUVZKU1FVNVVXU0JQUmlCQlRsa2dTMGxPUkN3Z1JWaFFVa1ZUVTF4dUx5OGdUMUlnU1UxUVRFbEZSQ3dnU1U1RFRGVkVTVTVISUVKVlZDQk9UMVFnVEVsTlNWUkZSQ0JVVHlCVVNFVWdWMEZTVWtGT1ZFbEZVeUJQUmx4dUx5OGdUVVZTUTBoQlRsUkJRa2xNU1ZSWkxDQkdTVlJPUlZOVElFWlBVaUJCSUZCQlVsUkpRMVZNUVZJZ1VGVlNVRTlUUlNCQlRrUWdUazlPU1U1R1VrbE9SMFZOUlU1VUxpQkpUbHh1THk4Z1RrOGdSVlpGVGxRZ1UwaEJURXdnVkVoRklFRlZWRWhQVWxNZ1QxSWdRMDlRV1ZKSlIwaFVJRWhQVEVSRlVsTWdRa1VnVEVsQlFreEZJRVpQVWlCQlRsa2dRMHhCU1Uwc1hHNHZMeUJFUVUxQlIwVlRJRTlTSUU5VVNFVlNJRXhKUVVKSlRFbFVXU3dnVjBoRlZFaEZVaUJKVGlCQlRpQkJRMVJKVDA0Z1QwWWdRMDlPVkZKQlExUXNJRlJQVWxRZ1QxSmNiaTh2SUU5VVNFVlNWMGxUUlN3Z1FWSkpVMGxPUnlCR1VrOU5MQ0JQVlZRZ1QwWWdUMUlnU1U0Z1EwOU9Ua1ZEVkVsUFRpQlhTVlJJSUZSSVJTQlRUMFpVVjBGU1JTQlBVaUJVU0VWY2JpOHZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVXlCSlRpQlVTRVVnVTA5R1ZGZEJVa1V1WEc1Y2JpOHZJRUVnWW1sMElITnBiWEJzWlhJZ2RHaGhiaUJ5WldGa1lXSnNaU0J6ZEhKbFlXMXpMbHh1THk4Z1NXMXdiR1Z0Wlc1MElHRnVJR0Z6ZVc1aklDNWZkM0pwZEdVb1kyaDFibXNzSUdOaUtTd2dZVzVrSUdsMEoyeHNJR2hoYm1Sc1pTQmhiR3hjYmk4dklIUm9aU0JrY21GcGJpQmxkbVZ1ZENCbGJXbHpjMmx2YmlCaGJtUWdZblZtWm1WeWFXNW5MbHh1WEc1dGIyUjFiR1V1Wlhod2IzSjBjeUE5SUZkeWFYUmhZbXhsTzF4dVhHNHZLanh5WlhCc1lXTmxiV1Z1ZEQ0cUwxeHVkbUZ5SUVKMVptWmxjaUE5SUhKbGNYVnBjbVVvSjJKMVptWmxjaWNwTGtKMVptWmxjanRjYmk4cVBDOXlaWEJzWVdObGJXVnVkRDRxTDF4dVhHNVhjbWwwWVdKc1pTNVhjbWwwWVdKc1pWTjBZWFJsSUQwZ1YzSnBkR0ZpYkdWVGRHRjBaVHRjYmx4dVhHNHZLanh5WlhCc1lXTmxiV1Z1ZEQ0cUwxeHVkbUZ5SUhWMGFXd2dQU0J5WlhGMWFYSmxLQ2RqYjNKbExYVjBhV3d0YVhNbktUdGNiblYwYVd3dWFXNW9aWEpwZEhNZ1BTQnlaWEYxYVhKbEtDZHBibWhsY21sMGN5Y3BPMXh1THlvOEwzSmxjR3hoWTJWdFpXNTBQaW92WEc1Y2JuWmhjaUJUZEhKbFlXMGdQU0J5WlhGMWFYSmxLQ2R6ZEhKbFlXMG5LVHRjYmx4dWRYUnBiQzVwYm1obGNtbDBjeWhYY21sMFlXSnNaU3dnVTNSeVpXRnRLVHRjYmx4dVpuVnVZM1JwYjI0Z1YzSnBkR1ZTWlhFb1kyaDFibXNzSUdWdVkyOWthVzVuTENCallpa2dlMXh1SUNCMGFHbHpMbU5vZFc1cklEMGdZMmgxYm1zN1hHNGdJSFJvYVhNdVpXNWpiMlJwYm1jZ1BTQmxibU52WkdsdVp6dGNiaUFnZEdocGN5NWpZV3hzWW1GamF5QTlJR05pTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJYY21sMFlXSnNaVk4wWVhSbEtHOXdkR2x2Ym5Nc0lITjBjbVZoYlNrZ2UxeHVJQ0IyWVhJZ1JIVndiR1Y0SUQwZ2NtVnhkV2x5WlNnbkxpOWZjM1J5WldGdFgyUjFjR3hsZUNjcE8xeHVYRzRnSUc5d2RHbHZibk1nUFNCdmNIUnBiMjV6SUh4OElIdDlPMXh1WEc0Z0lDOHZJSFJvWlNCd2IybHVkQ0JoZENCM2FHbGphQ0IzY21sMFpTZ3BJSE4wWVhKMGN5QnlaWFIxY201cGJtY2dabUZzYzJWY2JpQWdMeThnVG05MFpUb2dNQ0JwY3lCaElIWmhiR2xrSUhaaGJIVmxMQ0J0WldGdWN5QjBhR0YwSUhkbElHRnNkMkY1Y3lCeVpYUjFjbTRnWm1Gc2MyVWdhV1pjYmlBZ0x5OGdkR2hsSUdWdWRHbHlaU0JpZFdabVpYSWdhWE1nYm05MElHWnNkWE5vWldRZ2FXMXRaV1JwWVhSbGJIa2diMjRnZDNKcGRHVW9LVnh1SUNCMllYSWdhSGR0SUQwZ2IzQjBhVzl1Y3k1b2FXZG9WMkYwWlhKTllYSnJPMXh1SUNCMllYSWdaR1ZtWVhWc2RFaDNiU0E5SUc5d2RHbHZibk11YjJKcVpXTjBUVzlrWlNBL0lERTJJRG9nTVRZZ0tpQXhNREkwTzF4dUlDQjBhR2x6TG1ocFoyaFhZWFJsY2sxaGNtc2dQU0FvYUhkdElIeDhJR2gzYlNBOVBUMGdNQ2tnUHlCb2QyMGdPaUJrWldaaGRXeDBTSGR0TzF4dVhHNGdJQzh2SUc5aWFtVmpkQ0J6ZEhKbFlXMGdabXhoWnlCMGJ5QnBibVJwWTJGMFpTQjNhR1YwYUdWeUlHOXlJRzV2ZENCMGFHbHpJSE4wY21WaGJWeHVJQ0F2THlCamIyNTBZV2x1Y3lCaWRXWm1aWEp6SUc5eUlHOWlhbVZqZEhNdVhHNGdJSFJvYVhNdWIySnFaV04wVFc5a1pTQTlJQ0VoYjNCMGFXOXVjeTV2WW1wbFkzUk5iMlJsTzF4dVhHNGdJR2xtSUNoemRISmxZVzBnYVc1emRHRnVZMlZ2WmlCRWRYQnNaWGdwWEc0Z0lDQWdkR2hwY3k1dlltcGxZM1JOYjJSbElEMGdkR2hwY3k1dlltcGxZM1JOYjJSbElIeDhJQ0VoYjNCMGFXOXVjeTUzY21sMFlXSnNaVTlpYW1WamRFMXZaR1U3WEc1Y2JpQWdMeThnWTJGemRDQjBieUJwYm5SekxseHVJQ0IwYUdsekxtaHBaMmhYWVhSbGNrMWhjbXNnUFNCK2ZuUm9hWE11YUdsbmFGZGhkR1Z5VFdGeWF6dGNibHh1SUNCMGFHbHpMbTVsWldSRWNtRnBiaUE5SUdaaGJITmxPMXh1SUNBdkx5QmhkQ0IwYUdVZ2MzUmhjblFnYjJZZ1kyRnNiR2x1WnlCbGJtUW9LVnh1SUNCMGFHbHpMbVZ1WkdsdVp5QTlJR1poYkhObE8xeHVJQ0F2THlCM2FHVnVJR1Z1WkNncElHaGhjeUJpWldWdUlHTmhiR3hsWkN3Z1lXNWtJSEpsZEhWeWJtVmtYRzRnSUhSb2FYTXVaVzVrWldRZ1BTQm1ZV3h6WlR0Y2JpQWdMeThnZDJobGJpQW5abWx1YVhOb0p5QnBjeUJsYldsMGRHVmtYRzRnSUhSb2FYTXVabWx1YVhOb1pXUWdQU0JtWVd4elpUdGNibHh1SUNBdkx5QnphRzkxYkdRZ2QyVWdaR1ZqYjJSbElITjBjbWx1WjNNZ2FXNTBieUJpZFdabVpYSnpJR0psWm05eVpTQndZWE56YVc1bklIUnZJRjkzY21sMFpUOWNiaUFnTHk4Z2RHaHBjeUJwY3lCb1pYSmxJSE52SUhSb1lYUWdjMjl0WlNCdWIyUmxMV052Y21VZ2MzUnlaV0Z0Y3lCallXNGdiM0IwYVcxcGVtVWdjM1J5YVc1blhHNGdJQzh2SUdoaGJtUnNhVzVuSUdGMElHRWdiRzkzWlhJZ2JHVjJaV3d1WEc0Z0lIWmhjaUJ1YjBSbFkyOWtaU0E5SUc5d2RHbHZibk11WkdWamIyUmxVM1J5YVc1bmN5QTlQVDBnWm1Gc2MyVTdYRzRnSUhSb2FYTXVaR1ZqYjJSbFUzUnlhVzVuY3lBOUlDRnViMFJsWTI5a1pUdGNibHh1SUNBdkx5QkRjbmx3ZEc4Z2FYTWdhMmx1WkNCdlppQnZiR1FnWVc1a0lHTnlkWE4wZVM0Z0lFaHBjM1J2Y21sallXeHNlU3dnYVhSeklHUmxabUYxYkhRZ2MzUnlhVzVuWEc0Z0lDOHZJR1Z1WTI5a2FXNW5JR2x6SUNkaWFXNWhjbmtuSUhOdklIZGxJR2hoZG1VZ2RHOGdiV0ZyWlNCMGFHbHpJR052Ym1acFozVnlZV0pzWlM1Y2JpQWdMeThnUlhabGNubDBhR2x1WnlCbGJITmxJR2x1SUhSb1pTQjFibWwyWlhKelpTQjFjMlZ6SUNkMWRHWTRKeXdnZEdodmRXZG9MbHh1SUNCMGFHbHpMbVJsWm1GMWJIUkZibU52WkdsdVp5QTlJRzl3ZEdsdmJuTXVaR1ZtWVhWc2RFVnVZMjlrYVc1bklIeDhJQ2QxZEdZNEp6dGNibHh1SUNBdkx5QnViM1FnWVc0Z1lXTjBkV0ZzSUdKMVptWmxjaUIzWlNCclpXVndJSFJ5WVdOcklHOW1MQ0JpZFhRZ1lTQnRaV0Z6ZFhKbGJXVnVkRnh1SUNBdkx5QnZaaUJvYjNjZ2JYVmphQ0IzWlNkeVpTQjNZV2wwYVc1bklIUnZJR2RsZENCd2RYTm9aV1FnZEc4Z2MyOXRaU0IxYm1SbGNteDVhVzVuWEc0Z0lDOHZJSE52WTJ0bGRDQnZjaUJtYVd4bExseHVJQ0IwYUdsekxteGxibWQwYUNBOUlEQTdYRzVjYmlBZ0x5OGdZU0JtYkdGbklIUnZJSE5sWlNCM2FHVnVJSGRsSjNKbElHbHVJSFJvWlNCdGFXUmtiR1VnYjJZZ1lTQjNjbWwwWlM1Y2JpQWdkR2hwY3k1M2NtbDBhVzVuSUQwZ1ptRnNjMlU3WEc1Y2JpQWdMeThnZDJobGJpQjBjblZsSUdGc2JDQjNjbWwwWlhNZ2QybHNiQ0JpWlNCaWRXWm1aWEpsWkNCMWJuUnBiQ0F1ZFc1amIzSnJLQ2tnWTJGc2JGeHVJQ0IwYUdsekxtTnZjbXRsWkNBOUlEQTdYRzVjYmlBZ0x5OGdZU0JtYkdGbklIUnZJR0psSUdGaWJHVWdkRzhnZEdWc2JDQnBaaUIwYUdVZ2IyNTNjbWwwWlNCallpQnBjeUJqWVd4c1pXUWdhVzF0WldScFlYUmxiSGtzWEc0Z0lDOHZJRzl5SUc5dUlHRWdiR0YwWlhJZ2RHbGpheTRnSUZkbElITmxkQ0IwYUdseklIUnZJSFJ5ZFdVZ1lYUWdabWx5YzNRc0lHSmxZMkYxYzJVZ1lXNTVYRzRnSUM4dklHRmpkR2x2Ym5NZ2RHaGhkQ0J6YUc5MWJHUnVKM1FnYUdGd2NHVnVJSFZ1ZEdsc0lGd2liR0YwWlhKY0lpQnphRzkxYkdRZ1oyVnVaWEpoYkd4NUlHRnNjMjljYmlBZ0x5OGdibTkwSUdoaGNIQmxiaUJpWldadmNtVWdkR2hsSUdacGNuTjBJSGR5YVhSbElHTmhiR3d1WEc0Z0lIUm9hWE11YzNsdVl5QTlJSFJ5ZFdVN1hHNWNiaUFnTHk4Z1lTQm1iR0ZuSUhSdklHdHViM2NnYVdZZ2QyVW5jbVVnY0hKdlkyVnpjMmx1WnlCd2NtVjJhVzkxYzJ4NUlHSjFabVpsY21Wa0lHbDBaVzF6TENCM2FHbGphRnh1SUNBdkx5QnRZWGtnWTJGc2JDQjBhR1VnWDNkeWFYUmxLQ2tnWTJGc2JHSmhZMnNnYVc0Z2RHaGxJSE5oYldVZ2RHbGpheXdnYzI4Z2RHaGhkQ0IzWlNCa2IyNG5kRnh1SUNBdkx5QmxibVFnZFhBZ2FXNGdZVzRnYjNabGNteGhjSEJsWkNCdmJuZHlhWFJsSUhOcGRIVmhkR2x2Ymk1Y2JpQWdkR2hwY3k1aWRXWm1aWEpRY205alpYTnphVzVuSUQwZ1ptRnNjMlU3WEc1Y2JpQWdMeThnZEdobElHTmhiR3hpWVdOcklIUm9ZWFFuY3lCd1lYTnpaV1FnZEc4Z1gzZHlhWFJsS0dOb2RXNXJMR05pS1Z4dUlDQjBhR2x6TG05dWQzSnBkR1VnUFNCbWRXNWpkR2x2YmlobGNpa2dlMXh1SUNBZ0lHOXVkM0pwZEdVb2MzUnlaV0Z0TENCbGNpazdYRzRnSUgwN1hHNWNiaUFnTHk4Z2RHaGxJR05oYkd4aVlXTnJJSFJvWVhRZ2RHaGxJSFZ6WlhJZ2MzVndjR3hwWlhNZ2RHOGdkM0pwZEdVb1kyaDFibXNzWlc1amIyUnBibWNzWTJJcFhHNGdJSFJvYVhNdWQzSnBkR1ZqWWlBOUlHNTFiR3c3WEc1Y2JpQWdMeThnZEdobElHRnRiM1Z1ZENCMGFHRjBJR2x6SUdKbGFXNW5JSGR5YVhSMFpXNGdkMmhsYmlCZmQzSnBkR1VnYVhNZ1kyRnNiR1ZrTGx4dUlDQjBhR2x6TG5keWFYUmxiR1Z1SUQwZ01EdGNibHh1SUNCMGFHbHpMbUoxWm1abGNpQTlJRnRkTzF4dVhHNGdJQzh2SUc1MWJXSmxjaUJ2WmlCd1pXNWthVzVuSUhWelpYSXRjM1Z3Y0d4cFpXUWdkM0pwZEdVZ1kyRnNiR0poWTJ0elhHNGdJQzh2SUhSb2FYTWdiWFZ6ZENCaVpTQXdJR0psWm05eVpTQW5abWx1YVhOb0p5QmpZVzRnWW1VZ1pXMXBkSFJsWkZ4dUlDQjBhR2x6TG5CbGJtUnBibWRqWWlBOUlEQTdYRzVjYmlBZ0x5OGdaVzFwZENCd2NtVm1hVzVwYzJnZ2FXWWdkR2hsSUc5dWJIa2dkR2hwYm1jZ2QyVW5jbVVnZDJGcGRHbHVaeUJtYjNJZ2FYTWdYM2R5YVhSbElHTmljMXh1SUNBdkx5QlVhR2x6SUdseklISmxiR1YyWVc1MElHWnZjaUJ6ZVc1amFISnZibTkxY3lCVWNtRnVjMlp2Y20wZ2MzUnlaV0Z0YzF4dUlDQjBhR2x6TG5CeVpXWnBibWx6YUdWa0lEMGdabUZzYzJVN1hHNWNiaUFnTHk4Z1ZISjFaU0JwWmlCMGFHVWdaWEp5YjNJZ2QyRnpJR0ZzY21WaFpIa2daVzFwZEhSbFpDQmhibVFnYzJodmRXeGtJRzV2ZENCaVpTQjBhSEp2ZDI0Z1lXZGhhVzVjYmlBZ2RHaHBjeTVsY25KdmNrVnRhWFIwWldRZ1BTQm1ZV3h6WlR0Y2JuMWNibHh1Wm5WdVkzUnBiMjRnVjNKcGRHRmliR1VvYjNCMGFXOXVjeWtnZTF4dUlDQjJZWElnUkhWd2JHVjRJRDBnY21WeGRXbHlaU2duTGk5ZmMzUnlaV0Z0WDJSMWNHeGxlQ2NwTzF4dVhHNGdJQzh2SUZkeWFYUmhZbXhsSUdOMGIzSWdhWE1nWVhCd2JHbGxaQ0IwYnlCRWRYQnNaWGhsY3l3Z2RHaHZkV2RvSUhSb1pYa25jbVVnYm05MFhHNGdJQzh2SUdsdWMzUmhibU5sYjJZZ1YzSnBkR0ZpYkdVc0lIUm9aWGtuY21VZ2FXNXpkR0Z1WTJWdlppQlNaV0ZrWVdKc1pTNWNiaUFnYVdZZ0tDRW9kR2hwY3lCcGJuTjBZVzVqWlc5bUlGZHlhWFJoWW14bEtTQW1KaUFoS0hSb2FYTWdhVzV6ZEdGdVkyVnZaaUJFZFhCc1pYZ3BLVnh1SUNBZ0lISmxkSFZ5YmlCdVpYY2dWM0pwZEdGaWJHVW9iM0IwYVc5dWN5azdYRzVjYmlBZ2RHaHBjeTVmZDNKcGRHRmliR1ZUZEdGMFpTQTlJRzVsZHlCWGNtbDBZV0pzWlZOMFlYUmxLRzl3ZEdsdmJuTXNJSFJvYVhNcE8xeHVYRzRnSUM4dklHeGxaMkZqZVM1Y2JpQWdkR2hwY3k1M2NtbDBZV0pzWlNBOUlIUnlkV1U3WEc1Y2JpQWdVM1J5WldGdExtTmhiR3dvZEdocGN5azdYRzU5WEc1Y2JpOHZJRTkwYUdWeWQybHpaU0J3Wlc5d2JHVWdZMkZ1SUhCcGNHVWdWM0pwZEdGaWJHVWdjM1J5WldGdGN5d2dkMmhwWTJnZ2FYTWdhblZ6ZENCM2NtOXVaeTVjYmxkeWFYUmhZbXhsTG5CeWIzUnZkSGx3WlM1d2FYQmxJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJSFJvYVhNdVpXMXBkQ2duWlhKeWIzSW5MQ0J1WlhjZ1JYSnliM0lvSjBOaGJtNXZkQ0J3YVhCbExpQk9iM1FnY21WaFpHRmliR1V1SnlrcE8xeHVmVHRjYmx4dVhHNW1kVzVqZEdsdmJpQjNjbWwwWlVGbWRHVnlSVzVrS0hOMGNtVmhiU3dnYzNSaGRHVXNJR05pS1NCN1hHNGdJSFpoY2lCbGNpQTlJRzVsZHlCRmNuSnZjaWduZDNKcGRHVWdZV1owWlhJZ1pXNWtKeWs3WEc0Z0lDOHZJRlJQUkU4NklHUmxabVZ5SUdWeWNtOXlJR1YyWlc1MGN5QmpiMjV6YVhOMFpXNTBiSGtnWlhabGNubDNhR1Z5WlN3Z2JtOTBJR3AxYzNRZ2RHaGxJR05pWEc0Z0lITjBjbVZoYlM1bGJXbDBLQ2RsY25KdmNpY3NJR1Z5S1R0Y2JpQWdjSEp2WTJWemN5NXVaWGgwVkdsamF5aG1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQmpZaWhsY2lrN1hHNGdJSDBwTzF4dWZWeHVYRzR2THlCSlppQjNaU0JuWlhRZ2MyOXRaWFJvYVc1bklIUm9ZWFFnYVhNZ2JtOTBJR0VnWW5WbVptVnlMQ0J6ZEhKcGJtY3NJRzUxYkd3c0lHOXlJSFZ1WkdWbWFXNWxaQ3hjYmk4dklHRnVaQ0IzWlNkeVpTQnViM1FnYVc0Z2IySnFaV04wVFc5a1pTd2dkR2hsYmlCMGFHRjBKM01nWVc0Z1pYSnliM0l1WEc0dkx5QlBkR2hsY25kcGMyVWdjM1J5WldGdElHTm9kVzVyY3lCaGNtVWdZV3hzSUdOdmJuTnBaR1Z5WldRZ2RHOGdZbVVnYjJZZ2JHVnVaM1JvUFRFc0lHRnVaQ0IwYUdWY2JpOHZJSGRoZEdWeWJXRnlhM01nWkdWMFpYSnRhVzVsSUdodmR5QnRZVzU1SUc5aWFtVmpkSE1nZEc4Z2EyVmxjQ0JwYmlCMGFHVWdZblZtWm1WeUxDQnlZWFJvWlhJZ2RHaGhibHh1THk4Z2FHOTNJRzFoYm5rZ1lubDBaWE1nYjNJZ1kyaGhjbUZqZEdWeWN5NWNibVoxYm1OMGFXOXVJSFpoYkdsa1EyaDFibXNvYzNSeVpXRnRMQ0J6ZEdGMFpTd2dZMmgxYm1zc0lHTmlLU0I3WEc0Z0lIWmhjaUIyWVd4cFpDQTlJSFJ5ZFdVN1hHNGdJR2xtSUNnaGRYUnBiQzVwYzBKMVptWmxjaWhqYUhWdWF5a2dKaVpjYmlBZ0lDQWdJQ0YxZEdsc0xtbHpVM1J5YVc1bktHTm9kVzVyS1NBbUpseHVJQ0FnSUNBZ0lYVjBhV3d1YVhOT2RXeHNUM0pWYm1SbFptbHVaV1FvWTJoMWJtc3BJQ1ltWEc0Z0lDQWdJQ0FoYzNSaGRHVXViMkpxWldOMFRXOWtaU2tnZTF4dUlDQWdJSFpoY2lCbGNpQTlJRzVsZHlCVWVYQmxSWEp5YjNJb0owbHVkbUZzYVdRZ2JtOXVMWE4wY21sdVp5OWlkV1ptWlhJZ1kyaDFibXNuS1R0Y2JpQWdJQ0J6ZEhKbFlXMHVaVzFwZENnblpYSnliM0luTENCbGNpazdYRzRnSUNBZ2NISnZZMlZ6Y3k1dVpYaDBWR2xqYXlobWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lHTmlLR1Z5S1R0Y2JpQWdJQ0I5S1R0Y2JpQWdJQ0IyWVd4cFpDQTlJR1poYkhObE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCMllXeHBaRHRjYm4xY2JseHVWM0pwZEdGaWJHVXVjSEp2ZEc5MGVYQmxMbmR5YVhSbElEMGdablZ1WTNScGIyNG9ZMmgxYm1zc0lHVnVZMjlrYVc1bkxDQmpZaWtnZTF4dUlDQjJZWElnYzNSaGRHVWdQU0IwYUdsekxsOTNjbWwwWVdKc1pWTjBZWFJsTzF4dUlDQjJZWElnY21WMElEMGdabUZzYzJVN1hHNWNiaUFnYVdZZ0tIVjBhV3d1YVhOR2RXNWpkR2x2YmlobGJtTnZaR2x1WnlrcElIdGNiaUFnSUNCallpQTlJR1Z1WTI5a2FXNW5PMXh1SUNBZ0lHVnVZMjlrYVc1bklEMGdiblZzYkR0Y2JpQWdmVnh1WEc0Z0lHbG1JQ2gxZEdsc0xtbHpRblZtWm1WeUtHTm9kVzVyS1NsY2JpQWdJQ0JsYm1OdlpHbHVaeUE5SUNkaWRXWm1aWEluTzF4dUlDQmxiSE5sSUdsbUlDZ2haVzVqYjJScGJtY3BYRzRnSUNBZ1pXNWpiMlJwYm1jZ1BTQnpkR0YwWlM1a1pXWmhkV3gwUlc1amIyUnBibWM3WEc1Y2JpQWdhV1lnS0NGMWRHbHNMbWx6Um5WdVkzUnBiMjRvWTJJcEtWeHVJQ0FnSUdOaUlEMGdablZ1WTNScGIyNG9LU0I3ZlR0Y2JseHVJQ0JwWmlBb2MzUmhkR1V1Wlc1a1pXUXBYRzRnSUNBZ2QzSnBkR1ZCWm5SbGNrVnVaQ2gwYUdsekxDQnpkR0YwWlN3Z1kySXBPMXh1SUNCbGJITmxJR2xtSUNoMllXeHBaRU5vZFc1cktIUm9hWE1zSUhOMFlYUmxMQ0JqYUhWdWF5d2dZMklwS1NCN1hHNGdJQ0FnYzNSaGRHVXVjR1Z1WkdsdVoyTmlLeXM3WEc0Z0lDQWdjbVYwSUQwZ2QzSnBkR1ZQY2tKMVptWmxjaWgwYUdsekxDQnpkR0YwWlN3Z1kyaDFibXNzSUdWdVkyOWthVzVuTENCallpazdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdjbVYwTzF4dWZUdGNibHh1VjNKcGRHRmliR1V1Y0hKdmRHOTBlWEJsTG1OdmNtc2dQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdkbUZ5SUhOMFlYUmxJRDBnZEdocGN5NWZkM0pwZEdGaWJHVlRkR0YwWlR0Y2JseHVJQ0J6ZEdGMFpTNWpiM0pyWldRckt6dGNibjA3WEc1Y2JsZHlhWFJoWW14bExuQnliM1J2ZEhsd1pTNTFibU52Y21zZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ2RtRnlJSE4wWVhSbElEMGdkR2hwY3k1ZmQzSnBkR0ZpYkdWVGRHRjBaVHRjYmx4dUlDQnBaaUFvYzNSaGRHVXVZMjl5YTJWa0tTQjdYRzRnSUNBZ2MzUmhkR1V1WTI5eWEyVmtMUzA3WEc1Y2JpQWdJQ0JwWmlBb0lYTjBZWFJsTG5keWFYUnBibWNnSmlaY2JpQWdJQ0FnSUNBZ0lYTjBZWFJsTG1OdmNtdGxaQ0FtSmx4dUlDQWdJQ0FnSUNBaGMzUmhkR1V1Wm1sdWFYTm9aV1FnSmlaY2JpQWdJQ0FnSUNBZ0lYTjBZWFJsTG1KMVptWmxjbEJ5YjJObGMzTnBibWNnSmlaY2JpQWdJQ0FnSUNBZ2MzUmhkR1V1WW5WbVptVnlMbXhsYm1kMGFDbGNiaUFnSUNBZ0lHTnNaV0Z5UW5WbVptVnlLSFJvYVhNc0lITjBZWFJsS1R0Y2JpQWdmVnh1ZlR0Y2JseHVablZ1WTNScGIyNGdaR1ZqYjJSbFEyaDFibXNvYzNSaGRHVXNJR05vZFc1ckxDQmxibU52WkdsdVp5a2dlMXh1SUNCcFppQW9JWE4wWVhSbExtOWlhbVZqZEUxdlpHVWdKaVpjYmlBZ0lDQWdJSE4wWVhSbExtUmxZMjlrWlZOMGNtbHVaM01nSVQwOUlHWmhiSE5sSUNZbVhHNGdJQ0FnSUNCMWRHbHNMbWx6VTNSeWFXNW5LR05vZFc1cktTa2dlMXh1SUNBZ0lHTm9kVzVySUQwZ2JtVjNJRUoxWm1abGNpaGphSFZ1YXl3Z1pXNWpiMlJwYm1jcE8xeHVJQ0I5WEc0Z0lISmxkSFZ5YmlCamFIVnVhenRjYm4xY2JseHVMeThnYVdZZ2QyVW5jbVVnWVd4eVpXRmtlU0IzY21sMGFXNW5JSE52YldWMGFHbHVaeXdnZEdobGJpQnFkWE4wSUhCMWRDQjBhR2x6WEc0dkx5QnBiaUIwYUdVZ2NYVmxkV1VzSUdGdVpDQjNZV2wwSUc5MWNpQjBkWEp1TGlBZ1QzUm9aWEozYVhObExDQmpZV3hzSUY5M2NtbDBaVnh1THk4Z1NXWWdkMlVnY21WMGRYSnVJR1poYkhObExDQjBhR1Z1SUhkbElHNWxaV1FnWVNCa2NtRnBiaUJsZG1WdWRDd2djMjhnYzJWMElIUm9ZWFFnWm14aFp5NWNibVoxYm1OMGFXOXVJSGR5YVhSbFQzSkNkV1ptWlhJb2MzUnlaV0Z0TENCemRHRjBaU3dnWTJoMWJtc3NJR1Z1WTI5a2FXNW5MQ0JqWWlrZ2UxeHVJQ0JqYUhWdWF5QTlJR1JsWTI5a1pVTm9kVzVyS0hOMFlYUmxMQ0JqYUhWdWF5d2daVzVqYjJScGJtY3BPMXh1SUNCcFppQW9kWFJwYkM1cGMwSjFabVpsY2loamFIVnVheWtwWEc0Z0lDQWdaVzVqYjJScGJtY2dQU0FuWW5WbVptVnlKenRjYmlBZ2RtRnlJR3hsYmlBOUlITjBZWFJsTG05aWFtVmpkRTF2WkdVZ1B5QXhJRG9nWTJoMWJtc3ViR1Z1WjNSb08xeHVYRzRnSUhOMFlYUmxMbXhsYm1kMGFDQXJQU0JzWlc0N1hHNWNiaUFnZG1GeUlISmxkQ0E5SUhOMFlYUmxMbXhsYm1kMGFDQThJSE4wWVhSbExtaHBaMmhYWVhSbGNrMWhjbXM3WEc0Z0lDOHZJSGRsSUcxMWMzUWdaVzV6ZFhKbElIUm9ZWFFnY0hKbGRtbHZkWE1nYm1WbFpFUnlZV2x1SUhkcGJHd2dibTkwSUdKbElISmxjMlYwSUhSdklHWmhiSE5sTGx4dUlDQnBaaUFvSVhKbGRDbGNiaUFnSUNCemRHRjBaUzV1WldWa1JISmhhVzRnUFNCMGNuVmxPMXh1WEc0Z0lHbG1JQ2h6ZEdGMFpTNTNjbWwwYVc1bklIeDhJSE4wWVhSbExtTnZjbXRsWkNsY2JpQWdJQ0J6ZEdGMFpTNWlkV1ptWlhJdWNIVnphQ2h1WlhjZ1YzSnBkR1ZTWlhFb1kyaDFibXNzSUdWdVkyOWthVzVuTENCallpa3BPMXh1SUNCbGJITmxYRzRnSUNBZ1pHOVhjbWwwWlNoemRISmxZVzBzSUhOMFlYUmxMQ0JtWVd4elpTd2diR1Z1TENCamFIVnVheXdnWlc1amIyUnBibWNzSUdOaUtUdGNibHh1SUNCeVpYUjFjbTRnY21WME8xeHVmVnh1WEc1bWRXNWpkR2x2YmlCa2IxZHlhWFJsS0hOMGNtVmhiU3dnYzNSaGRHVXNJSGR5YVhSbGRpd2diR1Z1TENCamFIVnVheXdnWlc1amIyUnBibWNzSUdOaUtTQjdYRzRnSUhOMFlYUmxMbmR5YVhSbGJHVnVJRDBnYkdWdU8xeHVJQ0J6ZEdGMFpTNTNjbWwwWldOaUlEMGdZMkk3WEc0Z0lITjBZWFJsTG5keWFYUnBibWNnUFNCMGNuVmxPMXh1SUNCemRHRjBaUzV6ZVc1aklEMGdkSEoxWlR0Y2JpQWdhV1lnS0hkeWFYUmxkaWxjYmlBZ0lDQnpkSEpsWVcwdVgzZHlhWFJsZGloamFIVnVheXdnYzNSaGRHVXViMjUzY21sMFpTazdYRzRnSUdWc2MyVmNiaUFnSUNCemRISmxZVzB1WDNkeWFYUmxLR05vZFc1ckxDQmxibU52WkdsdVp5d2djM1JoZEdVdWIyNTNjbWwwWlNrN1hHNGdJSE4wWVhSbExuTjVibU1nUFNCbVlXeHpaVHRjYm4xY2JseHVablZ1WTNScGIyNGdiMjUzY21sMFpVVnljbTl5S0hOMGNtVmhiU3dnYzNSaGRHVXNJSE41Ym1Nc0lHVnlMQ0JqWWlrZ2UxeHVJQ0JwWmlBb2MzbHVZeWxjYmlBZ0lDQndjbTlqWlhOekxtNWxlSFJVYVdOcktHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdjM1JoZEdVdWNHVnVaR2x1WjJOaUxTMDdYRzRnSUNBZ0lDQmpZaWhsY2lrN1hHNGdJQ0FnZlNrN1hHNGdJR1ZzYzJVZ2UxeHVJQ0FnSUhOMFlYUmxMbkJsYm1ScGJtZGpZaTB0TzF4dUlDQWdJR05pS0dWeUtUdGNiaUFnZlZ4dVhHNGdJSE4wY21WaGJTNWZkM0pwZEdGaWJHVlRkR0YwWlM1bGNuSnZja1Z0YVhSMFpXUWdQU0IwY25WbE8xeHVJQ0J6ZEhKbFlXMHVaVzFwZENnblpYSnliM0luTENCbGNpazdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHOXVkM0pwZEdWVGRHRjBaVlZ3WkdGMFpTaHpkR0YwWlNrZ2UxeHVJQ0J6ZEdGMFpTNTNjbWwwYVc1bklEMGdabUZzYzJVN1hHNGdJSE4wWVhSbExuZHlhWFJsWTJJZ1BTQnVkV3hzTzF4dUlDQnpkR0YwWlM1c1pXNW5kR2dnTFQwZ2MzUmhkR1V1ZDNKcGRHVnNaVzQ3WEc0Z0lITjBZWFJsTG5keWFYUmxiR1Z1SUQwZ01EdGNibjFjYmx4dVpuVnVZM1JwYjI0Z2IyNTNjbWwwWlNoemRISmxZVzBzSUdWeUtTQjdYRzRnSUhaaGNpQnpkR0YwWlNBOUlITjBjbVZoYlM1ZmQzSnBkR0ZpYkdWVGRHRjBaVHRjYmlBZ2RtRnlJSE41Ym1NZ1BTQnpkR0YwWlM1emVXNWpPMXh1SUNCMllYSWdZMklnUFNCemRHRjBaUzUzY21sMFpXTmlPMXh1WEc0Z0lHOXVkM0pwZEdWVGRHRjBaVlZ3WkdGMFpTaHpkR0YwWlNrN1hHNWNiaUFnYVdZZ0tHVnlLVnh1SUNBZ0lHOXVkM0pwZEdWRmNuSnZjaWh6ZEhKbFlXMHNJSE4wWVhSbExDQnplVzVqTENCbGNpd2dZMklwTzF4dUlDQmxiSE5sSUh0Y2JpQWdJQ0F2THlCRGFHVmpheUJwWmlCM1pTZHlaU0JoWTNSMVlXeHNlU0J5WldGa2VTQjBieUJtYVc1cGMyZ3NJR0oxZENCa2IyNG5kQ0JsYldsMElIbGxkRnh1SUNBZ0lIWmhjaUJtYVc1cGMyaGxaQ0E5SUc1bFpXUkdhVzVwYzJnb2MzUnlaV0Z0TENCemRHRjBaU2s3WEc1Y2JpQWdJQ0JwWmlBb0lXWnBibWx6YUdWa0lDWW1YRzRnSUNBZ0lDQWdJQ0Z6ZEdGMFpTNWpiM0pyWldRZ0ppWmNiaUFnSUNBZ0lDQWdJWE4wWVhSbExtSjFabVpsY2xCeWIyTmxjM05wYm1jZ0ppWmNiaUFnSUNBZ0lDQWdjM1JoZEdVdVluVm1abVZ5TG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnWTJ4bFlYSkNkV1ptWlhJb2MzUnlaV0Z0TENCemRHRjBaU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdhV1lnS0hONWJtTXBJSHRjYmlBZ0lDQWdJSEJ5YjJObGMzTXVibVY0ZEZScFkyc29ablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUdGbWRHVnlWM0pwZEdVb2MzUnlaV0Z0TENCemRHRjBaU3dnWm1sdWFYTm9aV1FzSUdOaUtUdGNiaUFnSUNBZ0lIMHBPMXh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCaFpuUmxjbGR5YVhSbEtITjBjbVZoYlN3Z2MzUmhkR1VzSUdacGJtbHphR1ZrTENCallpazdYRzRnSUNBZ2ZWeHVJQ0I5WEc1OVhHNWNibVoxYm1OMGFXOXVJR0ZtZEdWeVYzSnBkR1VvYzNSeVpXRnRMQ0J6ZEdGMFpTd2dabWx1YVhOb1pXUXNJR05pS1NCN1hHNGdJR2xtSUNnaFptbHVhWE5vWldRcFhHNGdJQ0FnYjI1M2NtbDBaVVJ5WVdsdUtITjBjbVZoYlN3Z2MzUmhkR1VwTzF4dUlDQnpkR0YwWlM1d1pXNWthVzVuWTJJdExUdGNiaUFnWTJJb0tUdGNiaUFnWm1sdWFYTm9UV0Y1WW1Vb2MzUnlaV0Z0TENCemRHRjBaU2s3WEc1OVhHNWNiaTh2SUUxMWMzUWdabTl5WTJVZ1kyRnNiR0poWTJzZ2RHOGdZbVVnWTJGc2JHVmtJRzl1SUc1bGVIUlVhV05yTENCemJ5QjBhR0YwSUhkbElHUnZiaWQwWEc0dkx5QmxiV2wwSUNka2NtRnBiaWNnWW1WbWIzSmxJSFJvWlNCM2NtbDBaU2dwSUdOdmJuTjFiV1Z5SUdkbGRITWdkR2hsSUNkbVlXeHpaU2NnY21WMGRYSnVYRzR2THlCMllXeDFaU3dnWVc1a0lHaGhjeUJoSUdOb1lXNWpaU0IwYnlCaGRIUmhZMmdnWVNBblpISmhhVzRuSUd4cGMzUmxibVZ5TGx4dVpuVnVZM1JwYjI0Z2IyNTNjbWwwWlVSeVlXbHVLSE4wY21WaGJTd2djM1JoZEdVcElIdGNiaUFnYVdZZ0tITjBZWFJsTG14bGJtZDBhQ0E5UFQwZ01DQW1KaUJ6ZEdGMFpTNXVaV1ZrUkhKaGFXNHBJSHRjYmlBZ0lDQnpkR0YwWlM1dVpXVmtSSEpoYVc0Z1BTQm1ZV3h6WlR0Y2JpQWdJQ0J6ZEhKbFlXMHVaVzFwZENnblpISmhhVzRuS1R0Y2JpQWdmVnh1ZlZ4dVhHNWNiaTh2SUdsbUlIUm9aWEpsSjNNZ2MyOXRaWFJvYVc1bklHbHVJSFJvWlNCaWRXWm1aWElnZDJGcGRHbHVaeXdnZEdobGJpQndjbTlqWlhOeklHbDBYRzVtZFc1amRHbHZiaUJqYkdWaGNrSjFabVpsY2loemRISmxZVzBzSUhOMFlYUmxLU0I3WEc0Z0lITjBZWFJsTG1KMVptWmxjbEJ5YjJObGMzTnBibWNnUFNCMGNuVmxPMXh1WEc0Z0lHbG1JQ2h6ZEhKbFlXMHVYM2R5YVhSbGRpQW1KaUJ6ZEdGMFpTNWlkV1ptWlhJdWJHVnVaM1JvSUQ0Z01Ta2dlMXh1SUNBZ0lDOHZJRVpoYzNRZ1kyRnpaU3dnZDNKcGRHVWdaWFpsY25sMGFHbHVaeUIxYzJsdVp5QmZkM0pwZEdWMktDbGNiaUFnSUNCMllYSWdZMkp6SUQwZ1cxMDdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ1l5QTlJREE3SUdNZ1BDQnpkR0YwWlM1aWRXWm1aWEl1YkdWdVozUm9PeUJqS3lzcFhHNGdJQ0FnSUNCalluTXVjSFZ6YUNoemRHRjBaUzVpZFdabVpYSmJZMTB1WTJGc2JHSmhZMnNwTzF4dVhHNGdJQ0FnTHk4Z1kyOTFiblFnZEdobElHOXVaU0IzWlNCaGNtVWdZV1JrYVc1bkxDQmhjeUIzWld4c0xseHVJQ0FnSUM4dklGUlBSRThvYVhOaFlXTnpLU0JqYkdWaGJpQjBhR2x6SUhWd1hHNGdJQ0FnYzNSaGRHVXVjR1Z1WkdsdVoyTmlLeXM3WEc0Z0lDQWdaRzlYY21sMFpTaHpkSEpsWVcwc0lITjBZWFJsTENCMGNuVmxMQ0J6ZEdGMFpTNXNaVzVuZEdnc0lITjBZWFJsTG1KMVptWmxjaXdnSnljc0lHWjFibU4wYVc5dUtHVnljaWtnZTF4dUlDQWdJQ0FnWm05eUlDaDJZWElnYVNBOUlEQTdJR2tnUENCalluTXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ2MzUmhkR1V1Y0dWdVpHbHVaMk5pTFMwN1hHNGdJQ0FnSUNBZ0lHTmljMXRwWFNobGNuSXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHBPMXh1WEc0Z0lDQWdMeThnUTJ4bFlYSWdZblZtWm1WeVhHNGdJQ0FnYzNSaGRHVXVZblZtWm1WeUlEMGdXMTA3WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnTHk4Z1UyeHZkeUJqWVhObExDQjNjbWwwWlNCamFIVnVhM01nYjI1bExXSjVMVzl1WlZ4dUlDQWdJR1p2Y2lBb2RtRnlJR01nUFNBd095QmpJRHdnYzNSaGRHVXVZblZtWm1WeUxteGxibWQwYURzZ1l5c3JLU0I3WEc0Z0lDQWdJQ0IyWVhJZ1pXNTBjbmtnUFNCemRHRjBaUzVpZFdabVpYSmJZMTA3WEc0Z0lDQWdJQ0IyWVhJZ1kyaDFibXNnUFNCbGJuUnllUzVqYUhWdWF6dGNiaUFnSUNBZ0lIWmhjaUJsYm1OdlpHbHVaeUE5SUdWdWRISjVMbVZ1WTI5a2FXNW5PMXh1SUNBZ0lDQWdkbUZ5SUdOaUlEMGdaVzUwY25rdVkyRnNiR0poWTJzN1hHNGdJQ0FnSUNCMllYSWdiR1Z1SUQwZ2MzUmhkR1V1YjJKcVpXTjBUVzlrWlNBL0lERWdPaUJqYUhWdWF5NXNaVzVuZEdnN1hHNWNiaUFnSUNBZ0lHUnZWM0pwZEdVb2MzUnlaV0Z0TENCemRHRjBaU3dnWm1Gc2MyVXNJR3hsYml3Z1kyaDFibXNzSUdWdVkyOWthVzVuTENCallpazdYRzVjYmlBZ0lDQWdJQzh2SUdsbUlIZGxJR1JwWkc0bmRDQmpZV3hzSUhSb1pTQnZibmR5YVhSbElHbHRiV1ZrYVdGMFpXeDVMQ0IwYUdWdVhHNGdJQ0FnSUNBdkx5QnBkQ0J0WldGdWN5QjBhR0YwSUhkbElHNWxaV1FnZEc4Z2QyRnBkQ0IxYm5ScGJDQnBkQ0JrYjJWekxseHVJQ0FnSUNBZ0x5OGdZV3h6Ynl3Z2RHaGhkQ0J0WldGdWN5QjBhR0YwSUhSb1pTQmphSFZ1YXlCaGJtUWdZMklnWVhKbElHTjFjbkpsYm5Sc2VWeHVJQ0FnSUNBZ0x5OGdZbVZwYm1jZ2NISnZZMlZ6YzJWa0xDQnpieUJ0YjNabElIUm9aU0JpZFdabVpYSWdZMjkxYm5SbGNpQndZWE4wSUhSb1pXMHVYRzRnSUNBZ0lDQnBaaUFvYzNSaGRHVXVkM0pwZEdsdVp5a2dlMXh1SUNBZ0lDQWdJQ0JqS3lzN1hHNGdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNoaklEd2djM1JoZEdVdVluVm1abVZ5TG14bGJtZDBhQ2xjYmlBZ0lDQWdJSE4wWVhSbExtSjFabVpsY2lBOUlITjBZWFJsTG1KMVptWmxjaTV6YkdsalpTaGpLVHRjYmlBZ0lDQmxiSE5sWEc0Z0lDQWdJQ0J6ZEdGMFpTNWlkV1ptWlhJdWJHVnVaM1JvSUQwZ01EdGNiaUFnZlZ4dVhHNGdJSE4wWVhSbExtSjFabVpsY2xCeWIyTmxjM05wYm1jZ1BTQm1ZV3h6WlR0Y2JuMWNibHh1VjNKcGRHRmliR1V1Y0hKdmRHOTBlWEJsTGw5M2NtbDBaU0E5SUdaMWJtTjBhVzl1S0dOb2RXNXJMQ0JsYm1OdlpHbHVaeXdnWTJJcElIdGNiaUFnWTJJb2JtVjNJRVZ5Y205eUtDZHViM1FnYVcxd2JHVnRaVzUwWldRbktTazdYRzVjYm4wN1hHNWNibGR5YVhSaFlteGxMbkJ5YjNSdmRIbHdaUzVmZDNKcGRHVjJJRDBnYm5Wc2JEdGNibHh1VjNKcGRHRmliR1V1Y0hKdmRHOTBlWEJsTG1WdVpDQTlJR1oxYm1OMGFXOXVLR05vZFc1ckxDQmxibU52WkdsdVp5d2dZMklwSUh0Y2JpQWdkbUZ5SUhOMFlYUmxJRDBnZEdocGN5NWZkM0pwZEdGaWJHVlRkR0YwWlR0Y2JseHVJQ0JwWmlBb2RYUnBiQzVwYzBaMWJtTjBhVzl1S0dOb2RXNXJLU2tnZTF4dUlDQWdJR05pSUQwZ1kyaDFibXM3WEc0Z0lDQWdZMmgxYm1zZ1BTQnVkV3hzTzF4dUlDQWdJR1Z1WTI5a2FXNW5JRDBnYm5Wc2JEdGNiaUFnZlNCbGJITmxJR2xtSUNoMWRHbHNMbWx6Um5WdVkzUnBiMjRvWlc1amIyUnBibWNwS1NCN1hHNGdJQ0FnWTJJZ1BTQmxibU52WkdsdVp6dGNiaUFnSUNCbGJtTnZaR2x1WnlBOUlHNTFiR3c3WEc0Z0lIMWNibHh1SUNCcFppQW9JWFYwYVd3dWFYTk9kV3hzVDNKVmJtUmxabWx1WldRb1kyaDFibXNwS1Z4dUlDQWdJSFJvYVhNdWQzSnBkR1VvWTJoMWJtc3NJR1Z1WTI5a2FXNW5LVHRjYmx4dUlDQXZMeUF1Wlc1a0tDa2dablZzYkhrZ2RXNWpiM0pyYzF4dUlDQnBaaUFvYzNSaGRHVXVZMjl5YTJWa0tTQjdYRzRnSUNBZ2MzUmhkR1V1WTI5eWEyVmtJRDBnTVR0Y2JpQWdJQ0IwYUdsekxuVnVZMjl5YXlncE8xeHVJQ0I5WEc1Y2JpQWdMeThnYVdkdWIzSmxJSFZ1Ym1WalpYTnpZWEo1SUdWdVpDZ3BJR05oYkd4ekxseHVJQ0JwWmlBb0lYTjBZWFJsTG1WdVpHbHVaeUFtSmlBaGMzUmhkR1V1Wm1sdWFYTm9aV1FwWEc0Z0lDQWdaVzVrVjNKcGRHRmliR1VvZEdocGN5d2djM1JoZEdVc0lHTmlLVHRjYm4wN1hHNWNibHh1Wm5WdVkzUnBiMjRnYm1WbFpFWnBibWx6YUNoemRISmxZVzBzSUhOMFlYUmxLU0I3WEc0Z0lISmxkSFZ5YmlBb2MzUmhkR1V1Wlc1a2FXNW5JQ1ltWEc0Z0lDQWdJQ0FnSUNBZ2MzUmhkR1V1YkdWdVozUm9JRDA5UFNBd0lDWW1YRzRnSUNBZ0lDQWdJQ0FnSVhOMFlYUmxMbVpwYm1semFHVmtJQ1ltWEc0Z0lDQWdJQ0FnSUNBZ0lYTjBZWFJsTG5keWFYUnBibWNwTzF4dWZWeHVYRzVtZFc1amRHbHZiaUJ3Y21WbWFXNXBjMmdvYzNSeVpXRnRMQ0J6ZEdGMFpTa2dlMXh1SUNCcFppQW9JWE4wWVhSbExuQnlaV1pwYm1semFHVmtLU0I3WEc0Z0lDQWdjM1JoZEdVdWNISmxabWx1YVhOb1pXUWdQU0IwY25WbE8xeHVJQ0FnSUhOMGNtVmhiUzVsYldsMEtDZHdjbVZtYVc1cGMyZ25LVHRjYmlBZ2ZWeHVmVnh1WEc1bWRXNWpkR2x2YmlCbWFXNXBjMmhOWVhsaVpTaHpkSEpsWVcwc0lITjBZWFJsS1NCN1hHNGdJSFpoY2lCdVpXVmtJRDBnYm1WbFpFWnBibWx6YUNoemRISmxZVzBzSUhOMFlYUmxLVHRjYmlBZ2FXWWdLRzVsWldRcElIdGNiaUFnSUNCcFppQW9jM1JoZEdVdWNHVnVaR2x1WjJOaUlEMDlQU0F3S1NCN1hHNGdJQ0FnSUNCd2NtVm1hVzVwYzJnb2MzUnlaV0Z0TENCemRHRjBaU2s3WEc0Z0lDQWdJQ0J6ZEdGMFpTNW1hVzVwYzJobFpDQTlJSFJ5ZFdVN1hHNGdJQ0FnSUNCemRISmxZVzB1WlcxcGRDZ25abWx1YVhOb0p5azdYRzRnSUNBZ2ZTQmxiSE5sWEc0Z0lDQWdJQ0J3Y21WbWFXNXBjMmdvYzNSeVpXRnRMQ0J6ZEdGMFpTazdYRzRnSUgxY2JpQWdjbVYwZFhKdUlHNWxaV1E3WEc1OVhHNWNibVoxYm1OMGFXOXVJR1Z1WkZkeWFYUmhZbXhsS0hOMGNtVmhiU3dnYzNSaGRHVXNJR05pS1NCN1hHNGdJSE4wWVhSbExtVnVaR2x1WnlBOUlIUnlkV1U3WEc0Z0lHWnBibWx6YUUxaGVXSmxLSE4wY21WaGJTd2djM1JoZEdVcE8xeHVJQ0JwWmlBb1kySXBJSHRjYmlBZ0lDQnBaaUFvYzNSaGRHVXVabWx1YVhOb1pXUXBYRzRnSUNBZ0lDQndjbTlqWlhOekxtNWxlSFJVYVdOcktHTmlLVHRjYmlBZ0lDQmxiSE5sWEc0Z0lDQWdJQ0J6ZEhKbFlXMHViMjVqWlNnblptbHVhWE5vSnl3Z1kySXBPMXh1SUNCOVhHNGdJSE4wWVhSbExtVnVaR1ZrSUQwZ2RISjFaVHRjYm4xY2JpSmRmUT09IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiKVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIGhhc2ggPSA1MzgxLFxuICAgICAgaSAgICA9IHN0ci5sZW5ndGhcblxuICB3aGlsZShpKVxuICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSlcblxuICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBpZiB0aGUgaGlnaCBiaXRcbiAgICogaXMgc2V0LCB1bnNldCBpdCBhbmQgYWRkIGl0IGJhY2sgaW4gdGhyb3VnaCAoNjQtYml0IElFRUUpIGFkZGl0aW9uLiAqL1xuICByZXR1cm4gaGFzaCA+PSAwID8gaGFzaCA6IChoYXNoICYgMHg3RkZGRkZGRikgKyAweDgwMDAwMDAwXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG4iLCIvKiFcblx0dW5pcXVlLXJhbmRvbVxuXHRHZW5lcmF0ZSByYW5kb20gbnVtYmVycyB0aGF0IGFyZSBjb25zZWN1dGl2ZWx5IHVuaXF1ZVxuXHRodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3VuaXF1ZS1yYW5kb21cblx0YnkgU2luZHJlIFNvcmh1c1xuXHRNSVQgTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRmdW5jdGlvbiB1bmlxdWVSYW5kb20obWluLCBtYXgpIHtcblx0XHR2YXIgcHJldjtcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmFuZCgpIHtcblx0XHRcdHZhciBudW0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xuXHRcdFx0cmV0dXJuIHByZXYgPSBudW0gPT09IHByZXYgJiYgbWluICE9PSBtYXggPyByYW5kKCkgOiBudW07XG5cdFx0fTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gdW5pcXVlUmFuZG9tO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy51bmlxdWVSYW5kb20gPSB1bmlxdWVSYW5kb207XG5cdH1cbn0pKCk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciB1dGY4ID0ge1xuXHRcdCd2ZXJzaW9uJzogJzIuMC4wJyxcblx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdH1cblxufSh0aGlzKSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OTFkR1k0TDNWMFpqZ3Vhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHFJU0JvZEhSd2N6b3ZMMjEwYUhNdVltVXZkWFJtT0dweklIWXlMakF1TUNCaWVTQkFiV0YwYUdsaGN5QXFMMXh1T3lobWRXNWpkR2x2YmloeWIyOTBLU0I3WEc1Y2JseDBMeThnUkdWMFpXTjBJR1p5WldVZ2RtRnlhV0ZpYkdWeklHQmxlSEJ2Y25SellGeHVYSFIyWVhJZ1puSmxaVVY0Y0c5eWRITWdQU0IwZVhCbGIyWWdaWGh3YjNKMGN5QTlQU0FuYjJKcVpXTjBKeUFtSmlCbGVIQnZjblJ6TzF4dVhHNWNkQzh2SUVSbGRHVmpkQ0JtY21WbElIWmhjbWxoWW14bElHQnRiMlIxYkdWZ1hHNWNkSFpoY2lCbWNtVmxUVzlrZFd4bElEMGdkSGx3Wlc5bUlHMXZaSFZzWlNBOVBTQW5iMkpxWldOMEp5QW1KaUJ0YjJSMWJHVWdKaVpjYmx4MFhIUnRiMlIxYkdVdVpYaHdiM0owY3lBOVBTQm1jbVZsUlhod2IzSjBjeUFtSmlCdGIyUjFiR1U3WEc1Y2JseDBMeThnUkdWMFpXTjBJR1p5WldVZ2RtRnlhV0ZpYkdVZ1lHZHNiMkpoYkdBc0lHWnliMjBnVG05a1pTNXFjeUJ2Y2lCQ2NtOTNjMlZ5YVdacFpXUWdZMjlrWlN4Y2JseDBMeThnWVc1a0lIVnpaU0JwZENCaGN5QmdjbTl2ZEdCY2JseDBkbUZ5SUdaeVpXVkhiRzlpWVd3Z1BTQjBlWEJsYjJZZ1oyeHZZbUZzSUQwOUlDZHZZbXBsWTNRbklDWW1JR2RzYjJKaGJEdGNibHgwYVdZZ0tHWnlaV1ZIYkc5aVlXd3VaMnh2WW1Gc0lEMDlQU0JtY21WbFIyeHZZbUZzSUh4OElHWnlaV1ZIYkc5aVlXd3VkMmx1Wkc5M0lEMDlQU0JtY21WbFIyeHZZbUZzS1NCN1hHNWNkRngwY205dmRDQTlJR1p5WldWSGJHOWlZV3c3WEc1Y2RIMWNibHh1WEhRdktpMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRLaTljYmx4dVhIUjJZWElnYzNSeWFXNW5Sbkp2YlVOb1lYSkRiMlJsSUQwZ1UzUnlhVzVuTG1aeWIyMURhR0Z5UTI5a1pUdGNibHh1WEhRdkx5QlVZV3RsYmlCbWNtOXRJR2gwZEhCek9pOHZiWFJvY3k1aVpTOXdkVzU1WTI5a1pWeHVYSFJtZFc1amRHbHZiaUIxWTNNeVpHVmpiMlJsS0hOMGNtbHVaeWtnZTF4dVhIUmNkSFpoY2lCdmRYUndkWFFnUFNCYlhUdGNibHgwWEhSMllYSWdZMjkxYm5SbGNpQTlJREE3WEc1Y2RGeDBkbUZ5SUd4bGJtZDBhQ0E5SUhOMGNtbHVaeTVzWlc1bmRHZzdYRzVjZEZ4MGRtRnlJSFpoYkhWbE8xeHVYSFJjZEhaaGNpQmxlSFJ5WVR0Y2JseDBYSFIzYUdsc1pTQW9ZMjkxYm5SbGNpQThJR3hsYm1kMGFDa2dlMXh1WEhSY2RGeDBkbUZzZFdVZ1BTQnpkSEpwYm1jdVkyaGhja052WkdWQmRDaGpiM1Z1ZEdWeUt5c3BPMXh1WEhSY2RGeDBhV1lnS0haaGJIVmxJRDQ5SURCNFJEZ3dNQ0FtSmlCMllXeDFaU0E4UFNBd2VFUkNSa1lnSmlZZ1kyOTFiblJsY2lBOElHeGxibWQwYUNrZ2UxeHVYSFJjZEZ4MFhIUXZMeUJvYVdkb0lITjFjbkp2WjJGMFpTd2dZVzVrSUhSb1pYSmxJR2x6SUdFZ2JtVjRkQ0JqYUdGeVlXTjBaWEpjYmx4MFhIUmNkRngwWlhoMGNtRWdQU0J6ZEhKcGJtY3VZMmhoY2tOdlpHVkJkQ2hqYjNWdWRHVnlLeXNwTzF4dVhIUmNkRngwWEhScFppQW9LR1Y0ZEhKaElDWWdNSGhHUXpBd0tTQTlQU0F3ZUVSRE1EQXBJSHNnTHk4Z2JHOTNJSE4xY25KdloyRjBaVnh1WEhSY2RGeDBYSFJjZEc5MWRIQjFkQzV3ZFhOb0tDZ29kbUZzZFdVZ0ppQXdlRE5HUmlrZ1BEd2dNVEFwSUNzZ0tHVjRkSEpoSUNZZ01IZ3pSa1lwSUNzZ01IZ3hNREF3TUNrN1hHNWNkRngwWEhSY2RIMGdaV3h6WlNCN1hHNWNkRngwWEhSY2RGeDBMeThnZFc1dFlYUmphR1ZrSUhOMWNuSnZaMkYwWlRzZ2IyNXNlU0JoY0hCbGJtUWdkR2hwY3lCamIyUmxJSFZ1YVhRc0lHbHVJR05oYzJVZ2RHaGxJRzVsZUhSY2JseDBYSFJjZEZ4MFhIUXZMeUJqYjJSbElIVnVhWFFnYVhNZ2RHaGxJR2hwWjJnZ2MzVnljbTluWVhSbElHOW1JR0VnYzNWeWNtOW5ZWFJsSUhCaGFYSmNibHgwWEhSY2RGeDBYSFJ2ZFhSd2RYUXVjSFZ6YUNoMllXeDFaU2s3WEc1Y2RGeDBYSFJjZEZ4MFkyOTFiblJsY2kwdE8xeHVYSFJjZEZ4MFhIUjlYRzVjZEZ4MFhIUjlJR1ZzYzJVZ2UxeHVYSFJjZEZ4MFhIUnZkWFJ3ZFhRdWNIVnphQ2gyWVd4MVpTazdYRzVjZEZ4MFhIUjlYRzVjZEZ4MGZWeHVYSFJjZEhKbGRIVnliaUJ2ZFhSd2RYUTdYRzVjZEgxY2JseHVYSFF2THlCVVlXdGxiaUJtY205dElHaDBkSEJ6T2k4dmJYUm9jeTVpWlM5d2RXNTVZMjlrWlZ4dVhIUm1kVzVqZEdsdmJpQjFZM015Wlc1amIyUmxLR0Z5Y21GNUtTQjdYRzVjZEZ4MGRtRnlJR3hsYm1kMGFDQTlJR0Z5Y21GNUxteGxibWQwYUR0Y2JseDBYSFIyWVhJZ2FXNWtaWGdnUFNBdE1UdGNibHgwWEhSMllYSWdkbUZzZFdVN1hHNWNkRngwZG1GeUlHOTFkSEIxZENBOUlDY25PMXh1WEhSY2RIZG9hV3hsSUNncksybHVaR1Y0SUR3Z2JHVnVaM1JvS1NCN1hHNWNkRngwWEhSMllXeDFaU0E5SUdGeWNtRjVXMmx1WkdWNFhUdGNibHgwWEhSY2RHbG1JQ2gyWVd4MVpTQStJREI0UmtaR1Jpa2dlMXh1WEhSY2RGeDBYSFIyWVd4MVpTQXRQU0F3ZURFd01EQXdPMXh1WEhSY2RGeDBYSFJ2ZFhSd2RYUWdLejBnYzNSeWFXNW5Sbkp2YlVOb1lYSkRiMlJsS0haaGJIVmxJRDQrUGlBeE1DQW1JREI0TTBaR0lId2dNSGhFT0RBd0tUdGNibHgwWEhSY2RGeDBkbUZzZFdVZ1BTQXdlRVJETURBZ2ZDQjJZV3gxWlNBbUlEQjRNMFpHTzF4dVhIUmNkRngwZlZ4dVhIUmNkRngwYjNWMGNIVjBJQ3M5SUhOMGNtbHVaMFp5YjIxRGFHRnlRMjlrWlNoMllXeDFaU2s3WEc1Y2RGeDBmVnh1WEhSY2RISmxkSFZ5YmlCdmRYUndkWFE3WEc1Y2RIMWNibHh1WEhSbWRXNWpkR2x2YmlCamFHVmphMU5qWVd4aGNsWmhiSFZsS0dOdlpHVlFiMmx1ZENrZ2UxeHVYSFJjZEdsbUlDaGpiMlJsVUc5cGJuUWdQajBnTUhoRU9EQXdJQ1ltSUdOdlpHVlFiMmx1ZENBOFBTQXdlRVJHUmtZcElIdGNibHgwWEhSY2RIUm9jbTkzSUVWeWNtOXlLRnh1WEhSY2RGeDBYSFFuVEc5dVpTQnpkWEp5YjJkaGRHVWdWU3NuSUNzZ1kyOWtaVkJ2YVc1MExuUnZVM1J5YVc1bktERTJLUzUwYjFWd2NHVnlRMkZ6WlNncElDdGNibHgwWEhSY2RGeDBKeUJwY3lCdWIzUWdZU0J6WTJGc1lYSWdkbUZzZFdVblhHNWNkRngwWEhRcE8xeHVYSFJjZEgxY2JseDBmVnh1WEhRdktpMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRLaTljYmx4dVhIUm1kVzVqZEdsdmJpQmpjbVZoZEdWQ2VYUmxLR052WkdWUWIybHVkQ3dnYzJocFpuUXBJSHRjYmx4MFhIUnlaWFIxY200Z2MzUnlhVzVuUm5KdmJVTm9ZWEpEYjJSbEtDZ29ZMjlrWlZCdmFXNTBJRDQrSUhOb2FXWjBLU0FtSURCNE0wWXBJSHdnTUhnNE1DazdYRzVjZEgxY2JseHVYSFJtZFc1amRHbHZiaUJsYm1OdlpHVkRiMlJsVUc5cGJuUW9ZMjlrWlZCdmFXNTBLU0I3WEc1Y2RGeDBhV1lnS0NoamIyUmxVRzlwYm5RZ0ppQXdlRVpHUmtaR1JqZ3dLU0E5UFNBd0tTQjdJQzh2SURFdFlubDBaU0J6WlhGMVpXNWpaVnh1WEhSY2RGeDBjbVYwZFhKdUlITjBjbWx1WjBaeWIyMURhR0Z5UTI5a1pTaGpiMlJsVUc5cGJuUXBPMXh1WEhSY2RIMWNibHgwWEhSMllYSWdjM2x0WW05c0lEMGdKeWM3WEc1Y2RGeDBhV1lnS0NoamIyUmxVRzlwYm5RZ0ppQXdlRVpHUmtaR09EQXdLU0E5UFNBd0tTQjdJQzh2SURJdFlubDBaU0J6WlhGMVpXNWpaVnh1WEhSY2RGeDBjM2x0WW05c0lEMGdjM1J5YVc1blJuSnZiVU5vWVhKRGIyUmxLQ2dvWTI5a1pWQnZhVzUwSUQ0K0lEWXBJQ1lnTUhneFJpa2dmQ0F3ZUVNd0tUdGNibHgwWEhSOVhHNWNkRngwWld4elpTQnBaaUFvS0dOdlpHVlFiMmx1ZENBbUlEQjRSa1pHUmpBd01EQXBJRDA5SURBcElIc2dMeThnTXkxaWVYUmxJSE5sY1hWbGJtTmxYRzVjZEZ4MFhIUmphR1ZqYTFOallXeGhjbFpoYkhWbEtHTnZaR1ZRYjJsdWRDazdYRzVjZEZ4MFhIUnplVzFpYjJ3Z1BTQnpkSEpwYm1kR2NtOXRRMmhoY2tOdlpHVW9LQ2hqYjJSbFVHOXBiblFnUGo0Z01USXBJQ1lnTUhnd1Jpa2dmQ0F3ZUVVd0tUdGNibHgwWEhSY2RITjViV0p2YkNBclBTQmpjbVZoZEdWQ2VYUmxLR052WkdWUWIybHVkQ3dnTmlrN1hHNWNkRngwZlZ4dVhIUmNkR1ZzYzJVZ2FXWWdLQ2hqYjJSbFVHOXBiblFnSmlBd2VFWkdSVEF3TURBd0tTQTlQU0F3S1NCN0lDOHZJRFF0WW5sMFpTQnpaWEYxWlc1alpWeHVYSFJjZEZ4MGMzbHRZbTlzSUQwZ2MzUnlhVzVuUm5KdmJVTm9ZWEpEYjJSbEtDZ29ZMjlrWlZCdmFXNTBJRDQrSURFNEtTQW1JREI0TURjcElId2dNSGhHTUNrN1hHNWNkRngwWEhSemVXMWliMndnS3owZ1kzSmxZWFJsUW5sMFpTaGpiMlJsVUc5cGJuUXNJREV5S1R0Y2JseDBYSFJjZEhONWJXSnZiQ0FyUFNCamNtVmhkR1ZDZVhSbEtHTnZaR1ZRYjJsdWRDd2dOaWs3WEc1Y2RGeDBmVnh1WEhSY2RITjViV0p2YkNBclBTQnpkSEpwYm1kR2NtOXRRMmhoY2tOdlpHVW9LR052WkdWUWIybHVkQ0FtSURCNE0wWXBJSHdnTUhnNE1DazdYRzVjZEZ4MGNtVjBkWEp1SUhONWJXSnZiRHRjYmx4MGZWeHVYRzVjZEdaMWJtTjBhVzl1SUhWMFpqaGxibU52WkdVb2MzUnlhVzVuS1NCN1hHNWNkRngwZG1GeUlHTnZaR1ZRYjJsdWRITWdQU0IxWTNNeVpHVmpiMlJsS0hOMGNtbHVaeWs3WEc1Y2RGeDBkbUZ5SUd4bGJtZDBhQ0E5SUdOdlpHVlFiMmx1ZEhNdWJHVnVaM1JvTzF4dVhIUmNkSFpoY2lCcGJtUmxlQ0E5SUMweE8xeHVYSFJjZEhaaGNpQmpiMlJsVUc5cGJuUTdYRzVjZEZ4MGRtRnlJR0o1ZEdWVGRISnBibWNnUFNBbkp6dGNibHgwWEhSM2FHbHNaU0FvS3l0cGJtUmxlQ0E4SUd4bGJtZDBhQ2tnZTF4dVhIUmNkRngwWTI5a1pWQnZhVzUwSUQwZ1kyOWtaVkJ2YVc1MGMxdHBibVJsZUYwN1hHNWNkRngwWEhSaWVYUmxVM1J5YVc1bklDczlJR1Z1WTI5a1pVTnZaR1ZRYjJsdWRDaGpiMlJsVUc5cGJuUXBPMXh1WEhSY2RIMWNibHgwWEhSeVpYUjFjbTRnWW5sMFpWTjBjbWx1Wnp0Y2JseDBmVnh1WEc1Y2RDOHFMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzBxTDF4dVhHNWNkR1oxYm1OMGFXOXVJSEpsWVdSRGIyNTBhVzUxWVhScGIyNUNlWFJsS0NrZ2UxeHVYSFJjZEdsbUlDaGllWFJsU1c1a1pYZ2dQajBnWW5sMFpVTnZkVzUwS1NCN1hHNWNkRngwWEhSMGFISnZkeUJGY25KdmNpZ25TVzUyWVd4cFpDQmllWFJsSUdsdVpHVjRKeWs3WEc1Y2RGeDBmVnh1WEc1Y2RGeDBkbUZ5SUdOdmJuUnBiblZoZEdsdmJrSjVkR1VnUFNCaWVYUmxRWEp5WVhsYllubDBaVWx1WkdWNFhTQW1JREI0UmtZN1hHNWNkRngwWW5sMFpVbHVaR1Y0S3lzN1hHNWNibHgwWEhScFppQW9LR052Ym5ScGJuVmhkR2x2YmtKNWRHVWdKaUF3ZUVNd0tTQTlQU0F3ZURnd0tTQjdYRzVjZEZ4MFhIUnlaWFIxY200Z1kyOXVkR2x1ZFdGMGFXOXVRbmwwWlNBbUlEQjRNMFk3WEc1Y2RGeDBmVnh1WEc1Y2RGeDBMeThnU1dZZ2QyVWdaVzVrSUhWd0lHaGxjbVVzSUdsMDRvQ1pjeUJ1YjNRZ1lTQmpiMjUwYVc1MVlYUnBiMjRnWW5sMFpWeHVYSFJjZEhSb2NtOTNJRVZ5Y205eUtDZEpiblpoYkdsa0lHTnZiblJwYm5WaGRHbHZiaUJpZVhSbEp5azdYRzVjZEgxY2JseHVYSFJtZFc1amRHbHZiaUJrWldOdlpHVlRlVzFpYjJ3b0tTQjdYRzVjZEZ4MGRtRnlJR0o1ZEdVeE8xeHVYSFJjZEhaaGNpQmllWFJsTWp0Y2JseDBYSFIyWVhJZ1lubDBaVE03WEc1Y2RGeDBkbUZ5SUdKNWRHVTBPMXh1WEhSY2RIWmhjaUJqYjJSbFVHOXBiblE3WEc1Y2JseDBYSFJwWmlBb1lubDBaVWx1WkdWNElENGdZbmwwWlVOdmRXNTBLU0I3WEc1Y2RGeDBYSFIwYUhKdmR5QkZjbkp2Y2lnblNXNTJZV3hwWkNCaWVYUmxJR2x1WkdWNEp5azdYRzVjZEZ4MGZWeHVYRzVjZEZ4MGFXWWdLR0o1ZEdWSmJtUmxlQ0E5UFNCaWVYUmxRMjkxYm5RcElIdGNibHgwWEhSY2RISmxkSFZ5YmlCbVlXeHpaVHRjYmx4MFhIUjlYRzVjYmx4MFhIUXZMeUJTWldGa0lHWnBjbk4wSUdKNWRHVmNibHgwWEhSaWVYUmxNU0E5SUdKNWRHVkJjbkpoZVZ0aWVYUmxTVzVrWlhoZElDWWdNSGhHUmp0Y2JseDBYSFJpZVhSbFNXNWtaWGdyS3p0Y2JseHVYSFJjZEM4dklERXRZbmwwWlNCelpYRjFaVzVqWlNBb2JtOGdZMjl1ZEdsdWRXRjBhVzl1SUdKNWRHVnpLVnh1WEhSY2RHbG1JQ2dvWW5sMFpURWdKaUF3ZURnd0tTQTlQU0F3S1NCN1hHNWNkRngwWEhSeVpYUjFjbTRnWW5sMFpURTdYRzVjZEZ4MGZWeHVYRzVjZEZ4MEx5OGdNaTFpZVhSbElITmxjWFZsYm1ObFhHNWNkRngwYVdZZ0tDaGllWFJsTVNBbUlEQjRSVEFwSUQwOUlEQjRRekFwSUh0Y2JseDBYSFJjZEhaaGNpQmllWFJsTWlBOUlISmxZV1JEYjI1MGFXNTFZWFJwYjI1Q2VYUmxLQ2s3WEc1Y2RGeDBYSFJqYjJSbFVHOXBiblFnUFNBb0tHSjVkR1V4SUNZZ01IZ3hSaWtnUER3Z05pa2dmQ0JpZVhSbE1qdGNibHgwWEhSY2RHbG1JQ2hqYjJSbFVHOXBiblFnUGowZ01IZzRNQ2tnZTF4dVhIUmNkRngwWEhSeVpYUjFjbTRnWTI5a1pWQnZhVzUwTzF4dVhIUmNkRngwZlNCbGJITmxJSHRjYmx4MFhIUmNkRngwZEdoeWIzY2dSWEp5YjNJb0owbHVkbUZzYVdRZ1kyOXVkR2x1ZFdGMGFXOXVJR0o1ZEdVbktUdGNibHgwWEhSY2RIMWNibHgwWEhSOVhHNWNibHgwWEhRdkx5QXpMV0o1ZEdVZ2MyVnhkV1Z1WTJVZ0tHMWhlU0JwYm1Oc2RXUmxJSFZ1Y0dGcGNtVmtJSE4xY25KdloyRjBaWE1wWEc1Y2RGeDBhV1lnS0NoaWVYUmxNU0FtSURCNFJqQXBJRDA5SURCNFJUQXBJSHRjYmx4MFhIUmNkR0o1ZEdVeUlEMGdjbVZoWkVOdmJuUnBiblZoZEdsdmJrSjVkR1VvS1R0Y2JseDBYSFJjZEdKNWRHVXpJRDBnY21WaFpFTnZiblJwYm5WaGRHbHZia0o1ZEdVb0tUdGNibHgwWEhSY2RHTnZaR1ZRYjJsdWRDQTlJQ2dvWW5sMFpURWdKaUF3ZURCR0tTQThQQ0F4TWlrZ2ZDQW9ZbmwwWlRJZ1BEd2dOaWtnZkNCaWVYUmxNenRjYmx4MFhIUmNkR2xtSUNoamIyUmxVRzlwYm5RZ1BqMGdNSGd3T0RBd0tTQjdYRzVjZEZ4MFhIUmNkR05vWldOclUyTmhiR0Z5Vm1Gc2RXVW9ZMjlrWlZCdmFXNTBLVHRjYmx4MFhIUmNkRngwY21WMGRYSnVJR052WkdWUWIybHVkRHRjYmx4MFhIUmNkSDBnWld4elpTQjdYRzVjZEZ4MFhIUmNkSFJvY205M0lFVnljbTl5S0NkSmJuWmhiR2xrSUdOdmJuUnBiblZoZEdsdmJpQmllWFJsSnlrN1hHNWNkRngwWEhSOVhHNWNkRngwZlZ4dVhHNWNkRngwTHk4Z05DMWllWFJsSUhObGNYVmxibU5sWEc1Y2RGeDBhV1lnS0NoaWVYUmxNU0FtSURCNFJqZ3BJRDA5SURCNFJqQXBJSHRjYmx4MFhIUmNkR0o1ZEdVeUlEMGdjbVZoWkVOdmJuUnBiblZoZEdsdmJrSjVkR1VvS1R0Y2JseDBYSFJjZEdKNWRHVXpJRDBnY21WaFpFTnZiblJwYm5WaGRHbHZia0o1ZEdVb0tUdGNibHgwWEhSY2RHSjVkR1UwSUQwZ2NtVmhaRU52Ym5ScGJuVmhkR2x2YmtKNWRHVW9LVHRjYmx4MFhIUmNkR052WkdWUWIybHVkQ0E5SUNnb1lubDBaVEVnSmlBd2VEQkdLU0E4UENBd2VERXlLU0I4SUNoaWVYUmxNaUE4UENBd2VEQkRLU0I4WEc1Y2RGeDBYSFJjZENoaWVYUmxNeUE4UENBd2VEQTJLU0I4SUdKNWRHVTBPMXh1WEhSY2RGeDBhV1lnS0dOdlpHVlFiMmx1ZENBK1BTQXdlREF4TURBd01DQW1KaUJqYjJSbFVHOXBiblFnUEQwZ01IZ3hNRVpHUmtZcElIdGNibHgwWEhSY2RGeDBjbVYwZFhKdUlHTnZaR1ZRYjJsdWREdGNibHgwWEhSY2RIMWNibHgwWEhSOVhHNWNibHgwWEhSMGFISnZkeUJGY25KdmNpZ25TVzUyWVd4cFpDQlZWRVl0T0NCa1pYUmxZM1JsWkNjcE8xeHVYSFI5WEc1Y2JseDBkbUZ5SUdKNWRHVkJjbkpoZVR0Y2JseDBkbUZ5SUdKNWRHVkRiM1Z1ZER0Y2JseDBkbUZ5SUdKNWRHVkpibVJsZUR0Y2JseDBablZ1WTNScGIyNGdkWFJtT0dSbFkyOWtaU2hpZVhSbFUzUnlhVzVuS1NCN1hHNWNkRngwWW5sMFpVRnljbUY1SUQwZ2RXTnpNbVJsWTI5a1pTaGllWFJsVTNSeWFXNW5LVHRjYmx4MFhIUmllWFJsUTI5MWJuUWdQU0JpZVhSbFFYSnlZWGt1YkdWdVozUm9PMXh1WEhSY2RHSjVkR1ZKYm1SbGVDQTlJREE3WEc1Y2RGeDBkbUZ5SUdOdlpHVlFiMmx1ZEhNZ1BTQmJYVHRjYmx4MFhIUjJZWElnZEcxd08xeHVYSFJjZEhkb2FXeGxJQ2dvZEcxd0lEMGdaR1ZqYjJSbFUzbHRZbTlzS0NrcElDRTlQU0JtWVd4elpTa2dlMXh1WEhSY2RGeDBZMjlrWlZCdmFXNTBjeTV3ZFhOb0tIUnRjQ2s3WEc1Y2RGeDBmVnh1WEhSY2RISmxkSFZ5YmlCMVkzTXlaVzVqYjJSbEtHTnZaR1ZRYjJsdWRITXBPMXh1WEhSOVhHNWNibHgwTHlvdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTb3ZYRzVjYmx4MGRtRnlJSFYwWmpnZ1BTQjdYRzVjZEZ4MEozWmxjbk5wYjI0bk9pQW5NaTR3TGpBbkxGeHVYSFJjZENkbGJtTnZaR1VuT2lCMWRHWTRaVzVqYjJSbExGeHVYSFJjZENka1pXTnZaR1VuT2lCMWRHWTRaR1ZqYjJSbFhHNWNkSDA3WEc1Y2JseDBMeThnVTI5dFpTQkJUVVFnWW5WcGJHUWdiM0IwYVcxcGVtVnljeXdnYkdsclpTQnlMbXB6TENCamFHVmpheUJtYjNJZ2MzQmxZMmxtYVdNZ1kyOXVaR2wwYVc5dUlIQmhkSFJsY201elhHNWNkQzh2SUd4cGEyVWdkR2hsSUdadmJHeHZkMmx1WnpwY2JseDBhV1lnS0Z4dVhIUmNkSFI1Y0dWdlppQmtaV1pwYm1VZ1BUMGdKMloxYm1OMGFXOXVKeUFtSmx4dVhIUmNkSFI1Y0dWdlppQmtaV1pwYm1VdVlXMWtJRDA5SUNkdlltcGxZM1FuSUNZbVhHNWNkRngwWkdWbWFXNWxMbUZ0WkZ4dVhIUXBJSHRjYmx4MFhIUmtaV1pwYm1Vb1puVnVZM1JwYjI0b0tTQjdYRzVjZEZ4MFhIUnlaWFIxY200Z2RYUm1PRHRjYmx4MFhIUjlLVHRjYmx4MGZWeDBaV3h6WlNCcFppQW9abkpsWlVWNGNHOXlkSE1nSmlZZ0lXWnlaV1ZGZUhCdmNuUnpMbTV2WkdWVWVYQmxLU0I3WEc1Y2RGeDBhV1lnS0daeVpXVk5iMlIxYkdVcElIc2dMeThnYVc0Z1RtOWtaUzVxY3lCdmNpQlNhVzVuYjBwVElIWXdMamd1TUN0Y2JseDBYSFJjZEdaeVpXVk5iMlIxYkdVdVpYaHdiM0owY3lBOUlIVjBaamc3WEc1Y2RGeDBmU0JsYkhObElIc2dMeThnYVc0Z1RtRnlkMmhoYkNCdmNpQlNhVzVuYjBwVElIWXdMamN1TUMxY2JseDBYSFJjZEhaaGNpQnZZbXBsWTNRZ1BTQjdmVHRjYmx4MFhIUmNkSFpoY2lCb1lYTlBkMjVRY205d1pYSjBlU0E5SUc5aWFtVmpkQzVvWVhOUGQyNVFjbTl3WlhKMGVUdGNibHgwWEhSY2RHWnZjaUFvZG1GeUlHdGxlU0JwYmlCMWRHWTRLU0I3WEc1Y2RGeDBYSFJjZEdoaGMwOTNibEJ5YjNCbGNuUjVMbU5oYkd3b2RYUm1PQ3dnYTJWNUtTQW1KaUFvWm5KbFpVVjRjRzl5ZEhOYmEyVjVYU0E5SUhWMFpqaGJhMlY1WFNrN1hHNWNkRngwWEhSOVhHNWNkRngwZlZ4dVhIUjlJR1ZzYzJVZ2V5QXZMeUJwYmlCU2FHbHVieUJ2Y2lCaElIZGxZaUJpY205M2MyVnlYRzVjZEZ4MGNtOXZkQzUxZEdZNElEMGdkWFJtT0R0Y2JseDBmVnh1WEc1OUtIUm9hWE1wS1R0Y2JpSmRmUT09IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OTFkR2xzTDNWMGFXd3Vhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEVpTENKbWFXeGxJam9pWjJWdVpYSmhkR1ZrTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklpOHZJRU52Y0hseWFXZG9kQ0JLYjNsbGJuUXNJRWx1WXk0Z1lXNWtJRzkwYUdWeUlFNXZaR1VnWTI5dWRISnBZblYwYjNKekxseHVMeTljYmk4dklGQmxjbTFwYzNOcGIyNGdhWE1nYUdWeVpXSjVJR2R5WVc1MFpXUXNJR1p5WldVZ2IyWWdZMmhoY21kbExDQjBieUJoYm5rZ2NHVnljMjl1SUc5aWRHRnBibWx1WnlCaFhHNHZMeUJqYjNCNUlHOW1JSFJvYVhNZ2MyOW1kSGRoY21VZ1lXNWtJR0Z6YzI5amFXRjBaV1FnWkc5amRXMWxiblJoZEdsdmJpQm1hV3hsY3lBb2RHaGxYRzR2THlCY0lsTnZablIzWVhKbFhDSXBMQ0IwYnlCa1pXRnNJR2x1SUhSb1pTQlRiMlowZDJGeVpTQjNhWFJvYjNWMElISmxjM1J5YVdOMGFXOXVMQ0JwYm1Oc2RXUnBibWRjYmk4dklIZHBkR2h2ZFhRZ2JHbHRhWFJoZEdsdmJpQjBhR1VnY21sbmFIUnpJSFJ2SUhWelpTd2dZMjl3ZVN3Z2JXOWthV1o1TENCdFpYSm5aU3dnY0hWaWJHbHphQ3hjYmk4dklHUnBjM1J5YVdKMWRHVXNJSE4xWW14cFkyVnVjMlVzSUdGdVpDOXZjaUJ6Wld4c0lHTnZjR2xsY3lCdlppQjBhR1VnVTI5bWRIZGhjbVVzSUdGdVpDQjBieUJ3WlhKdGFYUmNiaTh2SUhCbGNuTnZibk1nZEc4Z2QyaHZiU0IwYUdVZ1UyOW1kSGRoY21VZ2FYTWdablZ5Ym1semFHVmtJSFJ2SUdSdklITnZMQ0J6ZFdKcVpXTjBJSFJ2SUhSb1pWeHVMeThnWm05c2JHOTNhVzVuSUdOdmJtUnBkR2x2Ym5NNlhHNHZMMXh1THk4Z1ZHaGxJR0ZpYjNabElHTnZjSGx5YVdkb2RDQnViM1JwWTJVZ1lXNWtJSFJvYVhNZ2NHVnliV2x6YzJsdmJpQnViM1JwWTJVZ2MyaGhiR3dnWW1VZ2FXNWpiSFZrWldSY2JpOHZJR2x1SUdGc2JDQmpiM0JwWlhNZ2IzSWdjM1ZpYzNSaGJuUnBZV3dnY0c5eWRHbHZibk1nYjJZZ2RHaGxJRk52Wm5SM1lYSmxMbHh1THk5Y2JpOHZJRlJJUlNCVFQwWlVWMEZTUlNCSlV5QlFVazlXU1VSRlJDQmNJa0ZUSUVsVFhDSXNJRmRKVkVoUFZWUWdWMEZTVWtGT1ZGa2dUMFlnUVU1WklFdEpUa1FzSUVWWVVGSkZVMU5jYmk4dklFOVNJRWxOVUV4SlJVUXNJRWxPUTB4VlJFbE9SeUJDVlZRZ1RrOVVJRXhKVFVsVVJVUWdWRThnVkVoRklGZEJVbEpCVGxSSlJWTWdUMFpjYmk4dklFMUZVa05JUVU1VVFVSkpURWxVV1N3Z1JrbFVUa1ZUVXlCR1QxSWdRU0JRUVZKVVNVTlZURUZTSUZCVlVsQlBVMFVnUVU1RUlFNVBUa2xPUmxKSlRrZEZUVVZPVkM0Z1NVNWNiaTh2SUU1UElFVldSVTVVSUZOSVFVeE1JRlJJUlNCQlZWUklUMUpUSUU5U0lFTlBVRmxTU1VkSVZDQklUMHhFUlZKVElFSkZJRXhKUVVKTVJTQkdUMUlnUVU1WklFTk1RVWxOTEZ4dUx5OGdSRUZOUVVkRlV5QlBVaUJQVkVoRlVpQk1TVUZDU1V4SlZGa3NJRmRJUlZSSVJWSWdTVTRnUVU0Z1FVTlVTVTlPSUU5R0lFTlBUbFJTUVVOVUxDQlVUMUpVSUU5U1hHNHZMeUJQVkVoRlVsZEpVMFVzSUVGU1NWTkpUa2NnUmxKUFRTd2dUMVZVSUU5R0lFOVNJRWxPSUVOUFRrNUZRMVJKVDA0Z1YwbFVTQ0JVU0VVZ1UwOUdWRmRCVWtVZ1QxSWdWRWhGWEc0dkx5QlZVMFVnVDFJZ1QxUklSVklnUkVWQlRFbE9SMU1nU1U0Z1ZFaEZJRk5QUmxSWFFWSkZMbHh1WEc1MllYSWdabTl5YldGMFVtVm5SWGh3SUQwZ0x5VmJjMlJxSlYwdlp6dGNibVY0Y0c5eWRITXVabTl5YldGMElEMGdablZ1WTNScGIyNG9aaWtnZTF4dUlDQnBaaUFvSVdselUzUnlhVzVuS0dZcEtTQjdYRzRnSUNBZ2RtRnlJRzlpYW1WamRITWdQU0JiWFR0Y2JpQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeVozVnRaVzUwY3k1c1pXNW5kR2c3SUdrckt5a2dlMXh1SUNBZ0lDQWdiMkpxWldOMGN5NXdkWE5vS0dsdWMzQmxZM1FvWVhKbmRXMWxiblJ6VzJsZEtTazdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ2WW1wbFkzUnpMbXB2YVc0b0p5QW5LVHRjYmlBZ2ZWeHVYRzRnSUhaaGNpQnBJRDBnTVR0Y2JpQWdkbUZ5SUdGeVozTWdQU0JoY21kMWJXVnVkSE03WEc0Z0lIWmhjaUJzWlc0Z1BTQmhjbWR6TG14bGJtZDBhRHRjYmlBZ2RtRnlJSE4wY2lBOUlGTjBjbWx1WnlobUtTNXlaWEJzWVdObEtHWnZjbTFoZEZKbFowVjRjQ3dnWm5WdVkzUnBiMjRvZUNrZ2UxeHVJQ0FnSUdsbUlDaDRJRDA5UFNBbkpTVW5LU0J5WlhSMWNtNGdKeVVuTzF4dUlDQWdJR2xtSUNocElENDlJR3hsYmlrZ2NtVjBkWEp1SUhnN1hHNGdJQ0FnYzNkcGRHTm9JQ2g0S1NCN1hHNGdJQ0FnSUNCallYTmxJQ2NsY3ljNklISmxkSFZ5YmlCVGRISnBibWNvWVhKbmMxdHBLeXRkS1R0Y2JpQWdJQ0FnSUdOaGMyVWdKeVZrSnpvZ2NtVjBkWEp1SUU1MWJXSmxjaWhoY21kelcya3JLMTBwTzF4dUlDQWdJQ0FnWTJGelpTQW5KV29uT2x4dUlDQWdJQ0FnSUNCMGNua2dlMXh1SUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJLVTA5T0xuTjBjbWx1WjJsbWVTaGhjbWR6VzJrcksxMHBPMXh1SUNBZ0lDQWdJQ0I5SUdOaGRHTm9JQ2hmS1NCN1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlDZGJRMmx5WTNWc1lYSmRKenRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnWkdWbVlYVnNkRHBjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSGc3WEc0Z0lDQWdmVnh1SUNCOUtUdGNiaUFnWm05eUlDaDJZWElnZUNBOUlHRnlaM05iYVYwN0lHa2dQQ0JzWlc0N0lIZ2dQU0JoY21keld5c3JhVjBwSUh0Y2JpQWdJQ0JwWmlBb2FYTk9kV3hzS0hncElIeDhJQ0ZwYzA5aWFtVmpkQ2g0S1NrZ2UxeHVJQ0FnSUNBZ2MzUnlJQ3M5SUNjZ0p5QXJJSGc3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lITjBjaUFyUFNBbklDY2dLeUJwYm5Od1pXTjBLSGdwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVJQ0J5WlhSMWNtNGdjM1J5TzF4dWZUdGNibHh1WEc0dkx5Qk5ZWEpySUhSb1lYUWdZU0J0WlhSb2IyUWdjMmh2ZFd4a0lHNXZkQ0JpWlNCMWMyVmtMbHh1THk4Z1VtVjBkWEp1Y3lCaElHMXZaR2xtYVdWa0lHWjFibU4wYVc5dUlIZG9hV05vSUhkaGNtNXpJRzl1WTJVZ1lua2daR1ZtWVhWc2RDNWNiaTh2SUVsbUlDMHRibTh0WkdWd2NtVmpZWFJwYjI0Z2FYTWdjMlYwTENCMGFHVnVJR2wwSUdseklHRWdibTh0YjNBdVhHNWxlSEJ2Y25SekxtUmxjSEpsWTJGMFpTQTlJR1oxYm1OMGFXOXVLR1p1TENCdGMyY3BJSHRjYmlBZ0x5OGdRV3hzYjNjZ1ptOXlJR1JsY0hKbFkyRjBhVzVuSUhSb2FXNW5jeUJwYmlCMGFHVWdjSEp2WTJWemN5QnZaaUJ6ZEdGeWRHbHVaeUIxY0M1Y2JpQWdhV1lnS0dselZXNWtaV1pwYm1Wa0tHZHNiMkpoYkM1d2NtOWpaWE56S1NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJsZUhCdmNuUnpMbVJsY0hKbFkyRjBaU2htYml3Z2JYTm5LUzVoY0hCc2VTaDBhR2x6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUgwN1hHNGdJSDFjYmx4dUlDQnBaaUFvY0hKdlkyVnpjeTV1YjBSbGNISmxZMkYwYVc5dUlEMDlQU0IwY25WbEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdadU8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUhkaGNtNWxaQ0E5SUdaaGJITmxPMXh1SUNCbWRXNWpkR2x2YmlCa1pYQnlaV05oZEdWa0tDa2dlMXh1SUNBZ0lHbG1JQ2doZDJGeWJtVmtLU0I3WEc0Z0lDQWdJQ0JwWmlBb2NISnZZMlZ6Y3k1MGFISnZkMFJsY0hKbFkyRjBhVzl1S1NCN1hHNGdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2lodGMyY3BPMXh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2h3Y205alpYTnpMblJ5WVdObFJHVndjbVZqWVhScGIyNHBJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMyOXNaUzUwY21GalpTaHRjMmNwTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnWTI5dWMyOXNaUzVsY25KdmNpaHRjMmNwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnZDJGeWJtVmtJRDBnZEhKMVpUdGNiaUFnSUNCOVhHNGdJQ0FnY21WMGRYSnVJR1p1TG1Gd2NHeDVLSFJvYVhNc0lHRnlaM1Z0Wlc1MGN5azdYRzRnSUgxY2JseHVJQ0J5WlhSMWNtNGdaR1Z3Y21WallYUmxaRHRjYm4wN1hHNWNibHh1ZG1GeUlHUmxZblZuY3lBOUlIdDlPMXh1ZG1GeUlHUmxZblZuUlc1MmFYSnZianRjYm1WNGNHOXlkSE11WkdWaWRXZHNiMmNnUFNCbWRXNWpkR2x2YmloelpYUXBJSHRjYmlBZ2FXWWdLR2x6Vlc1a1pXWnBibVZrS0dSbFluVm5SVzUyYVhKdmJpa3BYRzRnSUNBZ1pHVmlkV2RGYm5acGNtOXVJRDBnY0hKdlkyVnpjeTVsYm5ZdVRrOUVSVjlFUlVKVlJ5QjhmQ0FuSnp0Y2JpQWdjMlYwSUQwZ2MyVjBMblJ2VlhCd1pYSkRZWE5sS0NrN1hHNGdJR2xtSUNnaFpHVmlkV2R6VzNObGRGMHBJSHRjYmlBZ0lDQnBaaUFvYm1WM0lGSmxaMFY0Y0NnblhGeGNYR0luSUNzZ2MyVjBJQ3NnSjF4Y1hGeGlKeXdnSjJrbktTNTBaWE4wS0dSbFluVm5SVzUyYVhKdmJpa3BJSHRjYmlBZ0lDQWdJSFpoY2lCd2FXUWdQU0J3Y205alpYTnpMbkJwWkR0Y2JpQWdJQ0FnSUdSbFluVm5jMXR6WlhSZElEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQnRjMmNnUFNCbGVIQnZjblJ6TG1admNtMWhkQzVoY0hCc2VTaGxlSEJ2Y25SekxDQmhjbWQxYldWdWRITXBPMXh1SUNBZ0lDQWdJQ0JqYjI1emIyeGxMbVZ5Y205eUtDY2xjeUFsWkRvZ0pYTW5MQ0J6WlhRc0lIQnBaQ3dnYlhObktUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUdSbFluVm5jMXR6WlhSZElEMGdablZ1WTNScGIyNG9LU0I3ZlR0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnY21WMGRYSnVJR1JsWW5WbmMxdHpaWFJkTzF4dWZUdGNibHh1WEc0dktpcGNiaUFxSUVWamFHOXpJSFJvWlNCMllXeDFaU0J2WmlCaElIWmhiSFZsTGlCVWNubHpJSFJ2SUhCeWFXNTBJSFJvWlNCMllXeDFaU0J2ZFhSY2JpQXFJR2x1SUhSb1pTQmlaWE4wSUhkaGVTQndiM056YVdKc1pTQm5hWFpsYmlCMGFHVWdaR2xtWm1WeVpXNTBJSFI1Y0dWekxseHVJQ3BjYmlBcUlFQndZWEpoYlNCN1QySnFaV04wZlNCdlltb2dWR2hsSUc5aWFtVmpkQ0IwYnlCd2NtbHVkQ0J2ZFhRdVhHNGdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdiM0IwY3lCUGNIUnBiMjVoYkNCdmNIUnBiMjV6SUc5aWFtVmpkQ0IwYUdGMElHRnNkR1Z5Y3lCMGFHVWdiM1YwY0hWMExseHVJQ292WEc0dktpQnNaV2RoWTNrNklHOWlhaXdnYzJodmQwaHBaR1JsYml3Z1pHVndkR2dzSUdOdmJHOXljeW92WEc1bWRXNWpkR2x2YmlCcGJuTndaV04wS0c5aWFpd2diM0IwY3lrZ2UxeHVJQ0F2THlCa1pXWmhkV3gwSUc5d2RHbHZibk5jYmlBZ2RtRnlJR04wZUNBOUlIdGNiaUFnSUNCelpXVnVPaUJiWFN4Y2JpQWdJQ0J6ZEhsc2FYcGxPaUJ6ZEhsc2FYcGxUbTlEYjJ4dmNseHVJQ0I5TzF4dUlDQXZMeUJzWldkaFkza3VMaTVjYmlBZ2FXWWdLR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ2dQajBnTXlrZ1kzUjRMbVJsY0hSb0lEMGdZWEpuZFcxbGJuUnpXekpkTzF4dUlDQnBaaUFvWVhKbmRXMWxiblJ6TG14bGJtZDBhQ0ErUFNBMEtTQmpkSGd1WTI5c2IzSnpJRDBnWVhKbmRXMWxiblJ6V3pOZE8xeHVJQ0JwWmlBb2FYTkNiMjlzWldGdUtHOXdkSE1wS1NCN1hHNGdJQ0FnTHk4Z2JHVm5ZV041TGk0dVhHNGdJQ0FnWTNSNExuTm9iM2RJYVdSa1pXNGdQU0J2Y0hSek8xeHVJQ0I5SUdWc2MyVWdhV1lnS0c5d2RITXBJSHRjYmlBZ0lDQXZMeUJuYjNRZ1lXNGdYQ0p2Y0hScGIyNXpYQ0lnYjJKcVpXTjBYRzRnSUNBZ1pYaHdiM0owY3k1ZlpYaDBaVzVrS0dOMGVDd2diM0IwY3lrN1hHNGdJSDFjYmlBZ0x5OGdjMlYwSUdSbFptRjFiSFFnYjNCMGFXOXVjMXh1SUNCcFppQW9hWE5WYm1SbFptbHVaV1FvWTNSNExuTm9iM2RJYVdSa1pXNHBLU0JqZEhndWMyaHZkMGhwWkdSbGJpQTlJR1poYkhObE8xeHVJQ0JwWmlBb2FYTlZibVJsWm1sdVpXUW9ZM1I0TG1SbGNIUm9LU2tnWTNSNExtUmxjSFJvSUQwZ01qdGNiaUFnYVdZZ0tHbHpWVzVrWldacGJtVmtLR04wZUM1amIyeHZjbk1wS1NCamRIZ3VZMjlzYjNKeklEMGdabUZzYzJVN1hHNGdJR2xtSUNocGMxVnVaR1ZtYVc1bFpDaGpkSGd1WTNWemRHOXRTVzV6Y0dWamRDa3BJR04wZUM1amRYTjBiMjFKYm5Od1pXTjBJRDBnZEhKMVpUdGNiaUFnYVdZZ0tHTjBlQzVqYjJ4dmNuTXBJR04wZUM1emRIbHNhWHBsSUQwZ2MzUjViR2w2WlZkcGRHaERiMnh2Y2p0Y2JpQWdjbVYwZFhKdUlHWnZjbTFoZEZaaGJIVmxLR04wZUN3Z2IySnFMQ0JqZEhndVpHVndkR2dwTzF4dWZWeHVaWGh3YjNKMGN5NXBibk53WldOMElEMGdhVzV6Y0dWamREdGNibHh1WEc0dkx5Qm9kSFJ3T2k4dlpXNHVkMmxyYVhCbFpHbGhMbTl5Wnk5M2FXdHBMMEZPVTBsZlpYTmpZWEJsWDJOdlpHVWpaM0poY0docFkzTmNibWx1YzNCbFkzUXVZMjlzYjNKeklEMGdlMXh1SUNBblltOXNaQ2NnT2lCYk1Td2dNakpkTEZ4dUlDQW5hWFJoYkdsakp5QTZJRnN6TENBeU0xMHNYRzRnSUNkMWJtUmxjbXhwYm1VbklEb2dXelFzSURJMFhTeGNiaUFnSjJsdWRtVnljMlVuSURvZ1d6Y3NJREkzWFN4Y2JpQWdKM2RvYVhSbEp5QTZJRnN6Tnl3Z016bGRMRnh1SUNBblozSmxlU2NnT2lCYk9UQXNJRE01WFN4Y2JpQWdKMkpzWVdOckp5QTZJRnN6TUN3Z016bGRMRnh1SUNBbllteDFaU2NnT2lCYk16UXNJRE01WFN4Y2JpQWdKMk41WVc0bklEb2dXek0yTENBek9WMHNYRzRnSUNkbmNtVmxiaWNnT2lCYk16SXNJRE01WFN4Y2JpQWdKMjFoWjJWdWRHRW5JRG9nV3pNMUxDQXpPVjBzWEc0Z0lDZHlaV1FuSURvZ1d6TXhMQ0F6T1Ywc1hHNGdJQ2Q1Wld4c2IzY25JRG9nV3pNekxDQXpPVjFjYm4wN1hHNWNiaTh2SUVSdmJpZDBJSFZ6WlNBbllteDFaU2NnYm05MElIWnBjMmxpYkdVZ2IyNGdZMjFrTG1WNFpWeHVhVzV6Y0dWamRDNXpkSGxzWlhNZ1BTQjdYRzRnSUNkemNHVmphV0ZzSnpvZ0oyTjVZVzRuTEZ4dUlDQW5iblZ0WW1WeUp6b2dKM2xsYkd4dmR5Y3NYRzRnSUNkaWIyOXNaV0Z1SnpvZ0ozbGxiR3h2ZHljc1hHNGdJQ2QxYm1SbFptbHVaV1FuT2lBblozSmxlU2NzWEc0Z0lDZHVkV3hzSnpvZ0oySnZiR1FuTEZ4dUlDQW5jM1J5YVc1bkp6b2dKMmR5WldWdUp5eGNiaUFnSjJSaGRHVW5PaUFuYldGblpXNTBZU2NzWEc0Z0lDOHZJRndpYm1GdFpWd2lPaUJwYm5SbGJuUnBiMjVoYkd4NUlHNXZkQ0J6ZEhsc2FXNW5YRzRnSUNkeVpXZGxlSEFuT2lBbmNtVmtKMXh1ZlR0Y2JseHVYRzVtZFc1amRHbHZiaUJ6ZEhsc2FYcGxWMmwwYUVOdmJHOXlLSE4wY2l3Z2MzUjViR1ZVZVhCbEtTQjdYRzRnSUhaaGNpQnpkSGxzWlNBOUlHbHVjM0JsWTNRdWMzUjViR1Z6VzNOMGVXeGxWSGx3WlYwN1hHNWNiaUFnYVdZZ0tITjBlV3hsS1NCN1hHNGdJQ0FnY21WMGRYSnVJQ2RjWEhVd01ERmlXeWNnS3lCcGJuTndaV04wTG1OdmJHOXljMXR6ZEhsc1pWMWJNRjBnS3lBbmJTY2dLeUJ6ZEhJZ0sxeHVJQ0FnSUNBZ0lDQWdJQ0FuWEZ4MU1EQXhZbHNuSUNzZ2FXNXpjR1ZqZEM1amIyeHZjbk5iYzNSNWJHVmRXekZkSUNzZ0oyMG5PMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJSEpsZEhWeWJpQnpkSEk3WEc0Z0lIMWNibjFjYmx4dVhHNW1kVzVqZEdsdmJpQnpkSGxzYVhwbFRtOURiMnh2Y2loemRISXNJSE4wZVd4bFZIbHdaU2tnZTF4dUlDQnlaWFIxY200Z2MzUnlPMXh1ZlZ4dVhHNWNibVoxYm1OMGFXOXVJR0Z5Y21GNVZHOUlZWE5vS0dGeWNtRjVLU0I3WEc0Z0lIWmhjaUJvWVhOb0lEMGdlMzA3WEc1Y2JpQWdZWEp5WVhrdVptOXlSV0ZqYUNobWRXNWpkR2x2YmloMllXd3NJR2xrZUNrZ2UxeHVJQ0FnSUdoaGMyaGJkbUZzWFNBOUlIUnlkV1U3WEc0Z0lIMHBPMXh1WEc0Z0lISmxkSFZ5YmlCb1lYTm9PMXh1ZlZ4dVhHNWNibVoxYm1OMGFXOXVJR1p2Y20xaGRGWmhiSFZsS0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeWtnZTF4dUlDQXZMeUJRY205MmFXUmxJR0VnYUc5dmF5Qm1iM0lnZFhObGNpMXpjR1ZqYVdacFpXUWdhVzV6Y0dWamRDQm1kVzVqZEdsdmJuTXVYRzRnSUM4dklFTm9aV05ySUhSb1lYUWdkbUZzZFdVZ2FYTWdZVzRnYjJKcVpXTjBJSGRwZEdnZ1lXNGdhVzV6Y0dWamRDQm1kVzVqZEdsdmJpQnZiaUJwZEZ4dUlDQnBaaUFvWTNSNExtTjFjM1J2YlVsdWMzQmxZM1FnSmlaY2JpQWdJQ0FnSUhaaGJIVmxJQ1ltWEc0Z0lDQWdJQ0JwYzBaMWJtTjBhVzl1S0haaGJIVmxMbWx1YzNCbFkzUXBJQ1ltWEc0Z0lDQWdJQ0F2THlCR2FXeDBaWElnYjNWMElIUm9aU0IxZEdsc0lHMXZaSFZzWlN3Z2FYUW5jeUJwYm5Od1pXTjBJR1oxYm1OMGFXOXVJR2x6SUhOd1pXTnBZV3hjYmlBZ0lDQWdJSFpoYkhWbExtbHVjM0JsWTNRZ0lUMDlJR1Y0Y0c5eWRITXVhVzV6Y0dWamRDQW1KbHh1SUNBZ0lDQWdMeThnUVd4emJ5Qm1hV3gwWlhJZ2IzVjBJR0Z1ZVNCd2NtOTBiM1I1Y0dVZ2IySnFaV04wY3lCMWMybHVaeUIwYUdVZ1kybHlZM1ZzWVhJZ1kyaGxZMnN1WEc0Z0lDQWdJQ0FoS0haaGJIVmxMbU52Ym5OMGNuVmpkRzl5SUNZbUlIWmhiSFZsTG1OdmJuTjBjblZqZEc5eUxuQnliM1J2ZEhsd1pTQTlQVDBnZG1Gc2RXVXBLU0I3WEc0Z0lDQWdkbUZ5SUhKbGRDQTlJSFpoYkhWbExtbHVjM0JsWTNRb2NtVmpkWEp6WlZScGJXVnpMQ0JqZEhncE8xeHVJQ0FnSUdsbUlDZ2hhWE5UZEhKcGJtY29jbVYwS1NrZ2UxeHVJQ0FnSUNBZ2NtVjBJRDBnWm05eWJXRjBWbUZzZFdVb1kzUjRMQ0J5WlhRc0lISmxZM1Z5YzJWVWFXMWxjeWs3WEc0Z0lDQWdmVnh1SUNBZ0lISmxkSFZ5YmlCeVpYUTdYRzRnSUgxY2JseHVJQ0F2THlCUWNtbHRhWFJwZG1VZ2RIbHdaWE1nWTJGdWJtOTBJR2hoZG1VZ2NISnZjR1Z5ZEdsbGMxeHVJQ0IyWVhJZ2NISnBiV2wwYVhabElEMGdabTl5YldGMFVISnBiV2wwYVhabEtHTjBlQ3dnZG1Gc2RXVXBPMXh1SUNCcFppQW9jSEpwYldsMGFYWmxLU0I3WEc0Z0lDQWdjbVYwZFhKdUlIQnlhVzFwZEdsMlpUdGNiaUFnZlZ4dVhHNGdJQzh2SUV4dmIyc2dkWEFnZEdobElHdGxlWE1nYjJZZ2RHaGxJRzlpYW1WamRDNWNiaUFnZG1GeUlHdGxlWE1nUFNCUFltcGxZM1F1YTJWNWN5aDJZV3gxWlNrN1hHNGdJSFpoY2lCMmFYTnBZbXhsUzJWNWN5QTlJR0Z5Y21GNVZHOUlZWE5vS0d0bGVYTXBPMXh1WEc0Z0lHbG1JQ2hqZEhndWMyaHZkMGhwWkdSbGJpa2dlMXh1SUNBZ0lHdGxlWE1nUFNCUFltcGxZM1F1WjJWMFQzZHVVSEp2Y0dWeWRIbE9ZVzFsY3loMllXeDFaU2s3WEc0Z0lIMWNibHh1SUNBdkx5QkpSU0JrYjJWemJpZDBJRzFoYTJVZ1pYSnliM0lnWm1sbGJHUnpJRzV2YmkxbGJuVnRaWEpoWW14bFhHNGdJQzh2SUdoMGRIQTZMeTl0YzJSdUxtMXBZM0p2YzI5bWRDNWpiMjB2Wlc0dGRYTXZiR2xpY21GeWVTOXBaUzlrZDNjMU1uTmlkQ2gyUFhaekxqazBLUzVoYzNCNFhHNGdJR2xtSUNocGMwVnljbTl5S0haaGJIVmxLVnh1SUNBZ0lDQWdKaVlnS0d0bGVYTXVhVzVrWlhoUFppZ25iV1Z6YzJGblpTY3BJRDQ5SURBZ2ZId2dhMlY1Y3k1cGJtUmxlRTltS0Nka1pYTmpjbWx3ZEdsdmJpY3BJRDQ5SURBcEtTQjdYRzRnSUNBZ2NtVjBkWEp1SUdadmNtMWhkRVZ5Y205eUtIWmhiSFZsS1R0Y2JpQWdmVnh1WEc0Z0lDOHZJRk52YldVZ2RIbHdaU0J2WmlCdlltcGxZM1FnZDJsMGFHOTFkQ0J3Y205d1pYSjBhV1Z6SUdOaGJpQmlaU0J6YUc5eWRHTjFkSFJsWkM1Y2JpQWdhV1lnS0d0bGVYTXViR1Z1WjNSb0lEMDlQU0F3S1NCN1hHNGdJQ0FnYVdZZ0tHbHpSblZ1WTNScGIyNG9kbUZzZFdVcEtTQjdYRzRnSUNBZ0lDQjJZWElnYm1GdFpTQTlJSFpoYkhWbExtNWhiV1VnUHlBbk9pQW5JQ3NnZG1Gc2RXVXVibUZ0WlNBNklDY25PMXh1SUNBZ0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLQ2RiUm5WdVkzUnBiMjRuSUNzZ2JtRnRaU0FySUNkZEp5d2dKM053WldOcFlXd25LVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR2x6VW1WblJYaHdLSFpoYkhWbEtTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHTjBlQzV6ZEhsc2FYcGxLRkpsWjBWNGNDNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY3VZMkZzYkNoMllXeDFaU2tzSUNkeVpXZGxlSEFuS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0dselJHRjBaU2gyWVd4MVpTa3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQmpkSGd1YzNSNWJHbDZaU2hFWVhSbExuQnliM1J2ZEhsd1pTNTBiMU4wY21sdVp5NWpZV3hzS0haaGJIVmxLU3dnSjJSaGRHVW5LVHRjYmlBZ0lDQjlYRzRnSUNBZ2FXWWdLR2x6UlhKeWIzSW9kbUZzZFdVcEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1ptOXliV0YwUlhKeWIzSW9kbUZzZFdVcE8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lIWmhjaUJpWVhObElEMGdKeWNzSUdGeWNtRjVJRDBnWm1Gc2MyVXNJR0p5WVdObGN5QTlJRnNuZXljc0lDZDlKMTA3WEc1Y2JpQWdMeThnVFdGclpTQkJjbkpoZVNCellYa2dkR2hoZENCMGFHVjVJR0Z5WlNCQmNuSmhlVnh1SUNCcFppQW9hWE5CY25KaGVTaDJZV3gxWlNrcElIdGNiaUFnSUNCaGNuSmhlU0E5SUhSeWRXVTdYRzRnSUNBZ1luSmhZMlZ6SUQwZ1d5ZGJKeXdnSjEwblhUdGNiaUFnZlZ4dVhHNGdJQzh2SUUxaGEyVWdablZ1WTNScGIyNXpJSE5oZVNCMGFHRjBJSFJvWlhrZ1lYSmxJR1oxYm1OMGFXOXVjMXh1SUNCcFppQW9hWE5HZFc1amRHbHZiaWgyWVd4MVpTa3BJSHRjYmlBZ0lDQjJZWElnYmlBOUlIWmhiSFZsTG01aGJXVWdQeUFuT2lBbklDc2dkbUZzZFdVdWJtRnRaU0E2SUNjbk8xeHVJQ0FnSUdKaGMyVWdQU0FuSUZ0R2RXNWpkR2x2YmljZ0t5QnVJQ3NnSjEwbk8xeHVJQ0I5WEc1Y2JpQWdMeThnVFdGclpTQlNaV2RGZUhCeklITmhlU0IwYUdGMElIUm9aWGtnWVhKbElGSmxaMFY0Y0hOY2JpQWdhV1lnS0dselVtVm5SWGh3S0haaGJIVmxLU2tnZTF4dUlDQWdJR0poYzJVZ1BTQW5JQ2NnS3lCU1pXZEZlSEF1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29kbUZzZFdVcE8xeHVJQ0I5WEc1Y2JpQWdMeThnVFdGclpTQmtZWFJsY3lCM2FYUm9JSEJ5YjNCbGNuUnBaWE1nWm1seWMzUWdjMkY1SUhSb1pTQmtZWFJsWEc0Z0lHbG1JQ2hwYzBSaGRHVW9kbUZzZFdVcEtTQjdYRzRnSUNBZ1ltRnpaU0E5SUNjZ0p5QXJJRVJoZEdVdWNISnZkRzkwZVhCbExuUnZWVlJEVTNSeWFXNW5MbU5oYkd3b2RtRnNkV1VwTzF4dUlDQjlYRzVjYmlBZ0x5OGdUV0ZyWlNCbGNuSnZjaUIzYVhSb0lHMWxjM05oWjJVZ1ptbHljM1FnYzJGNUlIUm9aU0JsY25KdmNseHVJQ0JwWmlBb2FYTkZjbkp2Y2loMllXeDFaU2twSUh0Y2JpQWdJQ0JpWVhObElEMGdKeUFuSUNzZ1ptOXliV0YwUlhKeWIzSW9kbUZzZFdVcE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0d0bGVYTXViR1Z1WjNSb0lEMDlQU0F3SUNZbUlDZ2hZWEp5WVhrZ2ZId2dkbUZzZFdVdWJHVnVaM1JvSUQwOUlEQXBLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHSnlZV05sYzFzd1hTQXJJR0poYzJVZ0t5QmljbUZqWlhOYk1WMDdYRzRnSUgxY2JseHVJQ0JwWmlBb2NtVmpkWEp6WlZScGJXVnpJRHdnTUNrZ2UxeHVJQ0FnSUdsbUlDaHBjMUpsWjBWNGNDaDJZV3gxWlNrcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCamRIZ3VjM1I1YkdsNlpTaFNaV2RGZUhBdWNISnZkRzkwZVhCbExuUnZVM1J5YVc1bkxtTmhiR3dvZG1Gc2RXVXBMQ0FuY21WblpYaHdKeWs3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCamRIZ3VjM1I1YkdsNlpTZ25XMDlpYW1WamRGMG5MQ0FuYzNCbFkybGhiQ2NwTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdOMGVDNXpaV1Z1TG5CMWMyZ29kbUZzZFdVcE8xeHVYRzRnSUhaaGNpQnZkWFJ3ZFhRN1hHNGdJR2xtSUNoaGNuSmhlU2tnZTF4dUlDQWdJRzkxZEhCMWRDQTlJR1p2Y20xaGRFRnljbUY1S0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeXdnZG1semFXSnNaVXRsZVhNc0lHdGxlWE1wTzF4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUc5MWRIQjFkQ0E5SUd0bGVYTXViV0Z3S0daMWJtTjBhVzl1S0d0bGVTa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlHWnZjbTFoZEZCeWIzQmxjblI1S0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeXdnZG1semFXSnNaVXRsZVhNc0lHdGxlU3dnWVhKeVlYa3BPMXh1SUNBZ0lIMHBPMXh1SUNCOVhHNWNiaUFnWTNSNExuTmxaVzR1Y0c5d0tDazdYRzVjYmlBZ2NtVjBkWEp1SUhKbFpIVmpaVlJ2VTJsdVoyeGxVM1J5YVc1bktHOTFkSEIxZEN3Z1ltRnpaU3dnWW5KaFkyVnpLVHRjYm4xY2JseHVYRzVtZFc1amRHbHZiaUJtYjNKdFlYUlFjbWx0YVhScGRtVW9ZM1I0TENCMllXeDFaU2tnZTF4dUlDQnBaaUFvYVhOVmJtUmxabWx1WldRb2RtRnNkV1VwS1Z4dUlDQWdJSEpsZEhWeWJpQmpkSGd1YzNSNWJHbDZaU2duZFc1a1pXWnBibVZrSnl3Z0ozVnVaR1ZtYVc1bFpDY3BPMXh1SUNCcFppQW9hWE5UZEhKcGJtY29kbUZzZFdVcEtTQjdYRzRnSUNBZ2RtRnlJSE5wYlhCc1pTQTlJQ2RjWENjbklDc2dTbE5QVGk1emRISnBibWRwWm5rb2RtRnNkV1VwTG5KbGNHeGhZMlVvTDE1Y0lueGNJaVF2Wnl3Z0p5Y3BYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F1Y21Wd2JHRmpaU2d2Snk5bkxDQmNJbHhjWEZ3blhDSXBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0F1Y21Wd2JHRmpaU2d2WEZ4Y1hGd2lMMmNzSUNkY0lpY3BJQ3NnSjF4Y0p5YzdYRzRnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtITnBiWEJzWlN3Z0ozTjBjbWx1WnljcE8xeHVJQ0I5WEc0Z0lHbG1JQ2hwYzA1MWJXSmxjaWgyWVd4MVpTa3BYRzRnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtDY25JQ3NnZG1Gc2RXVXNJQ2R1ZFcxaVpYSW5LVHRjYmlBZ2FXWWdLR2x6UW05dmJHVmhiaWgyWVd4MVpTa3BYRzRnSUNBZ2NtVjBkWEp1SUdOMGVDNXpkSGxzYVhwbEtDY25JQ3NnZG1Gc2RXVXNJQ2RpYjI5c1pXRnVKeWs3WEc0Z0lDOHZJRVp2Y2lCemIyMWxJSEpsWVhOdmJpQjBlWEJsYjJZZ2JuVnNiQ0JwY3lCY0ltOWlhbVZqZEZ3aUxDQnpieUJ6Y0dWamFXRnNJR05oYzJVZ2FHVnlaUzVjYmlBZ2FXWWdLR2x6VG5Wc2JDaDJZV3gxWlNrcFhHNGdJQ0FnY21WMGRYSnVJR04wZUM1emRIbHNhWHBsS0NkdWRXeHNKeXdnSjI1MWJHd25LVHRjYm4xY2JseHVYRzVtZFc1amRHbHZiaUJtYjNKdFlYUkZjbkp2Y2loMllXeDFaU2tnZTF4dUlDQnlaWFIxY200Z0oxc25JQ3NnUlhKeWIzSXVjSEp2ZEc5MGVYQmxMblJ2VTNSeWFXNW5MbU5oYkd3b2RtRnNkV1VwSUNzZ0oxMG5PMXh1ZlZ4dVhHNWNibVoxYm1OMGFXOXVJR1p2Y20xaGRFRnljbUY1S0dOMGVDd2dkbUZzZFdVc0lISmxZM1Z5YzJWVWFXMWxjeXdnZG1semFXSnNaVXRsZVhNc0lHdGxlWE1wSUh0Y2JpQWdkbUZ5SUc5MWRIQjFkQ0E5SUZ0ZE8xeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Dd2diQ0E5SUhaaGJIVmxMbXhsYm1kMGFEc2dhU0E4SUd3N0lDc3JhU2tnZTF4dUlDQWdJR2xtSUNob1lYTlBkMjVRY205d1pYSjBlU2gyWVd4MVpTd2dVM1J5YVc1bktHa3BLU2tnZTF4dUlDQWdJQ0FnYjNWMGNIVjBMbkIxYzJnb1ptOXliV0YwVUhKdmNHVnlkSGtvWTNSNExDQjJZV3gxWlN3Z2NtVmpkWEp6WlZScGJXVnpMQ0IyYVhOcFlteGxTMlY1Y3l4Y2JpQWdJQ0FnSUNBZ0lDQlRkSEpwYm1jb2FTa3NJSFJ5ZFdVcEtUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnYjNWMGNIVjBMbkIxYzJnb0p5Y3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dUlDQnJaWGx6TG1admNrVmhZMmdvWm5WdVkzUnBiMjRvYTJWNUtTQjdYRzRnSUNBZ2FXWWdLQ0ZyWlhrdWJXRjBZMmdvTDE1Y1hHUXJKQzhwS1NCN1hHNGdJQ0FnSUNCdmRYUndkWFF1Y0hWemFDaG1iM0p0WVhSUWNtOXdaWEowZVNoamRIZ3NJSFpoYkhWbExDQnlaV04xY25ObFZHbHRaWE1zSUhacGMybGliR1ZMWlhsekxGeHVJQ0FnSUNBZ0lDQWdJR3RsZVN3Z2RISjFaU2twTzF4dUlDQWdJSDFjYmlBZ2ZTazdYRzRnSUhKbGRIVnliaUJ2ZFhSd2RYUTdYRzU5WEc1Y2JseHVablZ1WTNScGIyNGdabTl5YldGMFVISnZjR1Z5ZEhrb1kzUjRMQ0IyWVd4MVpTd2djbVZqZFhKelpWUnBiV1Z6TENCMmFYTnBZbXhsUzJWNWN5d2dhMlY1TENCaGNuSmhlU2tnZTF4dUlDQjJZWElnYm1GdFpTd2djM1J5TENCa1pYTmpPMXh1SUNCa1pYTmpJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVJHVnpZM0pwY0hSdmNpaDJZV3gxWlN3Z2EyVjVLU0I4ZkNCN0lIWmhiSFZsT2lCMllXeDFaVnRyWlhsZElIMDdYRzRnSUdsbUlDaGtaWE5qTG1kbGRDa2dlMXh1SUNBZ0lHbG1JQ2hrWlhOakxuTmxkQ2tnZTF4dUlDQWdJQ0FnYzNSeUlEMGdZM1I0TG5OMGVXeHBlbVVvSjF0SFpYUjBaWEl2VTJWMGRHVnlYU2NzSUNkemNHVmphV0ZzSnlrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSE4wY2lBOUlHTjBlQzV6ZEhsc2FYcGxLQ2RiUjJWMGRHVnlYU2NzSUNkemNHVmphV0ZzSnlrN1hHNGdJQ0FnZlZ4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUdsbUlDaGtaWE5qTG5ObGRDa2dlMXh1SUNBZ0lDQWdjM1J5SUQwZ1kzUjRMbk4wZVd4cGVtVW9KMXRUWlhSMFpYSmRKeXdnSjNOd1pXTnBZV3duS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNiaUFnYVdZZ0tDRm9ZWE5QZDI1UWNtOXdaWEowZVNoMmFYTnBZbXhsUzJWNWN5d2dhMlY1S1NrZ2UxeHVJQ0FnSUc1aGJXVWdQU0FuV3ljZ0t5QnJaWGtnS3lBblhTYzdYRzRnSUgxY2JpQWdhV1lnS0NGemRISXBJSHRjYmlBZ0lDQnBaaUFvWTNSNExuTmxaVzR1YVc1a1pYaFBaaWhrWlhOakxuWmhiSFZsS1NBOElEQXBJSHRjYmlBZ0lDQWdJR2xtSUNocGMwNTFiR3dvY21WamRYSnpaVlJwYldWektTa2dlMXh1SUNBZ0lDQWdJQ0J6ZEhJZ1BTQm1iM0p0WVhSV1lXeDFaU2hqZEhnc0lHUmxjMk11ZG1Gc2RXVXNJRzUxYkd3cE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2MzUnlJRDBnWm05eWJXRjBWbUZzZFdVb1kzUjRMQ0JrWlhOakxuWmhiSFZsTENCeVpXTjFjbk5sVkdsdFpYTWdMU0F4S1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUdsbUlDaHpkSEl1YVc1a1pYaFBaaWduWEZ4dUp5a2dQaUF0TVNrZ2UxeHVJQ0FnSUNBZ0lDQnBaaUFvWVhKeVlYa3BJSHRjYmlBZ0lDQWdJQ0FnSUNCemRISWdQU0J6ZEhJdWMzQnNhWFFvSjF4Y2JpY3BMbTFoY0NobWRXNWpkR2x2Ymloc2FXNWxLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z0p5QWdKeUFySUd4cGJtVTdYRzRnSUNBZ0lDQWdJQ0FnZlNrdWFtOXBiaWduWEZ4dUp5a3VjM1ZpYzNSeUtESXBPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUhOMGNpQTlJQ2RjWEc0bklDc2djM1J5TG5Od2JHbDBLQ2RjWEc0bktTNXRZWEFvWm5WdVkzUnBiMjRvYkdsdVpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2NtVjBkWEp1SUNjZ0lDQW5JQ3NnYkdsdVpUdGNiaUFnSUNBZ0lDQWdJQ0I5S1M1cWIybHVLQ2RjWEc0bktUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNCemRISWdQU0JqZEhndWMzUjViR2w2WlNnblcwTnBjbU4xYkdGeVhTY3NJQ2R6Y0dWamFXRnNKeWs3WEc0Z0lDQWdmVnh1SUNCOVhHNGdJR2xtSUNocGMxVnVaR1ZtYVc1bFpDaHVZVzFsS1NrZ2UxeHVJQ0FnSUdsbUlDaGhjbkpoZVNBbUppQnJaWGt1YldGMFkyZ29MMTVjWEdRckpDOHBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdjM1J5TzF4dUlDQWdJSDFjYmlBZ0lDQnVZVzFsSUQwZ1NsTlBUaTV6ZEhKcGJtZHBabmtvSnljZ0t5QnJaWGtwTzF4dUlDQWdJR2xtSUNodVlXMWxMbTFoZEdOb0tDOWVYQ0lvVzJFdGVrRXRXbDlkVzJFdGVrRXRXbDh3TFRsZEtpbGNJaVF2S1NrZ2UxeHVJQ0FnSUNBZ2JtRnRaU0E5SUc1aGJXVXVjM1ZpYzNSeUtERXNJRzVoYldVdWJHVnVaM1JvSUMwZ01pazdYRzRnSUNBZ0lDQnVZVzFsSUQwZ1kzUjRMbk4wZVd4cGVtVW9ibUZ0WlN3Z0oyNWhiV1VuS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdibUZ0WlNBOUlHNWhiV1V1Y21Wd2JHRmpaU2d2Snk5bkxDQmNJbHhjWEZ3blhDSXBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzV5WlhCc1lXTmxLQzljWEZ4Y1hDSXZaeXdnSjF3aUp5bGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMbkpsY0d4aFkyVW9MeWhlWENKOFhDSWtLUzluTENCY0lpZGNJaWs3WEc0Z0lDQWdJQ0J1WVcxbElEMGdZM1I0TG5OMGVXeHBlbVVvYm1GdFpTd2dKM04wY21sdVp5Y3BPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSEpsZEhWeWJpQnVZVzFsSUNzZ0p6b2dKeUFySUhOMGNqdGNibjFjYmx4dVhHNW1kVzVqZEdsdmJpQnlaV1IxWTJWVWIxTnBibWRzWlZOMGNtbHVaeWh2ZFhSd2RYUXNJR0poYzJVc0lHSnlZV05sY3lrZ2UxeHVJQ0IyWVhJZ2JuVnRUR2x1WlhORmMzUWdQU0F3TzF4dUlDQjJZWElnYkdWdVozUm9JRDBnYjNWMGNIVjBMbkpsWkhWalpTaG1kVzVqZEdsdmJpaHdjbVYyTENCamRYSXBJSHRjYmlBZ0lDQnVkVzFNYVc1bGMwVnpkQ3NyTzF4dUlDQWdJR2xtSUNoamRYSXVhVzVrWlhoUFppZ25YRnh1SnlrZ1BqMGdNQ2tnYm5WdFRHbHVaWE5GYzNRckt6dGNiaUFnSUNCeVpYUjFjbTRnY0hKbGRpQXJJR04xY2k1eVpYQnNZV05sS0M5Y1hIVXdNREZpWEZ4YlhGeGtYRnhrUDIwdlp5d2dKeWNwTG14bGJtZDBhQ0FySURFN1hHNGdJSDBzSURBcE8xeHVYRzRnSUdsbUlDaHNaVzVuZEdnZ1BpQTJNQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQmljbUZqWlhOYk1GMGdLMXh1SUNBZ0lDQWdJQ0FnSUNBb1ltRnpaU0E5UFQwZ0p5Y2dQeUFuSnlBNklHSmhjMlVnS3lBblhGeHVJQ2NwSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdKeUFuSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdiM1YwY0hWMExtcHZhVzRvSnl4Y1hHNGdJQ2NwSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdKeUFuSUN0Y2JpQWdJQ0FnSUNBZ0lDQWdZbkpoWTJWeld6RmRPMXh1SUNCOVhHNWNiaUFnY21WMGRYSnVJR0p5WVdObGMxc3dYU0FySUdKaGMyVWdLeUFuSUNjZ0t5QnZkWFJ3ZFhRdWFtOXBiaWduTENBbktTQXJJQ2NnSnlBcklHSnlZV05sYzFzeFhUdGNibjFjYmx4dVhHNHZMeUJPVDFSRk9pQlVhR1Z6WlNCMGVYQmxJR05vWldOcmFXNW5JR1oxYm1OMGFXOXVjeUJwYm5SbGJuUnBiMjVoYkd4NUlHUnZiaWQwSUhWelpTQmdhVzV6ZEdGdVkyVnZabUJjYmk4dklHSmxZMkYxYzJVZ2FYUWdhWE1nWm5KaFoybHNaU0JoYm1RZ1kyRnVJR0psSUdWaGMybHNlU0JtWVd0bFpDQjNhWFJvSUdCUFltcGxZM1F1WTNKbFlYUmxLQ2xnTGx4dVpuVnVZM1JwYjI0Z2FYTkJjbkpoZVNoaGNpa2dlMXh1SUNCeVpYUjFjbTRnUVhKeVlYa3VhWE5CY25KaGVTaGhjaWs3WEc1OVhHNWxlSEJ2Y25SekxtbHpRWEp5WVhrZ1BTQnBjMEZ5Y21GNU8xeHVYRzVtZFc1amRHbHZiaUJwYzBKdmIyeGxZVzRvWVhKbktTQjdYRzRnSUhKbGRIVnliaUIwZVhCbGIyWWdZWEpuSUQwOVBTQW5ZbTl2YkdWaGJpYzdYRzU5WEc1bGVIQnZjblJ6TG1selFtOXZiR1ZoYmlBOUlHbHpRbTl2YkdWaGJqdGNibHh1Wm5WdVkzUnBiMjRnYVhOT2RXeHNLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdZWEpuSUQwOVBTQnVkV3hzTzF4dWZWeHVaWGh3YjNKMGN5NXBjMDUxYkd3Z1BTQnBjMDUxYkd3N1hHNWNibVoxYm1OMGFXOXVJR2x6VG5Wc2JFOXlWVzVrWldacGJtVmtLR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdZWEpuSUQwOUlHNTFiR3c3WEc1OVhHNWxlSEJ2Y25SekxtbHpUblZzYkU5eVZXNWtaV1pwYm1Wa0lEMGdhWE5PZFd4c1QzSlZibVJsWm1sdVpXUTdYRzVjYm1aMWJtTjBhVzl1SUdselRuVnRZbVZ5S0dGeVp5a2dlMXh1SUNCeVpYUjFjbTRnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKMjUxYldKbGNpYzdYRzU5WEc1bGVIQnZjblJ6TG1selRuVnRZbVZ5SUQwZ2FYTk9kVzFpWlhJN1hHNWNibVoxYm1OMGFXOXVJR2x6VTNSeWFXNW5LR0Z5WnlrZ2UxeHVJQ0J5WlhSMWNtNGdkSGx3Wlc5bUlHRnlaeUE5UFQwZ0ozTjBjbWx1WnljN1hHNTlYRzVsZUhCdmNuUnpMbWx6VTNSeWFXNW5JRDBnYVhOVGRISnBibWM3WEc1Y2JtWjFibU4wYVc5dUlHbHpVM2x0WW05c0tHRnlaeWtnZTF4dUlDQnlaWFIxY200Z2RIbHdaVzltSUdGeVp5QTlQVDBnSjNONWJXSnZiQ2M3WEc1OVhHNWxlSEJ2Y25SekxtbHpVM2x0WW05c0lEMGdhWE5UZVcxaWIydzdYRzVjYm1aMWJtTjBhVzl1SUdselZXNWtaV1pwYm1Wa0tHRnlaeWtnZTF4dUlDQnlaWFIxY200Z1lYSm5JRDA5UFNCMmIybGtJREE3WEc1OVhHNWxlSEJ2Y25SekxtbHpWVzVrWldacGJtVmtJRDBnYVhOVmJtUmxabWx1WldRN1hHNWNibVoxYm1OMGFXOXVJR2x6VW1WblJYaHdLSEpsS1NCN1hHNGdJSEpsZEhWeWJpQnBjMDlpYW1WamRDaHlaU2tnSmlZZ2IySnFaV04wVkc5VGRISnBibWNvY21VcElEMDlQU0FuVzI5aWFtVmpkQ0JTWldkRmVIQmRKenRjYm4xY2JtVjRjRzl5ZEhNdWFYTlNaV2RGZUhBZ1BTQnBjMUpsWjBWNGNEdGNibHh1Wm5WdVkzUnBiMjRnYVhOUFltcGxZM1FvWVhKbktTQjdYRzRnSUhKbGRIVnliaUIwZVhCbGIyWWdZWEpuSUQwOVBTQW5iMkpxWldOMEp5QW1KaUJoY21jZ0lUMDlJRzUxYkd3N1hHNTlYRzVsZUhCdmNuUnpMbWx6VDJKcVpXTjBJRDBnYVhOUFltcGxZM1E3WEc1Y2JtWjFibU4wYVc5dUlHbHpSR0YwWlNoa0tTQjdYRzRnSUhKbGRIVnliaUJwYzA5aWFtVmpkQ2hrS1NBbUppQnZZbXBsWTNSVWIxTjBjbWx1Wnloa0tTQTlQVDBnSjF0dlltcGxZM1FnUkdGMFpWMG5PMXh1ZlZ4dVpYaHdiM0owY3k1cGMwUmhkR1VnUFNCcGMwUmhkR1U3WEc1Y2JtWjFibU4wYVc5dUlHbHpSWEp5YjNJb1pTa2dlMXh1SUNCeVpYUjFjbTRnYVhOUFltcGxZM1FvWlNrZ0ppWmNiaUFnSUNBZ0lDaHZZbXBsWTNSVWIxTjBjbWx1WnlobEtTQTlQVDBnSjF0dlltcGxZM1FnUlhKeWIzSmRKeUI4ZkNCbElHbHVjM1JoYm1ObGIyWWdSWEp5YjNJcE8xeHVmVnh1Wlhod2IzSjBjeTVwYzBWeWNtOXlJRDBnYVhORmNuSnZjanRjYmx4dVpuVnVZM1JwYjI0Z2FYTkdkVzVqZEdsdmJpaGhjbWNwSUh0Y2JpQWdjbVYwZFhKdUlIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkbWRXNWpkR2x2YmljN1hHNTlYRzVsZUhCdmNuUnpMbWx6Um5WdVkzUnBiMjRnUFNCcGMwWjFibU4wYVc5dU8xeHVYRzVtZFc1amRHbHZiaUJwYzFCeWFXMXBkR2wyWlNoaGNtY3BJSHRjYmlBZ2NtVjBkWEp1SUdGeVp5QTlQVDBnYm5Wc2JDQjhmRnh1SUNBZ0lDQWdJQ0FnZEhsd1pXOW1JR0Z5WnlBOVBUMGdKMkp2YjJ4bFlXNG5JSHg4WEc0Z0lDQWdJQ0FnSUNCMGVYQmxiMllnWVhKbklEMDlQU0FuYm5WdFltVnlKeUI4ZkZ4dUlDQWdJQ0FnSUNBZ2RIbHdaVzltSUdGeVp5QTlQVDBnSjNOMGNtbHVaeWNnZkh4Y2JpQWdJQ0FnSUNBZ0lIUjVjR1Z2WmlCaGNtY2dQVDA5SUNkemVXMWliMnduSUh4OElDQXZMeUJGVXpZZ2MzbHRZbTlzWEc0Z0lDQWdJQ0FnSUNCMGVYQmxiMllnWVhKbklEMDlQU0FuZFc1a1pXWnBibVZrSnp0Y2JuMWNibVY0Y0c5eWRITXVhWE5RY21sdGFYUnBkbVVnUFNCcGMxQnlhVzFwZEdsMlpUdGNibHh1Wlhod2IzSjBjeTVwYzBKMVptWmxjaUE5SUhKbGNYVnBjbVVvSnk0dmMzVndjRzl5ZEM5cGMwSjFabVpsY2ljcE8xeHVYRzVtZFc1amRHbHZiaUJ2WW1wbFkzUlViMU4wY21sdVp5aHZLU0I3WEc0Z0lISmxkSFZ5YmlCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG5SdlUzUnlhVzVuTG1OaGJHd29ieWs3WEc1OVhHNWNibHh1Wm5WdVkzUnBiMjRnY0dGa0tHNHBJSHRjYmlBZ2NtVjBkWEp1SUc0Z1BDQXhNQ0EvSUNjd0p5QXJJRzR1ZEc5VGRISnBibWNvTVRBcElEb2diaTUwYjFOMGNtbHVaeWd4TUNrN1hHNTlYRzVjYmx4dWRtRnlJRzF2Ym5Sb2N5QTlJRnNuU21GdUp5d2dKMFpsWWljc0lDZE5ZWEluTENBblFYQnlKeXdnSjAxaGVTY3NJQ2RLZFc0bkxDQW5TblZzSnl3Z0owRjFaeWNzSUNkVFpYQW5MRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQW5UMk4wSnl3Z0owNXZkaWNzSUNkRVpXTW5YVHRjYmx4dUx5OGdNallnUm1WaUlERTJPakU1T2pNMFhHNW1kVzVqZEdsdmJpQjBhVzFsYzNSaGJYQW9LU0I3WEc0Z0lIWmhjaUJrSUQwZ2JtVjNJRVJoZEdVb0tUdGNiaUFnZG1GeUlIUnBiV1VnUFNCYmNHRmtLR1F1WjJWMFNHOTFjbk1vS1Nrc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhCaFpDaGtMbWRsZEUxcGJuVjBaWE1vS1Nrc1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhCaFpDaGtMbWRsZEZObFkyOXVaSE1vS1NsZExtcHZhVzRvSnpvbktUdGNiaUFnY21WMGRYSnVJRnRrTG1kbGRFUmhkR1VvS1N3Z2JXOXVkR2h6VzJRdVoyVjBUVzl1ZEdnb0tWMHNJSFJwYldWZExtcHZhVzRvSnlBbktUdGNibjFjYmx4dVhHNHZMeUJzYjJjZ2FYTWdhblZ6ZENCaElIUm9hVzRnZDNKaGNIQmxjaUIwYnlCamIyNXpiMnhsTG14dlp5QjBhR0YwSUhCeVpYQmxibVJ6SUdFZ2RHbHRaWE4wWVcxd1hHNWxlSEJ2Y25SekxteHZaeUE5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0JqYjI1emIyeGxMbXh2WnlnbkpYTWdMU0FsY3ljc0lIUnBiV1Z6ZEdGdGNDZ3BMQ0JsZUhCdmNuUnpMbVp2Y20xaGRDNWhjSEJzZVNobGVIQnZjblJ6TENCaGNtZDFiV1Z1ZEhNcEtUdGNibjA3WEc1Y2JseHVMeW9xWEc0Z0tpQkpibWhsY21sMElIUm9aU0J3Y205MGIzUjVjR1VnYldWMGFHOWtjeUJtY205dElHOXVaU0JqYjI1emRISjFZM1J2Y2lCcGJuUnZJR0Z1YjNSb1pYSXVYRzRnS2x4dUlDb2dWR2hsSUVaMWJtTjBhVzl1TG5CeWIzUnZkSGx3WlM1cGJtaGxjbWwwY3lCbWNtOXRJR3hoYm1jdWFuTWdjbVYzY21sMGRHVnVJR0Z6SUdFZ2MzUmhibVJoYkc5dVpWeHVJQ29nWm5WdVkzUnBiMjRnS0c1dmRDQnZiaUJHZFc1amRHbHZiaTV3Y205MGIzUjVjR1VwTGlCT1QxUkZPaUJKWmlCMGFHbHpJR1pwYkdVZ2FYTWdkRzhnWW1VZ2JHOWhaR1ZrWEc0Z0tpQmtkWEpwYm1jZ1ltOXZkSE4wY21Gd2NHbHVaeUIwYUdseklHWjFibU4wYVc5dUlHNWxaV1J6SUhSdklHSmxJSEpsZDNKcGRIUmxiaUIxYzJsdVp5QnpiMjFsSUc1aGRHbDJaVnh1SUNvZ1puVnVZM1JwYjI1eklHRnpJSEJ5YjNSdmRIbHdaU0J6WlhSMWNDQjFjMmx1WnlCdWIzSnRZV3dnU21GMllWTmpjbWx3ZENCa2IyVnpJRzV2ZENCM2IzSnJJR0Z6WEc0Z0tpQmxlSEJsWTNSbFpDQmtkWEpwYm1jZ1ltOXZkSE4wY21Gd2NHbHVaeUFvYzJWbElHMXBjbkp2Y2k1cWN5QnBiaUJ5TVRFME9UQXpLUzVjYmlBcVhHNGdLaUJBY0dGeVlXMGdlMloxYm1OMGFXOXVmU0JqZEc5eUlFTnZibk4wY25WamRHOXlJR1oxYm1OMGFXOXVJSGRvYVdOb0lHNWxaV1J6SUhSdklHbHVhR1Z5YVhRZ2RHaGxYRzRnS2lBZ0lDQWdjSEp2ZEc5MGVYQmxMbHh1SUNvZ1FIQmhjbUZ0SUh0bWRXNWpkR2x2Ym4wZ2MzVndaWEpEZEc5eUlFTnZibk4wY25WamRHOXlJR1oxYm1OMGFXOXVJSFJ2SUdsdWFHVnlhWFFnY0hKdmRHOTBlWEJsSUdaeWIyMHVYRzRnS2k5Y2JtVjRjRzl5ZEhNdWFXNW9aWEpwZEhNZ1BTQnlaWEYxYVhKbEtDZHBibWhsY21sMGN5Y3BPMXh1WEc1bGVIQnZjblJ6TGw5bGVIUmxibVFnUFNCbWRXNWpkR2x2YmlodmNtbG5hVzRzSUdGa1pDa2dlMXh1SUNBdkx5QkViMjRuZENCa2J5QmhibmwwYUdsdVp5QnBaaUJoWkdRZ2FYTnVKM1FnWVc0Z2IySnFaV04wWEc0Z0lHbG1JQ2doWVdSa0lIeDhJQ0ZwYzA5aWFtVmpkQ2hoWkdRcEtTQnlaWFIxY200Z2IzSnBaMmx1TzF4dVhHNGdJSFpoY2lCclpYbHpJRDBnVDJKcVpXTjBMbXRsZVhNb1lXUmtLVHRjYmlBZ2RtRnlJR2tnUFNCclpYbHpMbXhsYm1kMGFEdGNiaUFnZDJocGJHVWdLR2t0TFNrZ2UxeHVJQ0FnSUc5eWFXZHBibHRyWlhselcybGRYU0E5SUdGa1pGdHJaWGx6VzJsZFhUdGNiaUFnZlZ4dUlDQnlaWFIxY200Z2IzSnBaMmx1TzF4dWZUdGNibHh1Wm5WdVkzUnBiMjRnYUdGelQzZHVVSEp2Y0dWeWRIa29iMkpxTENCd2NtOXdLU0I3WEc0Z0lISmxkSFZ5YmlCUFltcGxZM1F1Y0hKdmRHOTBlWEJsTG1oaGMwOTNibEJ5YjNCbGNuUjVMbU5oYkd3b2IySnFMQ0J3Y205d0tUdGNibjFjYmlKZGZRPT0iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG5tb2R1bGUuZXhwb3J0cyA9IGdldF9ibG9iKClcblxuZnVuY3Rpb24gZ2V0X2Jsb2IoKSB7XG4gIGlmKGdsb2JhbC5CbG9iKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBCbG9iKFsnYXNkZiddLCB7dHlwZTogJ3RleHQvcGxhaW4nfSlcbiAgICAgIHJldHVybiBCbG9iXG4gICAgfSBjYXRjaChlcnIpIHt9XG4gIH1cblxuICB2YXIgQnVpbGRlciA9IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgICAgIGdsb2JhbC5Nb3pCbG9iQnVpbGRlciB8fFxuICAgICAgICAgICAgICAgIGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHBhcnRzLCBiYWcpIHtcbiAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyXG4gICAgICAsIGVuZGluZ3MgPSBiYWcuZW5kaW5nc1xuICAgICAgLCB0eXBlID0gYmFnLnR5cGVcblxuICAgIGlmKGVuZGluZ3MpIGZvcih2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBidWlsZGVyLmFwcGVuZChwYXJ0c1tpXSwgZW5kaW5ncylcbiAgICB9IGVsc2UgZm9yKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnRzW2ldKVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlID8gYnVpbGRlci5nZXRCbG9iKHR5cGUpIDogYnVpbGRlci5nZXRCbG9iKClcbiAgfVxufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTkzTTJNdFlteHZZaTlpY205M2MyVnlMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SnRiMlIxYkdVdVpYaHdiM0owY3lBOUlHZGxkRjlpYkc5aUtDbGNibHh1Wm5WdVkzUnBiMjRnWjJWMFgySnNiMklvS1NCN1hHNGdJR2xtS0dkc2IySmhiQzVDYkc5aUtTQjdYRzRnSUNBZ2RISjVJSHRjYmlBZ0lDQWdJRzVsZHlCQ2JHOWlLRnNuWVhOa1ppZGRMQ0I3ZEhsd1pUb2dKM1JsZUhRdmNHeGhhVzRuZlNsY2JpQWdJQ0FnSUhKbGRIVnliaUJDYkc5aVhHNGdJQ0FnZlNCallYUmphQ2hsY25JcElIdDlYRzRnSUgxY2JseHVJQ0IyWVhJZ1FuVnBiR1JsY2lBOUlHZHNiMkpoYkM1WFpXSkxhWFJDYkc5aVFuVnBiR1JsY2lCOGZGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lHZHNiMkpoYkM1TmIzcENiRzlpUW5WcGJHUmxjaUI4ZkZ4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdkc2IySmhiQzVOVTBKc2IySkNkV2xzWkdWeVhHNWNiaUFnY21WMGRYSnVJR1oxYm1OMGFXOXVLSEJoY25SekxDQmlZV2NwSUh0Y2JpQWdJQ0IyWVhJZ1luVnBiR1JsY2lBOUlHNWxkeUJDZFdsc1pHVnlYRzRnSUNBZ0lDQXNJR1Z1WkdsdVozTWdQU0JpWVdjdVpXNWthVzVuYzF4dUlDQWdJQ0FnTENCMGVYQmxJRDBnWW1GbkxuUjVjR1ZjYmx4dUlDQWdJR2xtS0dWdVpHbHVaM01wSUdadmNpaDJZWElnYVNBOUlEQXNJR3hsYmlBOUlIQmhjblJ6TG14bGJtZDBhRHNnYVNBOElHeGxianNnS3l0cEtTQjdYRzRnSUNBZ0lDQmlkV2xzWkdWeUxtRndjR1Z1WkNod1lYSjBjMXRwWFN3Z1pXNWthVzVuY3lsY2JpQWdJQ0I5SUdWc2MyVWdabTl5S0haaGNpQnBJRDBnTUN3Z2JHVnVJRDBnY0dGeWRITXViR1Z1WjNSb095QnBJRHdnYkdWdU95QXJLMmtwSUh0Y2JpQWdJQ0FnSUdKMWFXeGtaWEl1WVhCd1pXNWtLSEJoY25SelcybGRLVnh1SUNBZ0lIMWNibHh1SUNBZ0lISmxkSFZ5YmlCMGVYQmxJRDhnWW5WcGJHUmxjaTVuWlhSQ2JHOWlLSFI1Y0dVcElEb2dZblZwYkdSbGNpNW5aWFJDYkc5aUtDbGNiaUFnZlZ4dWZWeHVJbDE5IiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XG5cbi8qKlxuICogV2ViU29ja2V0IGNvbnN0cnVjdG9yLlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQgPyB3cyA6IG51bGw7XG5cbi8qKlxuICogV2ViU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSB0aGlyZCBgb3B0c2Agb3B0aW9ucyBvYmplY3QgZ2V0cyBpZ25vcmVkIGluIHdlYiBicm93c2Vycywgc2luY2UgaXQnc1xuICogbm9uLXN0YW5kYXJkLCBhbmQgdGhyb3dzIGEgVHlwZUVycm9yIGlmIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9laW5hcm9zL3dzL2lzc3Vlcy8yMjdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtPYmplY3QpIG9wdHMgKG9wdGlvbmFsKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB3cyh1cmksIHByb3RvY29scywgb3B0cykge1xuICB2YXIgaW5zdGFuY2U7XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmkpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKFdlYlNvY2tldCkgd3MucHJvdG90eXBlID0gV2ViU29ja2V0LnByb3RvdHlwZTtcbiJdfQ==
